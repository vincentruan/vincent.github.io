<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星辰大海</title>
  
  <subtitle>My Conquest Is the Sea of Stars.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vincentruan.github.io/"/>
  <updated>2020-02-28T08:31:39.690Z</updated>
  <id>https://vincentruan.github.io/</id>
  
  <author>
    <name>Vincent</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>B+树和数据库索引原理简述</title>
    <link href="https://vincentruan.github.io/2020/02/27/B-%E6%A0%91%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
    <id>https://vincentruan.github.io/2020/02/27/B-%E6%A0%91%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</id>
    <published>2020-02-27T07:12:49.000Z</published>
    <updated>2020-02-28T08:31:39.690Z</updated>
    
    <content type="html"><![CDATA[<p>所以下面我们就从二叉树到平衡二叉树，再到 B- 树，最后到 B+ 树来一步一步了解数据库索引底层的原理！</p><h1 id="二叉树（Binary-Search-Trees）"><a href="#二叉树（Binary-Search-Trees）" class="headerlink" title="二叉树（Binary Search Trees）"></a>二叉树（Binary Search Trees）</h1><p>二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（Left Subtree）和“右子树”（Right Subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p><strong>二叉树有如下特性</strong>：</p><ul><li>每个结点都包含一个元素以及 n 个子树，这里 0≤n≤2。 </li><li>左子树和右子树是有顺序的，次序不能任意颠倒。左子树的值要小于父结点，右子树的值要大于父结点。</li></ul><a id="more"></a><p>光看概念有点枯燥，假设我们现在有这样一组数[35 27 48 12 29 38 55]，顺序的插入到一个数的结构中，步骤如下 ：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787709189.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787733056.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787744819.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787831568.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787847118.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787860077.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787871729.webp" alt="img"></p><p>好了，这就是一棵二叉树啦！我们能看到，经过一系列的插入操作之后，原本无序的一组数已经变成一个有序的结构了，并且这个树满足了上面提到的两个二叉树的特性！</p><p>但是如果同样是上面那一组数，我们自己升序排列后再插入，也就是说按照[12 27 29 35 38 48 55]的顺序插入，会怎么样呢？</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787881659.png" alt="img"></p><center>线性退化</center><p>由于是升序插入，新插入的数据总是比已存在的结点数据都要大，所以每次都会往结点的右边插入，最终导致这棵树严重偏科！</p><p>上图就是最坏的情况，也就是一棵树退化为一个线性链表了，这样查找效率自然就低了，完全没有发挥树的优势了呢！ </p><p>为了较大发挥二叉树的查找效率，让二叉树不再偏科，保持各科平衡，所以有了平衡二叉树！</p><h1 id="平衡二叉树-AVL-Trees"><a href="#平衡二叉树-AVL-Trees" class="headerlink" title="平衡二叉树 (AVL Trees)"></a>平衡二叉树 (AVL Trees)</h1><p>平衡二叉树是一种特殊的二叉树，所以他也满足前面说到的二叉树的两个特性，同时还有一个特性：它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p><p>大家也看到了前面[35 27 48 12 29 38 55]插入完成后的图，其实就已经是一棵平衡二叉树啦。</p><p>那如果按照[12 27 29 35 38 48 55]的顺序插入一棵平衡二叉树，会怎么样呢？</p><p>我们看看插入以及平衡的过程：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787943829.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787954773.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787967340.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787989170.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787998161.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788020862.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788029812.jpg" alt="img"></p><p>这棵树始终满足平衡二叉树的几个特性而保持平衡！这样我们的树也不会退化为线性链表了！</p><p>我们需要查找一个数的时候就能沿着树根一直往下找，这样的查找效率和二分法查找是一样的呢！</p><p>一棵平衡二叉树能容纳多少的结点呢？这跟树的高度是有关系的，假设树的高度为 h，那每一层最多容纳的结点数量为 2^(n-1)，整棵树最多容纳节点数为 2^0+2^1+2^2+…+2^(h-1)。</p><p>这样计算，100w 数据树的高度大概在 20 左右，也就是说从有着 100w 条数据的平衡二叉树中找一个数据，最坏的情况下需要 20 次查找。</p><p>如果是内存操作，效率也是很高的！但是我们数据库中的数据基本都是放在磁盘中的，每读取一个二叉树的结点就是一次磁盘 IO，这样我们找一条数据如果要经过 20 次磁盘的 IO？</p><p>那性能就成了一个很大的问题了！那我们是不是可以把这棵树压缩一下，让每一层能够容纳更多的节点呢？虽然我矮，但是我胖啊…</p><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>这颗矮胖的树就是 B-Tree，注意中间是杠精的杠而不是减，所以也不要读成 B 减 Tree 了~</p><p><strong>那 B-Tree 有哪些特性呢？一棵 m 阶的 B-Tree 有如下特性</strong>：</p><ul><li>每个结点最多 m 个子结点。 </li><li>除了根结点和叶子结点外，每个结点最少有 m/2（向上取整）个子结点。 </li><li>如果根结点不是叶子结点，那根结点至少包含两个子结点。 </li><li>所有的叶子结点都位于同一层。 </li><li>每个结点都包含 k 个元素（关键字），这里 m/2≤k。</li><li>每个节点中的元素（关键字）从小到大排列。 </li><li>每个元素（关键字）字左结点的值，都小于或等于该元素（关键字）。右结点的值都大于或等于该元素（关键字）。</li></ul><p>是不是感觉跟丈母娘张口问你要彩礼一样，列一堆的条件，而且每一条都让你很懵逼！</p><p>下面我们以一个[0,1,2,3,4,5,6,7]的数组插入一棵 3 阶的 B-Tree 为例，将所有的条件都串起来，你就明白了！</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788179282.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788189696.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788310198.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788325037.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788332662.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788338881.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788345347.jpg" alt="img"></p><p>那么，你是否对 B-Tree 的几点特性都清晰了呢？在二叉树中，每个结点只有一个元素。</p><p>但是在 B-Tree 中，每个结点都可能包含多个元素，并且非叶子结点在元素的左右都有指向子结点的指针。</p><p>如果需要查找一个元素，那流程是怎么样的呢？我们看下图，如果我们要在下面的 B-Tree 中找到关键字 24，那流程如下：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788382294.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788391253.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788400331.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788413177.png" alt="img"></p><p>从这个流程我们能看出，B-Tree 的查询效率好像也并不比平衡二叉树高。但是查询所经过的结点数量要少很多，也就意味着要少很多次的磁盘 IO，这对性能的提升是很大的。</p><p>从前面对 B-Tree 操作的图，我们能看出来，元素就是类似 1、2、3 这样的数值。</p><p>但是数据库的数据都是一条条的数据，如果某个数据库以 B-Tree 的数据结构存储数据，那数据怎么存放的呢？</p><p>我们看下一张图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788425169.png" alt="img"></p><p>普通的 B-Tree 的结点中，元素就是一个个的数字。但是上图中，我们把元素部分拆分成了 key-data 的形式，Key 就是数据的主键，Data 就是具体的数据。</p><p>这样我们在找一条数的时候，就沿着根结点往下找就 OK 了，效率是比较高的。</p><h1 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h1><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构。</p><p><strong>B+Tree 与 B-Tree 的结构很像，但是也有几个自己的特性</strong>：</p><ul><li>所有的非叶子节点只存储关键字信息。 </li><li>所有卫星数据（具体数据）都存在叶子结点中。 </li><li>所有的叶子结点中包含了全部元素的信息。 </li><li>所有叶子节点之间都有一个链指针。</li></ul><p>如果上面 B-Tree 的图变成 B+Tree，那应该如下： </p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788503163.png" alt="img"></p><p>大家仔细对比于 B-Tree 的图能发现什么不同？ </p><ul><li>非叶子结点上已经只有 Key 信息了，满足上面第 1 点特性！ </li><li>所有叶子结点下面都有一个 Data 区域，满足上面第 2 点特性！ </li><li>非叶子结点的数据在叶子结点上都能找到，如根结点的元素 4、8 在最底层的叶子结点上也能找到，满足上面第 3 点特性！ </li><li>注意图中叶子结点之间的箭头，满足上面第 4 点特性！</li></ul><h1 id="B-Tree-or-B-Tree？"><a href="#B-Tree-or-B-Tree？" class="headerlink" title="B-Tree or B+Tree？"></a>B-Tree or B+Tree？</h1><p>在讲这两种数据结构在数据库中的选择之前，我们还需要了解的一个知识点是操作系统从磁盘读取数据到内存是以磁盘块（Block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p><p>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。 </p><p>预读的长度一般为页（Page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为 4K）。</p><p><strong>B-Tree 和 B+Tree 该如何选择呢？都有哪些优劣呢？</strong></p><p>①B-Tree 因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。</p><p>而 B+Tree 所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的 B-Tree 和 B+Tree 中，B-Tree 查找某个关键字的效率更高。 </p><p>②由于 B+Tree 所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的数据的时候，B+Tree 只需要找到该关键字然后沿着链表遍历就可以了，而 B-Tree 还需要遍历该关键字结点的根结点去搜索。 </p><p>③由于 B-Tree 的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而 B+Tree 非叶子结点只存储关键字信息，而每个页的大小是有限的，所以同一页能存储的 B-Tree 的数据会比 B+Tree 存储的更少。</p><p>这样同样总量的数据，B-Tree 的深度会更大，增大查询时的磁盘 I/O 次数，进而影响查询效率。 </p><p>鉴于以上的比较，所以在常用的关系型数据库中，都是选择 B+Tree 的数据结构来存储数据！</p><p>下面我们以 MySQL 的 InnoDB 存储引擎为例讲解，其他类似 SQL Server、Oracle 的原理！</p><h2 id="InnoDB-引擎数据存储"><a href="#InnoDB-引擎数据存储" class="headerlink" title="InnoDB 引擎数据存储"></a>InnoDB 引擎数据存储</h2><p>在 InnoDB 存储引擎中，也有页的概念，默认每个页的大小为 16K，也就是每次读取数据时都是读取 4*4K 的大小！</p><p>假设我们现在有一个用户表，我们往里面写数据：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788570858.png" alt="img"></p><p>这里需要注意的一点是，在某个页内插入新行时，为了减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在某一个页内的数据并不是完全有序的（后面页结构部分有细讲）。</p><p>但是为了数据访问顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表，不过在这里为了方便演示我是按顺序排列的！</p><p>由于数据还比较少，一个页就能容下，所以只有一个根结点，主键和数据也都是保存在根结点（左边的数字代表主键，右边名字、性别代表具体的数据）。</p><p>假设我们写入 10 条数据之后，Page1 满了，再写入新的数据会怎么存放呢？</p><p>我们继续看下图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788597877.png" alt="img"></p><p>有个叫“秦寿生”的朋友来了，但是 Page1 已经放不下数据了，这时候就需要进行页分裂，产生一个新的 Page。</p><p><strong>在 InnoDB 中的流程是怎么样的呢？</strong></p><ul><li>产生新的 Page2，然后将 Page1 的内容复制到 Page2。 </li><li>产生新的 Page3，“秦寿生”的数据放入 Page3。 </li><li>原来的 Page1 依然作为根结点，但是变成了一个不存放数据只存放索引的页，并且有两个子结点 Page2、Page3。</li></ul><p><strong>这里有两个问题需要注意的是：</strong></p><p>①为什么要复制 Page1 为 Page2 而不是创建一个新的页作为根结点，这样就少了一步复制的开销了？</p><p>如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。</p><p>并且在 InnoDB 中根结点是会预读到内存中的，所以结点的物理地址固定会比较好！</p><p>②原来 Page1 有 10 条数据，在插入第 11 条数据的时候进行裂变，根据前面对 B-Tree、B+Tree 特性的了解，那这至少是一棵 11 阶的树，裂变之后每个结点的元素至少为 11/2=5 个。</p><p>那是不是应该页裂变之后主键 1-5 的数据还是在原来的页，主键 6-11 的数据会放到新的页，根结点存放主键 6？ </p><p>如果是这样的话，新的页空间利用率只有 50%，并且会导致更为频繁的页分裂。</p><p>所以 InnoDB 对这一点做了优化，新的数据放入新创建的页，不移动原有页面的任何记录。</p><p>随着数据的不断写入，这棵树也逐渐枝繁叶茂，如下图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788654590.webp" alt="img"></p><p>每次新增数据，都是将一个页写满，然后新创建一个页继续写，这里其实是有个隐含条件的，那就是主键自增！</p><p>主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！</p><p>但是如果主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！这也是为什么在 InnoDB 中建议设置主键自增的原因！</p><p>这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在 InnoDB 中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！</p><p>有数据插入那就有删除，如果这个用户表频繁的插入和删除，那会导致数据页产生碎片，页的空间利用率低，还会导致树变的“虚高”，降低查询效率！这可以通过索引重建来消除碎片提高查询效率！</p><h2 id="InnoDB-引擎数据查找"><a href="#InnoDB-引擎数据查找" class="headerlink" title="InnoDB 引擎数据查找"></a>InnoDB 引擎数据查找</h2><p>数据插入了怎么查找呢？</p><ul><li><strong>找到数据所在的页。</strong>这个查找过程就跟前面说到的 B+Tree 的搜索过程是一样的，从根结点开始查找一直到叶子结点。 </li><li><strong>在页内找具体的数据。</strong>读取第 1 步找到的叶子结点数据到内存中，然后通过分块查找的方法找到具体的数据。</li></ul><p>这跟我们在新华字典中找某个汉字是一样的，先通过字典的索引定位到该汉字拼音所在的页，然后到指定的页找到具体的汉字。</p><p>InnoDB 中定位到页后用了哪种策略快速查找某个主键呢？这我们就需要从页结构开始了解。</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788721379.png" alt="img"></p><p>左边蓝色区域称为 Page Directory，这块区域由多个 Slot 组成，是一个稀疏索引结构，即一个槽中可能属于多个记录，最少属于 4 条记录，最多属于 8 条记录。</p><p>槽内的数据是有序存放的，所以当我们寻找一条数据的时候可以先在槽中通过二分法查找到一个大致的位置。</p><p>右边区域为数据区域，每一个数据页中都包含多条行数据。注意看图中最上面和最下面的两条特殊的行记录 Infimum 和 Supremum，这是两个虚拟的行记录。</p><p>在没有其他用户数据的时候 Infimum 的下一条记录的指针指向 Supremum。</p><p>当有用户数据的时候，Infimum 的下一条记录的指针指向当前页中最小的用户记录，当前页中最大的用户记录的下一条记录的指针指向 Supremum，至此整个页内的所有行记录形成一个单向链表。</p><p>行记录被 Page Directory 逻辑的分成了多个块，块与块之间是有序的，也就是说“4”这个槽指向的数据块内最大的行记录的主键都要比“8”这个槽指向的数据块内最小的行记录的主键要小。但是块内部的行记录不一定有序。</p><p>每个行记录的都有一个 n_owned 的区域（图中粉红色区域），n_owned 标识这个块有多少条数据。</p><p>伪记录 Infimum 的 n_owned 值总是 1，记录 Supremum 的 n_owned 的取值范围为[1,8]，其他用户记录 n_owned 的取值范围[4,8]。</p><p>并且只有每个块中最大的那条记录的 n_owned 才会有值，其他的用户记录的 n_owned 为 0。</p><p>所以当我们要找主键为 6 的记录时，先通过二分法在稀疏索引中找到对应的槽，也就是 Page Directory 中“8”这个槽。</p><p>“8”这个槽指向的是该数据块中最大的记录，而数据是单向链表结构，所以无法逆向查找。</p><p>所以需要找到上一个槽即“4”这个槽，然后通过“4”这个槽中最大的用户记录的指针沿着链表顺序查找到目标记录。</p><h2 id="聚集索引-amp-非聚集索引"><a href="#聚集索引-amp-非聚集索引" class="headerlink" title="聚集索引&amp;非聚集索引"></a>聚集索引&amp;非聚集索引</h2><p>前面关于数据存储的都是演示的聚集索引的实现，如果上面的用户表需要以“用户名字”建立一个非聚集索引，是怎么实现的呢？</p><p>我们看下图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788771077.webp" alt="img"></p><p>非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而是数据的聚集索引的 Key。</p><p>所以通过非聚集索引查找的过程是先找到该索引 Key 对应的聚集索引的 Key，然后再拿聚集索引的 Key 到主键索引树上查找对应的数据，这个过程称为回表！</p><p><em>PS：图中的这些名字均来源于网络，希望没有误伤正在看这篇文章的你~^_^</em></p><h2 id="InnoDB-与-MyISAM-引擎对比"><a href="#InnoDB-与-MyISAM-引擎对比" class="headerlink" title="InnoDB 与 MyISAM 引擎对比"></a>InnoDB 与 MyISAM 引擎对比</h2><p>上面包括存储和搜索都是拿的 InnoDB 引擎为例，那 MyISAM 与 InnoDB 在存储上有啥不同呢？憋缩话，看图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788802217.webp" alt="img"></p><p>上图为 MyISAM 主键索引的存储结构，我们能看到的不同是：</p><ul><li>主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。 </li><li>数据的存储不是按主键顺序存放的，是按写入的顺序存放。</li></ul><p>也就是说 InnoDB 引擎数据在物理上是按主键顺序存放，而 MyISAM 引擎数据在物理上按插入的顺序存放。</p><p>并且 MyISAM 的叶子结点不存放数据，所以非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要回表，这比 InnoDB 的搜索效率会更高呢！</p><h2 id="索引优化建议"><a href="#索引优化建议" class="headerlink" title="索引优化建议"></a>索引优化建议</h2><p>大家经常会在很多的文章或书中能看到一些索引的使用建议，比如说：</p><ul><li>like 的模糊查询以 % 开头，会导致索引失效。 </li><li>一个表建的索引尽量不要超过 5 个。 </li><li>尽量使用覆盖索引。 </li><li>尽量不要在重复数据多的列上建索引。 </li><li>……</li></ul><p>很多这里就不一一列举了！那看完这篇文章，我们能否带着疑问去分析一下为什么要有这些建议？</p><blockquote><p>原<em>作者：苏静</em>，转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655825290&amp;idx=1&amp;sn=455202c916d0a7bd9e3fbbef95ddde76&amp;chksm=bd74e05d8a03694b028c2276d3ddda70e9e966ac98962d503e0c8c5c30bf5f4b6042165387d0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">心里没点B树，怎能吃透数据库索引底层原理？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所以下面我们就从二叉树到平衡二叉树，再到 B- 树，最后到 B+ 树来一步一步了解数据库索引底层的原理！&lt;/p&gt;
&lt;h1 id=&quot;二叉树（Binary-Search-Trees）&quot;&gt;&lt;a href=&quot;#二叉树（Binary-Search-Trees）&quot; class=&quot;headerlink&quot; title=&quot;二叉树（Binary Search Trees）&quot;&gt;&lt;/a&gt;二叉树（Binary Search Trees）&lt;/h1&gt;&lt;p&gt;二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（Left Subtree）和“右子树”（Right Subtree）。二叉树常被用于实现二叉查找树和二叉堆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树有如下特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个结点都包含一个元素以及 n 个子树，这里 0≤n≤2。 &lt;/li&gt;
&lt;li&gt;左子树和右子树是有顺序的，次序不能任意颠倒。左子树的值要小于父结点，右子树的值要大于父结点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="B树" scheme="https://vincentruan.github.io/tags/B%E6%A0%91/"/>
    
      <category term="B+树" scheme="https://vincentruan.github.io/tags/B-%E6%A0%91/"/>
    
      <category term="数据库" scheme="https://vincentruan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="https://vincentruan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>微服务-API网关</title>
    <link href="https://vincentruan.github.io/2020/02/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1-API%E7%BD%91%E5%85%B3/"/>
    <id>https://vincentruan.github.io/2020/02/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1-API%E7%BD%91%E5%85%B3/</id>
    <published>2020-02-27T06:29:12.000Z</published>
    <updated>2020-02-28T08:33:48.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h1><h2 id="什么是-API-网关"><a href="#什么是-API-网关" class="headerlink" title="什么是 API 网关"></a>什么是 API 网关</h2><p>既然需要 API 网关为我所用，首先就让我们来了解一下什么是 API 网关。</p><h3 id="什么是-API-网关-1"><a href="#什么是-API-网关-1" class="headerlink" title="什么是 API 网关"></a>什么是 API 网关</h3><p>网关一词最早出现在网络设备，比如两个相互独立的局域网之间通过路由器进行通信，中间的路由被称之为网关。</p><p>任何一个应用系统如果需要被其他系统调用，就需要暴露 API，这些 API 代表着一个一个的功能点。</p><p>如果两个系统中间通信，在系统之间加上一个中介者协助 API 的调用，这个中介者就是 API 网关。</p><a id="more"></a><p><img src="/2020/02/27/微服务-API网关/640-1582785125084.webp" alt="img"></p><center><i>对接两个系统的 API 网关</i></center><p>当然，API 网关可以放在两个系统之间，同时也可以放在客户端与服务端之间。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785171304.png" alt="img"></p><center><i>对接客户端和服务端的 API 网关</i></center><p>知道了 API 网关的基本定义，再来看看为什么我们要使用它。</p><h3 id="为何要使用-API-网关"><a href="#为何要使用-API-网关" class="headerlink" title="为何要使用 API 网关"></a>为何要使用 API 网关</h3><p>网关作为系统的唯一入口，也就是说，进入系统的所有请求都需要经过 API 网关。</p><p><strong>当系统外部的应用或者客户端访问系统的时候，都会遇到这样的情况：</strong></p><ul><li>系统要判断它们的权限</li><li>如果传输协议不一致，需要对协议进行转换</li><li>如果调用水平扩展的服务，需要做负载均衡</li><li>一旦请求流量超出系统承受的范围，需要做限流操作</li><li>针对每个请求以及回复，系统会记录响应的日志</li></ul><p>也就是说，只要是涉及到对系统的请求，并且能够从业务中抽离出来的功能，都有可能在网关上实现。</p><p>例如：协议转换，负载均衡，请求路由，流量控制等等。后面我们会一一给大家介绍这些功能。</p><p>在了解 API 网关有哪些基本功能以后，来看看它可以服务于哪些系统或者客户端。</p><h3 id="API-网关服务定位"><a href="#API-网关服务定位" class="headerlink" title="API 网关服务定位"></a>API 网关服务定位</h3><p>API 网关拥有处理请求的能力，从定位来看分为 5 类：</p><p><strong>①面向 WebApp，</strong>这部分的系统以网站和 H5 应用为主。通过前后端分离的设计，将大部分的业务功能都放在了后端，前面的 Web App 只展示页面的内容。</p><p><strong>②MobileApp，</strong>这里的 Mobile 指的是 iOS 和 Android，设计思路和 WebApp 基本相同。<br>区别是 API 网关需要做一些移动设备管理的工作（MDM）。例如：设备的注册，激活，使用，淘汰等，全生命周期的管理。<br>由于移动设备的特殊性，导致了我们在考虑移动设备请求的时候，需要考虑请求，设备，使用者之间的关系。</p><p><strong>③面向合作伙伴的 OpenAPI，</strong>通常系统会给合作伙伴提供接口。这些接口会全部开放或者部分开发，在有条件限制（时间，流量）的情况下给合作伙伴访问。因此需要更多考虑 API 网关的流量和安全以及协议转换的管理。</p><p><strong>④企业内部可扩展 API，</strong>给企业内部的其他部门或者项目使用，也可以作为中台输出的一部分，支持其他系统。这里需要更多地考虑划分功能边界，认证和授权问题。</p><p><strong>⑤面向 IOT 设备，</strong>会接收来自 IOT 设备的请求，特别是工业传感器等设备。这里需要考虑协议转换和数据过滤。</p><h3 id="API-网关架构"><a href="#API-网关架构" class="headerlink" title="API 网关架构"></a>API 网关架构</h3><p>既然谈了 API 网关的功能和定位，接下来说说它的架构：</p><p><img src="/2020/02/27/微服务-API网关/640-1582785312869.jpg" alt="img"></p><center><i>API 网关系统架构图</i></center><p>API 网关拆分成为 3 个系统：</p><ul><li><strong>Gateway-Core（核心）</strong></li><li><strong>Gateway-Admin（管理）</strong></li><li><strong>Gateway-Monitor（监控）</strong></li></ul><p>Gateway-Core 核心网关，负责接收客户端请求，调度、加载和执行组件，将请求路由到上游服务端，并处理其返回的结果。</p><p>大多数的功能都在这一层完成，例如：验证，鉴权，负载均衡，协议转换，服务路由，数据缓存。如果没有其他两个子系统，它也是可以单独运行的。</p><p>Gateway-Admin 网关管理界面，可以进行 API、组件等系统基础信息的配置；例如：限流的策略，缓存配置，告警设置。</p><p>Gateway-Monitor 监控日志、生成各种运维管理报表、自动告警等；管理和监控系统主要是为核心系统服务的，起到支撑的作用。</p><h2 id="API-网关技术原理"><a href="#API-网关技术原理" class="headerlink" title="API 网关技术原理"></a>API 网关技术原理</h2><p>上面谈到了网关的架构思路，这里谈几点技术原理。平时我们在使用网关的时候，多注重其实现的功能。例如：路由，负载均衡，限流，缓存，日志，发布等等。</p><p>实际上这些功能的背后有一些原理我们可以了解，这样在应用功能的时候会更加笃定。下面是几个原理分享给大家。</p><h3 id="协议转换"><a href="#协议转换" class="headerlink" title="协议转换"></a>协议转换</h3><p>每个系统内部服务之间的调用，可以统一使用一种协议，例如：HTTP，GRPC。</p><p>假设每个系统使用的协议不同，那么系统之间的调用或者数据传输，就存在协议转换的问题了。如果解决这个问题呢？API 网关通过泛化调用的方式实现协议之间的转化。</p><p>实际上就是将不同的协议转换成“通用协议”，然后再将通用协议转化成本地系统能够识别的协议。</p><p>这一转化工作通常在 API 网关完成。通用协议用得比较多的有 JSON，当然也有使用 XML 或者自定义 JSON 文件的。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785663976.webp" alt="img"></p><center><i>不同的协议需要转化成共同语言进行传输</i></center><h3 id="链式处理"><a href="#链式处理" class="headerlink" title="链式处理"></a>链式处理</h3><p>设计模式中有一种责任链模式，它将“处理请求”和“处理步骤”分开。每个处理步骤，只关心这个步骤上需要做的处理操作，处理步骤存在先后顺序。</p><p>消息从第一个“处理步骤”流入，从最后一个“处理步骤”流出，每个步骤对经过的消息进行处理，整个过程形成了一个链条。在 API 网关中也用到了类似的模式。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785725522.webp" alt="img"></p><center><i>Zuul 网关过滤器链式处理</i></center><p>下面以 Zuul 为例，当消息出入网关需要经历一系列的过滤器。这些过滤器之间是有先后顺序的，并且在每个过滤器需要进行的工作也是各不一样：</p><ul><li><strong>PRE：</strong>前置过滤器，用来处理通用事务，比如鉴权，限流，熔断降级，缓存。并且可以通过 Custom 过滤器进行扩展。</li><li><strong>ROUTING：</strong>路由过滤器，在这种过滤器中把用户请求发送给 Origin Server。它主要负责：协议转化和路由的工作。</li><li><strong>POST：</strong>后置过滤器，从 Origin Server 返回的响应信息会经过它，再返回给调用者。在返回的 Response 上加入 Response Header，同时可以做 Response 的统计和日志记录。</li><li><strong>ERROR：</strong>错误过滤器，当上面三个过滤器发生异常时，错误信息会进到这里，并对错误进行处理。</li></ul><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>所有的请求通过 API 网关访问应用服务，一旦吞吐量上去了，如何高效地处理这些请求？</p><p><strong>拿 Zuul 为例，Zuul1 采用：</strong>一个线程处理一个请求的方式。线程负责接受请求，然后调用应用返回结果。</p><p>如果把网络请求看成一次 IO 操作的话，处理请求的线程，从接受请求，到服务返回响应，都是阻塞状态。</p><p>同时，如果多个线程都处在这种状态，会导致系统缓慢。因为每个网关能够开启的线程数量是有限的，特别是在访问的高峰期。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785808868.webp" alt="img"></p><center><i>每个线程处理一个请求</i></center><p>为了解决这个问题，Zuul2 启动了异步请求的机制。每个请求进入网关的时候，会被包装成一个事件，CPU 内核会维持一个监听器，不断轮询“请求事件”。</p><p>一旦，发现请求事件，就会调用对应的应用。获取应用返回的信息以后，按照请求的要求把数据/文件放到指定的缓冲区，同时发送一个通知事件，告诉请求端数据已经就绪，可以从这个缓冲获取数据/文件。</p><p>这个过程是异步的，请求的线程不用一直等待数据的返回。它在请求完毕以后，就直接返回了，这时它可以做其他的事情。</p><p>当请求数据被 CPU 内核获取，并且发送到指定的数据缓冲区时，请求的线程会接到“数据返回”的通知，然后就直接使用数据，不用自己去做取数据的操作。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785841303.webp" alt="img"></p><center><i>异步请求处理，CPU 处理数据以后通知请求端</i></center><p>实现异步处理请求有两种模式，分别是：</p><ul><li><strong>Reactor</strong></li><li><strong>Proactor</strong></li></ul><p><img src="/2020/02/27/微服务-API网关/640-1582786001001.png" alt="img"></p><center><i>Reactor 工作原理流水图</i></center><p><strong>Reactor：</strong>通过 handle_events 事件循环处理请求。用户线程注册事件处理器之后，可以继续执行其他的工作（异步），而 Reactor 线程负责调用内核的 Select 函数检查 Socket 状态。</p><p>当有 Socket 被激活时（获取网络数据），则通知相应的用户线程，执行 handle_event 进行数据读取、处理的工作。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786035615.png" alt="img"></p><center><i>Proactor 工作原理流水图</i></center><p><strong>Proactor：</strong>用户线程使用 CPU 内核提供的异步 IO 发起请求，请求发起以后立即返回。CPU 内核继续执行用户请求线程代码。</p><p>此时用户线程已将 AsynchronousOperation（异步处理）和 CompletionHandler（完成获取资源）注册到内核。之后操作系统开启独立的内核线程去处理 IO 操作。</p><p>当请求的数据到达时，由内核负责读取 Socket（网络请求）中的数据，并写入用户指定的缓冲区中。</p><p>最后内核将数据和用户线程注册的 CompletionHandler 分发给内部 Proactor，Proactor 将 IO 完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步 IO。</p><h2 id="API-网关实现功能"><a href="#API-网关实现功能" class="headerlink" title="API 网关实现功能"></a>API 网关实现功能</h2><p>说起对 API 网关的使用，我们还是对具体功能更加感兴趣。让我们一起来看看它实现了哪些功能。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>当网关后面挂接同一应用的多个副本时，每次用户的请求都会通过网关的负载均衡算法，路由到对应的服务上面。例如：随机算法，权重算法，Hash 算法等等。</p><p>如果上游服务采取微服务的架构，也可以和注册中心合作实现动态的负载均衡。</p><p>当微服务动态挂载（动态扩容）的时候，可以通过服务注册中心获取微服务的注册信息，从而实现负载均衡。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786091726.png" alt="img"></p><center><i>Nginx+Lua+服务注册中心实现动态负载均衡</i></center><h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>这个不言而喻，网关可以根据请求的 URL 地址解析，知道需要访问的服务。再通过路由表把请求路由到目标服务上去。</p><p>有时候因为网络原因，服务可能会暂时的不可用，这个时候我们希望可以再次对服务进行重试。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786124168.webp" alt="img"></p><center><i>Zuul 作为 API 网关将请求路由到上游服务器</i></center><p>例如：Zuul 与 Spring Retry 合作完成路由重试。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否开启重试功能</span></span><br><span class="line"><span class="meta">zuul.retryable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#对当前服务的重试次数</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetries</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>限流是 API 网关常用的功能之一，当上游服务超出请求承载范围，或者服务因为某种原因无法正常使用，都会导致服务处理能力下滑。</p><p>这个时候，API 网关作为“看门人”，就可以限制流入的请求，让应用服务器免受冲击。</p><p>限流实际上就是限制流入请求的数量，其算法不少，有令牌桶算法，漏桶算法，连接数限制等等。这里我们就介绍三个常用的，一般通过 Nginx+Lua 来实现。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786174509.png" alt="img"></p><center><i>令牌桶限流</i></center><h3 id="统一鉴权"><a href="#统一鉴权" class="headerlink" title="统一鉴权"></a>统一鉴权</h3><p>访问应用服务器的请求都需要拥有一定权限，如果说每访问一个服务都需要验证一次权限，这个对效率是很大的影响。可以把权限认证放到 API 网关来进行。</p><p>目前比较常见的做法是，用户通过登录服务获取 Token，把它存放到客户端，在每次请求的时候把这个 Token 放入请求头，一起发送给服务器。</p><p>API 网关要做的事情就是解析这个 Token，知道访问者是谁（鉴定），他能做什么/访问什么（权限）。</p><p>说白了就是看访问者能够访问哪些 URL，这里根据权限/角色定义一个访问列表。</p><p>如果要实现多个系统的 OSS（Single Sign On 单点登录），API 网关需要和 CAS（Central Authentication Service 中心鉴权服务）做连接，来确定请求者的身份和权限。</p><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>当应用服务出现异常，不能继续提供服务的时候，也就是说应用服务不可用了。作为 API 网关需要做出处理，把请求导入到其他服务上。</p><p>或者对服务进行降级处理，例如：用兜底的服务数据返回客户端，或者提示服务暂时不可用。</p><p>同时通过服务注册中心，监听存在问题的服务，一旦服务恢复，随即恢复路由请求到该服务。</p><p>例如：Zuul 中提供了 ZuulFallbackProvider 接口来实现熔断，它提供两个方法，一个指明熔断拦截的服务 getRoute，一个指定返回内容 ClientHttpResponse。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The route this fallback will be used  for.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The route the fallback will be  used for.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provides a fallback response.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The fallback response.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">ClientHttpResponsefallbackResponse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过自定义的 Fallback 方法，并且将其指定给某个 Route 来实现该 Route 访问出问题的熔断处理。</p><p>主要继承 ZuulFallbackProvider 接口来实现，ZuulFallbackProvider 默认有两个方法，一个用来指明熔断拦截哪个服务，一个定制返回内容。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786260809.png" alt="img"></p><center><i>API 网关熔断降级</i></center><h3 id="发布测试"><a href="#发布测试" class="headerlink" title="发布测试"></a>发布测试</h3><p>在发布版本的时候会采用：金丝雀发布和蓝绿发布。作为 API 网关可以使用路由选择和流量切换来协助上述行为。这里以金丝雀发布为例，看看 API 网关如何做路由转换的。</p><p>假设将 4 个服务从 V1 更新到 V2 版本，这 4 个服务的流量请求由 1 个 API 网关管理。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786294156.webp" alt="img"></p><p>那么先将一台服务与 API 网关断开，部署 V2 版本的服务，然后 API 网关再将流量导入到 V2 版本的服务上。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786301772.webp" alt="img"></p><p>这里流量的导入可以是逐步进行的，一旦 V2 版本的服务趋于稳定。再如法炮制，将其他服务替换成 V2 版本。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786310099.jpg" alt="img"></p><p>金丝雀发布一般先发 1 台，或者一个小比例，例如 2% 的服务器，主要做流量验证用，也称为金丝雀（Canary）测试（灰度测试）。</p><p>其来历是，旷工下矿洞前，先放一只金丝雀探查是否有毒气，金丝雀发布由此得名。</p><p>金丝雀测试需要完善的监控设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回滚的依据。</p><p>如果金丝测试通过，则把剩余的 V1 版本全部升级为 V2 版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。</p><h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><p><img src="/2020/02/27/微服务-API网关/640-1582786344099.webp" alt="img"></p><p>我们可以在 API 网关缓存一些修改频率不高的数据。<em>例如：用户信息，配置信息，通过服务定期刷新这个缓存就行了</em>：</p><ul><li>用户请求先访问 API 网关，如果发现有缓存信息，直接返回给用户。</li><li>如果没有发现缓存信息，回源到应用服务器获取信息。</li><li>另外，有一个缓存更新服务，定期把应用服务器中的信息更新到网关本地缓存中。</li></ul><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>通过 API 网关上的过滤器我们可以加入日志服务，记录请求和返回信息。同时可以建立一个管理员的界面去监控这些数据。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785080155.webp" alt="img"></p><center><i>日志服务简图</i></center><p>日志记录了以后，可以做很多功能扩展。我们整理了以下几点供大家参考：</p><ul><li><strong>报表分析：</strong>针对服务访问情况，提供可视化展示。</li><li><strong>实时查询：</strong>了解实时关键信息，例如：吞吐量，并发数。在秒杀活动的时候，会特别关注。</li><li><strong>异常告警：</strong>针对关键参数进行监控，对于统计结果支持阈值报警，对接阿里云通知中心、短信、钉钉进行告警。</li><li><strong>日志投递：</strong>将日志进行归档，存放到文件库或者数据仓库中，以便后期分析。</li></ul><p><img src="/2020/02/27/微服务-API网关/640-1582785080158.webp" alt="img"></p><center><i>日志记录衍生的功能</i></center><h2 id="流行-API-网关对比"><a href="#流行-API-网关对比" class="headerlink" title="流行 API 网关对比"></a>流行 API 网关对比</h2><p>在介绍了 API 网关的功能以后，再来看看目前几个流行的 API 网关项目。看看他们各自的特点，并且把他们做一个简单的比较。这些网关目前都是开源的，大家可以有选择地在项目中使用。</p><h3 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h3><p>Kong 是 Mash ape 公司的开源项目，它是一个在 Nginx 中运行的 Lua 应用程序，并且可以通过 Lua-Nginx 模块实现扩展。</p><p>所以，可以通过插件集合的方式定制功能，例如：HTTP 基本认证、密钥认证、CORS（Cross-origin Resource Sharing，跨域资源共享）、TCP、UDP、日志、API 限流、请求转发以及监控，都是目前已有的插件。</p><p>由于是基于 Nginx 的，所以可以对网关进行水平扩展，来应对大批量的网络请求。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786729359.png" alt="img"></p><center><i>Kong 架构图</i></center><p>Kong 主要有三个组件：</p><ul><li><strong>KongServer ：</strong>基于 Nginx 的服务器，用来接收 API 请求。</li><li><strong>ApacheCassandra/PostgreSQL：</strong>用来存储操作数据。</li><li><strong>Kongdashboard：</strong>UI 管理工具。</li></ul><h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p><img src="/2020/02/27/微服务-API网关/640-1582786770091.webp" alt="img"></p><center><i>Traefik 架构图</i></center><p>Traefik 是 HTTP 反向代理和负载均衡器，可以轻松部署微服务，可以与现有的组件（Docker、Swarm，Kubernetes，Marathon，Consul，Etcd）做集成。</p><p>因为支持动态配置，所以它的伸缩性很好。不过它只支持 HTTP、HTTPS 和 GRPC。如果你需要 TCP 负载均衡，那么您需要选择其他方案了。</p><h3 id="Ambassador"><a href="#Ambassador" class="headerlink" title="Ambassador"></a>Ambassador</h3><p><img src="/2020/02/27/微服务-API网关/640-1582785080167.webp" alt="img"></p><center><i>Ambassador 架构图</i></center><p>Ambassador 是一个基于 Envoy Proxy 构建的，Kubernetes 原生的开源微服务网关。</p><p>它在构建之初就致力于支持多个独立的团队，这些团队需要为最终用户快速发布、监控和更新服务。</p><p>Ambassador 还具有 Kubernetes Ingress 和负载均衡的能力。它支持处理 Kubernetes Ingress Controller 和负载均衡等功能，可以与 Istio 无缝集成。</p><h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p><img src="/2020/02/27/微服务-API网关/640-1582785080168.webp" alt="img"></p><center><i>Zuul 2 结构图</i></center><p>Zuul 是 Spring Cloud 全家桶中的微服务 API 网关。所有从设备或网站来的请求都会经过 Zuul 到达后端的 Netflix 应用程序。</p><p>作为一个边界性质的应用程序，Zuul 提供了动态路由、监控、弹性负载和安全功能。包括 Zuul1 和 Zuul2 两个版本。</p><p>介绍了几个开源 API 网关的基本信息以后，我们从几个维度对他们进行比较：</p><p><img src="/2020/02/27/微服务-API网关/640-1582786854230.png" alt="img"></p><p>从开源社区活跃度来说，Kong 和 Traefik 较好；从成熟度来看，较好的是 Kong、Traefik；从架构优势的扩展性来看，Kong 有丰富的插件，Ambassador 也有插件但不多，而 Zuul 是需要自研。</p><p>但 Zuul 由于与 Spring Cloud 集成，如果使用 Spring Cloud 的小伙伴可以考虑使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>API 网关是系统内外通讯的中介者。从定位上来说它服务 WebApp，MobileApp，合作伙伴 OpenAPI，企业内部可扩展 API，以及 IOT 设备。</p><p>从架构设计角度来说，分为 Gateway-Core（核心）、Gateway-Admin（管理）、Gateway-Monitor（监控）三部分。</p><p>API 网关需要注意的技术原理有，协议转换，链式处理以及异步请求。它的应用比较广泛，例如：负载均衡，路由选择，流量控制，统一鉴权，熔断降级，发布测试，缓存数据，日志记录等。</p><p>比较流行的开源 API网关有 Kong，Traefik，Ambassador，Zuul。从使用上来说他们各有千秋，可以根据项目的情况选取。</p><blockquote><p>转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655826846&amp;idx=1&amp;sn=483ea4f2d1d34f921ef07e35a4af63c1&amp;chksm=bd74fe498a03775fc5980c568e1af13f53c64ebaaedea643dc4ec03acc338fac7a323e3656a7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655826846&amp;idx=1&amp;sn=483ea4f2d1d34f921ef07e35a4af63c1&amp;chksm=bd74fe498a03775fc5980c568e1af13f53c64ebaaedea643dc4ec03acc338fac7a323e3656a7&amp;scene=21#wechat_redirect</a> 原<em>作者：崔皓</em></p></blockquote><h1 id="各大API网关性能比较"><a href="#各大API网关性能比较" class="headerlink" title="各大API网关性能比较"></a>各大API网关性能比较</h1><p>API网关最基本的功能就是反向代理，所以在对API网关做技术选型的时候需要着重考察其性能表现，本文对Nginx、Haproxy、Netty、Spring Cloud Gateway、Zuul2做了性能测试，测试代码可以在<a href="https://github.com/chanjarster/api-gateways-comparison" target="_blank" rel="noopener">github</a>获得。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ul><li>准备了三台2CPU 4G内存的服务器，分别运行Tomcat、API Gateway、Gatling（压测工具）</li><li>先对Tomcat做压测，取Tomcat充分预热后的压测结果作为基准。压的是Tomcat自带的example：<code>/examples/jsp/jsp2/simpletag/book.jsp</code></li><li>在对Netty、Zuul2、Spring Cloud Gateway做压测时候也是先压个几轮做预热。</li><li>被测的API网关都没有添加额外业务，只做反向代理</li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>下图是吞吐量的情况，可以看到Netty、Nginx、Haproxy均比直压Tomcat低一点点，而Spring Cloud Gateway和Zuul2则要低得多。</p><p><img src="/2020/02/27/微服务-API网关/2973533330-5caf458852f74_articlex.png" alt="clipboard.png"></p><p>下面这张图可以更明显的看到吞吐量比较，Tomcat为100%因为它是基准值，Netty、Nginx、Haproxy的只比基准值低8%，而Spring Cloud Gateway和Zuul2则只是基准值的35%和34%（难兄难弟）。</p><p><img src="/2020/02/27/微服务-API网关/3673220854-5caf459e353c7_articlex.png" alt="clipboard.png"></p><h2 id="平均响应时间"><a href="#平均响应时间" class="headerlink" title="平均响应时间"></a>平均响应时间</h2><p>下图可以看到Netty、Nginx、Haproxy的平均响应时间与Tomcat差不多。但是Spring Cloud Gateway和Zuul2则是Tomcat的3倍多，不出所料。</p><p><img src="/2020/02/27/微服务-API网关/2061935431-5caf45afea0b8_articlex.png" alt="clipboard.png"></p><p>下图同样是以Tomcat作为基准值的比较：</p><p><img src="/2020/02/27/微服务-API网关/60484509-5caf45c794cb9_articlex.png" alt="clipboard.png"></p><h2 id="响应时间分布"><a href="#响应时间分布" class="headerlink" title="响应时间分布"></a>响应时间分布</h2><p>光看平均响应时间是不够的，我们还得看P50、P90、P99、P99.9以及Max响应时间（可惜Gatling只能设置4个百分位，否则我还想看看P99.99的响应时间）。</p><blockquote><p>为何要观察P99.9的响应时间？光看P90不够吗？理由有两个：</p><p>1）观察P99、P99.9、P99.99的响应时间可以观察系统的在高压情况下的稳定性，如果这三个时间的增长比较平滑那么说明该系统在高压力情况下比较稳定，如果这个曲线非常陡峭则说明不稳定。</p><p>2）观察P99、P99.9、P99.99的响应时间能够帮助你估算用户体验。假设你有一个页面会发出5次请求，那么这5次请求均落在P90以内概率是多少？90%^5=59%，至少会经历一次 &gt; P90响应时间的概率是 100%-59%=41%，如果你的P90=10s，那么就意味着用户有41%的概率会在加载页面的时候超过10s，是不是很惊人？如果你的P99=10s，那么用户只有5%的概率会在访问页面的时候超过10s。如果P99.9=10s，则有0.4%的概率。</p><p>关于如何正确测量系统可以看 <a href="https://www.youtube.com/watch?v=lJ8ydIuPFeU" target="_blank" rel="noopener">“How NOT to Measure Latency” by Gil Tene</a></p></blockquote><p><img src="/2020/02/27/微服务-API网关/684416954-5caf45ec7efc3_articlex.png" alt="clipboard.png"></p><p>下面同样是把结果与Tomcat基准值做对比：</p><p><img src="/2020/02/27/微服务-API网关/851752044-5caf460b876aa_articlex.png" alt="clipboard.png"></p><p>可以看到几个很有趣的现象：</p><ul><li>Haproxy、Nginx的P50、P90、P99、P99.9、Max都是逐渐递增的。</li><li>Netty的P50、P90、P99、P99.9是很平坦的，Max则为基准值的207%。</li><li>Spring Cloud Gateway和Zuul2则是相反的，它们的平面呈现下降趋势。Spring Cloud Gateway的Max甚至还比基准值低了一点点（94%），我相信这只是一个随机出现的数字，不要太在意。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Nginx、Haproxy、Netty三者的表现均很不错，其对于吞吐量和响应时间的性能损耗很低，可以忽略不计。</p><p>但是目前最为火热的Spring Cloud Gateway和Zuul2则表现得比较糟糕，因我没有写额外的业务逻辑这，可以推测这和它们的内置逻辑有关，那么大致有这么几种可能：</p><ol><li>内置逻辑比较多</li><li>内置逻辑算法存在问题，占用了太多CPU时间</li><li>内置逻辑存在阻塞</li><li>内置逻辑没有用正确姿势使用Netty（两者皆基于Netty）</li></ol><p>不管是上面的哪一种都需要再后续分析。</p><p>不过话说回来考虑选用那种作为API网关（的基础技术）不光要看性能，还要看：</p><ul><li>是否易于扩展自己的业务逻辑</li><li>API使用的便利性</li><li>代码的可维护性</li><li>文档是否齐全</li><li>…</li></ul><p>性能只是我们手里的一个筹码，当我们知道这个东西性能到底几何后，才可以与上面的这些做交换（trade-off）。比如Nginx和Haproxy的可扩展性很差，那么我们可以使用Netty。如果你觉得Netty的API太底层了太难用了，那么可以考虑<code>Spring Cloud Gateway</code>或<code>Zuul2</code>。前提是你知道你会失去多少性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API-网关&quot;&gt;&lt;a href=&quot;#API-网关&quot; class=&quot;headerlink&quot; title=&quot;API 网关&quot;&gt;&lt;/a&gt;API 网关&lt;/h1&gt;&lt;h2 id=&quot;什么是-API-网关&quot;&gt;&lt;a href=&quot;#什么是-API-网关&quot; class=&quot;headerlink&quot; title=&quot;什么是 API 网关&quot;&gt;&lt;/a&gt;什么是 API 网关&lt;/h2&gt;&lt;p&gt;既然需要 API 网关为我所用，首先就让我们来了解一下什么是 API 网关。&lt;/p&gt;
&lt;h3 id=&quot;什么是-API-网关-1&quot;&gt;&lt;a href=&quot;#什么是-API-网关-1&quot; class=&quot;headerlink&quot; title=&quot;什么是 API 网关&quot;&gt;&lt;/a&gt;什么是 API 网关&lt;/h3&gt;&lt;p&gt;网关一词最早出现在网络设备，比如两个相互独立的局域网之间通过路由器进行通信，中间的路由被称之为网关。&lt;/p&gt;
&lt;p&gt;任何一个应用系统如果需要被其他系统调用，就需要暴露 API，这些 API 代表着一个一个的功能点。&lt;/p&gt;
&lt;p&gt;如果两个系统中间通信，在系统之间加上一个中介者协助 API 的调用，这个中介者就是 API 网关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构设计" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="API网关" scheme="https://vincentruan.github.io/tags/API%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>数据库软件架构设计</title>
    <link href="https://vincentruan.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://vincentruan.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-02-26T03:28:47.000Z</published>
    <updated>2020-02-26T09:53:39.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="概念一：单库"><a href="#概念一：单库" class="headerlink" title="概念一：单库"></a>概念一：单库</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688299341.webp" alt="img"></p><h2 id="概念二：分片"><a href="#概念二：分片" class="headerlink" title="概念二：分片"></a>概念二：分片</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688306996.webp" alt="img"></p><p>分片解决“数据量太大”这一问题，也就是通常说的“水平切分”。</p><p>一旦引入分片，势必面临“数据路由”的新问题，数据到底要访问哪个库。路由规则通常有3种方法：</p><a id="more"></a><h3 id="（1）范围：range"><a href="#（1）范围：range" class="headerlink" title="（1）范围：range"></a>（1）范围：range</h3><p>优点：简单，容易扩展。</p><p>缺点：各库压力不均（新号段更活跃）。</p><h3 id="（2）哈希：hash"><a href="#（2）哈希：hash" class="headerlink" title="（2）哈希：hash"></a>（2）哈希：hash</h3><p>优点：简单，数据均衡，负载均匀。</p><p>缺点：迁移麻烦（2库扩3库数据要迁移）。</p><h3 id="（3）统一路由服务：router-config-server"><a href="#（3）统一路由服务：router-config-server" class="headerlink" title="（3）统一路由服务：router-config-server"></a>（3）统一路由服务：router-config-server</h3><p>优点：灵活性强，业务与路由算法解耦。</p><p>缺点：每次访问数据库前多一次查询。</p><p>大部分互联网公司采用的方案二：哈希路由。</p><h2 id="概念三：分组"><a href="#概念三：分组" class="headerlink" title="概念三：分组"></a>概念三：分组</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688370033.webp" alt="img"><br>分组解决“可用性，性能提升”这一问题，分组通常通过主从复制的方式实现。</p><p>互联网公司数据库实际软件架构是“既分片，又分组”：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805463.webp" alt="img"></p><hr><p>数据库软件架构，究竟设计些什么呢，至少要考虑以下四点：</p><ul><li>如何保证数据可用性</li><li>如何提高数据库读性能（大部分应用读多写少，读会先成为瓶颈）</li><li>如何保证一致性</li><li>如何提高扩展性</li></ul><hr><h1 id="如何保证数据的可用性？"><a href="#如何保证数据的可用性？" class="headerlink" title="如何保证数据的可用性？"></a>如何保证数据的可用性？</h1><p>解决可用性问题的思路是：冗余。</p><blockquote><p>如何保证站点的可用性？冗余站点。<br>如何保证服务的可用性？冗余服务。<br>如何保证数据的可用性？冗余数据。</p></blockquote><p>数据的冗余，会带来一个副作用：一致性问题。</p><h2 id="如何保证数据库“读”高可用？"><a href="#如何保证数据库“读”高可用？" class="headerlink" title="如何保证数据库“读”高可用？"></a>如何保证数据库“读”高可用？</h2><blockquote><p>冗余读库</p></blockquote><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805472.webp" alt="img"></p><p>冗余读库带来什么副作用？</p><p>读写有延时，数据可能不一致。</p><p>上图是很多互联网公司mysql的架构，写仍然是单点，不能保证写高可用。</p><h2 id="如何保证数据库“写”高可用？"><a href="#如何保证数据库“写”高可用？" class="headerlink" title="如何保证数据库“写”高可用？"></a>如何保证数据库“写”高可用？</h2><blockquote><p>冗余写库。</p></blockquote><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805479.webp" alt="img"><br>采用双主互备的方式，可以冗余写库。</p><p>冗余写库带来什么副作用？</p><p>双写同步，数据可能冲突（例如“自增id”同步冲突）。</p><blockquote><p>如何解决同步冲突，有两种常见解决方案：<br>（1）两个写库使用不同的初始值，相同的步长来增加id：1写库的id为0,2,4,6…；2写库的id为1,3,5,7…；<br>（2）不使用数据的id，业务层自己生成唯一的id，保证数据不冲突；</p></blockquote><p>阿里云的RDS服务号称写高可用，是如何实现的呢？</p><p>他们采用的就是类似于“双主同步”的方式（不再有从库了）。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805483.webp" alt="img"><br>仍是双主，但只有一个主提供读写服务，另一个主是“shadow-master”，只用来保证高可用，平时不提供服务。</p><p>master挂了，shadow-master顶上，虚IP漂移，对业务层透明，不需要人工介入。</p><blockquote><p>这种方式的好处：<br>（1）读写没有延时，无一致性问题；<br>（2）读写高可用；</p></blockquote><blockquote><p>不足是：<br>（1）不能通过加从库的方式扩展读性能；<br>（2）资源利用率为50%，一台冗余主没有提供服务；</p></blockquote><p><em>画外音：所以，高可用RDS还挺贵的。</em></p><h1 id="如何扩展读性能？"><a href="#如何扩展读性能？" class="headerlink" title="如何扩展读性能？"></a>如何扩展读性能？</h1><p>提高读性能的方式大致有三种，</p><h2 id="第一种是增加索引。"><a href="#第一种是增加索引。" class="headerlink" title="第一种是增加索引。"></a>第一种是增加索引。</h2><p>这种方式不展开，要提到的一点是，不同的库可以建立不同的索引。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805494.webp" alt="img"><br>如上图：</p><p>（1）写库不建立索引；<br>（2）线上读库建立线上访问索引，例如uid；<br>（3）线下读库建立线下访问索引，例如time；</p><h2 id="第二种扩充读性能的方式是，增加从库。"><a href="#第二种扩充读性能的方式是，增加从库。" class="headerlink" title="第二种扩充读性能的方式是，增加从库。"></a>第二种扩充读性能的方式是，增加从库。</h2><p>这种方法大家用的比较多，存在两个缺点：</p><p>（1）从库越多，同步越慢；<br>（2）同步越慢，数据不一致窗口越大；</p><h2 id="第三种增加系统读性能的方式是，增加缓存。"><a href="#第三种增加系统读性能的方式是，增加缓存。" class="headerlink" title="第三种增加系统读性能的方式是，增加缓存。"></a>第三种增加系统读性能的方式是，增加缓存。</h2><p>常见的缓存架构如下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805496.webp" alt="img"><br>（1）上游是业务应用；<br>（2）下游是主库，从库（读写分离），缓存；</p><p>如果系统架构实施了服务化：</p><p>（1）上游是业务应用；<br>（2）中间是服务；<br>（3）下游是主库，从库，缓存；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805568.webp" alt="img"><br>业务层不直接面向db和cache，服务层屏蔽了底层db、cache的复杂性。</p><p>不管采用主从的方式扩展读性能，还是缓存的方式扩展读性能，数据都要复制多份（主+从，db+cache），一定会引发一致性问题。</p><h1 id="如何保证一致性？"><a href="#如何保证一致性？" class="headerlink" title="如何保证一致性？"></a>如何保证一致性？</h1><p>主从数据库的一致性，通常有两种解决方案：</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688661771.webp" alt="img"><br>如果某一个key有写操作，在不一致时间窗口内，中间件会将这个key的读操作也路由到主库上。</p><h2 id="强制读主"><a href="#强制读主" class="headerlink" title="强制读主"></a>强制读主</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688686209.webp" alt="img"><br>“双主高可用”的架构，主从一致性的问题能够大大缓解。</p><p>第二类不一致，是db与缓存间的不一致。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582710817260.webp" alt="img"></p><p>这一类不一致，<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961368&amp;idx=1&amp;sn=82a59f41332e11a29c5759248bc1ba17&amp;chksm=bd2d0dc48a5a84d293f5999760b994cee9b7e20e240c04d0ed442e139f84ebacf608d51f4342&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《缓存架构，一篇足够？》</a>里有非常详细的叙述，本文不再展开。</p><p>另外建议，所有允许cache miss的业务场景，缓存中的KEY都设置一个超时时间，这样即使出现不一致，有机会得到自修复。</p><h1 id="如何保障数据库的扩展性？"><a href="#如何保障数据库的扩展性？" class="headerlink" title="如何保障数据库的扩展性？"></a>如何保障数据库的扩展性？</h1><h2 id="秒级成倍数据库扩容"><a href="#秒级成倍数据库扩容" class="headerlink" title="秒级成倍数据库扩容"></a>秒级成倍数据库扩容</h2><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962231&amp;idx=1&amp;sn=1b51d042c243f0b3ce0b748ddbcff865&amp;chksm=bd2d0eab8a5a87bdcbe7dd08fb4c969ad76fa0ea00b2c78645db8561fd2a78d813d7b8bef2ac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">亿级数据DB秒级平滑扩容</a>》</p><p>一步一步，娓娓道来。</p><p><strong>一般来说，并发量大，吞吐量大的互联网分层架构是怎么样的？</strong></p><p>数据库上层都有一个微服务，服务层记录“业务库”与“数据库实例配置”的映射关系，通过数据库连接池向数据库路由sql语句。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689399761.webp" alt="img"></p><p>如上图所示，服务层配置用户库user对应的数据库实例ip。</p><p><em>画外音：其实是一个内网域名。</em></p><h3 id="该分层架构，如何应对数据库的高可用？"><a href="#该分层架构，如何应对数据库的高可用？" class="headerlink" title="该分层架构，如何应对数据库的高可用？"></a>该分层架构，如何应对数据库的高可用？</h3><p>数据库高可用，很常见的一种方式，使用双主同步+keepalived+虚ip的方式进行。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689439373.webp" alt="img"></p><p>如上图所示，两个相互同步的主库使用相同的虚ip。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689464428.webp" alt="img"></p><p>当主库挂掉的时候，虚ip自动漂移到另一个主库，整个过程对调用方透明，通过这种方式保证数据库的高可用。</p><p><em>画外音：关于高可用，《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962050&amp;idx=1&amp;sn=f60b8bb833fe3425f5227da42e3b3adf&amp;chksm=bd2d0f1e8a5a8608f81d42a16eea476d0bd4763f84f9a008ed616d1cfa050a4015780f898eb1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">互联网分层架构如何保证“高可用“？</a>》专题介绍过，本文不再展开。</em></p><hr><h3 id="该分层架构，如何应对数据量的暴增？"><a href="#该分层架构，如何应对数据量的暴增？" class="headerlink" title="该分层架构，如何应对数据量的暴增？"></a>该分层架构，如何应对数据量的暴增？</h3><p>随着数据量的增大，数据库要进行水平切分，分库后将数据分布到不同的数据库实例（甚至物理机器）上，以达到降低数据量，增强性能的扩容目的。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689545536.webp" alt="img"></p><p>如上图所示，用户库user分布在两个实例上，ip0和ip1，服务层通过用户标识uid取模的方式进行寻库路由，模2余0的访问ip0上的user库，模2余1的访问ip1上的user库。</p><p><em>画外音：此时，水平切分集群的读写实例加倍，单个实例的数据量减半，性能增长可不止一倍。</em></p><p>综上三点所述，大数据量，高可用的互联网微服务分层的架构如下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689574601.webp" alt="img"></p><p>既有水平切分，又保证高可用。</p><p><strong>如果数据量持续增大，2个库性能扛不住了，该怎么办呢？</strong></p><p>此时，需要继续水平拆分，拆成更多的库，降低单库数据量，增加库主库实例（机器）数量，提高性能。</p><p><strong>新的问题来了，分成n个库后，随着数据量的增加，要增加到2*n个库，数据库如何扩容，数据能否平滑迁移，能够持续对外提供服务，保证服务的可用性？</strong></p><p><em>画外音：你遇到过类似的问题么？</em></p><p><strong>停服扩容，是最容易想到的方案？</strong></p><p>在讨论秒级平滑扩容方案之前，先简要说明下停服务扩容的方案的步骤：</p><p>（1）站点挂一个公告“为了为广大用户提供更好的服务，本站点/游戏将在今晚00:00-2:00之间升级，届时将不能登录，用户周知”；</p><p><em>画外音：见过这样的公告么，实际上在迁移数据。</em></p><p>（2）<strong>微服务停止服务</strong>，数据库不再有流量写入；</p><p>（3）<strong>新建2*n个新库</strong>，并做好高可用；</p><p><strong>（4）</strong>写一个小脚本进行<strong>数据迁移</strong>，把数据从n个库里select出来，insert到2*n个库里；</p><p>（5）<strong>修改微服务的数据库路由配置</strong>，模n变为模2*n；</p><p>（6）<strong>微服务重启</strong>，连接新库重新对外提供服务；</p><p>整个过程中，最耗时的是第四步数据迁移。</p><p><strong>如果出现问题，如何进行回滚？</strong></p><p>如果数据迁移失败，或者迁移后测试失败，则将<strong>配置改回旧库，恢复服务</strong>即可。</p><p><strong>停服方案有什么优劣？</strong></p><p>优点：<strong>简单</strong>。</p><p>缺点：</p><p>（1）需要停止服务，<strong>方案不高可用</strong>；</p><p>（2）技术同学压力大，所有工作要在规定时间内完成，根据经验，压力越大约容易出错；</p><p><em>画外音：这一点很致命。</em></p><p>（3）如果有问题第一时间没检查出来，启动了服务，运行一段时间后再发现有问题，则难以回滚，如果<strong>回档会丢失一部分数据</strong>；</p><h3 id="有没有秒级实施、更平滑、更帅气的方案呢？"><a href="#有没有秒级实施、更平滑、更帅气的方案呢？" class="headerlink" title="有没有秒级实施、更平滑、更帅气的方案呢？"></a>有没有秒级实施、更平滑、更帅气的方案呢？</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582689771696.webp" alt="img"></p><p>再次看一眼扩容前的架构，分两个库，假设每个库1亿数据量，<strong>如何</strong>平滑扩容，增加实例数，降低单库数据量呢？三个简单步骤搞定。</p><h4 id="步骤一：修改配置"><a href="#步骤一：修改配置" class="headerlink" title="步骤一：修改配置"></a>步骤一：修改配置</h4><p><img src="/2020/02/26/数据库软件架构设计/640-1582701009934.webp" alt="img"></p><p>主要修改两处：</p><ul><li>数据库实例所在的机器做<strong>双虚ip</strong>：</li></ul><p>（1）原%2=0的库是虚ip0，现增加一个虚ip00；</p><p>（2）原%2=1的库是虚ip1，现增加一个虚ip11；</p><ul><li>修改服务的配置，将2个库的<strong>数据库配置</strong>，改为4个库的数据库配置，修改的时候要注意旧库与新库的映射关系：</li></ul><p>（1）%2=0的库，会变为%4=0与%4=2；</p><p>（2）%2=1的部分，会变为%4=1与%4=3；</p><p><em>画外音：这样能够保证，依然路由到正确的数据。</em></p><h4 id="步骤二：reload配置，实例扩容"><a href="#步骤二：reload配置，实例扩容" class="headerlink" title="步骤二：reload配置，实例扩容"></a>步骤二：reload配置，实例扩容</h4><p><img src="/2020/02/26/数据库软件架构设计/640-1582701068464.webp" alt="img"></p><p>服务层reload配置，reload可能是这么几种方式：</p><p>（a）比较原始的，重启服务，读新的配置文件；<br>（b）高级一点的，配置中心给服务发信号，重读配置文件，重新初始化数据库连接池；</p><p>不管哪种方式，reload之后，数据库的实例扩容就完成了，原来是2个数据库实例提供服务，现在变为4个数据库实例提供服务，这个过程一般可以在秒级完成。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701102779.webp" alt="img"></p><p>整个过程可以逐步重启，对服务的正确性和可用性完全没有影响：</p><p>（a）<strong>即使%2寻库和%4寻库同时存在，也不影响数据的正确性</strong>，因为此时仍然是双主数据同步的；<br>（b）<strong>即使%4=0与%4=2的寻库落到同一个数据库实例上，也不影响数据的正确性</strong>，因为此时仍然是双主数据同步的；</p><p>完成了实例的扩展，会发现每个数据库的数据量依然没有下降，所以第三个步骤还要做一些收尾工作。</p><p><em>画外音：这一步，数据库实例个数加倍了。</em></p><h4 id="步骤三：收尾工作，数据收缩"><a href="#步骤三：收尾工作，数据收缩" class="headerlink" title="步骤三：收尾工作，数据收缩"></a>步骤三：收尾工作，数据收缩</h4><p><img src="/2020/02/26/数据库软件架构设计/640.jpg" alt="img"></p><p>有这些一些收尾工作：</p><p>（a）把双虚ip修改回单虚ip；</p><p>（b）解除旧的双主同步，让成对库的数据不再同步增加；</p><p>（c）增加新的双主同步，保证高可用；</p><p>（d）删除掉冗余数据，例如：ip0里%4=2的数据全部删除，只为%4=0的数据提供服务；</p><p><em>画外音：这一步，数据库单实例数据量减半了。</em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582701273816.webp" alt="img"></p><p>互联网大数据量，高吞吐量，高可用微服务分层架构，数据库实现秒级平滑扩容的三个步骤为：</p><p>（1）修改配置（双虚ip，微服务数据库路由）；</p><p>（2）reload配置，<strong>实例增倍</strong>完成；</p><p>（3）删除冗余数据等收尾工作，<strong>数据量减半</strong>完成；</p><p><strong>思路</strong>比结论重要，希望大家有收获。</p><h2 id="100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？"><a href="#100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？" class="headerlink" title="100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？"></a>100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？</h2><p>如果不是成倍扩容：</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962270&amp;idx=1&amp;sn=3131888f29d0d137d02703a6dc91fa56&amp;chksm=bd2d0e428a5a87547dfc6a0a292a7746ad50b74a078e29b4b8024633fa42db6ccc5f47435063&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">100亿数据平滑数据迁移,不影响服务</a>》</p><p>如果不是“双倍”扩容，能否做到平滑迁移，不影响服务呢？</p><h3 id="适用什么场景？"><a href="#适用什么场景？" class="headerlink" title="适用什么场景？"></a>适用什么场景？</h3><p>互联网有很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，其典型系统分层架构如下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584150.webp" alt="img"></p><p>（1）上游是<strong>业务层biz</strong>，实现个性化的业务逻辑；<br>（2）中游是<strong>服务层service</strong>，封装数据访问；<br>（3）下游是<strong>数据层db</strong>，存储固化的业务数据；</p><p>服务化分层架构的好处是，服务层屏蔽下游数据层的复杂性，例如缓存、分库分表、存储引擎等存储细节不需要向调用方暴露，而只向上游提供方便的RPC访问接口，当有一些数据层变化的时候，所有的调用方也不需要升级，只需要服务层升级即可。</p><p>互联网架构，很多时候面临着这样一些需求：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701647190.png" alt="img"></p><p><strong>（1）底层表结构变更</strong>：数据量非常大的情况下，数据表增加了一些属性，删除了一些属性，修改了一些属性。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584125.webp" alt="img"></p><p><strong>（2）分库个数变化</strong>：由于数据量的持续增加，底层分库个数非成倍增加。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701690543.png" alt="img"></p><p><strong>（3）底层存储介质变化</strong>：底层存储引擎由一个数据库换为另一个数据库。</p><p>种种需求，都需要进行数据迁移，如何平滑迁移数据，迁移过程不停机，保证系统持续服务，是文本将要讨论的问题。</p><h4 id="方案一：停机方案"><a href="#方案一：停机方案" class="headerlink" title="方案一：停机方案"></a>方案一：停机方案</h4><p>在讨论平滑迁移数据方案之前，先看下不平滑的停机数据迁移方案，主要分三个步骤。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584135.webp" alt="img"></p><p><strong>步骤一</strong>：<strong>挂</strong>一个类似“为了给广大用户提供更好的服务，服务器会在凌晨0:00-0:400进行停机维护”的<strong>公告</strong>，并在对应时段进行<strong>停机</strong>，这个时段系统没有流量进入。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701774823.png" alt="img"></p><p><strong>步骤二</strong>：停机后，研发一个<strong>离线</strong>的数据迁移工具，进行<strong>数据迁移</strong>。针对第一节的三类需求，会分别开发不同的数据迁移工具。</p><p>（1）底层表结构变更需求：开发旧表导新表的工具；</p><p>（2）分库个数变换需求：开发2库导3库的工具；</p><p>（3）底层存储介质变换需求：开发Mongo导Mysql工具；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584173.webp" alt="img"></p><p><strong>步骤三</strong>：<strong>恢复服务</strong>，并将流量切到新库，不同的需求，可能会涉及不同服务升级。</p><p>（1）底层表结构变更需求：服务要升级到访问新表；<br>（2）分库个数变换需求：服务不需要升级，只需要改寻库路由配置；<br>（3）底层存储介质变换需求：服务升级到访问新的存储介质；</p><p>总的来说，停机方案是<strong>相对直观和简单</strong>的，但对<strong>服务的可用性有影响</strong>，许多游戏公司的服务器升级，游戏分区与合区，可能会采用类似的方案。</p><p>除了影响服务的可用性，这个方案还有一个缺点，就是必须在指定时间完成升级，这个对研发、测试、运维同学来说，<strong>压力会非常大</strong>，一旦出现问题例如数据不一致，必须在规定时间内解决，否则只能回滚。根据经验，<strong>人压力越大越容易出错</strong>，这个缺点一定程度上是致命的。</p><p>无论如何，停机方案并不是今天要讨论的重点，接下来看一下常见的平滑数据迁移方案。</p><h4 id="方案二：追日志方案"><a href="#方案二：追日志方案" class="headerlink" title="方案二：追日志方案"></a>方案二：追日志方案</h4><p>追日志方案，是一个高可用的平滑迁移方案，这个方案主要分为五个步骤。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584118.webp" alt="img"></p><p>数据迁移前，上游业务应用通过旧的服务访问旧的数据。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701865724.png" alt="img"></p><p><strong>步骤一</strong>：服务进行升级，<strong>记录“对旧库上的数据修改”的日志</strong>（这里的修改，为数据的insert, delete, update），这个日志不需要记录详细数据，主要记录：</p><p>（1）被修改的<strong>库</strong>；<br>（2）被修改的<strong>表</strong>；<br>（3）被修改的<strong>唯一主键</strong>；</p><p>具体新增了什么行，修改后的数据格式是什么，不需要详细记录。这样的好处是，不管业务细节如何变化，日志的格式是固定的，这样能保证方案的通用性。</p><p>这个服务升级风险较小：</p><p>（1）写接口是少数接口，改动点较少；<br>（2）升级只是增加了一些日志，对业务功能没有任何影响；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584104.webp" alt="img"></p><p><strong>步骤二</strong>：<em>研发一个数据迁移工具，进行数据迁移</em>。这个数据迁移工具和离线迁移工具一样，把旧库中的数据转移到新库中来。</p><p>这个小工具的风险较小：</p><p>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，都可以把新库中的数据干掉重来；<br>（4）可以限速慢慢迁移，技术同学没有时间压力；</p><p><strong>数据迁移完成之后，就能够切到新库提供服务了么？</strong></p><p><strong>答案是否定的</strong>，在数据迁移的过程中，旧库依然对线上提供着服务，库中的数据随时可能变化，这个变化并没有反映到新库中来，于是旧库和新库的数据并不一致，所以不能直接切库，需要将数据追平。</p><p><strong>哪些数据发生了变化呢？</strong></p><p>步骤一中日志里记录的，正是变化的数据。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701996028.png" alt="img"></p><p><strong>步骤三</strong>：<strong>研发一个读取日志并迁移数据的小工具，要把步骤二迁移数据过程中产生的差异数据追平</strong>。这个小工具需要做的是：<br>（1）读取日志，得到哪个库、哪个表、哪个主键发生了变化；<br>（2）把旧库中对应主键的记录读取出来；<br>（3）把新库中对应主键的记录替换掉；</p><p>无论如何，<strong>原则是数据以旧库为准</strong>。</p><p>这个小工具的风险也很小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，大不了从步骤二开始重来；<br>（4）可以限速慢慢重放日志，技术同学没有时间压力；</p><p><strong>日志重放之后，就能够切到新库提供服务了么？</strong></p><p><strong>答案依然是否定的</strong>，在日志重放的过程中，旧库中又可能有数据发生了变化，导致数据不一致，所以还是不能切库，需要进一步读取日志，追平记录。可以看到，重放日志追平数据的程序是一个while(1)的程序，新库与旧库中的<strong>数据追平也会是一个“无限逼近”的过程</strong>。</p><p><strong>什么时候数据会完全一致呢？</strong></p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584177.webp" alt="img"></p><p><strong>步骤四</strong>：在持续重放日志，<strong>追平数据的过程中，研发一个数据校验的小工具，将旧库和新库中的数据进行比对，直到数据完全一致</strong>。</p><p>这个小工具的风险依旧很小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，大不了从步骤二开始重来；<br>（4）可以限速慢慢比对数据，技术同学没有时间压力；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584187.webp" alt="img"></p><p><strong>步骤五</strong>：在数据比对完全一致之后，将<strong>流量迁移到新库</strong>，新库提供服务，完成迁移。</p><p>如果步骤四数据一直是99.9%的一致，不能完全一致，也是正常的，可以做一个秒级的旧库readonly，等日志重放程序完全追上数据后，再进行切库切流量。</p><p>至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</p><h4 id="方案三：双写方案"><a href="#方案三：双写方案" class="headerlink" title="方案三：双写方案"></a>方案三：双写方案</h4><p>双写方案，也是一个高可用的平滑迁移方案，这个方案主要分为四个步骤。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584167.webp" alt="img"></p><p>数据迁移前，上游业务应用通过旧的服务访问旧的数据。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582702242950.png" alt="img"></p><p><strong>步骤一</strong>：<strong>服务进行升级</strong>，对“对旧库上的数据修改”（这里的修改，为数据的insert, delete, update），在新库上进行相同的修改操作，这就是所谓的“<strong>双写</strong>”，主要修改操作包括：<br>（1）旧库与新库的同时insert；<br>（2）旧库与新库的同时delete；<br>（3）旧库与新库的同时update；</p><p>由于新库中此时是没有数据的，所以双写旧库与新库中的affect rows可能不一样，不过这完全不影响业务功能，只要不切库，依然是旧库提供业务服务。</p><p>这个服务升级风险较小：<br>（1）写接口是少数接口，改动点较少；<br>（2）新库的写操作执行成功与否，对业务功能没有任何影响；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582702288458.png" alt="img"></p><p><strong>步骤二</strong>：研发一个数据迁移工具，进行<strong>数据迁移</strong>。这个数据迁移工具在本文中已经出现第三次了，把旧库中的数据转移到新库中来。</p><p>这个小工具的风险较小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，都可以把新库中的数据干掉重来；<br>（4）可以限速慢慢迁移，技术同学没有时间压力；</p><p><strong>数据迁移完成之后，就能够切到新库提供服务了么？</strong></p><p><strong>答案是肯定的</strong>，因为前置步骤进行了双写，所以理论上数据迁移完之后，新库与旧库的数据应该完全一致。</p><p>由于迁移数据的过程中，旧库新库双写操作在同时进行，<strong>怎么证明数据迁移完成之后数据就完全一致了呢？</strong></p><p><img src="/2020/02/26/数据库软件架构设计/640.png" alt="img"></p><p>如上图所示：</p><p>（1）左侧是旧库中的数据，右侧是新库中的数据；</p><p>（2）按照primary key从min到max的顺序，分段，限速进行数据的迁移，假设已经迁移到now这个数据段，数据迁移过程中的修改操作分别讨论：</p><ul><li>假设迁移过程中进行了一个<strong>双insert操作</strong>，旧库新库都插入了数据，数据一致性没有被破坏</li><li>假设迁移过程中进行了一个<strong>双delete操作</strong>，这又分为两种情况</li></ul><p><strong>情况一</strong>：假设这delete的数据属于[min,now]范围，即已经完成迁移，则旧库新库都删除了数据，<code>数据一致性</code>没有被破坏；<br><strong>情况二</strong>：假设这delete的数据属于[now,max]范围，即未完成迁移，则旧库中删除操作的affect rows为1，新库中删除操作的affect rows为0，但是数据迁移工具在后续数据迁移中，并不会将这条旧库中被删除的数据迁移到新库中，所以数据一致性仍没有被破坏；</p><ul><li>假设迁移过程中进行了一个<strong>双update操作</strong>，可以认为update操作是一个delete加一个insert操作的复合操作，所以数据仍然是<code>一致</code>的</li></ul><p>除非，在一种非常极限的情况下：<br>（1）date-migrate-tool<strong>刚好</strong>从旧库中将某一条数据X取出；<br>（2）在X插入到新库中之前，旧库与新库中<strong>刚好</strong>对X进行了双delete操作；<br>（3）date-migrate-tool再将X插入到新库中；</p><p>这样，会出现新库比旧库多出一条数据X。</p><p>但无论如何，为了保证数据的一致性，切库之前，还是需要进行数据校验的。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582702403207.png" alt="img"></p><p><strong>步骤三</strong>：在数据迁移完成之后，需要<strong>使用数据校验的小工具</strong>，将旧库和新库中的数据进行比对，完全一致则符合预期，如果出现步骤二中的极限不一致情况，则以旧库中的数据为准。</p><p>这个小工具的风险依旧很小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，大不了从步骤二开始重来；<br>（4）可以限速慢慢比对数据，技术同学没有时间压力；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584204.webp" alt="img"></p><p><strong>步骤四</strong>：数据完全一致之后，将<strong>流量切到新库</strong>，完成平滑数据迁移。</p><p>至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>针对互联网很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，在：<br>（1）底层表结构变更；<br>（2）分库个数变化；<br>（3）底层存储介质变化；</p><p>的众多需求下，需要进行数据迁移，完成<strong>“平滑迁移数据，迁移过程不停机，保证系统持续服务”</strong>有两种常见的解决方案。</p><p><strong>追日志方案</strong>，五个步骤：<br>（1）<strong>服务进行升级</strong>，<code>记录</code>“对旧库上的数据修改”的<code>日志</code>；<br>（2）研发一个数据迁移<strong>小工具</strong>，进行<code>数据迁移</code>；<br>（3）研发一个读取日志<strong>小工具</strong>，<code>追平数据差异</code>；<br>（4）研发一个数据比对<strong>小工具</strong>，<code>校验数据</code>一致性；<br>（5）<code>流量切到新库</code>，完成平滑迁移；</p><p><strong>双写方案</strong>，四个步骤：<br>（1）<strong>服务进行升级</strong>，记录“对旧库上的数据修改”进行新库的<code>双写</code>；<br>（2）研发一个数据迁移<strong>小工具</strong>，进行<code>数据迁移</code>；<br>（3）研发一个数据比对<strong>小工具</strong>，<code>校验数据</code>一致性；<br>（4）<code>流量切到新库</code>，完成平滑迁移；</p><p><strong>思路</strong>比结论重要。</p><h2 id="1万属性，100亿数据，每秒10万吞吐，架构如何设计？"><a href="#1万属性，100亿数据，每秒10万吞吐，架构如何设计？" class="headerlink" title="1万属性，100亿数据，每秒10万吞吐，架构如何设计？"></a>1万属性，100亿数据，每秒10万吞吐，架构如何设计？</h2><p>也可能，是要对字段进行扩展：《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962219&amp;idx=1&amp;sn=30545c7a9f46fa74a61cc09323a6a8c9&amp;chksm=bd2d0eb78a5a87a1c16b1d10fbb688adb2848345b70fa2fbc161b3a566c7c3e02adaccd5981e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">1万属性，100亿数据，架构设计？</a>》，如下：</p><p>有一类业务场景，没有固定的schema存储，却有着海量的数据行数，架构上如何来实现这类业务的存储与检索呢？58最核心的数据“帖子”的架构实现技术细节，今天和大家聊一聊。</p><h3 id="背景描述及业务介绍"><a href="#背景描述及业务介绍" class="headerlink" title="背景描述及业务介绍"></a>背景描述及业务介绍</h3><p><strong>什么是58最核心的数据？</strong></p><p>58是一个信息平台，有很多垂直品类：招聘、房产、二手物品、二手车、黄页等等，每个品类又有很多子品类，不管哪个品类，最核心的数据都是“帖子信息”。</p><p><em>画外音：像不像一个大论坛？</em></p><p><strong>各分类帖子的信息有什么特点？</strong></p><p>逛过58的朋友很容易了解到，这里的帖子信息：<br>（1）<strong>各品类的属性千差万别</strong>，招聘帖子和二手帖子属性完全不同，二手手机和二手家电的属性又完全不同，目前恐怕有<code>近万个属性</code>；<br>（2）<strong>数据量巨大</strong>，<code>100亿</code>级别；<br>（3）<strong>每个属性上都有查询需求</strong>，各组合属性上都可能有组合查询需求，招聘要查职位/经验/薪酬范围，二手手机要查颜色/价格/型号，二手要查冰箱/洗衣机/空调；<br>（4）<strong>吞吐量很大</strong>，<code>每秒几十万吞吐</code>；</p><p>如何解决100亿数据量，1万属性，多属性组合查询，10万并发查询的技术难题呢？一步步来。</p><h3 id="最容易想到的方案"><a href="#最容易想到的方案" class="headerlink" title="最容易想到的方案"></a>最容易想到的方案</h3><p>每个公司的发展都是一个从小到大的过程，撇开并发量和数据量不谈，先看看<br>（1）如何实现属性扩展性需求；<br>（2）多属性组合查询需求；<br><em>画外音：公司初期并发量和数据量都不大，必须先解决业务问题。</em></p><p><strong>如何满足业务的存储需求呢？</strong></p><p>最开始，业务只有一个招聘品类，那帖子表可能是这么设计的：<br>tiezi(tid, uid, c1, c2, c3);</p><p><strong>那如何满足各属性之间的组合查询需求呢？</strong></p><p>最容易想到的是通过组合索引满足查询需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index_1(c1, c2)</span><br><span class="line">index_2(c2, c3)</span><br><span class="line">index_3(c1, c3)</span><br></pre></td></tr></table></figure></p><p><strong>随着业务的发展，又新增了一个房产类别，存储问题又该如何解决呢？</strong></p><p>可以新增若干属性满足存储需求，于是帖子表变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiezi(tid, uid, c1, c2, c3, c10, c11, c12, c13);</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>c1,c2,c3是招聘类别属性</li><li>c10,c11,c12,c13是房产类别属性</li></ul><p>通过扩展属性，可以解决存储的问题。</p><p><strong>查询需求，又该如何满足呢？</strong></p><p>首先，跨业务属性一般没有组合查询需求。只能建立了若干组合索引，满足房产类别的查询需求。</p><p><em>画外音：不敢想有多少个索引能覆盖所有两属性查询，三属性查询。</em></p><p><strong>当业务越来越多时，是不是发现玩不下去了？</strong></p><h3 id="垂直拆分是一个思路"><a href="#垂直拆分是一个思路" class="headerlink" title="垂直拆分是一个思路"></a>垂直拆分是一个思路</h3><p>新增属性是一种扩展方式，新增表也是一种方式，垂直拆分也是常见的存储扩展方案。</p><p><strong>如何按照业务进行垂直拆分？</strong></p><p>可以这么玩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tiezi_zhaopin(tid, uid, c1, c2, c3);</span><br><span class="line"></span><br><span class="line">tiezi_fangchan(tid, uid, c10, c11, c12, c13);</span><br></pre></td></tr></table></figure></p><p><strong>在业务各异，数据量和吞吐量都巨大的情况下，垂直拆分会遇到什么问题呢？</strong></p><p>这些表，以及对应的服务维护在不同的部门，看上去各业务灵活性强，研发闭环，这恰恰是悲剧的开始：<br>（1）tid如何规范？<br>（2）属性如何规范？<br>（3）按照uid来查询怎么办（查询自己发布的所有帖子）？<br>（4）按照时间来查询怎么办（最新发布的帖子）？<br>（5）跨品类查询怎么办（例如首页搜索框）？<br>（6）技术范围的扩散，有的用mongo存储，有的用mysql存储，有的自研存储；<br>（7）重复开发了不少组件；<br>（8）维护成本过高；<br>（9）…</p><p><em>画外音：想想看，电商的商品表，不可能一个类目一个表的。</em></p><h3 id="58的玩法：三大中心服务"><a href="#58的玩法：三大中心服务" class="headerlink" title="58的玩法：三大中心服务"></a>58的玩法：三大中心服务</h3><h4 id="第一：统一帖子中心服务"><a href="#第一：统一帖子中心服务" class="headerlink" title="第一：统一帖子中心服务"></a>第一：统一帖子中心服务</h4><p><code>平台型</code>创业型公司，可能有多个品类，各品类有很多异构数据的存储需求，到底是分还是合，无需纠结：<strong>基础数据基础服务的统一</strong>，是一个很好的实践。</p><p><em>画外音：这里说的是平台型业务。</em></p><p><strong>如何将不同品类，异构的数据统一存储起来呢？</strong></p><p>（1）全品类通用属性统一存储；<br>（2）单品类特有属性，品类类型与通用属性json来进行存储；</p><p>更具体的：</p><p>tiezi(tid, uid, time, title, cate, subcate, xxid, ext);</p><p>（1）一些通用的字段抽取出来单独存储；<br>（2）通过cate, subcate, xxid等来定义ext是何种含义；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582704023957.webp" alt="img"></p><p>（3）通过ext来存储不同业务线的个性化需求</p><p>例如：</p><p>招聘的帖子，ext为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“job”:”driver”,”salary”:8000,”location”:”bj”&#125;</span><br></pre></td></tr></table></figure></p><p>而二手的帖子，ext为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;”type”:”iphone”,”money”:3500&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382769.png" alt="img"></p><p>帖子数据，100亿的数据量，分256库，通过ext存储异构业务数据，使用mysql存储，上层架了一个帖子中心服务，使用memcache做缓存，就是这样一个并不复杂的架构，解决了业务的大问题。这是58最核心的帖子中心服务IMC（Info Management Center）。</p><p><em>画外音：该服务的底层存储在16年全面切换为了自研存储引擎，替换了mysql，但架构理念仍未变。</em></p><p>解决了海量异构数据的存储问题，遇到的<strong>新问题</strong>是：</p><p>（1）每条记录ext内key都需要重复存储，占据了大量的空间，能否压缩存储；<br>（2）cateid已经不足以描述ext内的内容，品类有层级，深度不确定，ext能否具备自描述性；<br>（3）随时可以增加属性，保证扩展性；</p><p>解决完海量异构数据的存储问题，接下来，要解决的是类目的扩展性问题。</p><h4 id="第二：统一类目属性服务"><a href="#第二：统一类目属性服务" class="headerlink" title="第二：统一类目属性服务"></a>第二：统一类目属性服务</h4><p><strong>每个业务有多少属性，这些属性是什么含义，值的约束等，**</strong>耦合到帖子服务里<strong>**显然是不合理的，那怎么办呢？</strong></p><p>抽象出一个统一的类目、属性服务，单独来管理这些信息，而帖子库ext字段里json的key，统一由数字来表示，减少存储空间。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382664.webp" alt="img"></p><p><em>画外音：帖子表只存元信息，不管业务含义。</em></p><p>如上图所示，json里的key不再是”salary” ”location” ”money” 这样的长字符串了，取而代之的是数字1,2,3,4，这些数字是什么含义，属于哪个子分类，值的校验约束，统一都存储在类目、属性服务里。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382674.webp" alt="img"></p><p><em>画外音：类目表存业务信息，以及约束信息，与帖子表解耦。</em></p><p>这个表里对帖子中心服务里ext字段里的数字key进行了解释：<br>（1）1代表job，属于招聘品类下100子品类，其value必须是一个小于32的[a-z]字符；<br>（2）4代表type，属于二手品类下200子品类，其value必须是一个short；</p><p>这样就对原来帖子表ext扩展属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;“1”:”driver”,”2”:8000,”3”:”bj”&#125;</span><br><span class="line"></span><br><span class="line">&#123;”4”:”iphone”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p><code>key和value都做了统一约束。</code></p><p>除此之外，如果ext里某个key的value不是正则校验的值，而是枚举值时，需要有一个对值进行限定的枚举表来进行校验：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382708.webp" alt="img"></p><p>这个枚举校验，说明key=4的属性（对应属性表里二手，手机类型字段），其值不只是要进行“short类型”校验，而是value必须是固定的枚举值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;”4”:”iphone”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>这个ext就是不合法的，key=4的value=iphone不合法，而应该是枚举属性，合法的应该为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;”4”:”5”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>此外，<em>类目属性服务还能记录类目之间的层级关系</em>：<br>（1）一级类目是招聘、房产、二手…<br>（2）二手下有二级类目二手家具、二手手机…<br>（3）二手手机下有三级类目二手iphone，二手小米，二手三星…<br>（4）…</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582704209305.webp" alt="img"></p><p>类目服务<code>解释了帖子数据，描述品类层级关系，保证各类目属性扩展性，保证各属性值合理性校验</code>，就是58另一个统一的核心服务CMC（Category Management Center）。</p><blockquote><p><em>画外音：类目、属性服务像不像电商系统里的SKU扩展服务？</em><br><em>（1）品类层级关系，对应电商里的类别层级体系；</em><br><em>（2）属性扩展，对应电商里各类别商品SKU的属性；</em><br><em>（3）枚举值校验，对应属性的枚举值，例如颜色：红，黄，蓝；</em></p></blockquote><p>通过品类服务，解决了key压缩，key描述，key扩展，value校验，品类层级的问题，还有这样的一个问题没有解决：每个品类下帖子的属性各不相同，查询需求各不相同，<strong>如何解决100亿数据量，1万属性的检索与联合检索需求呢？</strong></p><h4 id="第三：统一检索服务"><a href="#第三：统一检索服务" class="headerlink" title="第三：统一检索服务"></a>第三：统一检索服务</h4><p>数据量很大的时候，不同属性上的查询需求，不可能通过组合索引来满足所有查询需求，“外置索引，统一检索服务”是一个很常用的实践：</p><p>（1）数据库提供“帖子id”的正排查询需求；<br>（2）所有非“帖子id”的个性化检索需求，统一走外置索引；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382712.webp" alt="img"></p><p>元数据与索引数据的操作遵循：<br>（1）对帖子进行tid正排查询，直接访问帖子服务；<br>（2）对帖子进行修改，帖子服务通知检索服务，同时对索引进行修改；<br>（3）对帖子进行复杂查询，通过检索服务满足需求；</p><blockquote><p><em>画外音：这个检索服务，扛起了58同城80%的请求（不管来自PC还是APP，不管是主页、城市页、分类页、列表页、详情页，最终都会转化为一个检索请求），它就是58另一个统一的核心服务E-search，这个搜索引擎，是完全自研的。</em></p></blockquote><p>对于这个内核自研服务的搜索引擎架构，简单说明一下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382739.webp" alt="img"></p><p>为应对100亿级别数据量、几十万级别的吞吐量，业务线各种复杂的复杂检索查询，<code>扩展性是设计重点</code>：<br>（1）统一的<strong>代理层</strong>，作为入口，其无状态性能够保证增加机器就能扩充系统性能；<br>（2）统一的<strong>结果聚合层</strong>，其无状态性也能够保证增加机器就能扩充系统性能；<br>（3）搜索内核<strong>检索层</strong>，服务和索引数据部署在同一台机器上，服务启动时可以加载索引数据到内存，请求访问时从内存中load数据，访问速度很快：</p><ul><li>为了满足<code>数据容量的扩展性</code>，索引数据进行了水平切分，增加切分份数，就能够无限扩展性能</li><li>为了满足一份<code>数据的性能扩展性</code>，同一份数据进行了冗余，理论上做到增加机器就无限扩展性能</li></ul><p>系统时延，100亿级别帖子检索，包含请求分合，拉链求交集，从聚合层均可以做到10ms返回。</p><p><em>画外音：入口层是Java研发的，聚合层与检索层都是C语言研发的。</em></p><p>帖子业务，一致性不是主要矛盾，E-search会定期全量重建索引，以保证即使数据不一致，也不会持续很长的时间。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382663.webp" alt="img"></p><p>文章写了很长，最后做一个简单总结，面对100亿数据量，1万列属性，10万吞吐量的业务需求，可以采用了<strong>元数据服务、属性服务、搜索服务来</strong>解决：</p><ul><li>一个解决存储问题</li><li>一个解决品类解耦问题</li><li>一个解决检索问题</li></ul><p>任何复杂问题的解决，都是<code>循序渐进</code>的。</p><p><strong>思路</strong>比结论重要，希望大家有收获。</p><h2 id="100亿数据1万属性数据架构设计"><a href="#100亿数据1万属性数据架构设计" class="headerlink" title="100亿数据1万属性数据架构设计"></a>100亿数据1万属性数据架构设计</h2><p>《<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959855&amp;idx=1&amp;sn=f33abe8ec598c273f29cebb9365ece59&amp;chksm=bd2d07f38a5a8ee58a944507a134e1da1efc3ac9c4d1c4cff261137cd986e51f5fe7cee9de15&amp;scene=25#wechat_redirect" target="_blank" rel="noopener">100亿数据1万属性数据架构设计</a>》</p><p>对于version + ext方案，还是有很多朋友质疑“线上不可能这么用”。本篇将讲述一下58同城最核心的数据“帖子”的架构实现技术细节，说明不仅不是“不可能这么用”，而是大数据，可变属性，高吞吐场景下的“常用手段”。</p><h3 id="背景描述及业务介绍-1"><a href="#背景描述及业务介绍-1" class="headerlink" title="背景描述及业务介绍"></a>背景描述及业务介绍</h3><p><strong>问：什么是数据库扩展的version + ext方案？</strong></p><p>使用ext来承载不同业务需求的个性化属性，使用version来标识ext里各个字段的含义。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010881.webp" alt="img"></p><p>例如上述user表：<br>verion=0表示ext里是passwd/nick<br>version=1表示ext里是passwd/nick/age/sex</p><p><strong>优点？</strong></p><p>（1）可以随时动态扩展属性，扩展性好<br>（2）新旧两种数据可以同时存在，兼容性好</p><p><strong>不足？</strong></p><p>（1）ext里的字段无法建立索引<br>（2）ext里的key值有大量冗余，建议key短一些</p><p><strong><em>问：</em>什么是58同城最核心的数据？</strong></p><p>58同城是一个信息平台，有很多垂直品类：招聘、房产、二手物品、二手车、黄页等等，每个品类又有很多子品类，不管哪个品类，最核心的数据都是“帖子信息”（业务像一个大论坛？）。</p><p><strong><em>问：</em>帖子信息有什么特点？</strong><br>大家去58同城的首页上看看就知道了：</p><p>（1）<code>每个品类的属性千差万别</code>，招聘帖子和二手帖子属性完全不同，二手手机和二手家电的属性又完全不同，目前恐怕有近万个属性<br>（2）<code>帖子量很大，100亿级别</code><br>（3）<code>每个属性上都有查询需求</code>（各组合属性上都可能有组合查询需求），招聘要查职位/经验/薪酬范围，二手手机要查颜色/价格/型号，二手要查冰箱/洗衣机/空调<br>（4）<code>查询量很大，每秒几十万级别</code></p><p>如何解决<strong>100亿数据量，1万属性，多属性组合查询，10万并发查询</strong>的技术难题，是今天要讨论的内容。</p><h3 id="最容易想到的方案-1"><a href="#最容易想到的方案-1" class="headerlink" title="最容易想到的方案"></a>最容易想到的方案</h3><p>每个公司的发展都是一个从小到大的过程，撇开并发量和数据量不谈，先看看</p><p>（1）如何实现属性扩展性需求<br>（2）多属性组合查询需求</p><p>最开始，可能只有一个<strong>招聘品类</strong>，那帖子表可能是这么设计的：</p><p>tiezi(tid,uid, c1, c2, c3)</p><p>那如何满足各属性之间的组合查询需求呢？</p><p>最容易想到的是通过组合索引：</p><p>index_1(c1,c2) index_2(c2, c3) index_3(c1, c3)</p><p>随着业务的发展，又新增了一个<strong>房产类别</strong>，新增了若干属性，新增了若干组合查询，于是帖子表变成了：</p><p>tiezi(tid,uid, c1, c2, c3, c10, c11, c12, c13)</p><p>其中c1,c2,c3是招聘类别属性，c10,c11,c12,c13是房产类别属性，这两块属性一般没有组合查询需求</p><p>但为了满足房产类别的查询需求，又要建立了若干组合索引（不敢想有多少个索引能覆盖所有两属性查询，三属性查询）</p><p>是不是发现玩不下去了？</p><h3 id="友商的玩法"><a href="#友商的玩法" class="headerlink" title="友商的玩法"></a>友商的玩法</h3><p>新增属性是一种扩展方式，新增表也是一种方式，有友商是这么玩的，按照业务进行垂直拆分：</p><blockquote><p>tiezi_zhaopin(tid,uid, c1, c2, c3)<br>tiezi_fangchan(tid,uid, c10, c11, c12, c13)</p></blockquote><p>这些表，这些服务维护在不同的部门，不同的研发同学手里，看上去各业务线灵活性强，这恰恰是悲剧的开始：</p><p>（1）tid如何规范？<br>（2）属性如何规范？<br>（3）按照uid来查询怎么办（查询自己发布的所有帖子）？<br>（4）按照时间来查询怎么办（最新发布的帖子）？<br>（5）跨品类查询怎么办（例如首页搜索框）？<br>（6）技术范围的扩散，有的用mongo存储，有的用mysql存储，有的自研存储<br>（7）重复开发了不少组件<br>（8）维护成本过高<br>（9）…</p><p>想想看，电商的商品表，不可能一个类目一个表的。</p><h3 id="58同城的玩法"><a href="#58同城的玩法" class="headerlink" title="58同城的玩法"></a>58同城的玩法</h3><h4 id="【统一帖子中心服务】"><a href="#【统一帖子中心服务】" class="headerlink" title="【统一帖子中心服务】"></a>【统一帖子中心服务】</h4><p>平台型创业型公司，可能有多个品类，例如58同城的招聘房产二手，很多异构数据的存储需求，到底是分还是合，无需纠结：<strong>基础数据基础服务的统一</strong>，无疑是58同城技术路线发展roadmap上最正确的决策之一，把这个方针坚持下来，@老崔 @晓飞 这些高瞻远瞩的先贤功不可没，业务线会有“扩展性”“灵活性”上的微词，后文看看先贤们如何通过一些巧妙的技术方案来解决的。</p><p>如何将不同品类，异构的数据统一存储起来，采用的就是类似<code>version+ext</code>的方式：</p><p>tiezi(tid,uid, time, title, cate, subcate, xxid, ext)</p><p>（1）<code>一些通用的字段抽取出来单独存储</code><br>（2）<code>通过cate, subcate, xxid等来定义ext是何种含义</code>（和version有点像？）</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010848.webp" alt="img"></p><p>（3）通过ext来存储不同业务线的个性化需求</p><p>例如招聘的帖子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;“job”:”driver”,”salary”:8000,”location”:”bj”&#125;</span><br></pre></td></tr></table></figure></p><p>而二手的帖子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;”type”:”iphone”,”money”:3500&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010843.png" alt="img"></p><p>58同城最核心的帖子数据，100亿的数据量，分256库，异构数据mysql存储，上层架了一个服务，使用memcache做缓存，就是这样一个简单的架构，一直坚持这这么多年。上层的这个服务，就是<strong>58同城最核心的统一服务IMC（Imformation Management Center）</strong>，注意这个最核心，是没有之一。</p><p>解决了海量异构数据的存储问题，遇到的<strong>新问题</strong>是：</p><p>（1）每条记录ext内key都需要重复存储，占据了大量的空间，能否压缩存储<br>（2）cateid已经不足以描述ext内的内容，品类有层级，深度不确定，ext能否具备自描述性<br>（3）随时可以增加属性，保证扩展性</p><h4 id="【统一类目属性服务】"><a href="#【统一类目属性服务】" class="headerlink" title="【统一类目属性服务】"></a>【统一类目属性服务】</h4><p>每个业务有多少属性，这些属性是什么含义，值的约束等揉不到帖子服务里，怎么办呢？</p><p>58同城的先贤们抽象出一个统一的类目、属性服务，单独来管理这些信息，而帖子库ext字段里json的key，统一由数字来表示，减少存储空间。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010912.webp" alt="img"></p><p>如上图所示，json里的key不再是”salary” ”location” ”money” 这样的长字符串了，取而代之的是数字1,2,3,4，这些数字是什么含义，属于哪个子分类，值的校验约束，统一都存储在类目、属性服务里。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010931.webp" alt="img"></p><p>这个表里对帖子中心服务里ext字段里的数字key进行了解释：</p><p>1代表job，属于招聘品类下100子品类，其value必须是一个小于32的[a-z]字符</p><p>4代表type，属于二手品类下200子品类，其value必须是一个short</p><p>这样就对原来帖子表ext里的<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;“1”:”driver”,”2”:8000,”3”:”bj”&#125;</span><br><span class="line"></span><br><span class="line">ext : &#123;”4”:”iphone”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>key和value都做了统一约束。</p><p>除此之外，如果ext里某个key的value不是正则校验的值，而是枚举值时，需要有一个对值进行限定的枚举表来进行校验：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010936.webp" alt="img"></p><p>这个枚举校验，说明key=4的属性（对应属性表里二手，手机类型字段），其值不只是要进行“short类型”校验，而是value必须是固定的枚举值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;”4”:”iphone”,”5”:3500&#125; 这个ext就是不合法的（key=4的value=iphone不合法），合法的应该为</span><br><span class="line"></span><br><span class="line">ext : &#123;”4”:”5”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>此外，类目属性服务还能记录类目之间的层级关系：</p><p>（1）一级类目是招聘、房产、二手…<br>（2）二手下有二级类目二手家具、二手手机…<br>（3）二手手机下有三级类目二手iphone，二手小米，二手三星…<br>（4）…</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010961.webp" alt="img"></p><p>协助解释58同城最核心的帖子数据，描述品类层级关系，保证各类目属性扩展性，保证各属性值合理性校验，就是<strong>58同城另一个统一的核心服务CMC（Category Management Center）</strong>。</p><p>多提一句，类目、属性服务像不像电商系统里的SKU扩展服务？</p><p>（1）品类层级关系，对应电商里的类别层级体系<br>（2）属性扩展，对应电商里各类别商品SKU的属性<br>（3）枚举值校验，对应属性的枚举值，例如颜色：红，黄，蓝</p><p>解决了key压缩，key描述，key扩展，value校验，品类层级的问题，<strong>还有这样的一个问题</strong>没有解决：每个品类下帖子的属性各不相同，查询需求各不相同，如何解决100亿数据量，1万属性的查询需求，是58同城面临的新问题。</p><p>####【统一检索服务】</p><p>数据量很大的时候，不同属性上的查询需求，不可能通过组合索引来满足所有查询需求，怎么办呢？</p><p>58同城的先贤们，从一早就确定了“外置索引，统一检索服务”的技术路线：</p><p>（1）数据库提供“帖子id”的正排查询需求<br>（2）所有非“帖子id”的个性化检索需求，统一走外置索引</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010966.webp" alt="img"></p><p>元数据与索引数据的操作遵循：</p><p>（1）对帖子进行tid正排查询，直接访问帖子服务<br>（2）对帖子进行修改，帖子服务通知检索服务，同时对索引进行修改<br>（3）对帖子进行复杂查询，通过检索服务满足需求</p><p>这个扛起58同城80%终端请求（不管来自PC还是APP，不管是主页、城市页、分类页、列表页、详情页，很可能这个请求最终会是一个检索请求）的服务，就是<strong>58同城另一个统一的核心服务E-search</strong>，这个搜索引擎的每一行代码都来自58同城@老崔 @老龚 等先贤们，目前系统维护者，就是“架构师之路”里屡次提到的@龙神 。</p><p>对于这个服务的架构，简单展开说明一下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010962.webp" alt="img"></p><p>为应对100亿级别数据量、几十万级别的吞吐量，业务线各种复杂的复杂检索查询，扩展性是设计重点：</p><p>（1）<strong>统一的Java代理层集群</strong>，其无状态性能够保证增加机器就能扩充系统性能<br>（2）<strong>统一的合并层C服务集群</strong>，其无状态性也能够保证增加机器就能扩充系统性能<br>（3）<strong>搜索内核检索层C服务集群</strong>，服务和索引数据部署在同一台机器上，服务启动时可以加载索引数据到内存，请求访问时从内存中load数据，访问速度很快<br>（3.1）为了满足数据容量的扩展性，索引数据进行了水平切分，增加切分份数，就能够无限扩展性能<br>（3.2）为了满足一份数据的性能扩展性，同一份数据进行了冗余，理论上做到增加机器就无限扩展性能</p><p>系统时延，100亿级别帖子检索，包含请求分合，拉链求交集，从merger层均可以做到10ms返回。</p><p>58同城的帖子业务，一致性不是主要矛盾，E-search会定期全量重建索引，以保证即使数据不一致，也不会持续很长的时间。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582709011000.webp" alt="img"></p><p>文章写了很长，最后做一个简单总结，面对<strong>100亿数据量，1万列属性，10万吞吐量的业务需求</strong>，58同城的经验，是采用了<code>元数据服务、属性服务、搜索服务</code>来解决的。</p><h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><p>数据库软件架构，到底要设计些什么？</p><ul><li>可用性</li><li>读性能</li><li>一致性</li><li>扩展性</li></ul><blockquote><p>转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962610&amp;idx=1&amp;sn=e5ddf9d321139b143186f2ee596c1f06&amp;chksm=bd2d092e8a5a8038ac72b243f7114d41a754dddfff4177eeb9d897443a3ec01922bbc4ae02cd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">数据库软件架构，到底要设计些什么？</a>，在原文基础上有修改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;概念一：单库&quot;&gt;&lt;a href=&quot;#概念一：单库&quot; class=&quot;headerlink&quot; title=&quot;概念一：单库&quot;&gt;&lt;/a&gt;概念一：单库&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/26/数据库软件架构设计/640-1582688299341.webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念二：分片&quot;&gt;&lt;a href=&quot;#概念二：分片&quot; class=&quot;headerlink&quot; title=&quot;概念二：分片&quot;&gt;&lt;/a&gt;概念二：分片&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/26/数据库软件架构设计/640-1582688306996.webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;分片解决“数据量太大”这一问题，也就是通常说的“水平切分”。&lt;/p&gt;
&lt;p&gt;一旦引入分片，势必面临“数据路由”的新问题，数据到底要访问哪个库。路由规则通常有3种方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="架构设计" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】多次尝试学习，终于搞懂了微服务架构</title>
    <link href="https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E5%A4%9A%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%BB%88%E4%BA%8E%E6%90%9E%E6%87%82%E4%BA%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E5%A4%9A%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%BB%88%E4%BA%8E%E6%90%9E%E6%87%82%E4%BA%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2020-02-25T07:40:45.000Z</published>
    <updated>2020-02-25T15:09:15.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务?"></a>什么是微服务?</h1><p>微服务 Microservices 之父，马丁.福勒，对微服务大概的概述如下：</p><blockquote><p>就目前而言，对于微服务业界并没有一个统一的、标准的定义(While there is no precise definition of this architectural style ) 。</p></blockquote><blockquote><p>但通常在其而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。</p></blockquote><blockquote><p>服务之间采用轻量级的通信机制互相沟通(通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。</p></blockquote><blockquote><p>另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p></blockquote><a id="more"></a><p>根据马丁.福勒的描述，我总结了以下几点：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/e242f34d8c87c66437d98b728f4a171d.jpg" alt="img"></p><h2 id="小服务"><a href="#小服务" class="headerlink" title="小服务"></a>小服务</h2><p>小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。</p><h2 id="进程独立"><a href="#进程独立" class="headerlink" title="进程独立"></a>进程独立</h2><p>每一组服务都是独立运行的，可能我这个服务运行在 Tomcat 容器，而另一个服务运行在 Jetty 上。可以通过进程方式，不断的横向扩展整个服务。</p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>过去的协议都是很重的，就像 ESB，就像 SOAP，轻通信，这意味着相比过去更智能更轻量的服务相互调用，就所谓 smart endpoints and dumb pipes。</p><p>这些 Endpoint 都是解耦的，完成一个业务通信调用串起这些 Micro Service 就像是 Linux 系统中通过管道串起一系列命令业务。</p><p>过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维职责。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>传统的企业级 SOA 服务往往很大，不易于管理，耦合性高，团队开发成本比较大。</p><p>微服务，可以让团队各思其政的选择技术实现，不同的 Service 可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</p><h1 id="微服务的利与弊"><a href="#微服务的利与弊" class="headerlink" title="微服务的利与弊"></a>微服务的利与弊</h1><p>为什么用微服务呢?因为好玩?不是的。下面是我从网络上找到说的比较全的优点：</p><ul><li>优点是每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。</li><li>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。</li><li>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。</li><li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li><li>微服务能使用不同的语言开发。</li><li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如 Jenkins，Hudson，bamboo。</li><li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。微服务允许你利用融合最新技术。</li><li>微服务只是业务逻辑的代码，不会和 HTML，CSS 或其他界面组件混合。</li><li>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库。</li></ul><p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p><p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p><h1 id="什么组织适合使用微服务"><a href="#什么组织适合使用微服务" class="headerlink" title="什么组织适合使用微服务?"></a>什么组织适合使用微服务?</h1><p>微服务带了种种优点，种种弊端，那么什么组织适合使用微服务?</p><h2 id="墨菲定律-设计系统-和康威定律-系统划分"><a href="#墨菲定律-设计系统-和康威定律-系统划分" class="headerlink" title="墨菲定律(设计系统)和康威定律(系统划分)"></a>墨菲定律(设计系统)和康威定律(系统划分)</h2><p>康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是：</p><blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</p><p>-Melvin Conway(1967)</p></blockquote><p>中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。</p><p>看看下面的图片，再想想 Apple 的产品、微软的产品设计，就能形象生动的理解这句话。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/da1466451bb6c8b1c86be88beeeb20ec.jpg" alt="img"><br>感兴趣的各位可以研究一下!</p><h2 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a>架构演化</h2><p>架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/27b5dcef62fffede437262192a8d5049.jpg" alt="img"></p><p>传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。</p><p>我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/8e89430be81287e37febfb9daaa7c266.jpg-wh_600x-s_3329617205.jpg" alt="img"></p><p>使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用 API 方式发布他们的功能，而平台使用他们的功能发布产品。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/2f8f923667a1cf85e4ea0a36142dd463.jpg-wh_600x-s_3077522574.jpg" alt="img"></p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/3fd3fa788ba4f3ded5c42e9812112632.jpg-wh_600x-s_3676732613.jpg" alt="img"></p><h1 id="微服务技术架构体系"><a href="#微服务技术架构体系" class="headerlink" title="微服务技术架构体系"></a>微服务技术架构体系</h1><p>下面我分享一下大部分公司都使用的微服务技术架构体系：</p><p><a href="https://s4.51cto.com/oss/201911/20/bdce530e4c713c192e33aacf560cf36b.jpg" target="_blank" rel="noopener"><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/bdce530e4c713c192e33aacf560cf36b.jpg" alt="img"></a></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>主流的服务发现，分为三种：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/a7482fcd1ab956afac3925367032d166.jpg-wh_600x-s_699873961.jpg" alt="img"></p><p>第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过 DNS 就能找到我们对应的服务。</p><p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/648fcd0296d3e6e5ddb45a5d97bfc0b5.jpg-wh_600x-s_746651471.jpg" alt="img"></p><p>第二种，是目前普遍的做法。可以参考 Zuul 网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p><p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在 Spring Cloud 上的。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/65e07e662e2d302a734e43ab65ccb9ca.jpg-wh_600x-s_947263207.jpg" alt="img"></p><p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p><p>这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>微服务的网关是什么?我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。</p><p>将生活实际联系到微服务上，就不难理解网关的意思了：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/768eea8c5a33305f0fddc39f61153229.jpg-wh_600x-s_1831175765.jpg" alt="img"></p><p>网关的作用如下：</p><ul><li>反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务调用。</li><li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li><li>限流熔断：当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题。</li><li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息。</li><li>灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行 A/B testing。</li></ul><p>即让一部分用户继续用产品特性 A，一部分用户开始用产品特性 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。</p><p>开源网关 Zuul 架构：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/226237b2fb8ff757a643e67ec682df71.jpg" alt="img"></p><p>Zuul 网关核心其实是一个 Servlet，所有请求都会经过 Zuul Servlet 传到 ZuulFilter Runner，然后分发到三种过滤器。</p><p>先说说架构图左半部分，分别是使用 Groovy 实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p><p>一般请求都会先经过前置路由过滤器处理，一般的自定义 Java 封装逻辑也会在这里实现。</p><p>路由过滤器，实现的是找到对应的微服务进行调用。调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p><p>可以说 Zuul 网关最大的特色就是它的三层过滤器。架构图右半部分，是 Zuul 网关设计的自定义过滤器加载机制。</p><p>网关内部会有生产者消费者模型，自动的将过滤器脚本发布到 Zuul 网关读取加载运行。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。</p><p>一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。</p><p>因此就有配置中心这个喽!现在的开源中心有百度配置中心 Disconf，Spring Cloud Config，Apollo。</p><p>今天重点说说现在应用质量不错的配置中心，携程开源的阿波罗(Apollo)：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/cd598d47c727b134a2ca198e41c50462.jpg-wh_600x-s_1032512502.jpg" alt="img"></p><p>Apollo 的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。</p><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><p>关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/b2119c2e7c9bce882b42c644c1fdeca8.jpg-wh_600x-s_1516237122.jpg" alt="img"></p><h2 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h2><p>监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。</p><p>一般监控分为如下层次：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/002cbe53dc2f67ae16350acbcb8f7dd7.jpg" alt="img"></p><p>从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。</p><p>总体来说，微服务可分为 5 个监控点：</p><ul><li>日志监控</li><li>Metrics 监控</li><li>健康检查</li><li>调用链检查</li><li>告警系统</li></ul><h3 id="监控架构"><a href="#监控架构" class="headerlink" title="监控架构"></a>监控架构</h3><p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个 Agent，Agent 收集到关键信息，会传到一些 MQ 中，为了解耦。</p><p>同时将日志传入 ELK，将 Metrics 传入 InfluxDB 时间序列库。而像 Nagios，可以定期向 Agent 发起信息检查微服务。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/9b8b3cb7cf0e2ac69578caefc5f1d9a3.jpg" alt="img"></p><h3 id="调用链监控-APM"><a href="#调用链监控-APM" class="headerlink" title="调用链监控 APM"></a>调用链监控 APM</h3><p>很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的 Cat，大部分调用链监控(没错，我指的 Zipkin)架构是这样的：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/286dfb2abc5d0b52436469a52e543232.jpg" alt="img"></p><p>当请求进入 Web 容器的时候，会经过创建 Tracer，连接 Spans(模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过 HTTP Headers)。</p><p>Spans 有一个上下文，其中包含 Tracer 标识符，将其放在表示分布式操作的树的正确位置。</p><p>当我们把图中的各种 Span 放到后端的时候，我们的服务调用链会动态的生成调用链。</p><p>下面是一些市场上用的比较多的调用链监控对比：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/d8e4aaf560ea57e869d4aebd08f1fe8b.jpg-wh_600x-s_3497886967.jpg" alt="img"></p><h3 id="熔断、隔离、限流、降级"><a href="#熔断、隔离、限流、降级" class="headerlink" title="熔断、隔离、限流、降级"></a>熔断、隔离、限流、降级</h3><p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断(系统自动将服务关闭防止让出现的问题最大化)、隔离(将服务和服务隔离，防止一个服务挂了其他服务不能访问)、限流(单位时间内之允许一定数量用户访问)、降级(当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务或任务进行服务的延迟使用或暂停使用)措施。</p><p>下面介绍一下 Hystrix 的运行流程：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/5b7f9f765608935b6ab292657d7acaa6.jpg-wh_600x-s_499345865.jpg" alt="img"></p><p>每一个微服务调用时，都会使用 Hystrix 的 Command 方式(上图的左上角那个)，然后使用 Command 同步的，或者是响应式的，或者是异步的，判断电路是否熔断(顺着图从左往右看)，如果断路则走降级 Fallback。</p><p>如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施(看图的第 5 步)。</p><p>如果走完了，执行成功了，则走 run() 方法，获取 Response，但是这个过程如果出错了，则继续走降级 Fallback。</p><p>同时，看图最上面有一个后缀是 Health 的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。</p><h1 id="容器与服务编排引擎"><a href="#容器与服务编排引擎" class="headerlink" title="容器与服务编排引擎"></a>容器与服务编排引擎</h1><p>从物理机到虚拟机，从虚拟机到容器;从物理集群到 OpenStack，OpenStack 到 Kubernetes;科技不断的变化，我们的认知也没刷新。</p><p>我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。</p><p>虚拟机会将虚拟硬件、内核(即操作系统)以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。</p><p>虚拟机依赖于 Hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致 Hypervisor 在某些方面被认为是一种操作系统。</p><p>一旦 Hypervisor 安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。</p><p>简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层 Runtime，然后供应用程序运行。</p><p>对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如 LXC 或 Libcontainer)安装在主机操作系统(通常是 Linux 变种)之上。</p><p>在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。</p><p>但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p><p>相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味着相比于虚拟机，单个操作系统能够承载更多的容器。</p><p>云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。</p><p>此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。</p><p>因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。</p><p>我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。</p><p>正因为如此，容器才拥有极为出色的轻量化特性。我们最常用的容器是 Docker。</p><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>过去虚拟机可以通过云平台 OpenStack 管理虚拟化，容器时代如何管理容器呢?这就要看看容器编排引擎了。</p><p>Apache Mesos：Mesos 是基于 Master，Slave 架构，框架决定如何利用资源，Master 负责管理机器，Slave 会定期的将机器情况报告给 Master，Master 再将信息给框架。Master 是高可用的，因为 ZK，也有 Leader 的存在。</p><p>下面是架构图：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/f42d01026d05b86c3218871af63ac4a8.jpg" alt="img"></p><p>Kubernetes：Kubernetes 是最近十分火热的开源容器编排引擎，具体可以参考前几天分享的一篇文章《我花了10个小时，写出了这篇K8S架构解析》</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/3e364b0e4be082fb50b51b793db18863.jpg-wh_600x-s_3201520885.jpg" alt="img"></p><p>Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构，先说说每一个 Kubernetes 节点内部，kubelet 管理全局全局 pod，而每一个 pod 承载着一个或多个容器，kube-proxy 负责网络代理和负载均衡。</p><p>Kubernetes 节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。</p><h2 id="服务网格化"><a href="#服务网格化" class="headerlink" title="服务网格化"></a>服务网格化</h2><p>关于服务网络化，后面会更加深入的为大家进行讲解。</p><h1 id="资料与文献"><a href="#资料与文献" class="headerlink" title="资料与文献"></a>资料与文献</h1><ul><li>马丁.福勒对微服务的描述</li><li>微服务架构的理论基础 - 康威定律</li><li>调用链选型之Zipkin，Pinpoint，SkyWalking，CAT</li></ul><hr><blockquote><p>原文转载自<a href="https://mp.weixin.qq.com/s/Pfs57ee6KpW342cKmJTGrw" target="_blank" rel="noopener">多次尝试学习，终于搞懂了微服务架构</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务?&quot;&gt;&lt;/a&gt;什么是微服务?&lt;/h1&gt;&lt;p&gt;微服务 Microservices 之父，马丁.福勒，对微服务大概的概述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就目前而言，对于微服务业界并没有一个统一的、标准的定义(While there is no precise definition of this architectural style ) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;但通常在其而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;服务之间采用轻量级的通信机制互相沟通(通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】我花了10个小时，写出了这篇K8S架构解析</title>
    <link href="https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%88%91%E8%8A%B1%E4%BA%8610%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E5%86%99%E5%87%BA%E4%BA%86%E8%BF%99%E7%AF%87K8S%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <id>https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%88%91%E8%8A%B1%E4%BA%8610%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E5%86%99%E5%87%BA%E4%BA%86%E8%BF%99%E7%AF%87K8S%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</id>
    <published>2020-02-25T07:40:31.000Z</published>
    <updated>2020-02-25T15:09:15.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>互联网技术飞速发展的今天，为了承载请求的高并发和业务的多样性，微服务的架构成了各个公司的标配。</p></blockquote><p>每个微服务通过 Docker 进行发布，随着业务的发展，系统中遍布着各种各样的容器。于是，容器的资源调度，部署运行，扩容缩容就是我们要面临的问题。</p><p>基于 Kubernetes 作为容器集群的管理平台被广泛应用，今天我们一起来看看 Kubernetes 的架构中有那些常用的组件以及运行原理。</p><a id="more"></a><h1 id="Kubernetes-架构概述"><a href="#Kubernetes-架构概述" class="headerlink" title="Kubernetes 架构概述"></a>Kubernetes 架构概述</h1><p>Kubernetes 是用来管理容器集群的平台。既然是管理集群，那么就存在被管理节点，针对每个 Kubernetes 集群都由一个 Master 负责管理和控制集群节点。</p><p>我们通过 Master 对每个节点 Node 发送命令。简单来说，Master 就是管理者，Node 就是被管理者。</p><p>Node 可以是一台机器或者一台虚拟机。在 Node 上面可以运行多个 Pod，Pod 是 Kubernetes 管理的最小单位，同时每个 Pod 可以包含多个容器（Docker）。</p><p>通过下面的 Kubernetes 架构简图可以看到 Master 和 Node 之间的关系：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612508509.webp" alt="img"></p><p><center><i>Kubernetes 架构简图</i></center><br>通常我们都是通过 kubectl 对 Kubernetes 下命令的，它通过 APIServer 去调用各个进程来完成对 Node 的部署和控制。</p><p>APIServer 的核心功能是对核心对象（例如：Pod，Service，RC）的增删改查操作，同时也是集群内模块之间数据交换的枢纽。</p><p>它包括了常用的 API，访问（权限）控制，注册，信息存储（etcd）等功能。在它的下面我们可以看到 Scheduler，它将待调度的 Pod 绑定到 Node 上，并将绑定信息写入 etcd 中。</p><p>etcd 包含在 APIServer 中，用来存储资源信息。接下来就是 Controller Manager 了，如果说 Kubernetes 是一个自动化运行的系统，那么就需要有一套管理规则来控制这套系统。</p><p>Controller Manager 就是这个管理者，或者说是控制者。它包括 8 个 Controller，分别对应着副本，节点，资源，命名空间，服务等等。</p><p>紧接着，Scheduler 会把 Pod 调度到 Node 上，调度完以后就由 kubelet 来管理 Node 了。</p><p>kubelet 用于处理 Master 下发到 Node 的任务（即 Scheduler 的调度任务），同时管理 Pod 及 Pod 中的容器。</p><p>在完成资源调度以后，kubelet 进程也会在 APIServer 上注册 Node 信息，定期向 Master 汇报 Node 信息，并通过 cAdvisor 监控容器和节点资源。</p><p>由于，微服务的部署都是分布式的，所以对应的 Pod 以及容器的部署也是。为了能够方便地找到这些 Pod 或者容器，引入了 Service（kube-proxy）进程，它来负责反向代理和负载均衡的实施。</p><p>上面就是 Kubernetes 架构的简易说明，涉及到了一些核心概念以及简单的信息流动。</p><p>将一些功能收录到了 APIServer 中，这个简图比官网的图显得简单一些，主要是方便大家记忆。</p><p>后面我们会用一个简单的例子，带大家把 Kubernetes 的概念的由来做深入的了解。</p><h1 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h1><p>假设使用 Kubernetes 部署 Tomcat 和 MySQL 服务到两个 Node 上面。其中 Tomcat 服务生成两个实例也就是生成两个 Pod，用来对其做水平扩展。</p><p>MySQL 只部署一个实例，也就是一个 Pod。可以通过外网访问 Tomcat，而 Tomcat 可以在内网访问 MySQL。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612580738.webp" alt="img"></p><p><center><i>例子示意图</i></center><br>这里我们假设 Kubernetes 和 Docker 的安装都已经完成，并且镜像文件都已经准备好了。重点看 Kubernetes 如何部署和管理容器。</p><h1 id="kubectl-和-APIServer"><a href="#kubectl-和-APIServer" class="headerlink" title="kubectl 和 APIServer"></a>kubectl 和 APIServer</h1><p>既然我们要完成上面的例子，接下来就要部署两个应用。</p><p>首先，根据要部署的应用建立 Replication Controller（RC）。RC 是用来声明应用副本的个数，也就是 Pod 的个数。</p><p>按照上面的例子，Tomcat 的 RC 就是 2，MySQL 的 RC 就是 1。</p><p>由于 kubectl 作为用户接口向 Kubernetes 下发指令，那么指令是通过“.yaml”的配置文件编写的。</p><p>定义 ysql-rc.yaml 的配置文件来描述 MySQL 的 RC：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">V1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">mysql#RC的名称，全局唯一</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="string">replicas:1</span> <span class="comment">#Pod 副本的期待数量</span></span><br><span class="line"><span class="attr">selector :</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"> <span class="attr">template:</span> <span class="comment">#Pod模版，用这个模版来创建Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line"><span class="string">app:mysql#Pod副本的标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="string">containers:#容器定义部分</span></span><br><span class="line">     <span class="string">-name:mysql</span></span><br><span class="line"><span class="string">Image:mysql#容器对应的DockerImage</span></span><br><span class="line">      <span class="attr">Ports:</span></span><br><span class="line">      <span class="string">-containerPort:3306#容器应用监听的端口号</span></span><br><span class="line">      <span class="string">Env:#注入容器的环境变量</span></span><br><span class="line">      <span class="string">-name:MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="string">Value:”123456”</span></span><br></pre></td></tr></table></figure><p>从上面的配置文件可以看出，需要对这个 RC 定义一个名字，以及期望的副本数，以及容器中的镜像文件。然后通过 kubectl 作为客户端的 cli 工具，执行这个配置文件。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612852256.webp" alt="img"></p><p><center><i>通过 kubectl 执行 RC 配置文件</i></center><br>执行了上面的命令以后，Kubernetes 会帮助我们部署副本 MySQL 的 Pod 到 Node。</p><p>此时先不着急看结果，回到最开始的架构图，可以看到 kubectl 会向 Master 中的 APIServer 发起命令，看看 APIServer 的结构和信息的传递吧。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612887167.png" alt="img"></p><p>Kubernetes API Server 通过一个名为 kube-apiserver 的进程提供服务，该进程运行在 Master 上。</p><p>可以通过 Master 的 8080 端口访问 kube-apiserver 进程，它提供 REST 服务。</p><p>因此可以通过命令行工具 kubectl 来与 Kubernetes APIServer 交互，它们之间的接口是 RESTful API。</p><p><strong>APIServer 的架构从上到下分为四层</strong>：</p><ul><li><strong>API 层：</strong>主要以 REST 方式提供各种 API 接口，针对 Kubernetes 资源对象的 CRUD 和 Watch 等主要 API，还有健康检查、UI、日志、性能指标等运维监控相关的 API。</li><li><strong>访问控制层：</strong>负责身份鉴权，核准用户对资源的访问权限，设置访问逻辑（Admission Control）。</li><li><strong>注册表层：</strong>选择要访问的资源对象。PS：Kubernetes 把所有资源对象都保存在注册表（Registry）中，例如：Pod，Service，Deployment 等等。</li><li><strong>etcd 数据库：</strong>保存创建副本的信息。用来持久化 Kubernetes 资源对象的 Key-Value 数据库。</li></ul><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449162.webp" alt="img"></p><p><center><i>APIServer 分层架构图</i></center><br>当 kubectl 用 Create 命令建立 Pod 时，是通过 APIServer 中的 API 层调用对应的 RESTAPI 方法。</p><p>之后会进入权限控制层，通过 Authentication 获取调用者身份，Authorization 获取权限信息。</p><p>AdmissionControl 中可配置权限认证插件，通过插件来检查请求约束。例如：启动容器之前需要下载镜像，或者检查具备某命名空间的资源。</p><p>还记得 mysql-rc.yaml 中配置需要生成的 Pod 的个数为 1。到了 Registry 层会从 CoreRegistry 资源中取出 1 个 Pod 作为要创建的 Kubernetes 资源对象。</p><p>然后将 Node，Pod 和 Container 信息保存在 etcd 中去。这里的 etcd 可以是一个集群，由于里面保存集群中各个 Node/Pod/Container 的信息，所以必要时需要备份，或者保证其可靠性。</p><h1 id="Controller-Manager，Scheduler-和-kubelet"><a href="#Controller-Manager，Scheduler-和-kubelet" class="headerlink" title="Controller Manager，Scheduler 和 kubelet"></a>Controller Manager，Scheduler 和 kubelet</h1><p>前面通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 上面建立 Pod 和 Container。</p><p>在 APIServer，经过 API 调用，权限控制，调用资源和存储资源的过程。实际上还没有真正开始部署应用。</p><p>这里需要 Controller Manager，Scheduler 和 kubelet 的协助才能完成整个部署过程。</p><p>在介绍他们协同工作之前，要介绍一下在 Kubernetes 中的监听接口。从上面的操作知道，所有部署的信息都会写到 etcd 中保存。</p><p>实际上 etcd 在存储部署信息的时候，会发送 Create 事件给 APIServer，而 APIServer 会通过监听（Watch）etcd 发过来的事件。其他组件也会监听（Watch）APIServer 发出来的事件。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612994188.webp" alt="img"></p><p><strong>Kubernetes 就是用这种 List-Watch 的机制保持数据同步的，如上图</strong>：</p><ul><li><p>这里有三个 List-Watch，分别是 kube-controller-manager（运行在Master），kube-scheduler（运行在 Master），kublete（运行在 Node）。他们在进程已启动就会监听（Watch）APIServer 发出来的事件。</p></li><li><p>kubectl 通过命令行，在 APIServer 上建立一个 Pod 副本。</p></li><li><p>这个部署请求被记录到 etcd 中，存储起来。</p></li><li><p>当 etcd 接受创建 Pod 信息以后，会发送一个 Create 事件给 APIServer。</p></li><li><p>由于 Kubecontrollermanager 一直在监听 APIServer 中的事件。此时 APIServer 接受到了 Create 事件，又会发送给 Kubecontrollermanager。</p></li><li><p>Kubecontrollermanager 在接到 Create 事件以后，调用其中的 Replication Controller 来保证 Node 上面需要创建的副本数量。</p><p>上面的例子 MySQL 应用是 1 个副本，Tomcat 应用是两个副本。一旦副本数量少于 RC 中定义的数量，Replication Controller 会自动创建副本。总之它是保证副本数量的 Controller。PS：扩容缩容的担当。</p></li><li><p>在 Controller Manager 创建 Pod 副本以后，APIServer 会在 etcd 中记录这个 Pod 的详细信息。例如在 Pod 的副本数，Container 的内容是什么。</p></li><li><p>同样的 etcd 会将创建 Pod 的信息通过事件发送给 APIServer。</p></li><li><p>由于 Scheduler 在监听（Watch）APIServer，并且它在系统中起到了“承上启下”的作用，“承上”是指它负责接收创建的 Pod 事件，为其安排 Node；“启下”是指安置工作完成后，Node 上的 kubelet 服务进程接管后继工作，负责 Pod 生命周期中的“下半生”。</p><p>换句话说，Scheduler 的作用是将待调度的 Pod 按照调度算法和策略绑定到集群中 Node 上，并将绑定信息写入 etcd 中。</p></li><li><p>Scheduler 调度完毕以后会更新 Pod 的信息，此时的信息更加丰富了。除了知道 Pod 的副本数量，副本内容。还知道部署到哪个 Node 上面了。</p></li><li><p>同样，将上面的 Pod 信息更新到 etcd 中，保存起来。</p></li><li><p>etcd 将更新成功的事件发送给 APIServer。</p></li><li><p>注意这里的 kubelet 是在 Node 上面运行的进程，它也通过 List-Watch 的方式监听（Watch）APIServer 发送的 Pod 更新的事件。实际上，在第 9 步的时候创建 Pod 的工作就已经完成了。</p><p>为什么 kubelete 还要一直监听呢？原因很简单，假设这个时候 kubectl 发命令，需要把原来的 MySQL 的 1 个 RC 副本扩充成 2 个。那么这个流程又会触发一遍。</p><p>作为 Node 的管理者 kubelet 也会根据最新的 Pod 的部署情况调整 Node 端的资源。</p><p>又或者 MySQL 应用的 RC 个数没有发生变化，但是其中的镜像文件升级了，kubelet 也会自动获取最新的镜像文件并且加载。</p></li></ul><p>通过上面 List-Watch 的介绍大家发现了，除了之前引入的 kubectl 和 APIServer 以外又引入了 Controller Manager，Scheduler 和 kubelet。</p><p>这里给大家介绍一下他们的作用和原理：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613048027.png" alt="img"></p><p><center><i>聚焦 Scheduler，Controller Manager，kubelet</i></center></p><h1 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h1><p>Kubernetes 需要管理集群中的不同资源，所以针对不同的资源要建立不同的 Controller。</p><p>每个 Controller 通过监听机制获取 APIServer 中的事件（消息），它们通过 API Server 提供的（List-Watch）接口监控集群中的资源，并且调整资源的状态。</p><p>可以把它想象成一个尽职的管理者，随时管理和调整资源。比如 MySQL 所在的 Node 意外宕机了，Controller Manager 中的 Node Controller 会及时发现故障，并执行修复流程。</p><p>在部署了成百上千微服务的系统中，这个功能极大地协助了运维人员。从此可以看出，Controller Manager 是 Kubernetes 资源的管理者，是运维自动化的核心。</p><p>它分为 8 个 Controller，上面我们介绍了 Replication Controller，这里我们把其他几个都列出来，就不展开描述了。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640.jpg" alt="img"></p><p><center><i>Controller Manager 中不同的 Controller 负责对不同资源的监控和管理</i></center></p><h1 id="Scheduler-与-kubelet"><a href="#Scheduler-与-kubelet" class="headerlink" title="Scheduler 与 kubelet"></a>Scheduler 与 kubelet</h1><p>Scheduler 的作用是，将待调度的 Pod 按照算法和策略绑定到 Node 上，同时将信息保存在 etcd 中。</p><p>如果把 Scheduler 比作调度室，那么这三件事就是它需要关注的，待调度的 Pod、可用的 Node，调度算法和策略。</p><p>简单地说，就是通过调度算法/策略把 Pod 放到合适的 Node 中去。此时 Node 上的 kubelet 通过 APIServer 监听到 Scheduler 产生的 Pod 绑定事件，然后通过 Pod 的描述装载镜像文件，并且启动容器。</p><p>也就是说 Scheduler 负责思考，Pod 放在哪个 Node，然后将决策告诉 kubelet，kubelet 完成 Pod 在 Node 的加载工作。</p><p>说白了，Scheduler 是 boss，kubelet 是干活的工人，他们都通过 APIServer 进行信息交换。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613129697.webp" alt="img"></p><p><center><i>Scheduler 与 kubelet 协同工作图</i></center></p><h1 id="Service-和-kubelet"><a href="#Service-和-kubelet" class="headerlink" title="Service 和 kubelet"></a>Service 和 kubelet</h1><p>经历上面一系列的过程，终于将 Pod 和容器部署到 Node 上了。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449201.webp" alt="img"></p><p><center><i>MySQL 部署成功</i></center><br>作为部署在 Kubernetes 中，Pod 如何访问其他的 Pod 呢？答案是通过 Kubernetes 的 Service 机制。</p><p>在 Kubernetes 中的 Service 定义了一个服务的访问入口地址（IP+Port）。Pod 中的应用通过这个地址访问一个或者一组 Pod 副本。</p><p>Service 与后端 Pod 副本集群之间是通过 Label Selector 来实现连接的。Service 所访问的这一组 Pod 都会有同样的 Label，通过这样的方法知道这些 Pod 属于同一个组。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449202.webp" alt="img"></p><p><center><i>Pod 通过 Service 访问其他 Pod</i></center><br>写 MySQL 服务的配置文件（mysql-svc.yaml）如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion :</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment">#说明创建资源对象的类型是Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">mysql#Service全局唯一名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">prots:</span></span><br><span class="line"><span class="string">-port:</span> <span class="number">3306</span><span class="comment">#Service的服务端口号</span></span><br><span class="line"> <span class="string">selector:#Service对应的Pod标签，用来给Pod分类</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>按照惯例运行 kubectl，创建 Service：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449203.webp" alt="img"></p><p>再用 getsvc 命令检查 Service 信息：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613228838.webp" alt="img"></p><p>这里的 Cluster-IP 169.169.253.143 是由 Kubernetes 自动分配的。当一个 Pod 需要访问其他的 Pod 的时候就需要通过 Service 的 Cluster-IP 和 Port。</p><p>也就是说 Cluster-IP 和 Port 是 Kubernetes 集群的内部地址，是提供给集群内的 Pod 之间访问使用的，外部系统是无法通过这个 Cluster-IP 来访问 Kubernetes 中的应用的。</p><p>上面提到的 Service 只是一个概念，而真正将 Service 落实的是 kube-proxy。</p><p>只有理解了 kube-proxy 的原理和机制，我们才能真正理解 Service 背后的实现逻辑。</p><p>在 Kubernetes 集群的每个 Node 上都会运行一个 kube-proxy 服务进程，我们可以把这个进程看作 Service 的负载均衡器，其核心功能是将到 Service 的请求转发到后端的多个 Pod 上。</p><p>此外，Service 的 Cluster-IP 与 NodePort 是 kube-proxy 服务通过 iptables 的 NAT 转换实现的。kube-proxy 在运行过程中动态创建与 Service 相关的 iptables 规则。</p><p>由于 iptables 机制针对的是本地的 kube-proxy 端口，所以在每个 Node 上都要运行 kube-proxy 组件。</p><p>因此在 Kubernetes 集群内部，可以在任意 Node 上发起对 Service 的访问请求。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613246411.webp" alt="img"></p><p><center><i>集群内部通过 kube-proxy（Service）访问其他 Pod</i></center><br>正如 MySQL 服务，可以被 Kubernetes 内部的 Tomcat 调用，那么 Tomcat 如何被 Kubernetes 外部调用？</p><p>先生成配置文件，myweb-rc.yaml 看看：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">V1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">myweb#RC的名称，全局唯一</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="string">replicas:2#Pod</span> <span class="string">副本的期待数量，这里的数量是2，需要建立两个Tomcat的副本</span></span><br><span class="line"><span class="attr">selector :</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line"> <span class="attr">template:</span> <span class="comment">#Pod模版，用这个模版来创建Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line"><span class="string">app:myweb#Pod副本的标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">containers:</span> <span class="comment">#容器定义部分</span></span><br><span class="line">     <span class="string">-name:mysql</span></span><br><span class="line"><span class="string">Image:kubeguide/tomcat-app:v1#容器对应的DockerImage</span></span><br><span class="line">      <span class="attr">Ports:</span></span><br><span class="line">      <span class="string">-containerPort:8080#容器应用监听的端口号</span></span><br></pre></td></tr></table></figure><p>在 kubectl 中使用 Create 建立 myweb 副本。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613310553.webp" alt="img"></p><p>副本创建完毕以后，创建对应的服务配置文件 myweb-svc.yaml。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion :</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment">#说明创建资源对象的类型是Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">myweb#Service全局唯一名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">prots:</span></span><br><span class="line"><span class="string">-port:</span> <span class="number">8080</span><span class="comment">#Service的服务端口号</span></span><br><span class="line"><span class="attr">nodePort:</span> <span class="number">30001</span><span class="comment">#这个就是外网访问Kubernetes内部应用的端口。</span></span><br><span class="line"> <span class="attr">selector:</span> <span class="comment">#Service对应的Pod标签，用来给Pod分类</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">myweb</span></span><br></pre></td></tr></table></figure><p>同样在 kubectl 中运行 Create 命令，建立 Service 资源。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613324973.webp" alt="img"></p><p>从上面的配置文件可以看出，Tomcat 的 Service 中多了一个 nodePort 的配置，值为 30001。</p><p>也就是说外网通过 30001 这个端口加上 NodeIP 就可以访问 Tomcat 了。</p><p>运行命令之后，得到一个提示，大致意思是“如果你要将服务暴露给外网使用，你需要设置防火墙规则让 30001 端口能够通行。”</p><p>由于 Cluster-IP 是一个虚拟的 IP，仅供 Kubernetes 内部的 Pod 之间的通信。</p><p>Node 作为一个物理节点，因此需要使用 Node-IP 和 nodePort 的组合来从 Kubernetes 外面访问内部的应用。</p><p>如果按照上面的配置，部署了两个 Tomcat 应用，当外网访问时选择那个 Pod 呢？这里需要通过 Kubernetes 之外的负载均衡器来实现的。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613344698.webp" alt="img"></p><p><center><i>Kubernetes 之外的负载均衡器</i></center><br>可以通过 Kubernetes 的 LoadBlancerService 组件来协助实现。通过云平台申请创建负载均衡器，向外暴露服务。</p><p>目前 LoadBlancerService 组件支持的云平台比较完善，比如国外的 GCE、DigitalOcean，国内的阿里云，私有云 OpenStack 等等。</p><p>从用法上只要把 Service 的 type=NodePort 改为 type=LoadBalancer，Kubernetes 就会自动创建一个对应的 Load Balancer 实例并返回它的 IP 地址供外部客户端使用。</p><p>至此，MySQL（RC 1）和 Tomcat（RC 2）已经在 Kubernetes 部署了。并在 Kubernetes 内部 Pod 之间是可以互相访问的，在外网也可以访问到 Kubernetes 内部的 Pod。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449248.webp" alt="img"></p><p><center><i>Pod 在 Kubernetes 内互相访问，外网访问 Pod</i></center><br>另外，作为资源监控 Kubernetes 在每个 Node 和容器上都运行了 cAdvisor。它是用来分析资源使用率和性能的工具，支持 Docker 容器。</p><p>kubelet 通过 cAdvisor 获取其所在 Node 及容器（Docker）的数据。cAdvisor 自动采集 CPU、内存、文件系统和网络使用的统计信息。</p><p>kubelet 作为 Node 的管理者，把 cAdvisor 采集上来的数据通过 RESTAPI 的形式暴露给 Kubernetes 的其他资源，让他们知道 Node/Pod 中的资源使用情况。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于微服务的迅猛发展，Kubernetes 作为微服务治理平台被广泛应用。由于其发展时间长，包含服务功能多我们无法一一列出。</p><p>因此，从一个简单的创建应用副本的例子入手，介绍了各个重要组件的概念和基本原理。</p><p>Kubernetes 是用来管理容器集群的，Master 作为管理者，包括 APIServer，Scheduler，Controller Manager。</p><p>Node作为副本部署的载体，包含多个 Pod，每个 Pod 又包含多个容器（container）。用户通过 kubectl 给 Master 中的 APIServer 下部署命令。</p><p>命令主体是以“.yaml”结尾的配置文件，包含副本的类型，副本个数，名称，端口，模版等信息。</p><p>APIServer 接受到请求以后，会分别进行以下操作：权限验证（包括特殊控制），取出需要创建的资源，保存副本信息到etcd。</p><p>APIServer 和 Controller Manager，Scheduler 以及 kubelete 之间通过 List-Watch 方式通信（事件发送与监听）。</p><p>Controller Manager 通过 etcd 获取需要创建资源的副本数，交由 Scheduler 进行策略分析。</p><p>最后 kubelet 负责最终的 Pod 创建和容器加载。部署好容器以后，通过 Service 进行访问，通过 cAdvisor 监控资源。</p><blockquote><p>原文转载自51CTO技术栈，崔皓，<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655827885&amp;idx=1&amp;sn=47feb253e0aa012023d6f421572a04b3&amp;chksm=bd74fa7a8a03736c08e43b4e7082c3763c0e64491e7b7ef3ddd9f3756cfa5e536730f8f022e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我花了10个小时，写出了这篇K8S架构解析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;互联网技术飞速发展的今天，为了承载请求的高并发和业务的多样性，微服务的架构成了各个公司的标配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个微服务通过 Docker 进行发布，随着业务的发展，系统中遍布着各种各样的容器。于是，容器的资源调度，部署运行，扩容缩容就是我们要面临的问题。&lt;/p&gt;
&lt;p&gt;基于 Kubernetes 作为容器集群的管理平台被广泛应用，今天我们一起来看看 Kubernetes 的架构中有那些常用的组件以及运行原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="k8s" scheme="https://vincentruan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>【转载】神一样的CAP理论被应用在何方</title>
    <link href="https://vincentruan.github.io/2020/02/24/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84CAP%E7%90%86%E8%AE%BA%E8%A2%AB%E5%BA%94%E7%94%A8%E5%9C%A8%E4%BD%95%E6%96%B9/"/>
    <id>https://vincentruan.github.io/2020/02/24/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84CAP%E7%90%86%E8%AE%BA%E8%A2%AB%E5%BA%94%E7%94%A8%E5%9C%A8%E4%BD%95%E6%96%B9/</id>
    <published>2020-02-24T13:39:19.000Z</published>
    <updated>2020-02-25T15:09:15.058Z</updated>
    
    <content type="html"><![CDATA[<p>对于开发或设计分布式系统的架构师工程师来说，CAP是必须要掌握的理论。</p><blockquote><p>（but：这个文章的重点并不是讨论CAP理论和细节，重点是说说CAP在微服务中的开发怎么起到一个指引作用，会通过几个微服务开发的例子说说明，尽量的去贴近开发）</p></blockquote><p>CAP定理又被成为布鲁尔定理，是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。不过布鲁尔在出来CAP的时候并没有对CAP三者（Consistency，Availability，Partition tolerance）进行详细的定义，所以在网上也出现了不少对CAP不同解读的声音。</p><a id="more"></a><h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>CAP定理在发展中存在过两个版本，我们以第二个版本为准</p><blockquote><p>在一个分布式系统中（指互相连接并共享数据的节点集合）中，当涉及到读写操作时，只能保证一致性（Consistence）、可用性(Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。</p></blockquote><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f809b3bc" alt="image"></p><p>这个版本的CAP理论在探讨分布式系统，更加强调两点是互联和共享数据，其实也是理清楚了第一个版本中三选二的一些缺陷，分布式系统不一定都存在互联和共享数据，例如memcached集群相互间就没有存在连接和共享数据，所以memcached集群这类的分布式系统并不在CAP理论讨论的范围，而想Mysql集群就是互联和数据共享复制，因此mysql集群式属于CAP理论讨论的对象。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值</p><h4 id="可用性-Availability）"><a href="#可用性-Availability）" class="headerlink" title="可用性(Availability）"></a>可用性(Availability）</h4><p>非故障的节点在合理的时间内返回合理的响应</p><h4 id="分区容错性-Partition-Tolerance"><a href="#分区容错性-Partition-Tolerance" class="headerlink" title="分区容错性(Partition Tolerance)"></a>分区容错性(Partition Tolerance)</h4><p>当网络出现分区后，系统依然能够继续旅行社职责</p><p>在分布式的环境下，网络无法做到100%可靠，有可能出现故障，因此分区是一个必须的选项，如果选择了CA而放弃了P，若发生分区现象，为了保证C，系统需要禁止写入，此时就与A发生冲突，如果是为了保证A，则会出现正常的分区可以写入数据，有故障的分区不能写入数据，则与C就冲突了。因此分布式系统理论上不可能选择CA架构，而必须选择CP或AP架构。</p><h4 id="分布式事务BASE理论"><a href="#分布式事务BASE理论" class="headerlink" title="分布式事务BASE理论"></a>分布式事务BASE理论</h4><p>BASE理论是对CAP的延伸和补充，是对CAP中的AP方案的一个补充，即使在选择AP方案的情况下，如何更好的最终达到C。</p><p>BASE是基本可用，柔性状态，最终一致性三个短语的缩写，核心的思想是即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性。</p><h3 id="CAP在服务中实际的应用例子"><a href="#CAP在服务中实际的应用例子" class="headerlink" title="CAP在服务中实际的应用例子"></a>CAP在服务中实际的应用例子</h3><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f63920ec" alt="image"></p><p>理解貌似讲多了，项目的CAP可以参考下李运华的《从零开始学架构》的书，里面的21，22章比较详细的描绘了CAP的理论细节和CAP的版本演化过程。</p><p>这里着重的讲解的是神一样的CAP在我们的微服务中怎么去指导和应用起来，大概会举几个平时常见的例子</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f5068452" alt="image"></p><h3 id="服务注册中心，是选择AP还是选择CP-？"><a href="#服务注册中心，是选择AP还是选择CP-？" class="headerlink" title="服务注册中心，是选择AP还是选择CP ？"></a>服务注册中心，是选择AP还是选择CP ？</h3><h4 id="服务注册中心解决的问题"><a href="#服务注册中心解决的问题" class="headerlink" title="服务注册中心解决的问题"></a>服务注册中心解决的问题</h4><p>在讨论CAP之前先明确下服务注册中心主要是解决什么问题：一个是服务注册，一个是服务发现。</p><ul><li>服务注册：实例将自身服务信息注册到注册中心，这部分信息包括服务的主机IP和服务的Port，以及暴露服务自身状态和访问协议信息等。</li><li>服务发现：实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</li></ul><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888feb8431b" alt="image"></p><p>目前作为注册中心的一些组件大致有：dubbo的zookeeper，springcloud的eureka，consul，rocketMq的nameServer，hdfs的nameNode。目前微服务主流是dubbo和springcloud，使用最多是zookeeper和eureka，我们就来看看应该根据CAP理论应该怎么去选择注册中心。（springcloud也可以用zk，不过不是主流不讨论）。</p><h4 id="zookeeper选择CP"><a href="#zookeeper选择CP" class="headerlink" title="zookeeper选择CP"></a>zookeeper选择CP</h4><p>zookeep保证CP，即任何时刻对zookeeper的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性。从实际情况来分析，在使用zookeeper获取服务列表时，如果zk正在选举或者zk集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk不能保证服务可用性。</p><h4 id="eureka选择AP"><a href="#eureka选择AP" class="headerlink" title="eureka选择AP"></a>eureka选择AP</h4><p>eureka保证AP，eureka在设计时优先保证可用性，每一个节点都是平等的，一部分节点挂掉不会影响到正常节点的工作，不会出现类似zk的选举leader的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点，只要有一台eureka存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信息。</p><h4 id="zookeeper和eureka的数据一致性问题"><a href="#zookeeper和eureka的数据一致性问题" class="headerlink" title="zookeeper和eureka的数据一致性问题"></a>zookeeper和eureka的数据一致性问题</h4><p>先要明确一点，eureka的创建初心就是为一个注册中心，但是zk更多是作为分布式协调服务的存在，只不过因为它的特性被dubbo赋予了注册中心，它的职责更多是保证数据（配置数据，状态数据）在管辖下的所有服务之间保持一致，所有这个就不难理解为何zk被设计成CP而不是AP，zk最核心的算法ZAB，就是为了解决分布式系统下数据在多个服务之间一致同步的问题。</p><p>更深层的原因，zookeeper是按照CP原则构建，也就是说它必须保持每一个节点的数据都保持一致，如果zookeeper下节点断开或者集群中出现网络分割（例如交换机的子网间不能互访），那么zk会将它们从自己的管理范围中剔除，外界不能访问这些节点，即使这些节点是健康的可以提供正常的服务，所以导致这些节点请求都会丢失。</p><p>而eureka则完全没有这方面的顾虑，它的节点都是相对独立，不需要考虑数据一致性的问题，这个应该是eureka的诞生就是为了注册中心而设计，相对zk来说剔除了leader节点选取和事务日志极致，这样更有利于维护和保证eureka在运行的健壮性。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888fc2f78b3" alt="image"></p><p>再来看看，数据不一致性在注册服务中中会给eureka带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些ip节点被调用数少，某些ip节点调用数少的问题。也有可能存在一些本应该被删除而没被删除的脏数据。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f75401e9" alt="image"></p><h4 id="小结：服务注册应该选择AP还是CP"><a href="#小结：服务注册应该选择AP还是CP" class="headerlink" title="小结：服务注册应该选择AP还是CP"></a>小结：服务注册应该选择AP还是CP</h4><p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果，对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p><p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择AP。</p><h3 id="分布式锁，是选择AP还是选择CP-？"><a href="#分布式锁，是选择AP还是选择CP-？" class="headerlink" title="分布式锁，是选择AP还是选择CP ？"></a>分布式锁，是选择AP还是选择CP ？</h3><p>这里实现分布式锁的方式选取了三种：</p><ul><li>基于数据库实现分布式锁</li><li>基于redis实现分布式锁</li><li>基于zookeeper实现分布式锁</li></ul><h4 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h4><p>构建表结构</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a12368882" alt="image"></p><p>利用表的 UNIQUE KEY <code>idx_lock</code> (<code>method_lock</code>) 作为唯一主键，当进行上锁时进行insert动作，数据库成功录入则以为上锁成功，当数据库报出 Duplicate entry 则表示无法获取该锁。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a11076d99" alt="image"></p><p>不过这种方式对于单主却无法自动切换主从的mysql来说，基本就无法现实P分区容错性，（Mysql自动主从切换在目前并没有十分完美的解决方案）。可以说这种方式强依赖于数据库的可用性，数据库写操作是一个单点，一旦数据库挂掉，就导致锁的不可用。这种方式基本不在CAP的一个讨论范围。</p><h4 id="基于redis实现分布式锁"><a href="#基于redis实现分布式锁" class="headerlink" title="基于redis实现分布式锁"></a>基于redis实现分布式锁</h4><p>redis单线程串行处理天然就是解决串行化问题，用来解决分布式锁是再适合不过。</p><p>实现方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setnx key value Expire_time</span><br><span class="line">获取到锁 返回 1 ， 获取失败 返回 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>为了解决数据库锁的无主从切换的问题，可以选择redis集群，或者是 sentinel 哨兵模式，实现主从故障转移，当master节点出现故障，哨兵会从slave中选取节点，重新变成新的master节点。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05889f092fb7f" alt="image"></p><p>哨兵模式故障转移是由sentinel集群进行监控判断，当maser出现异常即复制中止，重新推选新slave成为master，sentinel在重新进行选举并不在意主从数据是否复制完毕具备一致性。</p><p>所以redis的复制模式是属于AP的模式。保证可用性，在主从复制中“主”有数据，但是可能“从”还没有数据，这个时候，一旦主挂掉或者网络抖动等各种原因，可能会切换到“从”节点，这个时候可能会导致两个业务县城同时获取得两把锁</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05889f24be477" alt="image"></p><p>这个过程如下：</p><ol><li>业务线程-1 向主节点请求锁</li><li>业务线程-1 获取锁</li><li>业务线程-1 获取到锁并开始执行业务</li><li>这个时候redis刚生成的锁在主从之间还未进行同步</li><li>redis这时候主节点挂掉了</li><li>redis的从节点升级为主节点</li><li>业务线程-2 想新的主节点请求锁</li><li>业务线程-2 获取到新的主节点返回的锁</li><li>业务线程-2 获取到锁开始执行业务</li><li>这个时候 业务线程-1 和 业务线程-2 同时在执行任务</li></ol><p>上述的问题其实并不是redis的缺陷，只是redis采用了AP模型，它本身无法确保我们对一致性的要求。redis官方推荐redlock算法来保证，问题是redlock至少需要三个redis主从实例来实现，维护成本比较高，相当于redlock使用三个redis集群实现了自己的另一套一致性算法，比较繁琐，在业界也使用得比较少。</p><h5 id="能否使用redis作为分布式锁？"><a href="#能否使用redis作为分布式锁？" class="headerlink" title="能否使用redis作为分布式锁？"></a>能否使用redis作为分布式锁？</h5><p>能不能使用redis作为分布式锁，这个本身就不是redis的问题，还是取决于业务场景，我们先要自己确认我们的场景是适合 AP 还是 CP ， 如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，redis提供给我们高性能的AP模型是非常适合的，但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻在一种更加适合的 CP 模型</p><h4 id="基于zookeeper实现分布式锁"><a href="#基于zookeeper实现分布式锁" class="headerlink" title="基于zookeeper实现分布式锁"></a>基于zookeeper实现分布式锁</h4><p>刚刚也分析过，redis其实无法确保数据的一致性，先来看zookeeper是否合适作为我们需要的分布式锁，首先zk的模式是CP模型，也就是说，当zk锁提供给我们进行访问的时候，在zk集群中能确保这把锁在zk的每一个节点都存在。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05889f6a5ce1c" alt="image"></p><p>（这个实际上是zk的leader通过二阶段提交写请求来保证的，这个也是zk的集群规模大了的一个瓶颈点）</p><h5 id="zk锁实现的原理"><a href="#zk锁实现的原理" class="headerlink" title="zk锁实现的原理"></a>zk锁实现的原理</h5><p>说zk的锁问题之前先看看zookeeper中几个特性，这几个特性构建了zk的一把分布式锁</p><p><strong>特性：</strong></p><ul><li>有序节点</li></ul><blockquote><p>当在一个父目录下如 /lock 下创建 有序节点，节点会按照严格的先后顺序创建出自节点 lock000001,lock000002,lock0000003,以此类推，有序节点能严格保证各个自节点按照排序命名生成。</p></blockquote><ul><li>临时节点</li></ul><blockquote><p>客户端建立了一个临时节点，在客户端的会话结束或会话超时，zookepper会自动删除该解ID那。</p></blockquote><ul><li>事件监听</li></ul><blockquote><p>在读取数据时，我们可以对节点设置监听，当节点的数据发生变化（1 节点创建 2 节点删除 3 节点数据变成 4 自节点变成）时，zookeeper会通知客户端。</p></blockquote><p>结合这几个特点，来看下zk是怎么组合分布式锁。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a51620561" alt="image"></p><ol><li>业务线程-1 业务线程-2 分别向zk的/lock目录下，申请创建有序的临时节点</li><li>业务线程-1 抢到/lock0001 的文件，也就是在整个目录下最小序的节点，也就是线程-1获取到了锁</li><li>业务线程-2 只能抢到/lock0002的文件，并不是最小序的节点，线程2未能获取锁</li><li>业务线程-1 与 lock0001 建立了连接，并维持了心跳，维持的心跳也就是这把锁的租期</li><li>当业务线程-1 完成了业务，将释放掉与zk的连接，也就是释放了这把锁</li></ol><h5 id="zk分布式锁的代码实现"><a href="#zk分布式锁的代码实现" class="headerlink" title="zk分布式锁的代码实现"></a>zk分布式锁的代码实现</h5><p>zk官方提供的客户端并不支持分布式锁的直接实现，我们需要自己写代码去利用zk的这几个特性去进行实现。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a68844a5a" alt="image"></p><h4 id="小结：究竟该用CP还是AP的分布式锁"><a href="#小结：究竟该用CP还是AP的分布式锁" class="headerlink" title="小结：究竟该用CP还是AP的分布式锁"></a>小结：究竟该用CP还是AP的分布式锁</h4><p>首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型。</p><p>无论是redis，zk，例如redis的AP模型会限制很多使用场景，但它却拥有了几者中最高的性能，zookeeper的分布式锁要比redis可靠很多，但他繁琐的实现机制导致了它的性能不如redis，而且zk会随着集群的扩大而性能更加下降。</p><p>简单来说，先了解业务场景，后进行技术选型。</p><h3 id="分布式事务，是怎么从ACID解脱，投身CAP-BASE"><a href="#分布式事务，是怎么从ACID解脱，投身CAP-BASE" class="headerlink" title="分布式事务，是怎么从ACID解脱，投身CAP/BASE"></a>分布式事务，是怎么从ACID解脱，投身CAP/BASE</h3><p>如果说到事务，ACID是传统数据库常用的设计理念，追求强一致性模型，关系数据库的ACID模型拥有高一致性+可用性，所以很难进行分区，所以在微服务中ACID已经是无法支持，我们还是回到CAP去寻求解决方案，不过根据上面的讨论，CAP定理中，要么只能CP，要么只能AP，如果我们追求数据的一致性而忽略可用性这个在微服务中肯定是行不通的，如果我们追求可用性而忽略一致性，那么在一些重要的数据（例如支付，金额）肯定出现漏洞百出，这个也是无法接受。所以我们既要一致性，也要可用性。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a859246f5" alt="image"></p><p>都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入BASE理论，在分布式事务中，BASE最重要是为CAP提出了最终一致性的解决方案，BASE强调牺牲高一致性，从而获取肯用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p><h4 id="实现最终一致性"><a href="#实现最终一致性" class="headerlink" title="实现最终一致性"></a>实现最终一致性</h4><p><strong>弱一致性</strong>：系统不能保证后续访问返回更新的值。需要在一些条件满足之后，更新的值才能返回。从更新操作开始，到系统保证任何观察者总是看到更新的值的这期间被称为不一致窗口。</p><p><strong>最终一致性</strong>：这是弱一致性的特殊形式；存储系统保证如果没有对某个对象的新更新操作，最终所有的访问将返回这个对象的最后更新的值。</p><h4 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h4><p>BASE模型是传统ACID模型的反面，不同与ACID，BASE强调牺牲高一致性，从而获得可用性，数据允许在一段时间内的不一致，只要保证最终一致就可以了。</p><p>BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库) Soft state软状态 状态可以有一段时间不同步，异步。 Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时一致。</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在分布式系统中，要实现分布式事务，无外乎几种解决方案。方案各有不同，不过其实都是遵循BASE理论，是最终一致性模型。</p><ul><li>两阶段提交（2PC）</li><li>补偿事务（TCC）</li><li>本地消息表</li><li>MQ事务消息</li></ul><h4 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h4><p>其实还有一个数据库的XA事务，不过目前在真正的互联网中实际的应用基本很少，两阶段提交就是使用XA原理。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a87ee0c96" alt="image"></p><p>在 XA 协议中分为两阶段：</p><ol><li>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li><li>事务协调器要求每个数据库提交数据，或者回滚数据。</li></ol><p>说一下，为何在互联网的系统中没被改造过的两阶段提交基本很少被业界应用，最最大的缺点就是同步阻塞问题，在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。这个在互联网高并发大数据的今天，两阶段的提交是不能满足现在互联网的发展。</p><p>还有就是两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，例如：</p><p>比如在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p><h4 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h4><p>TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588aa354cd70" alt="image"></p><p>相比两阶段提交，TCC解决了几个问题</p><p>同步阻塞，引入了超时机制，超时后进行补偿，并不会像两阶段提交锁定了整个资源，将资源转换为业务逻辑形式，粒度变小。 因为有了补偿机制，可以由业务活动管理器进行控制，保证数据一致性。</p><p>1). try阶段</p><p>try只是一个初步的操作，进行初步的确认，它的主要职责是完成所有业务的检查，预留业务资源</p><p>2). confirm阶段</p><p>confirm是在try阶段检查执行完毕后，继续执行的确认操作，必须满足幂等性操作，如果confirm中执行失败，会有事务协调器触发不断的执行，直到满足为止</p><p>3). cancel是取消执行，在try没通过并释放掉try阶段预留的资源，也必须满足幂等性，跟confirm一样有可能被不断执行</p><p>一个下订单，生成订单扣库存的例子：</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588aa9cf1fed" alt="image"></p><p>接下来看看，我们的下单扣减库存的流程怎么加入TCC</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588ab8cd2a20" alt="image"></p><p>在try的时候，会让库存服务预留n个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源， 在confirm的时候，会使用在try预留的资源，在TCC事务机制中认为，如果在try阶段能正常预留的资源，那么在confirm一定能完整的提交</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588ab8c51652" alt="image"></p><p>在try的时候，有任务一方为执行失败，则会执行cancel的接口操作，将在try阶段预留的资源进行释放。</p><p>这个并不是重点要论tcc事务是怎么实现，重点还是讨论分布式事务在CAP+BASE理论的应用。实现可以参考：<a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">github.com/changmingxi…</a></p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案 <a href="https://queue.acm.org/detail.cfm?id=1394128。" target="_blank" rel="noopener">queue.acm.org/detail.cfm?…</a></p><p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588acde414a6" alt="image"></p><p>对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明</p><ol><li>当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）</li><li>配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。</li><li>库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。</li></ol><p>这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。</p><p>本地消息队列是BASE理论，是最终一致性模型，适用对一致性要求不高的情况。</p><h4 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h4><p>RocketMq在4.3版本已经正式宣布支持分布式事务，在选择Rokcetmq做分布式事务请务必选择4.3以上的版本。</p><p>RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588ae2844970" alt="image"></p><p>事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588aeba679cf" alt="image"></p><p>MQ事务是对本地消息表的一层封装，将本地消息表移动到了MQ内部，所以也是基于BASE理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时MQ事务将整个流程异步化了，也非常适合在高并发情况下使用。</p><h3 id="RocketMQ选择异步-同步刷盘，异步-同步复制，背后的CP和AP思考"><a href="#RocketMQ选择异步-同步刷盘，异步-同步复制，背后的CP和AP思考" class="headerlink" title="RocketMQ选择异步/同步刷盘，异步/同步复制，背后的CP和AP思考"></a>RocketMQ选择异步/同步刷盘，异步/同步复制，背后的CP和AP思考</h3><p>虽然同步刷盘/异步刷盘，同步/异步复制，并没有对cAP直接的应用，但在配置的过程中也一样涉及到可用性和一致性的考虑</p><h4 id="同步刷盘-异步刷盘"><a href="#同步刷盘-异步刷盘" class="headerlink" title="同步刷盘/异步刷盘"></a>同步刷盘/异步刷盘</h4><p>RocketMQ的消息是可以做到持久化的，数据会持久化到磁盘，RocketMQ为了提高性能，尽可能保证磁盘的顺序写入，消息在Producer写入RocketMq的时候，有两种写入磁盘方式：</p><ol><li>异步刷盘： 消息快速写入到内存的pagecache，就立马返回写成功状态，当内存的消息累计到一定程度的时候，会触发统一的写磁盘操作。这种方式可以保证大吞吐量，但也存在着消息可能未存入磁盘丢失的风险。</li><li>同步刷盘： 消息快速写入内存的pagecahe，立刻通知刷盘线程进行刷盘，等待刷盘完成之后，唤醒等待的线程，返回消息写成功的状态。</li></ol><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588b056e080a" alt="image"></p><h4 id="同步复制-异步复制"><a href="#同步复制-异步复制" class="headerlink" title="同步复制/异步复制"></a>同步复制/异步复制</h4><p>一个broker组有Master和Slave，消息需要从Master复制到Slave上，所以有同步和异步两种复制方式。</p><ol><li>同步复制： 是等Master和Slave均写成功后才反馈给客户端写成功状态。</li><li>异步复制： 是只要Master写成功即可反馈给客户端写成功状态。</li></ol><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588af130c763" alt="image"></p><p>异步复制的优点是可以提高响应速度，但牺牲了一致性 ，一般实现该类协议的算法需要增加额外的补偿机制。同步复制的优点是可以保证一致性(一般通过两阶段提交协议)，但是开销较大，可用性不好(参见CAP定理)，带来了更多的冲突和死锁等问题。值得一提的是Lazy+Primary/Copy的复制协议在实际生产环境中是非常实用的。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588b16477dcb" alt="image"></p><p>RocketMQ的设置要结合业务场景，合理设置刷盘方式和主从复制方式，尤其是SYNC_FLUSH方式，由于频繁的触发写磁盘动作，会明显降低性能。通常情况下，应该把Master和Slave设置成ASYNC_FLUSH的刷盘方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台机器出故障，仍然可以保证数据不丢。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在微服务的构建中，永远都逃离不了CAP理论，因为网络永远不稳定，硬件总会老化，软件会可能出现bug，所以分区容错性在微服务中是躲不过的命题，可以这么说，只要是分布式，只要是集群都面临着AP或者CP的选择，但你很贪心的时候，既要一致性又要可用性，那只能对一致性作出一点妥协，也就是引入了BASE理论，在业务允许的情况下实现最终一致性。</p><p>究竟是选AP还是选CP，真的在于对业务的了解，例如金钱，库存相关会优先考虑CP模型，例如社区发帖相关可以优先选择AP模型，这个说白了其实基于对业务的了解是一个选择和妥协的过程。</p><hr><blockquote><p>转载自陈于喆 - 神一样的CAP理论被应用在何方，原文地址<br><a href="https://juejin.im/post/5d720e86f265da03cc08de74" target="_blank" rel="noopener">https://juejin.im/post/5d720e86f265da03cc08de74</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于开发或设计分布式系统的架构师工程师来说，CAP是必须要掌握的理论。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（but：这个文章的重点并不是讨论CAP理论和细节，重点是说说CAP在微服务中的开发怎么起到一个指引作用，会通过几个微服务开发的例子说说明，尽量的去贴近开发）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CAP定理又被成为布鲁尔定理，是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。不过布鲁尔在出来CAP的时候并没有对CAP三者（Consistency，Availability，Partition tolerance）进行详细的定义，所以在网上也出现了不少对CAP不同解读的声音。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="CAP" scheme="https://vincentruan.github.io/tags/CAP/"/>
    
      <category term="架构" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【转载】30张图带你彻底理解红黑树</title>
    <link href="https://vincentruan.github.io/2020/02/24/30%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://vincentruan.github.io/2020/02/24/30%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-02-24T12:44:16.000Z</published>
    <updated>2020-02-25T15:09:15.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ &gt;                                                                                - 学红黑树有感。</p></blockquote><p>终于，在学习了几天的红黑树相关的知识后，我想把我所学所想和所感分享给大家。红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等一连串的问题在学习前困扰着我。如果你在学习过程中也会存在我的疑问，那么本文对你会有帮助，本文帮助你全面、彻底地理解红黑树！</p><a id="more"></a><p>本文将通过图文的方式讲解红黑树的知识点，并且不会涉及到任何代码，相信我，在懂得红黑树实现原理前，看代码会一头雾水的，当原理懂了，代码也就按部就班写而已，没任何难度。</p><p>阅读本文你需具备知识点：</p><ul><li>二叉查找树</li><li>完美平衡二叉树</li></ul><p>事不宜迟，让我们进入正题吧。</p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。现在在脑海想下怎么实现？是不是太多情景需要考虑了？啧啧，先别急，通过本文的学习后，你会觉得，其实也不过如此而已。好吧，我们先来看下红黑树的定义和一些基本性质。</p><h4 id="红黑树定义和性质"><a href="#红黑树定义和性质" class="headerlink" title="红黑树定义和性质"></a>红黑树定义和性质</h4><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5又可以推出：</p><ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p>图1就是一颗简单的红黑树。其中Nil为叶子结点，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-4996bbfb4017a3b2.webp" alt="img"></p><p><center>图1 一颗简单的红黑树</center><br>红黑树并不是一个<em>完美</em>平衡二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如图2所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-abedf3ecc733ccd5.webp" alt="img"></p><p><center>图2 结点叫法约定</center><br>我们把正在处理(遍历)的结点叫做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。</p><p>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</p><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li><li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-a95db442f1b47f8a.webp" alt="img"></p><p><center>图3 左旋</center><br><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-0676a8e2a12e2a0b.webp" alt="img"></p><p><center>图4 右旋</center><br>上面所说的旋转结点也即旋转的支点，图4和图5中的P结点。<br>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。<br><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><p>所以旋转操作是<strong>局部</strong>的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。</p><p>但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住<strong>红黑树总是通过旋转和变色达到自平衡</strong>。</p><p>balabala了这么多，相信你对红黑树有一定印象了，那么现在来考考你：</p><p><strong><em>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？</em></strong> (答案见文末)</p><p>接下来先讲解红黑树的查找热热身。</p><hr><h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li>从根结点开始查找，把根结点设置为当前结点；</li><li>若当前结点为空，返回null；</li><li>若当前结点不为空，用当前结点的key跟查找key作比较；</li><li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li></ol><p>如图5所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-07b47eb3722981e6.webp" alt="img"></p><p><center>图5 二叉树查找流程图</center><br>非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～</p><hr><h4 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h4><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>如图6所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-7521866b50683a24.webp" alt="img"></p><p><center>图6 红黑树插入位置查找</center><br>ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>所有插入情景如图7所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-fa2b78271263d2c8.webp" alt="img"></p><p><center>图7 红黑树插入情景</center><br>嗯，插入情景很多呢，8种插入情景！但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。</p><p>另外，根据二叉树的性质，<strong>除了情景2，所有插入操作都是在叶子结点进行的</strong>。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。</p><p>在开始每个情景的讲解前，我们还是先来约定下，如图8所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-9ac3d6b69ef7ead3.webp" alt="img"></p><p><center>图8 插入操作结点的叫法约定</center><br>图8的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。</p><p>好了，下面让我们一个一个来分析每个插入的情景以其处理。</p><h5 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h5><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h5 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h5><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h5 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h5><p>由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h5 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h5><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><p><strong>插入情景4.1：叔叔结点存在并且为红结点</strong><br> 从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-9f2c746bf0769f49.webp" alt="img"></p><p><center>图9 插入情景4.1_1</center><br><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-5374ea3c2956b441.webp" alt="img"></p><p><center>图10 插入情景4.1_2</center><br>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><p><strong>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</strong><br> 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><p><strong>插入情景4.2.1：插入结点是其父结点的左子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-ab4097b750826870.webp" alt="img"></p><p><center>图11 插入情景4.2.1</center><br>由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把P设为红色，I和PP设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把P设为红色，I和PP设为黑色。但把P设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><p><strong>插入情景4.2.2：插入结点是其父结点的右子结点</strong><br> 这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-fbfc4f299941cb8b.webp" alt="img"></p><p><center>图12 插入情景4.2.2</center><br><strong>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</strong><br> 该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><p><strong>插入情景4.3.1：插入结点是其父结点的右子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-2bc24a78b68dae51.webp" alt="img"></p><p><center>图13 插入情景4.3.1</center><br><strong>插入情景4.3.2：插入结点是其父结点的右子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-ee1a9027ddcc210a.webp" alt="img"></p><p><center>图14 插入情景4.3.2</center><br>好了，讲完插入的所有情景了。可能又同学会想：上面的情景举例的都是第一次插入而不包含自底向上处理的情况，那么上面所说的情景都适合自底向上的情况吗？答案是肯定的。理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的。好吧，在出个习题，请大家拿出笔和纸画下试试（请务必动手画下，加深印象）：</p><p><strong>习题1：请画出图15的插入自平衡处理过程。</strong>（答案见文末）</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-28186be7e43be254.webp" alt="img"></p><h2 id="图15-习题1"><a href="#图15-习题1" class="headerlink" title="图15 习题1"></a><center>图15 习题1</center></h2><h4 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h4><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最左结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。如图16所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-dc4f0ab5d111ff96.webp" alt="img"></p><p><center>图16 二叉树投射x轴后有序</center><br>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong>话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-f45799daa674d0ad.webp" alt="img"></p><p><center>图17 删除结点换位思路</center><br>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图18所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-a48550e315b3b132.webp" alt="img"></p><p><center>图18 二叉树删除情景转换</center><br>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图19所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-edaf96e55f08c198.webp" alt="img"></p><p><center>图19 红黑树删除情景</center><br>哈哈，是的，即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图20所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-db3468a5977ad998-1582549732988.webp" alt="img"></p><p><center>图20 删除操作结点的叫法约定</center><br>图20的字母并不代表结点Key的大小。R<em>表示替代结点</em>，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h5 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h5><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h5 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h5><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><p><strong>删除情景2.1：替换结点是其父结点的左子结点</strong><br> <strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br> 若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-1e4c3388491b588f.webp" alt="img"></p><p><center>图21 删除情景2.1.1</center><br><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong><br> 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br> 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图22所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-7eea721cbb855876.webp" alt="img"></p><p><center>图22 删除情景2.1.2.1</center><br>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br> 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。图如23所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对S进行右旋，得到情景2.1.2.1</strong></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-dc29605ce9889973.webp" alt="img"></p><p><center>图23 删除情景2.1.2.2</center><br><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br> 好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-75293515d8d87024.webp" alt="img"></p><p><center>图24 情景2.1.2.3</center><br><strong>删除情景2.2：替换结点是其父结点的右子结点</strong><br> 好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br> 处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-387664c771b21f1b.webp" alt="img"></p><p><center>图25 删除情景2.2.1</center><br><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br> <strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br> <strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-b1ea52c823ce0b0b.webp" alt="img"></p><p><center>图26 删除情景2.2.2.1</center><br><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-edcb4ea6ac87e342.webp" alt="img"></p><p><center>图27 删除情景2.2.2.2</center><br><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-6559c4cccf3df81c.webp" alt="img"></p><p><center>图28 删除情景2.2.2.3</center><br>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><p>哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～</p><p>最后再做个习题加深理解（请不熟悉的同学务必动手画下）：</p><p><strong>习题2：请画出图29的删除自平衡处理过程。 </strong></p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-d3231b6890ab76a3.webp" alt="img"></p><h2 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a><center>习题2</center></h2><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>耗时良久，终于写完了～自己加深了红黑树的理解的同时，也希望能帮助大家。如果你之前没学习过红黑树，看完这篇文章后可能还存在很多疑问，如果有疑问可以在评论区写出来，我会尽自己所能解答。另外给大家推荐一个支持红黑树在线生成的网站，来做各种情景梳理很有帮助：<a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener">在线生成红黑树</a>。（删除操作那个把替代结点看作删除结点思路就是我自己在用这个网站时自己顿悟的，我觉得这样讲解更容易理解。）</p><p>少了代码是不是觉得有点空虚？哈哈，后续我会写关于Java和HashMap和TreeMap的文章，里面都有红黑树相关的知识。相信看了这篇文章后，再去看Java和HashMap和TreeMap的源码绝对没难度！</p><p>最后来看下思考题和习题的答案吧。</p><hr><h4 id="思考题和习题答案"><a href="#思考题和习题答案" class="headerlink" title="思考题和习题答案"></a>思考题和习题答案</h4><p><strong><em>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？</em></strong><br> 答：可以。如下图的F结点：</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-3e64f9f3481b209d.webp" alt="img"></p><p><strong><em>习题1：请画出图15的插入自平衡处理过程。</em></strong><br> 答：</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-f4c0891c264a2243.webp" alt="img"></p><p><strong><em>习题2：请画出图29的删除自平衡处理过程。</em></strong><br> 答：</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-b037e4c29cbffc4d.webp" alt="img"></p><hr><p>转载自<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ &amp;gt;                                                                                - 学红黑树有感。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;终于，在学习了几天的红黑树相关的知识后，我想把我所学所想和所感分享给大家。红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等一连串的问题在学习前困扰着我。如果你在学习过程中也会存在我的疑问，那么本文对你会有帮助，本文帮助你全面、彻底地理解红黑树！&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://vincentruan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://vincentruan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="红黑树" scheme="https://vincentruan.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[译]StackOverflow: 你没见过的七个最好的Java答案</title>
    <link href="https://vincentruan.github.io/2020/02/24/%E8%AF%91-StackOverflow-%E4%BD%A0%E6%B2%A1%E8%A7%81%E8%BF%87%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84Java%E7%AD%94%E6%A1%88/"/>
    <id>https://vincentruan.github.io/2020/02/24/%E8%AF%91-StackOverflow-%E4%BD%A0%E6%B2%A1%E8%A7%81%E8%BF%87%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84Java%E7%AD%94%E6%A1%88/</id>
    <published>2020-02-24T07:25:22.000Z</published>
    <updated>2020-02-25T15:09:15.071Z</updated>
    
    <content type="html"><![CDATA[<p>StackOverflow(后边简称so)发展到目前，已经成为了全球开发者的金矿。它能够帮助我们找到在各个领域遇到的问题的最有用的解决方案，同时我们也会从中学习到很多新的东西。这篇文章是在我们审阅了so上最流行的Java问题以及答案后从中挑出来的。即使你是一个有丰富经验的开发者，也能从中学到不少东西。</p><a id="more"></a><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>SO上最多投票的一个Java问题是：<a href="http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array" target="_blank" rel="noopener">为什么处理一个排序数组要比非排序数组快的多</a>。为了回答这个问题，你需要使用分支预测(branch prediction)。分支预测是一种架构，旨在通过在真实的路径发生前猜测某一分支的下一步来提升处理过程。</p><p>分支在这里即一个if语句。这样的话，如果是一个排序数组，那么分支预测将会进行，否则不会进行。<a href="http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902" target="_blank" rel="noopener">Mysticial</a>(so上的一个回答者)试图使用铁路和火车来简单介绍这个概念。假设你在铁轨连接处要决定火车要走哪条路，你会选择左边还是右边？你可以拦住火车，然后问司机该往那里，但是这样会让整个过程变慢。因此你只能去猜正确的方向，那么如何去猜呢？最好的办法就是通过观察目前这个火车每次经过时的路线，推测出正确的方向。</p><p>这就是分支预测：识别模式并使用它。</p><p>不幸的是，这个问题的提问者是分支预测失败的受害者。因为他的分支没有任何可以识别出的模式，所以预测出的行为是随机的。</p><h2 id="Java中的安全"><a href="#Java中的安全" class="headerlink" title="Java中的安全"></a>Java中的安全</h2><p>另一个流行的Java问题是：<a href="http://stackoverflow.com/questions/8881291/why-is-char-preferred-over-string-for-passwords-in-java" target="_blank" rel="noopener">为什么在Java中有关密码的地方更加喜欢使用char[]而不是String</a>？其实原始的问题更加具体一些，就是问的在Swing中，password控件有一个getPassword方法(返回char[]而不是getText()返回的String)。</p><p>其实这里不用惊讶-这是一个安全问题。String是不可变的，意味着一旦它被创建了，那么你就不可能去修改它。这也意味着在GC之前，你对这些数据不能做任何处理。因此，只要有人能够访问你的内存，那么String就有可能被他获取到。</p><p>这也就是为什么要使用char数组。你可以显示地清除数据或者覆盖它。这样密码这种敏感数据即使GC还没有进行也不会再在系统留下痕迹。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>即使很多开发者倾向于忽略对受检异常的处理，SO上仍然有很多关于异常的问题。其中一个最流行的问题是：什么是NullPointerException，我该怎么处理它？对此，我们并没有感到惊讶，因为这个问题也是<a href="http://blog.takipi.com/the-top-10-exceptions-types-in-production-java-applications-based-on-1b-events/" target="_blank" rel="noopener">在生产环境的Java应用中排名第一的异常</a>。</p><p>实际上，当NullPointerException(或者其他exception)在系统出现的时候，我们可以发出一个告警。因为这种异常一般情况下都是业务代码逻辑有问题造成(笔者注)。</p><h2 id="为什么这段代码使用随机字符串打印出了”hello-world”"><a href="#为什么这段代码使用随机字符串打印出了”hello-world”" class="headerlink" title="为什么这段代码使用随机字符串打印出了”hello world”"></a>为什么这段代码使用随机字符串打印出了”hello world”</h2><p>问题链接：<a href="http://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world" target="_blank" rel="noopener">http://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world</a></p><p>这个问题给出了下面的代码，并打印出了”hello world”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(randomString(-<span class="number">229985452</span>) + <span class="string">" "</span> + randomString(-<span class="number">147909649</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomString</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    Random ran = <span class="keyword">new</span> Random(i);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = ran.nextInt(<span class="number">27</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        sb.append((<span class="keyword">char</span>)(<span class="string">'`'</span> + k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，选择一组随机的整数并不是随机的。给定一个seed参数(在这个例子中是-229985452和-147909649), 那么每次随机，同样的seed则会产生同样的输出。</p><p>Random(-229985452).nextInt(27)产生的前六个数字：8, 5, 12, 12, 15, 0</p><p>Random(-147909649).nextInt(27)产生的前六个数字：23, 15, 18, 12, 4, 0</p><p>这样，最终输出的就是”hello world”。</p><h2 id="为什么两个时间戳相减-in-1927-得出一个奇怪的结果？"><a href="#为什么两个时间戳相减-in-1927-得出一个奇怪的结果？" class="headerlink" title="为什么两个时间戳相减(in 1927)得出一个奇怪的结果？"></a>为什么两个时间戳相减(in 1927)得出一个奇怪的结果？</h2><p>问题链接：<a href="http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result" target="_blank" rel="noopener">http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">    String str3 = <span class="string">"1927-12-31 23:54:07"</span>;  </span><br><span class="line">    String str4 = <span class="string">"1927-12-31 23:54:08"</span>;  </span><br><span class="line">    Date sDt3 = sf.parse(str3);  </span><br><span class="line">    Date sDt4 = sf.parse(str4);  </span><br><span class="line">    <span class="keyword">long</span> ld3 = sDt3.getTime() /<span class="number">1000</span>;  </span><br><span class="line">    <span class="keyword">long</span> ld4 = sDt4.getTime() /<span class="number">1000</span>;</span><br><span class="line">    System.out.println(ld4-ld3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按说上面的代码最后的结果应该是1，但实际的输出却是353。其实，这是一个时区的问题。1927年12月31号24:00，上海时间往回调整了5分钟52秒，因此”1927-12-31 23:54:08”发生了两次，Java将后面一次实例化成了本地的这个时间。因此和前一秒的差距成了353。</p><p>我们需要指出，如果你试着来运行这段代码，结果并不一定是353。<a href="http://stackoverflow.com/a/6841479/5982245" target="_blank" rel="noopener">Jon Skeet指出了这一点</a>，在时区数据库项目2014版中，这个改变的时间点改到了1900-12-31，因此成了344秒的差距。</p><h2 id="无法被捕获的ChuckNorrisException"><a href="#无法被捕获的ChuckNorrisException" class="headerlink" title="无法被捕获的ChuckNorrisException"></a>无法被捕获的ChuckNorrisException</h2><p>问题链接：<a href="http://stackoverflow.com/questions/13883166/uncatchable-chucknorrisexception" target="_blank" rel="noopener">http://stackoverflow.com/questions/13883166/uncatchable-chucknorrisexception</a></p><p>这里有一个很明显的问题：如果有exception被抛出，但是没有任何办法去catch，那么应用会崩溃吗？或者如这个问题所问：是否可以写一段Java代码让一个假设的java.lang.ChuckNorrisException无法被捕获。</p><p>答案是可以，但是这里有一个”但是”。你可以编译一段代码抛出一个ChuckNorrisException，但是在Runtime时动态生成一个并不继承于Throwable接口的ChuckNorrisException类。当然，为了让这个过程可以进行，你需要关闭掉字节码验证。<a href="http://stackoverflow.com/a/13883510/5982245" target="_blank" rel="noopener">jtahlborn</a>给出了完整的解决办法。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是另外一个在SO上流行的问题系列。许多用户都想要知道所有集合类之间的区别，什么时候该使用哪种集合。</p><p>迭代顺序是主要考虑的因素。使用HashMap则忽略了所有的顺序信息，也就是获取元素的顺序和你插入元素的顺序是没有任何关系的；使用TreeMap则会得到一个排序好的迭代集合；使用LinkedHashMap则是一个FIFO的顺序。</p><p>如果你还是对这些感到困惑，这里有一个相关说明的图表可以<a href="http://zeroturnaround.com/wp-content/uploads/2016/04/Java-Collections-cheat-sheet.png" target="_blank" rel="noopener">参考</a>(Rebel Labs制作)。</p><p><img src="/2020/02/24/译-StackOverflow-你没见过的七个最好的Java答案/Java-Collections-cheat-sheet.png" alt="Java-Collections-cheat-sheet"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Java，其实关键的不在于你懂多少，而是在于你可以一直学到更多的东西。StackOverflow不仅在code上的一些问题可以帮助我们，也有助于我们回过头来去深入地学习一些我们已经知道的知识。</p><blockquote><p>转载文章<br>原文：<a href="https://dzone.com/articles/stackoverflow-7-of-the-best-java-answers-that-you" target="_blank" rel="noopener">https://dzone.com/articles/stackoverflow-7-of-the-best-java-answers-that-you</a><br>译文: <a href="https://www.rowkey.me/blog/2016/08/03/so-java-7-answers/" target="_blank" rel="noopener">https://www.rowkey.me/blog/2016/08/03/so-java-7-answers/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;StackOverflow(后边简称so)发展到目前，已经成为了全球开发者的金矿。它能够帮助我们找到在各个领域遇到的问题的最有用的解决方案，同时我们也会从中学习到很多新的东西。这篇文章是在我们审阅了so上最流行的Java问题以及答案后从中挑出来的。即使你是一个有丰富经验的开发者，也能从中学到不少东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/tags/Java/"/>
    
      <category term="StackOverflow" scheme="https://vincentruan.github.io/tags/StackOverflow/"/>
    
  </entry>
  
  <entry>
    <title>Java性能优化和JVM GC（垃圾回收机制）详解</title>
    <link href="https://vincentruan.github.io/2020/02/24/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CJVM-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
    <id>https://vincentruan.github.io/2020/02/24/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CJVM-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-24T06:42:01.000Z</published>
    <updated>2020-02-25T15:09:15.043Z</updated>
    
    <content type="html"><![CDATA[<p>Java的性能优化，JVM GC（垃圾回收机制）在学习Java GC 之前，我们需要记住一个单词：stop-the-world 。它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。</p><a id="more"></a><h1 id="JVM-GC回收哪个区域内的垃圾？"><a href="#JVM-GC回收哪个区域内的垃圾？" class="headerlink" title="JVM GC回收哪个区域内的垃圾？"></a><strong>JVM GC回收哪个区域内的垃圾？</strong></h1><p>需要注意的是，JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p><h1 id="JVM-GC怎么判断对象可以被回收了？"><a href="#JVM-GC怎么判断对象可以被回收了？" class="headerlink" title="JVM GC怎么判断对象可以被回收了？"></a><strong>JVM GC怎么判断对象可以被回收了？</strong></h1><ul><li><p>对象没有引用</p></li><li><p>作用域发生未捕获异常</p></li><li><p>程序在作用域正常执行完毕</p></li><li><p>程序执行了System.exit()</p></li><li><p>程序发生意外终止（被杀线程等）</p></li></ul><p>在Java程序中不能显式的分配和注销缓存，因为这些事情JVM都帮我们做了，那就是GC。</p><p>有些时候我们可以将相关的对象设置成null 来试图显示的清除缓存，但是并不是设置为null 就会一定被标记为可回收，有可能会发生逃逸。</p><p>将对象设置成null 至少没有什么坏处，但是使用System.gc() 便不可取了，使用System.gc() 时候并不是马上执行GC操作，而是会等待一段时间，甚至不执行，而且System.gc() 如果被执行，会触发Full GC ，这非常影响性能。</p><h1 id="JVM-GC什么时候执行？"><a href="#JVM-GC什么时候执行？" class="headerlink" title="JVM GC什么时候执行？"></a><strong>JVM GC什么时候执行？</strong></h1><p>eden区空间不够存放新对象的时候，执行Minro GC。升到老年代的对象大于老年代剩余空间的时候执行Full GC，或者小于的时候被HandlePromotionFailure 参数强制Full GC 。调优主要是减少 Full GC 的触发次数，可以通过 NewRatio 控制新生代转老年代的比例，通过MaxTenuringThreshold 设置对象进入老年代的年龄阀值（后面会介绍到）。</p><h1 id="按代的垃圾回收机制"><a href="#按代的垃圾回收机制" class="headerlink" title="按代的垃圾回收机制"></a><strong>按代的垃圾回收机制</strong></h1><p>新生代（Young generation）：绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：Minor GC 。</p><p>老年代（Old generation）：对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC 或者 Full GC。</p><p>持久代（Permanent generation）也称之为 方法区（Method area）：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Major GC 。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收：</p><ol><li>所有实例被回收</li><li>加载该类的ClassLoader 被回收</li><li>Class 对象无法通过任何途径访问（包括反射）</li></ol><p>可能我们会有疑问：</p><p>如果老年代的对象需要引用新生代的对象，会发生什么呢？</p><p>为了解决这个问题，老年代中存在一个 card table ，它是一个512byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询 card table 来决定是否可以被回收，而不用查询整个老年代。这个 card table 由一个write barrier 来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但完全是值得的。</p><blockquote><p>默认的新生代（Young generation）、老年代（Old generation）所占空间比例为 1 : 2 。</p></blockquote><h1 id="新生代空间的构成与逻辑"><a href="#新生代空间的构成与逻辑" class="headerlink" title="新生代空间的构成与逻辑"></a><strong>新生代空间的构成与逻辑</strong></h1><p>为了更好的理解GC，我们来学习新生代的构成，它用来保存那些第一次被创建的对象，它被分成三个空间：</p><ul><li><p>一个伊甸园空间（Eden）</p></li><li><p>两个幸存者空间（Fron Survivor、To Survivor）</p></li></ul><p>默认新生代空间的分配：<code>Eden : Fron : To = 8 : 1 : 1</code></p><p>每个空间的执行顺序如下：</p><ol><li>绝大多数刚刚被创建的对象会存放在伊甸园空间（Eden）。</li><li>在伊甸园空间执行第一次GC（Minor GC）之后，存活的对象被移动到其中一个幸存者空间（Survivor）。</li><li>此后，每次伊甸园空间执行GC后，存活的对象会被堆积在同一个幸存者空间。</li><li>当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。然后会清空已经饱和的哪个幸存者空间。</li><li>在以上步骤中重复N次（N = MaxTenuringThreshold（年龄阀值设定，默认15））依然存活的对象，就会被移动到老年代。</li></ol><p>从上面的步骤可以发现，两个幸存者空间，必须有一个是保持空的。如果两个两个幸存者空间都有数据，或两个空间都是空的，那一定是你的系统出现了某种错误。</p><p>我们需要重点记住的是，对象在刚刚被创建之后，是保存在伊甸园空间的（Eden）。那些长期存活的对象会经由幸存者空间（Survivor）转存到老年代空间（Old generation）。</p><p>也有例外出现，对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生。</p><h1 id="老年代空间的构成与逻辑"><a href="#老年代空间的构成与逻辑" class="headerlink" title="老年代空间的构成与逻辑"></a>老年代空间的构成与逻辑</h1><p>老年代空间的构成其实很简单，它不像新生代空间那样划分为几个区域，它只有一个区域，里面存储的对象并不像新生代空间绝大部分都是朝闻道，夕死矣。这里的对象几乎都是从Survivor 空间中熬过来的，它们绝不会轻易的狗带。因此，Full GC（Major GC）发生的次数不会有Minor GC 那么频繁，并且做一次Major GC 的时间比Minor GC 要更长（约10倍）。</p><h1 id="JVM-GC-算法讲解"><a href="#JVM-GC-算法讲解" class="headerlink" title="JVM GC 算法讲解"></a>JVM GC 算法讲解</h1><h2 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h2><p>根搜索算法是从离散数学中的图论引入的，程序把所有引用关系看作一张图，从一个节点GC ROOT 开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145513084.png" alt="image-20200224145513084"></p><p>上图红色为无用的节点，可以被回收。</p><p>目前Java中可以作为GC ROOT的对象有：</p><ol><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ol><p>基本所有GC算法都引用根搜索算法这种概念。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><p>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象进行直接回收，如上图。</p><p>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活的对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，并没有对还存活的对象进行整理，因此会导致内存碎片。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145555734.png" alt="image-20200224145555734">复制算法将内存划分为两个区间，使用此算法时，所有动态分配的对象都只能分配在其中一个区间（活动区间），而另外一个区间（空间区间）则是空闲的。</p><p>复制算法采用从根集合扫描，将存活的对象复制到空闲区间，当扫描完毕活动区间后，会的将活动区间一次性全部回收。此时原本的空闲区间变成了活动区间。下次GC时候又会重复刚才的操作，以此循环。</p><p>复制算法在存活对象比较少的时候，极为高效，但是带来的成本是牺牲一半的内存空间用于进行对象的移动。所以复制算法的使用场景，必须是对象的存活率非常低才行，而且最重要的是，我们需要克服50%内存的浪费。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h2><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145614350.png" alt="image-20200224145614350">标记-整理算法采用 <code>标记-清除</code> 算法一样的方式进行对象的标记、清除，但在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。标记-整理 算法是在标记-清除 算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><p>JVM为了优化内存的回收，使用了分代回收的方式，对于新生代内存的回收（Minor GC）主要采用复制算法。而对于老年代的回收（Major GC），大多采用标记-整理算法。</p><h1 id="垃圾回收器简介"><a href="#垃圾回收器简介" class="headerlink" title="垃圾回收器简介"></a>垃圾回收器简介</h1><p>需要注意的是，每一个回收器都存在Stop The World 的问题，只不过各个回收器在Stop The World 时间优化程度、算法的不同，可根据自身需求选择适合的回收器。</p><h2 id="Serial（-XX-UseSerialGC）"><a href="#Serial（-XX-UseSerialGC）" class="headerlink" title="Serial（-XX:+UseSerialGC）"></a>Serial（-XX:+UseSerialGC）</h2><p>从名字我们可以看出，这是一个串行收集器。</p><p>Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需暂停所有的用户线程，直到回收结束。</p><p>使用算法：复制算法</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145650521.png" alt="image-20200224145650521">JVM中文名称为Java虚拟机，因此它像一台虚拟的电脑在工作，而其中的每一个线程都被认为是JVM的一个处理器，因此图中的CPU0、CPU1实际上为用户的线程，而不是真正的机器CPU，不要误解哦。</p><p>Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。</p><h2 id="SerialOld（-XX-UseSerialGC）"><a href="#SerialOld（-XX-UseSerialGC）" class="headerlink" title="SerialOld（-XX:+UseSerialGC）"></a>SerialOld（-XX:+UseSerialGC）</h2><p>SerialOld是Serial收集器的老年代收集器版本，它同样是一个单线程收集器，这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。</p><p>使用算法：标记 - 整理算法</p><p>运行示意图与上图一致。</p><h2 id="ParNew（-XX-UseParNewGC）"><a href="#ParNew（-XX-UseParNewGC）" class="headerlink" title="ParNew（-XX:+UseParNewGC）"></a>ParNew（-XX:+UseParNewGC）</h2><p>ParNew其实就是Serial收集器的多线程版本。除了Serial收集器外，只有它能与CMS收集器配合工作。</p><p>使用算法：复制算法</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145719526.png" alt="image-20200224145719526"></p><p>ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。</p><h2 id="ParallelScavenge（-XX-UseParallelGC）"><a href="#ParallelScavenge（-XX-UseParallelGC）" class="headerlink" title="ParallelScavenge（-XX:+UseParallelGC）"></a><strong>ParallelScavenge（-XX:+UseParallelGC）</strong></h2><p>ParallelScavenge又被称为吞吐量优先收集器，和ParNew 收集器类似，是一个新生代收集器。</p><p>使用算法：复制算法</p><p>ParallelScavenge收集器的目标是达到一个可控件的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。如果虚拟机总共运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99% 。</p><h2 id="ParallelOld（-XX-UseParallelOldGC）"><a href="#ParallelOld（-XX-UseParallelOldGC）" class="headerlink" title="ParallelOld（-XX:+UseParallelOldGC）"></a><strong>ParallelOld（-XX:+UseParallelOldGC）</strong></h2><p>ParallelOld是并行收集器，和SerialOld一样，ParallelOld是一个老年代收集器，是老年代吞吐量优先的一个收集器。这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，“吞吐量优先”收集器才名副其实！</p><p>使用算法：标记 - 整理算法</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145812172.png" alt="image-20200224145812172"></p><p>在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。</p><h2 id="CMS-（-XX-UseConcMarkSweepGC）"><a href="#CMS-（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS （-XX:+UseConcMarkSweepGC）"></a><strong>CMS （-XX:+UseConcMarkSweepGC）</strong></h2><p>CMS是一个老年代收集器，全称 Concurrent Low Pause Collector，是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于响应时间的重要性需求大于吞吐量要求的收集器。对于要求服务器响应速度高的情况下，使用CMS非常合适。</p><p>CMS的一大特点，就是用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停。</p><p>使用算法：<code>标记 - 清理</code></p><p>CMS的执行过程如下：</p><p><strong>· 初始标记（STW initial mark）</strong></p><p>在这个阶段，需要虚拟机停顿正在执行的应用线程，官方的叫法STW（Stop Tow World）。这个过程从根对象扫描直接关联的对象，并作标记。这个过程会很快的完成。</p><p><strong>· 并发标记（Concurrent marking）</strong></p><p>这个阶段紧随初始标记阶段，在“初始标记”的基础上继续向下追溯标记。注意这里是并发标记，表示用户线程可以和GC线程一起并发执行，这个阶段不会暂停用户的线程哦。</p><p>· 并发预清理（Concurrent precleaning）</p><p>这个阶段任然是并发的，JVM查找正在执行“并发标记”阶段时候进入老年代的对象（可能这时会有对象从新生代晋升到老年代，或被分配到老年代）。通过重新扫描，减少在一个阶段“重新标记”的工作，因为下一阶段会STW。</p><p><strong>· 重新标记（STW remark）</strong></p><p>这个阶段会再次暂停正在执行的应用线程，重新重根对象开始查找并标记并发阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致），并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记。</p><p><strong>· 并发清理（Concurrent sweeping）</strong></p><p>这个阶段是并发的，应用线程和GC清除线程可以一起并发执行。</p><p><strong>· 并发重置（Concurrent reset）</strong></p><p>这个阶段任然是并发的，重置CMS收集器的数据结构，等待下一次垃圾回收。</p><p><strong>CMS的缺点：</strong></p><p>1、内存碎片。由于使用了 标记-清理 算法，导致内存空间中会产生内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。但是内存碎片的问题依然存在，如果一个对象需要3块连续的空间来存储，因为内存碎片的原因，寻找不到这样的空间，就会导致Full GC。</p><p>2、需要更多的CPU资源。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，这样就需要占用更多的CPU资源，也是牺牲了一定吞吐量的原因。</p><p>3、需要更大的堆空间。因为CMS标记阶段应用程序的线程还是执行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，必须预留一部分空间。CMS默认在老年代空间使用68%时候启动垃圾回收。可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。</p><h2 id="GarbageFirst（G1）"><a href="#GarbageFirst（G1）" class="headerlink" title="GarbageFirst（G1）"></a><strong>GarbageFirst（G1）</strong></h2><p>这是一个新的垃圾回收器，既可以回收新生代也可以回收老年代，SunHotSpot1.6u14以上EarlyAccess版本加入了这个回收器，Sun公司预期SunHotSpot1.7发布正式版本。通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。杯具的是Oracle收购这个收集器之后将其用于商用收费版收集器。因此目前暂时没有发现哪个公司使用它，这个放在之后再去研究吧。</p><p>整理一下新生代和老年代的收集器。</p><p><strong>新生代收集器：</strong></p><ul><li><p>Serial （-XX:+UseSerialGC）</p></li><li><p>ParNew（-XX:+UseParNewGC）</p></li><li><p>ParallelScavenge（-XX:+UseParallelGC）</p></li><li><p>G1 收集器</p></li></ul><p><strong>老年代收集器：</strong></p><ul><li><p>SerialOld（-XX:+UseSerialOldGC）</p></li><li><p>ParallelOld（-XX:+UseParallelOldGC）</p></li><li><p>CMS（-XX:+UseConcMarkSweepGC）</p></li><li><p>G1 收集器</p></li></ul><h2 id="调优jvm参数介绍"><a href="#调优jvm参数介绍" class="headerlink" title="调优jvm参数介绍"></a><strong>调优jvm参数介绍</strong></h2><p>堆设置</p><ul><li><p>-Xmx3550m：设置JVM最大堆内存 为3550M。</p></li><li><p>-Xms3550m：设置JVM初始堆内存 为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p></li><li><p>-Xss128k：设置每个线程的栈 大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能 生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></li><li><p>-Xmn2g：设置堆内存年轻代 大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p></li><li><p>-XX:PermSize=256M：设置堆内存持久代 初始值为256M。(貌似是Eclipse等IDE的初始化参数)</p></li><li><p>-XX:MaxNewSize=size：新生成的对象能占用内存的最大值。</p></li><li><p>-XX:MaxPermSize=512M：设置持久代最大值为512M。</p></li><li><p>-XX:NewRatio=4：设置堆内存年轻代（包括Eden和两个Survivor区）与堆内存年老代的比值（除去持久代） 。设置为4，则年轻代所占与年老代所占的比值为1:4。</p></li><li><p>-XX:SurvivorRatio=4：设置堆内存年轻代中Eden区与Survivor区大小的比值 。设置为4，则两个Survivor区（JVM堆内存年轻代中默认有2个Survivor区）与一个Eden区的比值为2:4，一个Survivor区占 整个年轻代的1/6。</p></li><li><p>-XX:MaxTenuringThreshold=7：表示一个对象如果在救助空间（Survivor区）移动7次还没有被回收就放入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于年老代比较多的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代即被回收的概率。</p></li></ul><p>回收器选择JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。</p><p>默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p><h2 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a><strong>串行收集器</strong></h2><ul><li>-XX:+UseSerialGC：设置串行收集器</li></ul><h2 id="并行收集器-吞吐量优先"><a href="#并行收集器-吞吐量优先" class="headerlink" title="并行收集器(吞吐量优先)"></a>并行收集器(吞吐量优先)</h2><ul><li><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</p></li><li><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p></li><li><p>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p></li><li><p>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒），如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p></li><li><p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等。</p></li></ul><p>此参数建议使用并行收集器时，一直打开。</p><h2 id="并发收集器-响应时间优先"><a href="#并发收集器-响应时间优先" class="headerlink" title="并发收集器(响应时间优先)"></a>并发收集器(响应时间优先)</h2><ul><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li></ul><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>全称Concurrent Low Pause Collector，是jdk1.4后期版本开始引入的新gc算法，在jdk5和jdk6中得到了进一步改进，它的主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用。CMS是用于对tenured generation的回收，也就是年老代的回收，目标是尽量减少应用的暂停时间，减少FullGC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代。</p><ul><li><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction=：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此参数设置运行次FullGC以后对内存空间进行压缩、整理。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除内存碎片。</p></li><li><p>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</p></li><li><p>-XX:CMSInitiatingOccupancyFraction=70：表示年老代空间到70%时就开始执行CMS，确保年老代有足够的空间接纳来自年轻代的对象。</p></li></ul><p>注：如果使用 throughput collector 和 concurrent low pause collector 这两种垃圾收集器，需要适当的挺高内存大小，为多线程做准备。</p><p>其它</p><ul><li><p>-XX:+ScavengeBeforeFullGC：新生代GC优先于Full GC执行。</p></li><li><p>-XX:-DisableExplicitGC：禁止调用System.gc()，但JVM的gc仍然有效。</p></li><li><p>-XX:+MaxFDLimit：最大化文件描述符的数量限制。</p></li><li><p>-XX:+UseThreadPriorities：启用本地线程优先级API，即使 java.lang.Thread.setPriority() 生效，反之无效。</p></li><li><p>-XX:SoftRefLRUPolicyMSPerMB=0：“软引用”的对象在最后一次被访问后能存活0毫秒（默认为1秒）。</p></li><li><p>-XX:TargetSurvivorRatio=90：允许90%的Survivor空间被占用（默认为50%）。提高对于Survivor的使用率——超过就会尝试垃圾回收。</p></li></ul><p><strong>辅助信息</strong></p><ul><li><p>-XX:-CITime：打印消耗在JIT编译的时间</p></li><li><p>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或者数据到指定文件中</p></li><li><p>-XX:-ExtendedDTraceProbes：开启solaris特有的dtrace探针</p></li><li><p>-XX:HeapDumpPath=./java_pid.hprof：指定导出堆信息时的路径或文件名</p></li><li><p>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时导出此时堆中相关信息</p></li><li><p>-XX:OnError=”;”：出现致命ERROR之后运行自定义命令</p></li><li><p>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令</p></li><li><p>-XX:-PrintClassHistogram：遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同</p></li><li><p>-XX:-PrintConcurrentLocks：遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同</p></li><li><p>-XX:-PrintCommandLineFlags：打印在命令行中出现过的标记</p></li><li><p>-XX:-PrintCompilation：当一个方法被编译时打印相关信息</p></li><li><p>-XX:-PrintGC：每次GC时打印相关信息</p></li><li><p>-XX:-PrintGC Details：每次GC时打印详细信息</p></li><li><p>-XX:-PrintGCTimeStamps：打印每次GC的时间戳</p></li><li><p>-XX:-TraceClassLoading：跟踪类的加载信息</p></li><li><p>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息</p></li><li><p>-XX:-TraceClassResolution：跟踪常量池</p></li><li><p>-XX:-TraceClassUnloading：跟踪类的卸载信息</p></li><li><p>-XX:-TraceLoaderConstraints：跟踪类加载器约束的相关信息</p></li></ul><h1 id="JVM服务调优实战"><a href="#JVM服务调优实战" class="headerlink" title="JVM服务调优实战"></a><strong>JVM服务调优实战</strong></h1><p>服务器：8 cup, 8G mem</p><p>e.g.</p><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><h2 id="调优方案："><a href="#调优方案：" class="headerlink" title="调优方案："></a><strong>调优方案：</strong></h2><p>-Xmx5g：设置JVM最大可用内存为5G。</p><p>-Xms5g：设置JVM初始内存为5G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>-Xmn2g：设置年轻代大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-XX:+UseParNewGC：设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p><p>-XX:ParallelGCThreads=8：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p><p>-XX:SurvivorRatio=6：设置年轻代中Eden区与Survivor区的大小比值。根据经验设置为6，则两个Survivor区与一个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。</p><p>-XX:MaxTenuringThreshold=30：设置垃圾最大年龄（次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值 设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。设置为30表示 一个对象如果在Survivor空间移动30次还没有被回收就放入年老代。</p><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试配置这个参数以后，参数-XX:NewRatio=4就失效了，所以，此时年轻代大小最好用-Xmn设置，因此这个参数不建议使用。</p><h1 id="参考资料-JVM堆内存的分代"><a href="#参考资料-JVM堆内存的分代" class="headerlink" title="参考资料 - JVM堆内存的分代"></a><strong>参考资料 - JVM堆内存的分代</strong></h1><p>虚拟机的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集器要收集的Java对象关系不大。所以，年轻代和年老代的划分才是对垃圾 收集影响比较大的。</p><h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a><strong>年轻代</strong></h2><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。</p><p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满 时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存 活的对象，将被复制“年老区(Tenured)”。</p><p>需要注意，两个Survivor区是对称的，没先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个 Survivor区复制过来的对象；而复制到年老区的只有从前一个Survivor区（相对的）过来的对象。而且，Survivor区总有一个是空的。特 殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><h2 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a><strong>年老代</strong></h2><p>在年轻代中经历了N（可配置）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><h2 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a><strong>持久代</strong></h2><p>用于存放静态数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些Class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。持久代大小通过 -XX:MaxPermSize= 进行设置。1.8已经移除改为metaspace。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的性能优化，JVM GC（垃圾回收机制）在学习Java GC 之前，我们需要记住一个单词：stop-the-world 。它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://vincentruan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper入门摘要</title>
    <link href="https://vincentruan.github.io/2020/02/14/zookeeper%E5%85%A5%E9%97%A8%E6%91%98%E8%A6%81/"/>
    <id>https://vincentruan.github.io/2020/02/14/zookeeper%E5%85%A5%E9%97%A8%E6%91%98%E8%A6%81/</id>
    <published>2020-02-14T10:01:16.000Z</published>
    <updated>2020-02-25T15:09:15.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ZooKeeper是什么？"><a href="#1-ZooKeeper是什么？" class="headerlink" title="1.ZooKeeper是什么？"></a>1.ZooKeeper是什么？</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p><p>有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。</p><a id="more"></a><h2 id="2-ZooKeeper提供了什么？"><a href="#2-ZooKeeper提供了什么？" class="headerlink" title="2.ZooKeeper提供了什么？"></a>2.ZooKeeper提供了什么？</h2><p>1、文件系统</p><p>2、通知机制</p><h2 id="3-Zookeeper文件系统"><a href="#3-Zookeeper文件系统" class="headerlink" title="3.Zookeeper文件系统"></a>3.Zookeeper文件系统</h2><p>Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。</p><h2 id="4-四种类型的znode"><a href="#4-四种类型的znode" class="headerlink" title="4.四种类型的znode"></a>4.四种类型的znode</h2><h3 id="1、PERSISTENT-持久化目录节点"><a href="#1、PERSISTENT-持久化目录节点" class="headerlink" title="1、PERSISTENT-持久化目录节点"></a>1、PERSISTENT-持久化目录节点</h3><p>客户端与zookeeper断开连接后，该节点依旧存在</p><h3 id="2、PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#2、PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h3><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><h3 id="3、EPHEMERAL-临时目录节点"><a href="#3、EPHEMERAL-临时目录节点" class="headerlink" title="3、EPHEMERAL-临时目录节点"></a>3、EPHEMERAL-临时目录节点</h3><p>客户端与zookeeper断开连接后，该节点被删除</p><h3 id="4、EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#4、EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h3><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><p><img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zk_dir_tree.png" alt></p><h2 id="5-Zookeeper通知机制"><a href="#5-Zookeeper通知机制" class="headerlink" title="5.Zookeeper通知机制"></a>5.Zookeeper通知机制</h2><p>client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。</p><h2 id="6-Zookeeper做了什么？"><a href="#6-Zookeeper做了什么？" class="headerlink" title="6.Zookeeper做了什么？"></a>6.Zookeeper做了什么？</h2><p>1、命名服务</p><p>2、配置管理</p><p>3、集群管理</p><p>4、分布式锁</p><p>5、队列管理</p><h2 id="7-zk的命名服务（文件系统）"><a href="#7-zk的命名服务（文件系统）" class="headerlink" title="7.zk的命名服务（文件系统）"></a>7.zk的命名服务（文件系统）</h2><p>命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><h2 id="8-zk的配置管理（文件系统、通知机制）"><a href="#8-zk的配置管理（文件系统、通知机制）" class="headerlink" title="8.zk的配置管理（文件系统、通知机制）"></a>8.zk的配置管理（文件系统、通知机制）</h2><p>程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p><h2 id="9-Zookeeper集群管理（文件系统、通知机制）"><a href="#9-Zookeeper集群管理（文件系统、通知机制）" class="headerlink" title="9.Zookeeper集群管理（文件系统、通知机制）"></a>9.Zookeeper集群管理（文件系统、通知机制）</h2><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。</p><p>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。</p><p>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p><h2 id="10-Zookeeper分布式锁（文件系统、通知机制）"><a href="#10-Zookeeper分布式锁（文件系统、通知机制）" class="headerlink" title="10.Zookeeper分布式锁（文件系统、通知机制）"></a>10.Zookeeper分布式锁（文件系统、通知机制）</h2><p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p><p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。</p><p>对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p><h2 id="11-获取分布式锁的流程"><a href="#11-获取分布式锁的流程" class="headerlink" title="11.获取分布式锁的流程"></a>11.获取分布式锁的流程</h2><p> <img src="/2020/02/14/zookeeper入门摘要/zookeeper_locker_directory.png" alt="获取分布式锁的流程"></p><p>在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。</p><p> <img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zookeeper_get_lock_flow.png" alt="获取分布式锁的流程"></p><p>代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper实现分布式锁的细节。</p><h2 id="12-Zookeeper队列管理（文件系统、通知机制）"><a href="#12-Zookeeper队列管理（文件系统、通知机制）" class="headerlink" title="12.Zookeeper队列管理（文件系统、通知机制）"></a>12.Zookeeper队列管理（文件系统、通知机制）</h2><p>两种类型的队列：</p><p>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p><p>2、队列按照 FIFO 方式进行入队和出队操作。</p><p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p><p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p><h2 id="13-Zookeeper数据复制"><a href="#13-Zookeeper数据复制" class="headerlink" title="13.Zookeeper数据复制"></a>13.Zookeeper数据复制</h2><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p><p>1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</p><p>2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</p><p>3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。</p><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p><p>1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</p><p>2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p><p>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p><h2 id="14-Zookeeper工作原理"><a href="#14-Zookeeper工作原理" class="headerlink" title="14.Zookeeper工作原理"></a>14.Zookeeper工作原理</h2><p>Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</p><h2 id="15-zookeeper是如何保证事务的顺序一致性的？"><a href="#15-zookeeper是如何保证事务的顺序一致性的？" class="headerlink" title="15.zookeeper是如何保证事务的顺序一致性的？"></a>15.zookeeper是如何保证事务的顺序一致性的？</h2><p>zookeeper采用了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h2 id="16-Zookeeper-下-Server工作状态"><a href="#16-Zookeeper-下-Server工作状态" class="headerlink" title="16.Zookeeper 下 Server工作状态"></a>16.Zookeeper 下 Server工作状态</h2><p>每个Server在工作过程中有三种状态：</p><p>LOOKING：当前Server不知道leader是谁，正在搜寻</p><p>LEADING：当前Server即为选举出来的leader</p><p>FOLLOWING：leader已经选举出来，当前Server与之同步</p><h2 id="17-zookeeper是如何选取主leader的？"><a href="#17-zookeeper是如何选取主leader的？" class="headerlink" title="17.zookeeper是如何选取主leader的？"></a>17.zookeeper是如何选取主leader的？</h2><p>当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。</p><p>1、Zookeeper选主流程(basic paxos)</p><p>（1）选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</p><p>（2）选举线程首先向所有Server发起一次询问(包括自己)；</p><p>（3）选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</p><p>（4）收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</p><p>（5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p><p><img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zk_epoch.png" alt></p><p>2、Zookeeper选主流程(basic paxos) fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。</p><p><img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zookeeper_elect_master.png" alt="img"></p><h2 id="18-Zookeeper同步流程"><a href="#18-Zookeeper同步流程" class="headerlink" title="18.Zookeeper同步流程"></a>18.Zookeeper同步流程</h2><p>选完Leader以后，zk就进入状态同步过程。</p><p>1、Leader等待server连接；</p><p>2、Follower连接leader，将最大的zxid发送给leader；</p><p>3、Leader根据follower的zxid确定同步点；</p><p>4、完成同步后通知follower 已经成为uptodate状态；</p><p>5、Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</p><pre class="mermaid">sequenceDiagram    participant L as Leader    participant F as Follower    F->>L: 1.Fllower连接Leader，发送最大zxid    L->>F: 2.Leader确定同步点，发送同步消息    F->>L: 3.完成同步，通知Leader，并修改自身状态</pre><h2 id="19-分布式通知和协调"><a href="#19-分布式通知和协调" class="headerlink" title="19.分布式通知和协调"></a>19.分布式通知和协调</h2><p>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。</p><p>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</p><h2 id="20-机器中为什么会有leader？"><a href="#20-机器中为什么会有leader？" class="headerlink" title="20.机器中为什么会有leader？"></a>20.机器中为什么会有leader？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader选举。</p><h2 id="21-zk节点宕机如何处理？"><a href="#21-zk节点宕机如何处理？" class="headerlink" title="21.zk节点宕机如何处理？"></a>21.zk节点宕机如何处理？</h2><p>Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><p>如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；</p><p>如果是一个Leader宕机，Zookeeper会选举出新的Leader。</p><p>ZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p><p>所以</p><p>3个节点的cluster可以挂掉1个节点(leader可以得到2票&gt;1.5)</p><p>2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票&lt;=1)</p><h2 id="22-zookeeper负载均衡和nginx负载均衡区别"><a href="#22-zookeeper负载均衡和nginx负载均衡区别" class="headerlink" title="22.zookeeper负载均衡和nginx负载均衡区别"></a>22.zookeeper负载均衡和nginx负载均衡区别</h2><p>zk的负载均衡是可以调控，nginx只是能调权重，其他需要可控的都需要自己写插件；但是nginx的吞吐量比zk大很多，应该说按业务选择用哪种方式。</p><h2 id="23-zookeeper-watch机制"><a href="#23-zookeeper-watch机制" class="headerlink" title="23.zookeeper watch机制"></a>23.zookeeper watch机制</h2><p>Watch机制官方声明：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</p><p>Zookeeper机制的特点：</p><p>1、一次性触发数据发生改变时，一个watcher event会被发送到client，但是client只会收到一次这样的信息。</p><p>2、watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。</p><p>3、数据监视Zookeeper有数据监视和子数据监视getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</p><p>4、注册watcher getData、exists、getChildren</p><p>5、触发watcher create、delete、setData</p><p>6、setData()会触发znode上设置的data watch（如果set成功的话）。一个成功的create() 操作会触发被创建的znode上的数据watch，以及其父节点上的child watch。而一个成功的delete()操作将会同时触发一个znode的data watch和child watch（因为这样就没有子节点了），同时也会触发其父节点的child watch。</p><p>7、当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</p><p>8、Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watcher的布尔类型</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-ZooKeeper是什么？&quot;&gt;&lt;a href=&quot;#1-ZooKeeper是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.ZooKeeper是什么？&quot;&gt;&lt;/a&gt;1.ZooKeeper是什么？&lt;/h2&gt;&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。&lt;/p&gt;
&lt;p&gt;客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。&lt;/p&gt;
&lt;p&gt;有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="zookeeper" scheme="https://vincentruan.github.io/tags/zookeeper/"/>
    
      <category term="分布式" scheme="https://vincentruan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的九种设计模式</title>
    <link href="https://vincentruan.github.io/2020/02/12/MyBatis%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://vincentruan.github.io/2020/02/12/MyBatis%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-12T08:54:07.000Z</published>
    <updated>2020-02-25T15:09:15.047Z</updated>
    
    <content type="html"><![CDATA[<p>虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</p><a id="more"></a><p>Mybatis至少遇到了以下的设计模式的使用：</p><ol><li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li><li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li><li>单例模式，例如ErrorContext和LogFactory；</li><li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li><li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li><li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li>迭代器模式，例如迭代器模式PropertyTokenizer；</li></ol><h3 id="1、Builder模式"><a href="#1、Builder模式" class="headerlink" title="1、Builder模式"></a>1、Builder模式</h3><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5cThHeThva0Rvc3dNQ3FnQkw3Q21tN2ljSkFlSmR6ZGgyWm1EV3k5RkNSMndjMHZxaWIxOGVKNFEvNjQw.jpg" alt="img"></p><p>在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p><p>其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取<code>*Mapper</code>文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。</p><p>在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。</p><p>对于builder的具体类，方法都大都用<code>build*</code>开头，比如SqlSessionFactoryBuilder为例，它包含以下方法：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5NmducW1ZZXUwTWFObWV3a1h6NkhqQVFjY2ZOUmliOFVBSWRJTmdmdWx2OWljM1BPa0cwQkNVb2cvNjQw.jpg" alt="img"></p><p>即根据不同的输入参数来构建SqlSessionFactory这个工厂对象。</p><h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5a1RtU2ljdmU3a05OVlpISVV1N1BMU0puNlNRVzdpYmliWHY1dDRRZlJTV2liVDBlSVFVZXZyY0tYUS82NDA.jpg" alt="img"></p><p>SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5ZUNpYmttQzdTc3VlUDc1cmliWmNvY1ZyaWFkckVXU3RnaWJOd1lnYWZsOUlUem96OUZpYURlSHhKSEEvNjQw.jpg" alt="img"></p><p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p><p>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。</p><p>在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。</p><p>而对于LogFactory，它的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error creating logger for logger "</span> + logger + <span class="string">".  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个特别的地方，是Log变量的的类型是Constructor，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。</p><h3 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h3><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5NzBGSkxLMVB0WmZqQlFpY2lhdUpQTE1IaWFXOE5pYk94UXF1ZUtWczZvUXNQY3g3SGljTW5PTXppYXZRLzY0MA.jpg" alt="img"></p><p>在Mybatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p>ErrorContext的单例实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;ErrorContext&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ErrorContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ErrorContext context = LOCAL.get();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">      context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">      LOCAL.set(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了ThreadLocal修饰，也就是说它属于每个线程各自的数据，而在instance()方法中，先获取本线程的该实例，如果没有就创建该线程独有的ErrorContext。</p><h3 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h3><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5Zm9NeDFjbG50bGJzMnpGekpaRmhFZTd6RmcyZjc2ekFRc2VFWVJDaWNsdE9ENVN3aWJYUkxDTVEvNjQw.jpg" alt="img"><br><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5U01VcTNyaDJxaHhUdUdINmhHNG0xa0Fsemt1eWZLNkZ4MEN0Z0hWWmM2VUloakhGNVNNaWJiZy82NDA.jpg" alt="img"></p><p>这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；</p><p>当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxy mapperProxy)生成代理对象然后返回。</p><p>而查看MapperProxy的代码，可以看到如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常典型的，该MapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法。</p><p>通过这种方式，我们只需要编写Mapper.java接口类，当真正执行一个Mapper接口的时候，就会转发给MapperProxy.invoke方法，而该方法则会调用后续的sqlSession.cud&gt;executor.execute&gt;prepareStatement等一系列方法，完成SQL的执行和返回。</p><h3 id="5、组合模式"><a href="#5、组合模式" class="headerlink" title="5、组合模式"></a>5、组合模式</h3><p><strong>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</strong></p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5WGlhUXZMMXRnTUE2ejJwNDQ4VjJaTkNYVkZvVlVqckNOakxCalNidnJPdzJDaHY2N1Y3dmVyQS82NDA.jpg" alt="img"></p><p>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"org.format.dynamicproxy.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">    UPDATE users</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">prefixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在DynamicSqlSource.getBoundSql方法里，调用了rootSqlNode.apply(context)方法，apply方法是所有的动态节点都实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span></span>&#123;</span><br><span class="line">    booleanapply(DynamicContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现该SqlSource接口的所有节点，就是整个组合模式树的各个节点：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5MUJKQ01DN295MlFVOU1ubXVFUlZTeTIwbkp0SmdpYzhtV1N1WXZPclhLWTlYMnVaMDZkT080US82NDA.jpg" alt="img"></p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">    context.appendSql(parser.parse(text));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即contents.apply方法，实现递归的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、模板方法模式"><a href="#6、模板方法模式" class="headerlink" title="6、模板方法模式"></a>6、模板方法模式</h3><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5aWNuMjZoZEYzMnhxMkV6bkJ4Ylc4WXdKUmFobGJzS0VpYzhCSVF5WWJPbmlhdUY1Q0Fsb1RuUFBBLzY0MA.jpg" alt="img"></p><p>在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5TWVnQk8zaWJmQnQwb1VPVnV6cWxGQ0JXNDU2cEJxaWMycGhWbFZLVWNVZE1Lb0N1WGxRM2trWGcvNjQw.jpg" alt="img"></p><p>其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>该模板方法类有几个子类的具体实现，使用了不同的策略：</p><ul><li>简单SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）</li><li>重用ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。（可以是Statement或PrepareStatement对象）</li><li>批量BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</li></ul><p>比如在SimpleExecutor中这样实现update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、适配器模式"><a href="#7、适配器模式" class="headerlink" title="7、适配器模式"></a>7、适配器模式</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5SHBKYld0QlMxV3JLVEswVkRTWVlEYnlNdVFOdm8xZjU3Z1hCS282YnJTd3JDVXIwRTVodndBLzY0MA.jpg" alt="img"></p><p>在Mybatsi的logging包中，有一个Log接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5MGljdWVqRTZ2STlteExJWXNYbXdlY3hXN2ljdEFQVzB0R0hIcXl2V29oeUFacG81NFBNTlJsVEEvNjQw.jpg" alt="img"></p><p>比如对于Log4jImpl的实现来说，该实现持有了org.apache.log4j.Logger的实例，然后所有的日志方法，均委托该实例来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jImpl<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Log4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    log = Logger.getLogger(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.ERROR, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.DEBUG, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.TRACE, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.WARN, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、装饰者模式"><a href="#8、装饰者模式" class="headerlink" title="8、装饰者模式"></a>8、装饰者模式</h3><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5blNSVHlwQWdhZnZPWDhUb0t4blhzRlFaNDBXTWoxNXRjMERvZm1IcEhvQUxpYVRpYXlWVVJGWHcvNjQw.jpg" alt="img"></p><p>在mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，然后通过一系列的装饰器来对PerpetualCache永久缓存进行缓存策略等方便的控制。如下图：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5MEswRTVCVzRsY3ZXOVIzYzRwVXpRNWliRGYxaWFMdXZ2U3g1SDlWWnFhaWFaMzlEeXBGVGtuVDRRLzY0MA.jpg" alt="img"></p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：</p><ol><li>FifoCache：先进先出算法，缓存回收策略</li><li>LoggingCache：输出缓存命中的日志信息</li><li>LruCache：最近最少使用算法，缓存回收策略</li><li>ScheduledCache：调度缓存，负责定时清空缓存</li><li>SerializedCache：缓存序列化和反序列化存储</li><li>SoftCache：基于软引用实现的缓存管理策略</li><li>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</li><li>WeakCache：基于弱引用实现的缓存管理策略</li></ol><p>另外，还有一个特殊的装饰器TransactionalCache：事务性的缓存</p><p>正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存</p><ul><li>一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在SqlSession（DefaultSqlSession）中，所以一级缓存的生命周期与SqlSession是相同的。</li><li>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在Configuration核心配置对象中。</li></ul><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。</p><p>Cache对象之间的引用顺序为：</p><blockquote><p>SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p></blockquote><h3 id="9、迭代器模式"><a href="#9、迭代器模式" class="headerlink" title="9、迭代器模式"></a>9、迭代器模式</h3><p>迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5ZWljckRhM05lbUQ3SkoydmxydkF1MnJmZGFjaFJlNjFPZ0hnd2EzSFRVV1RnM3RqR0RBMWxSZy82NDA.jpg" alt="img"></p><p>Java的Iterator就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5UWJNR1pGWmRpYm9DSmpCWWpZZEVmR2lhM2dKS21RaWJ6RUlES0s3MEFxbTR3dGRRQlZsNUxsWXZBLzY0MA.jpg" alt="img"></p><p>比如Mybatis的PropertyTokenizer是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterator接口，在使用时经常被用到的是Iterator接口中的hasNext这个函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String indexedName;</span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="keyword">private</span> String children;</span><br><span class="line"></span><br><span class="line">    publicPropertyTokenizer(String fullname) &#123;</span><br><span class="line">        <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">            children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = fullname;</span><br><span class="line">            children = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexedName = name;</span><br><span class="line">        delim = name.indexOf(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">            name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexedName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicbooleanhasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicvoidremove() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">"Remove is not supported, as it has no meaning in the context of properties."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li>图说设计模式</li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/index.html</a></li><li>深入浅出Mybatis系列（十）—SQL执行流程分析（源码篇）</li><li><a href="http://www.cnblogs.com/dongying/p/4142476.html" target="_blank" rel="noopener">http://www.cnblogs.com/dongying/p/4142476.html</a></li><li>设计模式读书笔记—–组合模式</li><li><a href="http://www.cnblogs.com/chenssy/p/3299719.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3299719.html</a></li><li>Mybatis3.3.x技术内幕（四）：五鼠闹东京之执行器Executor设计原本</li><li><a href="http://blog.csdn.net/wagcy/article/details/32963235" target="_blank" rel="noopener">http://blog.csdn.net/wagcy/article/details/32963235</a></li><li>mybatis缓存机制详解（一）——Cache</li><li><a href="https://my.oschina.net/lixin91/blog/620068" target="_blank" rel="noopener">https://my.oschina.net/lixin91/blog/620068</a></li></ul><blockquote><p>转载自<a href="http://www.crazyant.net/2022.html" target="_blank" rel="noopener">http://www.crazyant.net/2022.html</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="Mybatis" scheme="https://vincentruan.github.io/tags/Mybatis/"/>
    
      <category term="设计模式" scheme="https://vincentruan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>不可不说的Java锁事</title>
    <link href="https://vincentruan.github.io/2020/02/12/%E4%B8%8D%E5%8F%AF%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E9%94%81%E4%BA%8B/"/>
    <id>https://vincentruan.github.io/2020/02/12/%E4%B8%8D%E5%8F%AF%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E9%94%81%E4%BA%8B/</id>
    <published>2020-02-12T08:39:06.000Z</published>
    <updated>2020-02-25T15:09:15.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p><a id="more"></a><h1 id="JAVA主流锁"><a href="#JAVA主流锁" class="headerlink" title="JAVA主流锁"></a>JAVA主流锁</h1><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p><p><img src="/2020/02/12/不可不说的Java锁事/7f749fc8.png" alt="img"></p><h2 id="1-乐观锁-VS-悲观锁"><a href="#1-乐观锁-VS-悲观锁" class="headerlink" title="1. 乐观锁 VS 悲观锁"></a>1. 乐观锁 VS 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="/2020/02/12/不可不说的Java锁事/c8703cd9.png" alt="img"></p><p>根据从上面的概念描述我们可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><ol><li><p>ABA问题</p><p>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作</p><p>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h2 id="2-自旋锁-VS-适应性自旋锁"><a href="#2-自旋锁-VS-适应性自旋锁" class="headerlink" title="2. 自旋锁 VS 适应性自旋锁"></a>2. 自旋锁 VS 适应性自旋锁</h2><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/452a3363.png" alt="img"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.misc.Unsafe#getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p><h2 id="3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr><th style="text-align:left">锁状态</th><th style="text-align:left">存储内容</th><th style="text-align:left">存储内容</th></tr></thead><tbody><tr><td style="text-align:left">无锁</td><td style="text-align:left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">偏向锁</td><td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">轻量级锁</td><td style="text-align:left">指向栈中锁记录的指针</td><td style="text-align:left">00</td></tr><tr><td style="text-align:left">重量级锁</td><td style="text-align:left">指向互斥量（重量级锁）的指针</td><td style="text-align:left">10</td></tr></tbody></table><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img src="/2020/02/12/不可不说的Java锁事/8afdf6f2.png" alt="img"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h2 id="4-公平锁-VS-非公平锁"><a href="#4-公平锁-VS-非公平锁" class="headerlink" title="4. 公平锁 VS 非公平锁"></a>4. 公平锁 VS 非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/a23d746a.png" alt="img"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="/2020/02/12/不可不说的Java锁事/4499559e.png" alt="img"></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/6edea205.png" alt="img"></p><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="/2020/02/12/不可不说的Java锁事/bc6fe583.png" alt="img"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="/2020/02/12/不可不说的Java锁事/bd0036bb.png" alt="img"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h2 id="5-可重入锁-VS-非可重入锁"><a href="#5-可重入锁-VS-非可重入锁" class="headerlink" title="5. 可重入锁 VS 非可重入锁"></a>5. 可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/58fc5bc9.png" alt="img"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="/2020/02/12/不可不说的Java锁事/ea597a0c.png" alt="img"></p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p><img src="/2020/02/12/不可不说的Java锁事/32536e7a.png" alt="img"></p><h2 id="6-独享锁-VS-共享锁"><a href="#6-独享锁-VS-共享锁" class="headerlink" title="6. 独享锁 VS 共享锁"></a>6. 独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="/2020/02/12/不可不说的Java锁事/762a042b.png" alt="img"></p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><p><img src="/2020/02/12/不可不说的Java锁事/8793e00a.png" alt="img"></p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="/2020/02/12/不可不说的Java锁事/8b7878ec.png" alt="img"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h1 id="其他锁细节"><a href="#其他锁细节" class="headerlink" title="其他锁细节"></a>其他锁细节</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized 关键字是一把经典的锁，也是我们平时用得最多的。在 JDK1.6 之前， syncronized 是一把重量级的锁，不过随着 JDK 的升级，也在对它进行不断的优化，如今它变得不那么重了，甚至在某些场景下，它的性能反而优于轻量级锁。在加了 syncronized 关键字的方法、代码块中，一次只允许一个线程进入特定代码段，从而避免多线程同时修改同一数据。</p><p>synchronized 锁有如下几个特点：</p><p><strong>有锁升级过程</strong></p><p>在 JDK1.5 (含)之前， synchronized 的底层实现是重量级的，所以之前一致称呼它为”重量级锁”，在 JDK1.5 之后，对 synchronized 进行了各种优化，它变得不那么重了，实现原理就是锁升级的过程。我们先聊聊 1.5 之后的 synchronized 实现原理是怎样的。说到 synchronized 加锁原理，就不得不先说 Java 对象在内存中的布局， Java 对象内存布局如下:</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213202817218.png" alt="image-20200213202817218"></p><p>如上图所示，在创建一个对象后，在 JVM 虚拟机( HotSpot )中，对象在 Java 内存中的存储布局 可分为三块:</p><p><strong>对象头区域此处存储的信息包括两部分：</strong></p><p>1、对象自身的运行时数据( MarkWord )</p><p>存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID 、 CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。</p><p>2、对象类型指针( Class Pointer )</p><p>对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。</p><p><strong>实例数据区域</strong> </p><p> 此处存储的是对象真正有效的信息，比如对象中所有字段的内容</p><p><strong>对齐填充区域</strong></p><p> JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了”对齐”，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就”补位”到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。</p><p>当线程进入到 synchronized 处尝试获取该锁时， synchronized 锁升级流程如下：</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213203159163.png" alt="image-20200213203159163"></p><p>如上图所示， synchronized 锁升级的顺序为：偏向锁-&gt;轻量级锁-&gt;重量级锁，每一步触发锁升级的情况如下：</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在 JDK1.8 中，其实默认是轻量级锁，但如果设定了 -XX:BiasedLockingStartupDelay = 0 ，那在对一个 Object 做 syncronized 的时候，会立即上一把偏向锁。当处于偏向锁状态时， markwork 会记录当前线程 ID 。</p><h3 id="升级到轻量级锁"><a href="#升级到轻量级锁" class="headerlink" title="升级到轻量级锁"></a><strong>升级到轻量级锁</strong></h3><p>当下一个线程参与到偏向锁竞争时，会先判断 markword 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁。每个线程在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS (自旋)的操作将锁对象头中的 markwork 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着获得锁。关于 synchronized 中此时执行的 CAS 操作是通过 native 的调用 HotSpot 中 bytecodeInterpreter.cpp 文件 C++ 代码实现的，有兴趣的可以继续深挖。</p><h3 id="升级到重量级锁"><a href="#升级到重量级锁" class="headerlink" title="升级到重量级锁"></a><strong>升级到重量级锁</strong></h3><p>如果锁竞争加剧(如线程自旋次数或者自旋的线程数超过某阈值， JDK1.6 之后，由 JVM 自己控制该规则)，就会升级为重量级锁。此时就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。在重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是”重”的原因之一。</p><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a><strong>可重入</strong></h3><p>synchronized 拥有强制原子性的内部锁机制，是一把可重入锁。因此，在一个线程使用 synchronized 方法时调用该对象另一个 synchronized 方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的。在 Java 中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。 synchronized 锁的对象头的 markwork 中会记录该锁的线程持有者和计数器，当一个线程请求成功后， JVM 会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized 方法/块时，计数器会递减，如果计数器为 0 则释放该锁锁。</p><h3 id="悲观锁-互斥锁、排他锁"><a href="#悲观锁-互斥锁、排他锁" class="headerlink" title="悲观锁(互斥锁、排他锁)"></a><strong>悲观锁(互斥锁、排他锁)</strong></h3><p> synchronized 是一把悲观锁(独占锁)，当前线程如果获取到锁，会导致其它所有需要锁该的线程等待，一直等待持有锁的线程释放锁才继续进行锁的争抢。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 从字面可以看出是一把可重入锁，这点和 synchronized 一样，但实现原理也与 syncronized 有很大差别，它是基于经典的 AQS(AbstractQueueSyncronized) 实现的, AQS 是基于 volitale 和 CAS 实现的，其中 AQS 中维护一个 valitale 类型的变量 state 来做一个可重入锁的重入次数，加锁和释放锁也是围绕这个变量来进行的。 ReentrantLock 也提供了一些 synchronized 没有的特点，因此比 synchronized 好用。</p><p><strong>AQS模型如下图：</strong></p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213203315752.png" alt="image-20200213203315752"></p><p>ReentrantLock 有如下特点：</p><h3 id="可重入-1"><a href="#可重入-1" class="headerlink" title="可重入"></a>可重入</h3><p> ReentrantLock 和 syncronized 关键字一样，都是可重入锁，不过两者实现原理稍有差别， RetrantLock 利用 AQS 的的 state 状态来判断资源是否已锁，同一线程重入加锁， state 的状态 +1 ; 同一线程重入解锁, state 状态 -1 (解锁必须为当前独占线程，否则异常); 当 state 为 0 时解锁成功。</p><h3 id="需要手动加锁、解锁"><a href="#需要手动加锁、解锁" class="headerlink" title="需要手动加锁、解锁"></a>需要手动加锁、解锁</h3><p>synchronized 关键字是自动进行加锁、解锁的，而 ReentrantLock 需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成，来手动加锁、解锁。</p><h3 id="支持设置锁的超时时间"><a href="#支持设置锁的超时时间" class="headerlink" title="支持设置锁的超时时间"></a>支持设置锁的超时时间</h3><p> synchronized 关键字无法设置锁的超时时间，如果一个获得锁的线程内部发生死锁，那么其他线程就会一直进入阻塞状态，而 ReentrantLock 提供 tryLock 方法，允许设置线程获取锁的超时时间，如果超时，则跳过，不进行任何操作，避免死锁的发生。</p><h3 id="支持公平-非公平锁"><a href="#支持公平-非公平锁" class="headerlink" title="支持公平/非公平锁"></a>支持公平/非公平锁</h3><p>synchronized 关键字是一种非公平锁，先抢到锁的线程先执行。而 ReentrantLock 的构造方法中允许设置 true/false 来实现公平、非公平锁，如果设置为 true ，则线程获取锁要遵循”先来后到”的规则，每次都会构造一个线程 Node ，然后到双向链表的”尾巴”后面排队，等待前面的 Node 释放锁资源。</p><h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p> ReentrantLock 中的 lockInterruptibly() 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 interrupt() 方法就可以立刻打断 t1 线程的执行，来获取t1持有的那个可重入锁。而通过 ReentrantLock 的 lock() 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt() 方法的，直到该方法主动释放锁之后才会响应 interrupt() 方法。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock (读写锁)其实是两把锁，一把是 WriteLock (写锁)，一把是读锁， ReadLock 。读写锁的规则是：读读不互斥、读写互斥、写写互斥。在一些实际的场景中，读操作的频率远远高于写操作，如果直接用一般的锁进行并发控制的话，就会读读互斥、读写互斥、写写互斥，效率低下，读写锁的产生就是为了优化这种场景的操作效率。一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高，因此需要根据实际情况选择使用。 </p><p>ReentrantReadWriteLock 的原理也是基于 AQS 进行实现的，与 ReentrantLock 的差别在于 ReentrantReadWriteLock 锁拥有共享锁、排他锁属性。读写锁中的加锁、释放锁也是基于 Sync (继承于 AQS )，并且主要使用 AQS 中的 state 和 node 中的 waitState 变量进行实现的。实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。 ReentrantReadWriteLock 中将 AQS 中的 int 类型的 state 分为高 16 位与第 16 位分别记录读锁和写锁的状态，如下图所示：</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213203511263.png" alt="image-20200213203511263"></p><p><strong>WriteLock(写锁)是悲观锁(排他锁、互斥锁)</strong></p><p>通过计算 state&amp;((1&lt;&lt;16)-1) ，将 state 的高 16 位全部抹去，因此 state 的低位记录着写锁的重入计数。</p><p>获取写锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁</span></span><br><span class="line"><span class="comment">           Acquires the write lock.</span></span><br><span class="line"><span class="comment">         *  如果此时没有任何线程持有写锁或者读锁，那么当前线程执行CAS操作更新status，</span></span><br><span class="line"><span class="comment">         *  若更新成功，则设置读锁重入次数为1，并立即返回</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the write lock if neither the read nor write lock</span></span><br><span class="line"><span class="comment">         * are held by another thread</span></span><br><span class="line"><span class="comment">         * and returns immediately, setting the write lock hold count to</span></span><br><span class="line"><span class="comment">         * one.</span></span><br><span class="line"><span class="comment">         *  如果当前线程已经持有该写锁，那么将写锁持有次数设置为1，并立即返回</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the current thread already holds the write lock then the</span></span><br><span class="line"><span class="comment">         * hold count is incremented by one and the method returns</span></span><br><span class="line"><span class="comment">         * immediately.</span></span><br><span class="line"><span class="comment">         *  如果该锁已经被另外一个线程持有，那么停止该线程的CPU调度并进入休眠状态，</span></span><br><span class="line"><span class="comment">         *  直到该写锁被释放，且成功将写锁持有次数设置为1才表示获取写锁成功</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the lock is held by another thread then the current</span></span><br><span class="line"><span class="comment">         * thread becomes disabled for thread scheduling purposes and</span></span><br><span class="line"><span class="comment">         * lies dormant until the write lock has been acquired, at which</span></span><br><span class="line"><span class="comment">         * time the write lock hold count is set to one.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法为以独占模式获取锁，忽略中断</span></span><br><span class="line"><span class="comment">     * 如果调用一次该“tryAcquire”方法更新status成功，则直接返回，代表抢锁成功</span></span><br><span class="line"><span class="comment">     * 否则，将会进入同步队列等待，不断执行“tryAcquire”方法尝试CAS更新status状态，直到成功抢到锁</span></span><br><span class="line"><span class="comment">     * 其中“tryAcquire”方法在NonfairSync(公平锁)中和FairSync(非公平锁)中都有各自的实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1、如果读写锁的计数不为0，且持有锁的线程不是当前线程，则返回false</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2、如果持有锁的计数不为0且计数总数超过限定的最大值，也返回false</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3、如果该锁是可重入或该线程在队列中的策略是允许它尝试抢锁，那么该线程就能获取锁</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取读写锁的状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//获取该写锁重入的次数</span></span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="comment">//如果读写锁状态不为0，说明已经有其他线程获取了读锁或写锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果写锁重入次数为0，说明有线程获取到读锁，根据“读写锁互斥”原则，返回false</span></span><br><span class="line">                <span class="comment">//或者如果写锁重入次数不为0，且获取写锁的线程不是当前线程，根据"写锁独占"原则，返回false</span></span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">//如果写锁可重入次数超过最大次数（65535），则抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">//到这里说明该线程是重入写锁，更新重入写锁的计数(+1)，返回true</span></span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果读写锁状态为0,说明读锁和写锁都没有被获取，会走下面两个分支：</span></span><br><span class="line">            <span class="comment">//如果要阻塞或者执行CAS操作更新读写锁的状态失败，则返回false</span></span><br><span class="line">            <span class="comment">//如果不需要阻塞且CAS操作成功，则当前线程成功拿到锁，设置锁的owner为当前线程，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>释放写锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">  * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">  * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">  * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//若锁的持有者不是当前线程，抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">     <span class="comment">//写锁的可重入计数减掉releases个</span></span><br><span class="line">     <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">     <span class="comment">//如果写锁重入计数为0了，则说明写锁被释放了</span></span><br><span class="line">     <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">//若写锁被释放，则将锁的持有者设置为null，进行GC</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//更新写锁的重入计数</span></span><br><span class="line">     setState(nextc);</span><br><span class="line">     <span class="keyword">return</span> free;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>ReadLock(读锁)是共享锁(乐观锁)</strong></p><p>通过计算 state&gt;&gt;&gt;16 进行无符号补 0 ，右移 16 位，因此 state 的高位记录着写锁的重入计数.</p><p>读锁获取锁的过程比写锁稍微复杂些，首先判断写锁是否为 0 并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程 firstReader 和 firstReaderHoldCount ；若当前线程线程为第一个读线程，则增加 firstReaderHoldCount ；否则，将设置当前线程对应的 HoldCounter 对象的值，更新成功后会在 firstReaderHoldCount 中 readHolds ( ThreadLocal 类型的)的本线程副本中记录当前线程重入数，这是为了实现 JDK1.6 中加入的 getReadHoldCount ()方法的，这个方法能获取当前线程重入共享锁的次数( state 中记录的是多个线程的总重入次数)，加入了这个方法让代码复杂了不少，但是其原理还是很简单的：如果当前只有一个线程的话，还不需要动用 ThreadLocal ，直接往 firstReaderHoldCount 这个成员变量里存重入数，当有第二个线程来的时候，就要动用 ThreadLocal 变量 readHolds 了，每个线程拥有自己的副本，用来保存自己的重入数。</p><p>获取读锁源码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取读锁</span></span><br><span class="line"><span class="comment">         * Acquires the read lock.</span></span><br><span class="line"><span class="comment">         * 如果写锁未被其他线程持有，执行CAS操作更新status值，获取读锁后立即返回</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">         * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果写锁被其他线程持有，那么停止该线程的CPU调度并进入休眠状态，直到该读锁被释放</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">         * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">         * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法为以共享模式获取读锁，忽略中断</span></span><br><span class="line"><span class="comment">     * 如果调用一次该“tryAcquireShared”方法更新status成功，则直接返回，代表抢锁成功</span></span><br><span class="line"><span class="comment">     * 否则，将会进入同步队列等待，不断执行“tryAcquireShared”方法尝试CAS更新status状态，直到成功抢到锁</span></span><br><span class="line"><span class="comment">     * 其中“tryAcquireShared”方法在NonfairSync(公平锁)中和FairSync(非公平锁)中都有各自的实现</span></span><br><span class="line"><span class="comment">     * (看这注释是不是和写锁很对称)</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1、如果已经有其他线程获取到了写锁，根据“读写互斥”原则，抢锁失败，返回-1</span></span><br><span class="line"><span class="comment">             * 1.If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2、如果该线程本身持有写锁，那么看一下是否要readerShouldBlock，如果不需要阻塞，</span></span><br><span class="line"><span class="comment">             *    则执行CAS操作更新state和重入计数。</span></span><br><span class="line"><span class="comment">             *    这里要注意的是，上面的步骤不检查是否可重入(因为读锁属于共享锁，天生支持可重入)</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3、如果因为CAS更新status失败或者重入计数超过最大值导致步骤2执行失败</span></span><br><span class="line"><span class="comment">             *    那就进入到fullTryAcquireShared方法进行死循环，直到抢锁成功</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前尝试获取读锁的线程</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取该读写锁状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//如果有线程获取到了写锁 ，且获取写锁的不是当前线程则返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//获取读锁的重入计数</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="comment">//如果读线程不应该被阻塞，且重入计数小于最大值，且CAS执行读锁重入计数+1成功，则执行线程重入的计数加1操作，返回成功</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//如果还未有线程获取到读锁，则将firstReader设置为当前线程，firstReaderHoldCount设置为1</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">//如果firstReader是当前线程，则将firstReader的重入计数变量firstReaderHoldCount加1</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则说明有至少两个线程共享读锁，获取共享锁重入计数器HoldCounter</span></span><br><span class="line">                    <span class="comment">//从HoldCounter中拿到当前线程的线程变量cachedHoldCounter，将此线程的重入计数count加1</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果上面的if条件有一个都不满足，则进入到这个方法里进行死循环重新获取</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于处理CAS操作state失败和tryAcquireShared中未执行获取可重入锁动作的full方法(补偿方法？)</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 此代码与tryAcquireShared中的代码有部分相似的地方，</span></span><br><span class="line"><span class="comment">             * 但总体上更简单，因为不会使tryAcquireShared与重试和延迟读取保持计数之间的复杂判断</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取读写锁状态</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="comment">//如果有线程获取到了写锁</span></span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果获取写锁的线程不是当前线程，返回失败</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;<span class="comment">//如果没有线程获取到写锁，且读线程要阻塞</span></span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="comment">//如果当前线程为第一个获取到读锁的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果当前线程不是第一个获取到读锁的线程(也就是说至少有有一个线程获取到了读锁)</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *下面是既没有线程获取写锁，当前线程又不需要阻塞的情况</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//重入次数等于最大重入次数，抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">//如果执行CAS操作成功将读写锁的重入计数加1，则对当前持有这个共享读锁的线程的重入计数加1，然后返回成功</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>释放读锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">  * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">  *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">  *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放一次共享锁计数</span></span><br><span class="line">        doReleaseShared();<span class="comment">//真正释放锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *此方法表示读锁线程释放锁。</span></span><br><span class="line"><span class="comment"> *首先判断当前线程是否为第一个读线程firstReader，</span></span><br><span class="line"><span class="comment"> *若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，</span></span><br><span class="line"><span class="comment">  若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；</span></span><br><span class="line"><span class="comment">  若当前线程不是第一个读线程，</span></span><br><span class="line"><span class="comment">  那么首先会获取缓存计数器（上一个读锁线程对应的计数器 ），</span></span><br><span class="line"><span class="comment">  若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，</span></span><br><span class="line"><span class="comment">  如果计数器的计数count小于等于1，则移除当前线程对应的计数器，</span></span><br><span class="line"><span class="comment">  如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。</span></span><br><span class="line"><span class="comment">  无论何种情况，都会进入死循环，该循环可以确保成功设置状态state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取当前线程</span></span><br><span class="line">      Thread current = Thread.currentThread();</span><br><span class="line">      <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程</span></span><br><span class="line">          <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">         <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line">              firstReader = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">// 减少占用的资源</span></span><br><span class="line">              firstReaderHoldCount--;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不为第一个读线程</span></span><br><span class="line">         <span class="comment">// 获取缓存的计数器</span></span><br><span class="line">         HoldCounter rh = cachedHoldCounter;</span><br><span class="line">         <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line">             <span class="comment">// 获取当前线程对应的计数器</span></span><br><span class="line">             rh = readHolds.get();</span><br><span class="line">         <span class="comment">// 获取计数</span></span><br><span class="line">         <span class="keyword">int</span> count = rh.count;</span><br><span class="line">         <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123; <span class="comment">// 计数小于等于1</span></span><br><span class="line">             <span class="comment">// 移除</span></span><br><span class="line">             readHolds.remove();</span><br><span class="line">             <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="comment">// 计数小于等于0，抛出异常</span></span><br><span class="line">                 <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 减少计数</span></span><br><span class="line">         --rh.count;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">         <span class="comment">// 获取状态</span></span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="comment">// 获取状态</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并进行设置</span></span><br><span class="line">             <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">             <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">             <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**真正释放锁</span></span><br><span class="line"><span class="comment">  * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">  * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">  * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过分析可以看出：</p><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>在线程持有写锁的况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>在高并发的情况下，我们对一个 Integer 类型的整数直接进行 i++ 的时候，无法保证操作的原子性，会出现线程安全的问题。为此我们会用 juc 下的 AtomicInteger ，它是一个提供原子操作的 Interger 类，内部也是通过 CAS 实现线程安全的。但当大量线程同时去访问时，就会因为大量线程执行 CAS 操作失败而进行空旋转，导致 CPU 资源消耗过多，而且执行效率也不高。 Doug Lea 大神应该也不满意，于是在 JDK1.8 中对 CAS 进行了优化，提供了 LongAdder ，它是基于了 CAS 分段锁的思想实现的。</p><p>线程去读写一个 LongAdder 类型的变量时，流程如下：</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213204318608.png" alt="image-20200213204318608"></p><p> LongAdder 也是基于 Unsafe 提供的 CAS 操作 +valitale 去实现的。在 LongAdder 的父类 Striped64 中维护着一个 base 变量和一个 cell 数组，当多个线程操作一个变量的时候，先会在这个 base 变量上进行 cas 操作，当它发现线程增多的时候，就会使用 cell 数组。比如当 base 将要更新的时候发现线程增多（也就是调用 casBase 方法更新 base 值失败），那么它会自动使用 cell 数组，每一个线程对应于一个 cell ，在每一个线程中对该 cell 进行 cas 操作，这样就可以将单一 value 的更新压力分担到多个 value 中去，降低单个 value 的 “热度”，同时也减少了大量线程的空转，提高并发效率，分散并发压力。这种分段锁需要额外维护一个内存空间 cells ，不过在高并发场景下，这点成本几乎可以忽略。分段锁是一种优秀的优化思想， juc 中提供的的 ConcurrentHashMap 也是基于分段锁保证读写操作的线程安全。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java并发编程艺术》</li><li><a href="https://blog.csdn.net/u013256816/article/details/51204385" target="_blank" rel="noopener">Java中的锁</a></li><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></li><li><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc" target="_blank" rel="noopener">Java并发——关键字synchronized解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/29866981" target="_blank" rel="noopener">Java synchronized原理总结</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）——Java SE1.6中的Synchronized</a></li><li><a href="https://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="noopener">深入理解读写锁—ReadWriteLock源码分析</a></li><li><a href="https://www.cnblogs.com/twoheads/p/9635309.html" target="_blank" rel="noopener">【JUC】JDK1.8源码分析之ReentrantReadWriteLock</a></li><li><a href="https://my.oschina.net/adan1/blog/158107" target="_blank" rel="noopener">Java多线程（十）之ReentrantReadWriteLock深入分析</a></li><li><a href="https://mrdear.cn/2018/06/23/java/java--readwritelock" target="_blank" rel="noopener">Java–读写锁的实现原理</a></li></ol><blockquote><p>转载自美团技术团队，<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">原文地址</a>，在原文基础上有修改.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="并发" scheme="https://vincentruan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>从ReentrantLock的实现看AQS的原理及应用</title>
    <link href="https://vincentruan.github.io/2020/02/12/%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://vincentruan.github.io/2020/02/12/%E4%BB%8EReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2020-02-12T08:27:06.000Z</published>
    <updated>2020-02-25T15:09:15.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。</p><p>下面列出本篇文章的大纲和思路，以便于大家更好地理解：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/9d182d944e0889c304ef529ba50a4fcd205214.png" alt="img"></p><a id="more"></a><h2 id="1-ReentrantLock"><a href="#1-ReentrantLock" class="headerlink" title="1 ReentrantLock"></a>1 ReentrantLock</h2><h3 id="1-1-ReentrantLock特性概览"><a href="#1-1-ReentrantLock特性概览" class="headerlink" title="1.1 ReentrantLock特性概览"></a>1.1 ReentrantLock特性概览</h3><p>ReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img"></p><p>下面通过伪代码，进行更加直观的比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 2.可用于代码块</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line"><span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 4.手动释放锁</span></span><br><span class="line">lock.unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-ReentrantLock与AQS的关联"><a href="#1-2-ReentrantLock与AQS的关联" class="headerlink" title="1.2 ReentrantLock与AQS的关联"></a>1.2 ReentrantLock与AQS的关联</h3><p>通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a>》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。</p><p>非公平锁源码中的加锁流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#NonfairSync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的含义为：</p><ul><li>若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。</li><li>若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。</li></ul><p>第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：</p><ul><li>某个线程获取锁失败的后续流程是什么呢？有以下两种可能：</li></ul><p>(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。</p><p>(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><ul><li>对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</li><li>处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</li><li>如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？</li></ul><p>带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock#FairSync</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">  ...  </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。</p><p>对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。</p><h2 id="2-AQS"><a href="#2-AQS" class="headerlink" title="2 AQS"></a>2 AQS</h2><p>首先，我们通过下面的架构图来整体了解一下AQS框架：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p><ul><li>上图中有颜色的为Method，无颜色的为Attribution。</li><li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li><li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li></ul><p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt="img"></p><h3 id="2-1-原理概览"><a href="#2-1-原理概览" class="headerlink" title="2.1 原理概览"></a>2.1 原理概览</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p><strong>CLH</strong>：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p>主要原理图如下：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h4 id="2-1-1-AQS数据结构"><a href="#2-1-1-AQS数据结构" class="headerlink" title="2.1.1 AQS数据结构"></a>2.1.1 AQS数据结构</h4><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/960271cf2b5c8a185eed23e98b72c75538637.png" alt="img"></p><p>解释一下几个方法和属性值的含义：</p><table><thead><tr><th style="text-align:left">方法和属性值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">waitStatus</td><td style="text-align:left">当前节点在队列中的状态</td></tr><tr><td style="text-align:left">thread</td><td style="text-align:left">表示处于该节点的线程</td></tr><tr><td style="text-align:left">prev</td><td style="text-align:left">前驱指针</td></tr><tr><td style="text-align:left">predecessor</td><td style="text-align:left">返回前驱节点，没有的话抛出npe</td></tr><tr><td style="text-align:left">nextWaiter</td><td style="text-align:left">指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</td></tr><tr><td style="text-align:left">next</td><td style="text-align:left">后继指针</td></tr></tbody></table><p>线程两种锁的模式：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">SHARED</td><td style="text-align:left">表示线程以共享的模式等待锁</td></tr><tr><td style="text-align:left">EXCLUSIVE</td><td style="text-align:left">表示线程正在以独占的方式等待锁</td></tr></tbody></table><p>waitStatus有下面几个枚举值：</p><table><thead><tr><th style="text-align:left">枚举</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">当一个Node被初始化的时候的默认值</td></tr><tr><td style="text-align:left">CANCELLED</td><td style="text-align:left">为1，表示线程获取锁的请求已经取消了</td></tr><tr><td style="text-align:left">CONDITION</td><td style="text-align:left">为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr><tr><td style="text-align:left">PROPAGATE</td><td style="text-align:left">为-3，当前线程处在SHARED情况下，该字段才会使用</td></tr><tr><td style="text-align:left">SIGNAL</td><td style="text-align:left">为-1，表示线程已经准备好了，就等资源释放了</td></tr></tbody></table><h4 id="2-1-2-同步状态State"><a href="#2-1-2-同步状态State" class="headerlink" title="2.1.2 同步状态State"></a>2.1.2 同步状态State</h4><p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>下面提供了几个访问这个字段的方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">protected final int getState()</td><td style="text-align:left">获取State的值</td></tr><tr><td style="text-align:left">protected final void setState(int newState)</td><td style="text-align:left">设置State的值</td></tr><tr><td style="text-align:left">protected final boolean compareAndSetState(int expect, int update)</td><td style="text-align:left">使用CAS方式更新State</td></tr></tbody></table><p>这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/27605d483e8935da683a93be015713f331378.png" alt="img"><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img"></p><p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p><h2 id="2-2-AQS重要方法与ReentrantLock的关联"><a href="#2-2-AQS重要方法与ReentrantLock的关联" class="headerlink" title="2.2 AQS重要方法与ReentrantLock的关联"></a>2.2 AQS重要方法与ReentrantLock的关联</h2><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">protected boolean isHeldExclusively()</td><td style="text-align:left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td></tr><tr><td style="text-align:left">protected boolean tryAcquire(int arg)</td><td style="text-align:left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td></tr><tr><td style="text-align:left">protected boolean tryRelease(int arg)</td><td style="text-align:left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td></tr><tr><td style="text-align:left">protected int tryAcquireShared(int arg)</td><td style="text-align:left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td></tr><tr><td style="text-align:left">protected boolean tryReleaseShared(int arg)</td><td style="text-align:left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td></tr></tbody></table><p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p><p>以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/b8b53a70984668bc68653efe9531573e78636.png" alt="img"></p><p>为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/7aadb272069d871bdee8bf3a218eed8136919.png" alt="img"></p><p><strong>加锁：</strong></p><ul><li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li><li>会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。</li><li>AQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li><li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li></ul><p><strong>解锁：</strong></p><ul><li>通过ReentrantLock的解锁方法Unlock进行解锁。</li><li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li><li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li><li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li></ul><p>通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png" alt="img"></p><h2 id="2-3-通过ReentrantLock理解AQS"><a href="#2-3-通过ReentrantLock理解AQS" class="headerlink" title="2.3 通过ReentrantLock理解AQS"></a>2.3 通过ReentrantLock理解AQS</h2><p>ReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。</p><p>在非公平锁中，有一段这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下这个Acquire是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下tryAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。</p><h3 id="2-3-1-线程加入等待队列"><a href="#2-3-1-线程加入等待队列" class="headerlink" title="2.3.1 线程加入等待队列"></a>2.3.1 线程加入等待队列</h3><h4 id="2-3-1-1-加入队列的时机"><a href="#2-3-1-1-加入队列的时机" class="headerlink" title="2.3.1.1 加入队列的时机"></a>2.3.1.1 加入队列的时机</h4><p>当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</p><h4 id="2-3-1-2-如何加入队列"><a href="#2-3-1-2-如何加入队列" class="headerlink" title="2.3.1.2 如何加入队列"></a>2.3.1.2 如何加入队列</h4><p>获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的流程如下：</p><ul><li>通过当前的线程和锁模式新建一个节点。</li><li>Pred指针指向尾节点Tail。</li><li>将New中Node的Prev指针指向Pred。</li><li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("state"));</span><br><span class="line">headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("head"));</span><br><span class="line">tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("tail"));</span><br><span class="line">waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("waitStatus"));</span><br><span class="line">nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("next"));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p><ul><li>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">Node t = tail;</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p>总结一下，线程获取锁的时候，过程大体如下：</p><ol><li>当没有线程获取到锁时，线程1获取锁成功。</li><li>线程2申请锁，但是锁被线程1占有。</li></ol><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/e9e385c3c68f62c67c8d62ab0adb613921117.png" alt="img"></p><ol><li>如果再有线程要获取锁，依次在队列中往后排队即可。</li></ol><p>回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line"><span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line"><span class="comment">// thread is first in queue.</span></span><br><span class="line">Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">Node h = head;</span><br><span class="line">Node s;</span><br><span class="line"><span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我们理解一下h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><blockquote><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">tail = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">t.next = node;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。</p><h4 id="2-3-1-3-等待队列中线程出队列时机"><a href="#2-3-1-3-等待队列中线程出队列时机" class="headerlink" title="2.3.1.3 等待队列中线程出队列时机"></a>2.3.1.3 等待队列中线程出队列时机</h4><p>回到最初的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</p><p>总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p><p>下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 标记等待过程中是否中断过</span></span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 开始自旋，要么获取锁，要么中断</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span></span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="comment">// 获取锁成功，头指针移动到当前node</span></span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span></span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">head = node;</span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line">node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 靠前驱节点判断当前线程是否应该被阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点的节点状态</span></span><br><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="comment">// 说明头结点处于唤醒状态</span></span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line"><span class="comment">// 通过枚举值我们知道waitStatus&gt;0是取消状态</span></span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span></span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 设置前任节点等待状态为SIGNAL</span></span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的流程图如下：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/c124b76dcbefb9bdc778458064703d1135485.png" alt="img"></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/9af16e2481ad85f38ca322a225ae737535740.png" alt="img"></p><p>从队列中释放节点的疑虑打消了，那么又有新问题了：</p><ul><li>shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</li><li>是在什么时间释放节点通知到被挂起的线程呢？</li></ul><h3 id="2-3-2-CANCELLED状态节点生成"><a href="#2-3-2-CANCELLED状态节点生成" class="headerlink" title="2.3.2 CANCELLED状态节点生成"></a>2.3.2 CANCELLED状态节点生成</h3><p>acquireQueued方法中的Finally代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">...</span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将无效节点过滤</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 设置该节点不关联任何线程，也就是虚节点</span></span><br><span class="line">node.thread = <span class="keyword">null</span>;</span><br><span class="line">Node pred = node.prev;</span><br><span class="line">  <span class="comment">// 通过前驱节点，跳过取消状态的node</span></span><br><span class="line"><span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">  <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">Node predNext = pred.next;</span><br><span class="line">  <span class="comment">// 把当前node的状态设置为CANCELLED</span></span><br><span class="line">node.waitStatus = Node.CANCELLED;</span><br><span class="line">  <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span></span><br><span class="line">  <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span></span><br><span class="line"><span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ws;</span><br><span class="line">    <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">    <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line"><span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">Node next = node.next;</span><br><span class="line"><span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">compareAndSetNext(pred, predNext, next);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line">unparkSuccessor(node);</span><br><span class="line">&#125;</span><br><span class="line">node.next = node; <span class="comment">// help GC</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的流程：</p><ul><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：</li></ul><p>(1) 当前节点是尾节点。</p><p>(2) 当前节点是Head的后继节点。</p><p>(3) 当前节点不是Head的后继节点，也不是尾节点。</p><p>根据上述第二条，我们来分析每一种情况的流程。</p><p>当前节点是尾节点。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/b845211ced57561c24f79d56194949e822049.png" alt="img"></p><p>当前节点是Head的后继节点。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/ab89bfec875846e5028a4f8fead32b7117975.png" alt="img"></p><p>当前节点不是Head的后继节点，也不是尾节点。</p><p><img src="/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/45d0d9e4a6897eddadc4397cf53d6cd522452.png" alt="img"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><blockquote><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">do</span> &#123;</span><br><span class="line">&gt; node.prev = pred = pred.prev;</span><br><span class="line">&gt; &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-3-3-如何解锁"><a href="#2-3-3-如何解锁" class="headerlink" title="2.3.3 如何解锁"></a>2.3.3 如何解锁</h3><p>我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，本质释放锁的地方，是通过框架来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法返回当前锁是不是没有被线程持有</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 减少可重入次数</span></span><br><span class="line"><span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"><span class="comment">// 当前线程不是持有锁的线程，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"><span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">free = <span class="keyword">true</span>;</span><br><span class="line">setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);</span><br><span class="line"><span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来解释下述源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"><span class="comment">// 获取头结点</span></span><br><span class="line">Node h = head;</span><br><span class="line"><span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态</span></span><br><span class="line"><span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p><blockquote><p>h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</p><p>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</p><p>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p>再看一下unparkSuccessor方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取头结点waitStatus</span></span><br><span class="line"><span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">Node s = node.next;</span><br><span class="line"><span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span></span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line"><span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要从后往前找第一个非Cancelled的节点呢？原因如下。</p><p>之前的addWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p><h3 id="2-3-4-中断恢复后的执行流程"><a href="#2-3-4-中断恢复后的执行流程" class="headerlink" title="2.3.4 中断恢复后的执行流程"></a>2.3.4 中断恢复后的执行流程</h3><p>唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"><span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">setHead(node);</span><br><span class="line">p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">failed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> interrupted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果acquireQueued为True，就会执行selfInterrupt方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：</p><ol><li>当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。</li><li>线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。</li></ol><p>这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。</p><h3 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h3><p>我们在1.3小节中提出了一些问题，现在来回答一下。</p><blockquote><p>Q：某个线程获取锁失败的后续流程是什么呢？</p><p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p><p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>A：是CLH变体的FIFO双端队列。</p><p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p><p>A：可以详细看下2.3.1.3小节。</p><p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p><p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。</p><p>Q：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</p><p>A：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。</p></blockquote><h2 id="3-AQS应用"><a href="#3-AQS应用" class="headerlink" title="3 AQS应用"></a>3 AQS应用</h2><h3 id="3-1-ReentrantLock的可重入应用"><a href="#3-1-ReentrantLock的可重入应用" class="headerlink" title="3.1 ReentrantLock的可重入应用"></a>3.1 ReentrantLock的可重入应用</h3><p>ReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。</p><p>公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires))&#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line"><span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">setState(nextc);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>接下来看State这个字段主要的过程：</p><ol><li>State初始化的时候为0，表示没有任何线程持有锁。</li><li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。</li><li>解锁也是对这个字段-1，一直到0，此线程对锁释放。</li></ol><h3 id="3-2-JUC中的应用场景"><a href="#3-2-JUC中的应用场景" class="headerlink" title="3.2 JUC中的应用场景"></a>3.2 JUC中的应用场景</h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table><thead><tr><th style="text-align:left">同步工具</th><th style="text-align:left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td style="text-align:left">ReentrantLock</td><td style="text-align:left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td style="text-align:left">Semaphore</td><td style="text-align:left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td style="text-align:left">CountDownLatch</td><td style="text-align:left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td style="text-align:left">ReentrantReadWriteLock</td><td style="text-align:left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td style="text-align:left">ThreadPoolExecutor</td><td style="text-align:left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h3 id="3-3-自定义同步工具"><a href="#3-3-自定义同步工具" class="headerlink" title="3.3 自定义同步工具"></a>3.3 自定义同步工具</h3><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeLock</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span> <span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过我们自己定义的Lock完成一定的同步功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> LeeLock leeLock = <span class="keyword">new</span> LeeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Lea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.</li><li>《Java并发编程实战》</li><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></li></ul><blockquote><p>转载自美团技术团队 <a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。&lt;/p&gt;
&lt;p&gt;下面列出本篇文章的大纲和思路，以便于大家更好地理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/12/从ReentrantLock的实现看AQS的原理及应用/9d182d944e0889c304ef529ba50a4fcd205214.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="并发" scheme="https://vincentruan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ReentrantLock" scheme="https://vincentruan.github.io/tags/ReentrantLock/"/>
    
      <category term="AQS" scheme="https://vincentruan.github.io/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>MySQL增删改查都会用到什么锁?</title>
    <link href="https://vincentruan.github.io/2020/02/12/MySQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E9%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E9%94%81/"/>
    <id>https://vincentruan.github.io/2020/02/12/MySQL%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E9%83%BD%E4%BC%9A%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E9%94%81/</id>
    <published>2020-02-12T07:11:11.000Z</published>
    <updated>2020-02-26T03:28:53.200Z</updated>
    
    <content type="html"><![CDATA[<p>日常的操作中，增删改查都会使用什么类型的锁？其实这个问题，可以分为两个方面，一方面是读，一方面是写。</p><h1 id="读（select）"><a href="#读（select）" class="headerlink" title="读（select）"></a>读（select）</h1><p>  我们先来看读的部分。读的操作，其实分为两种，分别是<strong>一致性读</strong>和<strong>锁定读</strong>，</p><p>  这里我们温习一下，一致性读其实就是利用事务的MVCC机制，来读取一份数据的快照，所以有的书上也称之为快照读，一致性读是不加锁的，其他的事务是可以对表中的数据记录进行改动的。一般情况下，常见的读，例如：</p><p>select * from table；</p><p>select * from table left join table2;</p><p>  这种操作，在RU，RC，RR隔离级别下都是采用一直性读，不加锁的操作。这种情况下，<strong>读的并发可以非常高。</strong></p><p>  再来看看锁定读，如果我们的表当中有索引，我们想在读取记录的时候，获取某一条记录的锁，禁止别的事务对这条记录进行修改，那么我们可以使用下面的语句来对读取的记录加锁：</p><a id="more"></a><p><strong>select … lock in share mode;</strong>加共享锁。(其他事务可读，不可写)</p><p><strong>select … for update;</strong>加排它锁。(其他事务不可读，不可写)，这样，其他事务就不能对这条记录进行读取和更改了。</p><p>关于读操作的是否加锁，还有以下几点需要注意： </p><p>1、在Serializable这种事务的隔离级别下，普通的select操作会升级为select…in share mode；的模式。</p><p>2、在唯一索引上使用唯一的查询条件，会使用记录锁，而不会封锁记录之间的间隔，即不会使用间隙锁。</p><p>3、其他类型的索引使用范围的查询条件或者唯一的查询条件，innodb会自动锁定被扫描的范围，避免索引范围区间内插入新的记录。这块儿可能比较模糊，文章最后面给出各种类型下的加锁测试结果。</p><h1 id="写（update、delete、insert）"><a href="#写（update、delete、insert）" class="headerlink" title="写（update、delete、insert）"></a>写（update、delete、insert）</h1><h2 id="关于delete"><a href="#关于delete" class="headerlink" title="关于delete"></a>关于delete</h2><p>  对一条数据做delete的过程实际上是要先在索引的B+树上获取该记录的位置，然后再这个记录所在的位置加X锁，也就是排它锁。</p><p>  如果对某个范围内的数据做delete操作，则会在索引B+树上对范围内符合查询条件的记录以及记录之前的区间加next-key锁(本质是记录锁和间隙锁的组合，后面的文章会讲到)。  </p><p>   加完锁之后，再进行delete操作。这个delete操作的本质，其实是先将delete的标识为标识为1，而不是真正进行删除，如果下次这块空间可以复用，则innodb会直接进行复用。</p><p>   更多详情请见：Innodb数据页简介</p><h2 id="关于update"><a href="#关于update" class="headerlink" title="关于update"></a>关于update</h2><p>  对一条记录做update的时候，我们知道，如果该要更新的列在更新前后的存储空间没有发生变化，则会直接在该记录上进行更新操作。而如果发生了存储空间的变化，则会现将这条记录彻底删除掉，然后再插入一条新的记录。</p><p>  基本上分为一下三种情况：</p><p>1、如果update操作没有更新索引键值并且没有导致存储空间变化，则会直接在索引B+树上使用X锁来锁定update的记录。</p><p>2、如果update操作没有更新索引键值但却导致了数据的存储空间发生变化，则会现将这表数据记录删除掉，然后再插入一条新的记录，在这个过程中，先会获取索引B+树的X锁，然后insert过程会使用隐式锁来进行保护。</p><p>3、如果update修改了某条记录的索引键值，则需要先进行delete，然后再进行一次insert，加锁的规则就和delete以及insert一样了。</p><p>  这里有几点需要注意：</p><p>1、如果在唯一索引上使用唯一的查询条件来进行update和delete操作，那么这个过程中只会对记录加锁。</p><p>2、除了第一种情况之外，都会加排他的next-key锁，来锁定记录和记录之前的范围。</p><p>3、如果update的是主键的记录，则对应的普通索引的记录也会被隐式加锁，这是因为innodb中的普通索引会存储主键的值，检索普通索引本质上要进行回表操作，二次扫描聚集索引。</p><h2 id="关于insert"><a href="#关于insert" class="headerlink" title="关于insert"></a>关于insert</h2><p>  insert操作会用排它锁封锁被插入的索引记录，而不会封锁记录之前的范围。除此之外，会在插入区间加入插入意向锁</p><p>  最后，今天我做了一点测试，测试的数据太多了，不方便整理，这里把测试结果放在这里，大家可以看看，和自己设想的情况一样不一样：</p><p>（注意：所有测试均在RR隔离级别下，RC隔离级别下只有记录锁，没有间隙锁，相对比较简单，大家可以自行研究）</p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个空的记录，例如id=6的记录，表中只有id=5和id=9的值，那么会话2中<strong>不能</strong>插入id=6、7、8的值，因为这个间隙已经被锁定。其中，<strong>id可以是主键或者唯一索引。</strong></p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个存在记录，例如id=5的记录，表中有id=5的值，那么会话2中<strong>可以</strong>插入id=4、6、7、8的值，间隙没有锁定。其中，<strong>id可以是主键或者唯一索引。</strong></p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个范围记录，例如id&lt;6的记录，表中有id=5的值和id=9的值，那么会话2中<strong>不能</strong>插入id=6、7、8的值，间隙被锁定。其中，<strong>id可以是主键或者唯一索引。</strong></p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个范围记录，例如id&gt;6 and id &lt;11的记录，表中有id=5的值和id=9的值，那么会话2中<strong>不能</strong>插入id=6、7、8的值以及id大于9的所有值，间隙被锁定。其中，<strong>id可以是主键或者唯一索引</strong>。</p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个空的记录，例如id=6的记录，表中有id=5的值和id=9的值，那么会话2中<strong>不能</strong>插入id=5、6、7、8的值，间隙被锁定。但是可以插入9的值，其中，<strong>id是普通索引。</strong></p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个存在记录，例如id=5的记录，表中有id=5的值和id=9的值，那么会话2中<strong>不能</strong>插入id=4、6、7、8的值，但是可以插入9的值。间隙被锁定。其中，<strong>id是普通索引。</strong></p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个范围记录，例如id&lt;6的记录，表中有id=5的值和id=9的值，那么会话2中<strong>不能</strong>插入id=4、6、7、8的值，但是可以插入9的值，间隙被锁定。其中，<strong>id是普通索引**</strong>。**</p><p><strong>RR隔离级别下</strong>，如果会话1锁定了一个范围记录，例如id&gt;6 and id&lt;11的记录，表中有id=5的值和id=9的值，那么会话2中<strong>不能</strong>插入<strong>所有值的记录，所有**</strong>间隙被锁定，类似全表锁<strong>。其中，</strong>id是普通索引<strong>**。</strong></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="关于MySQL锁的两个知识点"><a href="#关于MySQL锁的两个知识点" class="headerlink" title="关于MySQL锁的两个知识点"></a>关于MySQL锁的两个知识点</h2><h3 id="MySQL快照读和当前读"><a href="#MySQL快照读和当前读" class="headerlink" title="MySQL快照读和当前读"></a>MySQL快照读和当前读</h3><p>  当我们对数据库中的表进行select、update、delete以及insert的时候，innodb存储引擎会根据操作类型的不同来给这些操作添加具体的锁。</p><p>  在MySQL中，读操作可以分成两类：<strong>快照读</strong> (snapshot read)与<strong>当前读</strong> (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><p>这里我们首先给出快照读和当前读的例子：</p><p>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id&gt;10 lock in share mode;</span><br><span class="line">select * from table where id&gt;10 for update;</span><br><span class="line">insert into table values (…);</span><br><span class="line">update table set id=11 where id=10;</span><br><span class="line">delete from table where id&gt;10;</span><br></pre></td></tr></table></figure><p>读取之后，需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句明确指出了lock in share mode之外，也就是对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p><p>这里我们给出一个update操作过程中，mysql server和innodb存储引擎进行交互的过程如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212152912203.png" alt="image-20200212152912203"></p><p>从上图中，我们可以看出一个update操作的具体流程。当update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，update操作内部，就包含了一个当前读。同理，delete操作也一样。insert操作会稍微有些不同，简单来说，就是insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><h3 id="关于死锁"><a href="#关于死锁" class="headerlink" title="关于死锁"></a>关于死锁</h3><blockquote><p> 死锁是指两个或者两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，这两个事务将保持等待状态，无法推进下去。很明显，这是我们不想看到的。</p></blockquote><p>  从上面的概念可以看出，死锁的关键点在于互相等待，如果我们要解决死锁的问题，就要从“等待”这个关键词上面入手，如果我们将等待都转化为回滚操作，并且事务都重新开始，这种方法无疑可以避免死锁问题的产生。但是会导致数据库并发性能的降低，这样的问题也是我们无法接受的。</p><p>  为了解决这一问题，我们采用一种超时的方法进行折中进行处理，超时是指当两个事务互相等待时，当某一方的等待时间超过一个阈值，我们将它进行回滚，这样，另一个事务就能够继续进行，在innodb存储引擎中，我们使用参数innodb_lock_wait_timeout来设置超时时间，这个参数如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like "innodb_lock_wait_timeout";</span><br><span class="line">+<span class="comment">--------------------------+-------+</span></span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+<span class="comment">--------------------------+-------+</span></span><br><span class="line">| innodb_lock_wait_timeout | 50    |</span><br><span class="line">+<span class="comment">--------------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.11</span> sec)</span><br></pre></td></tr></table></figure><p>  为了加深印象，我们模拟一个死锁的现象，让大家感受一下。</p><p>  首先，要模拟死锁，程序必须并发运行，串行的方法是无法模拟死锁的，这里我们采用两个连接会话进行模拟：</p><p><strong>会话A</strong></p><p><strong>我们先开启事务，然后锁定id=3的行；</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">| id | age |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">|  1 |   5 |</span><br><span class="line">|  2 |   4 |</span><br><span class="line">|  3 |   3 |</span><br><span class="line">|  4 |   2 |</span><br><span class="line">|  5 |   1 |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">begin</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t where id=3 for update;</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">| id | age |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">|  3 |   3 |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p><strong>会话B</strong></p><p><strong>在会话B上锁定id=2的行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin</span><br><span class="line">    -&gt; ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from t where id=2 for update;</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">| id | age |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">|  2 |   4 |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>会话A</strong></p><p><strong>我们在会话A上获取id=2的记录的锁，发现无法获取，产生了等待：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=2 for update;</span><br><span class="line"><span class="comment">##产生等待</span></span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p><strong>会话B</strong></p><p>在会话A进行等待的过程中，我们在会话B上面获取id=3的记录的锁，我们发现了两个变化：</p><p>第一、会话B上输出了死锁的提示信息，如下；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=3 for update;</span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting traction</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>第二、会话A上输出了id=2的记录，也就是A会话得到了特定的资源，但是产生了9s的延迟，如下；</p><p><strong>会话A</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=2 for update;</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">| id | age |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">|  2 |   4 |</span><br><span class="line">+<span class="comment">----+-----+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">9.04</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p>  在上述操作中，会话B抛出了1213这个错误状态码，它代表事务发生了死锁，死锁的原因是会话A和B的资源进行了相互等待，但是此时我们发现会话B中抛出死锁提示信息之后会话A中立即得到了记录为2的这个资源，这其实是因为会话B中的事务发生了回滚，否则的话，会话A中的事务是不可能得到相应的资源的。</p><p>  这里又不得不提innodb的一个特性，那就是它会回滚死锁情况下的一个事务，因此当我们在程序中捕获了一个1213的错误，其实不需要我们手动进行回滚。</p><h2 id="Innodb数据页简介"><a href="#Innodb数据页简介" class="headerlink" title="Innodb数据页简介"></a>Innodb数据页简介</h2><p>  页是内存和磁盘交互的基本单位，它的大小一般是16KB，可以被分为如下几个部分：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212162043235.png" alt="image-20200212162043235"></p><p>  上次的文章里面，我们对这几个部分大概做了介绍，今天我们说说上面数据页的蓝色部分。</p><p>  该部分保存的是数据页中真正的数据记录，也就是用户存储的记录。当我们一开始生成页的时候，其实并没有蓝色的Record部分，而是随着我们不断给数据库中插入记录，才逐渐从Free Space中划分出来的空间。用示意图来描述就是：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493216093.webp" alt="img"></p><p> 如果Free Space中的数据页被分配完了，则去申请新的数据页。</p><p>为了方便理解，我们现在创建一个表进行演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(</span><br><span class="line">    -&gt;     c1 <span class="built_in">INT</span>,</span><br><span class="line">    -&gt;     c2 <span class="built_in">INT</span>,</span><br><span class="line">    -&gt;     c3 <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">    -&gt;     PRIMARY <span class="keyword">KEY</span> (c1)</span><br><span class="line">    -&gt; ) <span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure><p>现在我们给这个表里面插入几条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'a'</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>,<span class="string">'bb'</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>,<span class="string">'ccc'</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="number">5</span>,<span class="string">'dddd'</span>);</span><br></pre></td></tr></table></figure><p>我们可以把上面的数据页结构简单表示如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640.webp" alt="img"></p><p>  我们可以看到，每条记录由三个部分构成，分别是记录头、记录数据以及其他信息，其中记录头里面包含很多字段来表示该条记录的信息，这些字段我们会逐渐进行讲解。目前4条记录都已经插入到record部分了，在实际过程中这四条记录是通过链表的方式进行连接的，如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640.png" alt="img"></p><p>  在第一张图的数据页中，蓝色部分还有一部分是infimum和supermun，它们是两条伪记录，它们分别是这个数据页中”指定的”最大的记录和最小的记录。它们的作用是作为当前数据页内数据链表的首末两端。这样，数据页中的数据就可以被我们排列成下面的样子：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493216124.webp" alt="img"></p><p>  我们已经可以看到，我们的主键按照从大到小的顺序形成了一个链表，链表的首末位置分别是两条伪记录。</p><p>  当我们对数据记录中id=2的一条记录进行删除时，实际上，在数据记录链表里面发生的变化如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493216095.webp" alt="img"></p><p>  可以看出，实际上并没有删除那条记录，而是通过将头信息中的delete标识位改为1、偏移量改为0来实现的，也就是说，这条记录所占用的空间并没有还给Free Space，当下一次插入id=2的记录的时候，这块空间还可以接着使用。</p><p>  在这个过程中，我们加入了record_type字段，这两条伪记录和正常记录的区别之处在于数据记录的头信息里面的record_type字段，最小记录的record_type为2，最大记录的record为3，正常记录的record_type为0，record_type为1的记录，稍后我们会进行解释。</p><p>  到现在为止，我们已经知道了头信息中的3个字段，分别是next_record和record_type以及delete字段，next_record保存的是下一条数据记录的真是数据的偏移量，record_type代表的是数据记录的类型，delete标示的是该字段是否被删除。除此之外，我们还需要知道记录头信息里面的另外一个字段n_owned，这个字段保存的是改组内一共有多少个数据记录，在上述删除的操作中，最大记录中该字段的变化过程如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493216096.webp" alt="img"></p><p>  关于这个初始值为何是5，后续的文章中我们会说明。至此，我们已经了解到，一个数据页，大概可以描述成如下形式：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493216136.webp" alt="img"></p><h2 id="MySQL锁优化"><a href="#MySQL锁优化" class="headerlink" title="MySQL锁优化"></a>MySQL锁优化</h2><h3 id="MySQL-锁分类"><a href="#MySQL-锁分类" class="headerlink" title="MySQL 锁分类"></a>MySQL 锁分类</h3><p>当多个事务或者进程访问同一个资源的时候，为了保证数据的一致性，就需要用到锁机制。</p><p>从锁定资源的角度来看，MySQL 中的锁分为：</p><ul><li><strong>表级锁</strong></li><li><strong>行级锁</strong></li><li><strong>页面锁</strong></li></ul><p><strong>表级锁：</strong>对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 </p><p><strong>行级锁：</strong>对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>在实际开发过程中，主要会使用到表级锁和行级锁两种。既然锁是针对资源的，那么这些资源就是数据，在 MySQL 提供插件式存储引擎对数据进行存储。</p><p>插件式存储引擎的好处是，开发人员可以根据需要选择适合的存储引擎。</p><p>在众多的存储引擎中，有两种引擎被比较多的使用，他们分别是：</p><ul><li><p><strong>MyISAM 存储引擎，</strong>它不支持事务、表锁设计，支持全文索引，主要面向一些在线分析处理（OLAP）数据库应用。说白了主要就是查询数据，对数据的插入，更新操作比较少。</p></li><li><p><strong>InnoDB 存储引擎，</strong>它支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。</p><p>其特点是行锁设计、支持外键，并支持类似于 Oracle 的非锁定读，即默认读取操作不会产生锁。</p><p>简单来说，就是对数据的插入，更新操作比较多。从 MySQL 数据库 5.5.8 版本开始，InnoDB 存储引擎是默认的存储引擎。</p></li></ul><p>上面两种存储引擎在处理多进程数据操作的时候是如何表现的，就是我们接下来要讨论的问题。</p><p>为了让整个描述更加清晰，我们将表级锁和行级锁以及 MyISAM，InnoDB 存储引擎，就形成了一个 2*2 的象限。</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493478029.webp" alt="img"></p><center><em>2\</em>2 表行锁，MyISAM，InnoDB 示意图<em></em></center><br>由于 MyISAM 存储引擎不支持行级锁，实际上后面讨论的问题会围绕三个象限的讨论展开。<br><br>从内容上来看，InnoDB 作为使用最多的存储引擎遇到的问题和值得注意的地方较多，也是本文的重点。<br><br>MyISAM 存储引擎和表级锁<br><br><br><br>首先，来看第一象限的内容：<br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212160055676.png" alt="image-20200212160055676"><br><br><center>2*2 表行锁，MyISAM，InnoDB 示意图-第一象限<em></em></center><br>MyISAM 存储引擎支持表级锁，并且支持两种锁模式：<br><br>- <strong>对 MyISAM 表的读操作（共享锁），</strong>不会阻塞其他进程对同一表的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他进程的写操作。<br>- <strong>对 MyISAM 表的写操作（排他锁），</strong>会阻塞其他进程对同一表的读写操作，当该锁释放后，才会执行其他进程的读写操作。<br><br>### MyISAM 优化建议<br><br>在使用 MyISAM 存储引擎时。执行 SQL 语句，会自动为 SELECT 语句加上共享锁，为 UDI（更新，删除，插入）操作加上排他锁。<br><br>由于这个特性在多进程并发插入同一张表的时候，就会因为排他锁而进行等待。<br><br>因此可以通过配置 concurrent_insert 系统变量，来控制其并发的插入行为。<br><br><strong>①concurrent_insert=0 时，</strong>不允许并发插入。<br><br><strong>②concurrent_insert=1 时，</strong>如果 MyISAM 表中没有空洞（即表中没有被删除的行），允许一个进程读表时，另一个进程向表的尾部插入记录（MySQL 默认设置）。<br><br>&gt; 注：空洞是行记录被删除以后，只是被标记为“已删除”其存储空间没有被回收，也就是说没有被物理删除。由另外一个进程，异步对这个数据进行删除。<br>&gt;<br>&gt; 因为空间长度问题，删除以后的物理空间不能被新的记录所使用，从而形成了空洞。<br><br><br><br><strong>③concurrent_insert=2 时，</strong>无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。<br><br><br><br>如果在数据插入的时候，没有并发删除操作的话，可以尝试把 concurrent_insert 设置为 1。<br><br>反之，在数据插入的时候有删除操作且量较大时，也就是会产生“空洞”的时候，就需要把 concurrent_insert 设置为 2。<br><br>另外，当一个进程请求某个 MyISAM 表的读锁，另一个进程也请求同一表的写锁。<br><br>即使读请求先到达，写请求后到达，写请求也会插到读请求之前。因为 MySQL 的默认设置认为，写请求比读请求重要。<br><br>我们可以通过 low_priority_updates 来调节读写行为的优先级：<br><br>- 数据库以读为主时，要优先保证查询性能时，可通过 low_priority_updates=1 设置读优先级高于写优先级。<br>- 数据库以写为主时，则不用设置 low_priority_updates 参数。<br><br>### InnoDB 存储引擎和表级锁<br><br>再来看看第二象限的内容：<br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493477955.webp" alt="img"><br><br><center>2*2 表行锁，MyISAM，InnoDB 示意图-第二象限*</center><p>InnoDB 存储引擎表锁。当没有对数据表中的索引数据进行查询时，会执行表锁操作。</p><p>上面是 InnoDB 实现行锁，同时它也可以实现表锁。其方式就是意向锁（Intention Locks）。</p><p>这里介绍两种意向锁：</p><ul><li><strong>意向共享锁（IS）：</strong>事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（IX）：</strong>事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。</li></ul><blockquote><p>注：意向共享锁和意向排他锁是数据库主动加的，不需要我们手动处理。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给数据集加排他锁。</p></blockquote><p><strong>InnoDB表锁的实现方式：</strong>假设有一个表 test2，有两个字段分别是 id 和 name。</p><p>没有设置主键同时也没有设置任何索引（index）如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493478033.webp" alt="img"></p><center><em>InnoDB 表锁实现方式图</em></center><br>### InnoDB 存储引擎和行级锁<br><br>第四象限我们使用的比较多，讨论的内容也相对多些：<br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493478031.webp" alt="img"><br><br><center><em>2\</em>2 表行锁，MyISAM，InnoDB 示意图-第四象限*</center><p>InnoDB 存储引擎行锁，当数据查询时针对索引数据进行时，会使用行级锁。</p><p><strong>共享锁（S）：</strong>当一个事务读取一条记录的时候，不会阻塞其他事务对同一记录的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他事务的写操作。</p><p>例如：select … lock in share mode</p><p><strong>排他锁（X）：</strong>当一个事务对一条记录进行写操作时，会阻塞其他事务对同一表的读写操作，当该锁释放后，才会执行其他事务的读写操作。</p><p>例如：select … for update</p><p><strong>行锁的实现方式：</strong>假设有一个表 test1，有两个字段分别是 id 和 name。</p><p>id 作为主键同时也是 table 的索引（index）如下：</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155919536.png" alt="image-20200212155919536"></p><center><em>InnoDB 行锁实现方式图</em></center><p>在高并发的情况下，多个事务同时请求更新数据，由于资源被占用等待事务增多。</p><p>如此，会造成性能问题，可以通过 innodb_lock_wait_timeout 来解决。innodb_lock_wait_timeout 是事务等待获取资源的最长时间，单位为秒。如果超过时间还未分配到资源，则会返回应用失败。</p><h3 id="四种锁的兼容情况"><a href="#四种锁的兼容情况" class="headerlink" title="四种锁的兼容情况"></a>四种锁的兼容情况</h3><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155859778.png" alt="image-20200212155859778"></p><center><em>共享锁，排他锁，意向共享锁，意向排他锁兼容图例</em></center><p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务；反之， 如果两者不兼容，该事务就要等待锁释放。</p><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a><strong>间隙锁</strong></h4><p>前面谈到行锁是针对一条记录进行加锁。当对一个范围内的记录加锁的时候，我们称之为间隙锁。</p><p>当使用范围条件索引数据时，InnoDB 会对符合条件的数据索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB 也会对这个“间隙”加锁，这就是间隙锁。间隙锁和行锁合称（Next-Key锁）。</p><p>如果表中只有 11 条记录，其 id 的值分别是 1,2,…,10，11 下面的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> table_gapwhere <span class="keyword">id</span> &gt; <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这是一个范围条件的检索，InnoDB 不仅会对符合条件的 id 值为 10 的记录加锁，会对 id 大于 10 的“间隙”加锁，即使大于 10 的记录不存在，例如 12，13。</p><p><strong>InnoDB 使用间隙锁的目的：</strong></p><ul><li>一方面是为了防止幻读。对于上例，如果不使用间隙锁，其他事务插入了 id 大于 10 的任何记录，本事务再次执行 select 语句，就会发生幻读。</li><li>另一方面，也是为了满足恢复和复制的需要。</li></ul><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493478032.webp" alt="img"></p><center><em>间隙锁图</em></center><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h4><p>两个事务都需要获得对方持有的排他锁才能继续完成任务，这种互相等待对方释放资源的情况就是死锁。</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493478014.webp" alt="img"></p><center><em>死锁图</em></center><p><strong>检测死锁：</strong>InnoDB 存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p><p><strong>死锁恢复：</strong>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁。</p><p>InnoDB 方法是，将持有最少行级排他锁的事务回滚。在应用程序设计时必须考虑处理死锁，多数情况下重新执行因死锁回滚的事务即可。</p><p><strong>避免死锁：</strong></p><ul><li><p>在事务开始时，如果有记录要修改，先使用 SELECT… FOR UPDATE 语句获取锁，即使这些修改语句是在后面执行。 </p></li><li><p>在事务中，如果要更新记录，直接申请排他锁。而不是查询时申请共享锁、更新时再申请排他锁。</p><p>这样做会导致，当申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。</p><p>简单来说，如果你要更新记录要做两步操作，第一步查询，第二步更新。就不要第一步上共享锁，第二部上排他锁了，直接在第一步就上排他锁，抢占先机。</p></li><li><p>如果事务需要锁定多个表，那么尽量按照相同的顺序使用加锁语句，可以降低产生死锁的机会。</p></li><li><p>通过 SELECT … LOCK INSHARE MODE（共享锁）获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。所以，如果要对行记录进行修改，直接上排他锁。</p></li><li><p>改变事务隔离级别（事务隔离级别在后面详细说明）。</p></li></ul><h4 id="MySQL-锁定情况的查询"><a href="#MySQL-锁定情况的查询" class="headerlink" title="MySQL 锁定情况的查询"></a><strong>MySQL 锁定情况的查询</strong></h4><p>在实际开发中无法避免数据被锁的问题，那么我们可以通过哪些手段来查询锁呢？</p><p>表级锁可以通过两个变量的查询：</p><ul><li>Table_locks_immediate，产生表级锁的次数。</li><li>Table_locks_waited，数显表级锁而等待的次数。</li></ul><p>行级锁可以通过下面几个变量查询：</p><ul><li>Innodb_row_lock_current_waits，当前正在等待锁定的数量。</li><li>Innodb_row_lock_time（重要），从系统启动到现在锁定总时长。</li><li>Innodb_row_lock_time_avg（重要），每次等待所花平均时间。</li><li>Innodb_row_lock_time_max，从系统启动到现在等待最长的一次花费时间。</li><li>Innodb_row_lock_waits（重要），从系统启动到现在总共等待的次数。</li></ul><p><strong>MySQL 事务隔离级别</strong></p><p>前面讲的死锁是因为并发访问数据库造成。当多个事务同时访问数据库，做并发操作的时候会发生以下问题。</p><p><strong>脏读（dirty read），</strong>一个事务在处理过程中，读取了另外一个事务未提交的数据。未提交的数据称之为脏数据。</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155822655.png" alt="image-20200212155822655"></p><center><em>脏读例子</em></center><p><strong>不可重复读（non-repeatable read），</strong>在事务范围内，多次查询某条记录，每次得到不同的结果。</p><p>第一个事务中的两次读取数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能不一样。</p><p><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155748878.png" alt="image-20200212155748878"></p><center><em>不可重复读例子</em></center><br><strong>幻读（phantom read），</strong>是事务非独立执行时发生的一种现象。<br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155718409.png" alt="image-20200212155718409"><br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155728846.png" alt="image-20200212155728846"><br><br><center><em>幻读的例子</em></center><br>在同一时间点，数据库允许多个并发事务，同时对数据进行读写操作，会造成数据不一致性。<br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/640-1581493477920.webp" alt="img"><br><br><center><em>四种隔离级别，解决事务并发问题对照图</em></center><br>隔离性就是用来防止这种数据不一致的。事务隔离根据级别不同，从低到高包括：<br><br>- <strong>读未提交（read uncommitted）：</strong>它是最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。有脏读的可能性。<br><br>- <strong>读提交（read committed）：</strong>保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。可避免脏读的发生，但是可能会造成不可重复读。<br><br>- <strong>可重复读（repeatable read MySQL 默认方式）：</strong>多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。<br><br>- <strong>串行化（serializable）：</strong>是最可靠的事务隔离级别。“写”会加“排他锁”，“读”会加“共享锁”。<br><br>  当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，所以事务执行是串行的。可避免脏读、不可重复读、幻读。<br><br>### InnoDB 优化建议<br><br>从锁机制的实现方面来说，InnoDB 的行级锁带来的性能损耗可能比表级锁要高一点，但在并发方面的处理能力远远优于 MyISAM 的表级锁。这也是大多数公司的 MySQL 都是使用 InnoDB 模式的原因。<br><br>但是，InnoDB 也有脆弱的一面，下面提出几个优化建议供大家参考：<br><br>- 尽可能让数据检索通过索引完成，避免 InnoDB 因为无法通过索引加行锁，而导致升级为表锁的情况。换句话说就是，多用行锁，少用表锁。<br>- 加索引的时候尽量准确，避免造成不必要的锁定影响其他查询。<br>- 尽量减少给予范围的数据检索（间隙锁），避免因为间隙锁带来的影响，锁定了不该锁定的记录。<br>- 尽量控制事务的大小，减少锁定的资源量和锁定时间。<br>- 尽量使用较低级别的事务隔离，减少 MySQL 因为事务隔离带来的成本。<br><br>### 总结<br><br><br><br><img src="/2020/02/12/MySQL增删改查都会用到什么锁/image-20200212155627181.png" alt="image-20200212155627181"><br><br><center><em>MySQL 数据库锁的思维导图</em></center><p>MySQL 的锁主要分为表级锁和行级锁。MyISAM 引擎使用的是表级锁，针对表级的共享锁和排他锁，可以通过 concurrent_insert 和 low_priority_updates 参数来优化。</p><p>InnoDB 支持表锁和行锁，根据索引来判断如何选择。行锁有，行共享锁和行排他锁；表锁有，意向共享锁，意向排他锁，表锁是系统自己加上的；锁范围的是间隙锁。遇到死锁，我们如何检测，恢复以及如何避免。</p><p>MySQL 有四个事务级别分别是，<strong><em>读未提交，读提交，可重复读，串行化</em></strong>。他们的隔离级别依次升高。</p><p>通过隔离级别的设置，可以避免，脏读，不可重复读和幻读的情况。最后，对于使用比较多的 InnoDB 引擎，提出了一些优化建议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常的操作中，增删改查都会使用什么类型的锁？其实这个问题，可以分为两个方面，一方面是读，一方面是写。&lt;/p&gt;
&lt;h1 id=&quot;读（select）&quot;&gt;&lt;a href=&quot;#读（select）&quot; class=&quot;headerlink&quot; title=&quot;读（select）&quot;&gt;&lt;/a&gt;读（select）&lt;/h1&gt;&lt;p&gt;  我们先来看读的部分。读的操作，其实分为两种，分别是&lt;strong&gt;一致性读&lt;/strong&gt;和&lt;strong&gt;锁定读&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;  这里我们温习一下，一致性读其实就是利用事务的MVCC机制，来读取一份数据的快照，所以有的书上也称之为快照读，一致性读是不加锁的，其他的事务是可以对表中的数据记录进行改动的。一般情况下，常见的读，例如：&lt;/p&gt;
&lt;p&gt;select * from table；&lt;/p&gt;
&lt;p&gt;select * from table left join table2;&lt;/p&gt;
&lt;p&gt;  这种操作，在RU，RC，RR隔离级别下都是采用一直性读，不加锁的操作。这种情况下，&lt;strong&gt;读的并发可以非常高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  再来看看锁定读，如果我们的表当中有索引，我们想在读取记录的时候，获取某一条记录的锁，禁止别的事务对这条记录进行修改，那么我们可以使用下面的语句来对读取的记录加锁：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://vincentruan.github.io/categories/MySQL/"/>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://vincentruan.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="https://vincentruan.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux实用的服务异常处理指南</title>
    <link href="https://vincentruan.github.io/2020/02/12/JAVA%E5%AE%9E%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E5%8D%97/"/>
    <id>https://vincentruan.github.io/2020/02/12/JAVA%E5%AE%9E%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E5%8D%97/</id>
    <published>2020-02-12T02:49:31.000Z</published>
    <updated>2020-02-26T03:27:42.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务异常的处理流程"><a href="#服务异常的处理流程" class="headerlink" title="服务异常的处理流程"></a>服务异常的处理流程</h1><p><img src="/2020/02/12/JAVA实用的服务异常处理指南/0ce47abcae0d474bb5bf9ebc993e6ad3.jpeg" alt="img"></p><a id="more"></a><h1 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>针对应用程序，我们通常关注的是内核CPU调度器功能和性能。</p><p>线程的状态分析主要是分析线程的时间用在什么地方，而线程状态的分类一般分为：</p><p>a. on-CPU：执行中，执行中的时间通常又分为用户态时间user和系统态时间sys。<br> b. off-CPU：等待下一轮上CPU，或者等待I/O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p><p>如果大量时间花在CPU上，对CPU的剖析能够迅速解释原因；如果系统时间大量处于off-cpu状态，定位问题就会费时很多。但是仍然需要清楚一些概念：</p><ul><li>处理器</li><li>核</li><li>硬件线程</li><li>CPU内存缓存</li><li>时钟频率</li><li>每指令周期数CPI和每周期指令数IPC</li><li>CPU指令</li><li>使用率</li><li>用户时间／内核时间</li><li>调度器</li><li>运行队列</li><li>抢占</li><li>多进程</li><li>多线程</li><li>字长</li></ul><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>uptime</td><td>平均负载</td></tr><tr><td>vmstat</td><td>包括系统范围的cpu平均负载</td></tr><tr><td>mpstat</td><td>查看所有cpu核信息</td></tr><tr><td>top</td><td>监控每个进程cpu用量</td></tr><tr><td>sar -u</td><td>查看cpu信息</td></tr><tr><td>pidstat</td><td>每个进程cpu用量分解</td></tr><tr><td>perf</td><td>cpu剖析和跟踪，性能计数分析</td></tr></tbody></table><p>说明:</p><ul><li>uptime,vmstat,mpstat,top,pidstat只能查询到cpu及负载的的使用情况。</li><li>perf可以跟着到进程内部具体函数耗时情况，并且可以指定内核函数进行统计，指哪打哪。</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查看系统cpu使用情况</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">//查看所有cpu核信息</span><br><span class="line">mpstat -P ALL 1</span><br><span class="line"></span><br><span class="line">//查看cpu使用情况以及平均负载</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">//进程cpu的统计信息</span><br><span class="line">pidstat -u 1 -p pid</span><br><span class="line"></span><br><span class="line">//跟踪进程内部函数级cpu使用情况</span><br><span class="line">perf top -p pid -e cpu-clock</span><br></pre></td></tr></table></figure><h2 id="查看机器-cpu-的负载"><a href="#查看机器-cpu-的负载" class="headerlink" title="查看机器 cpu 的负载"></a>查看机器 cpu 的负载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1 |grep java|awk <span class="string">'&#123;print "VIRT:"$5,"RES:"$6,"cpu:"$9"%","mem:"$10"%"&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="查找-cpu-占用率高的线程"><a href="#查找-cpu-占用率高的线程" class="headerlink" title="查找 cpu 占用率高的线程"></a>查找 cpu 占用率高的线程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top -p 25603 -H</span><br><span class="line"><span class="built_in">printf</span> 0x%x 25842</span><br><span class="line">jstack 25603 | grep 0x64f2</span><br><span class="line">cat /proc/interrupts</span><br></pre></td></tr></table></figure><p>（1）CPU<br>（2）Memory<br>（3）IO<br>（4）Network</p><p>可以从以下几个方面监控CPU的信息：<br>（1）中断；<br>（2）上下文切换；<br>（3）可运行队列；<br>（4）CPU 利用率</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>内存是为提高效率而生，实际分析问题的时候，内存出现问题可能不只是影响性能，而是影响服务或者引起其他问题。同样对于内存有些概念需要清楚：</p><ul><li>主存</li><li>虚拟内存</li><li>常驻内存</li><li>地址空间</li><li>OOM</li><li>页缓存</li><li>缺页</li><li>换页</li><li>交换空间</li><li>交换</li><li>用户分配器libc、glibc、libmalloc和mtmalloc</li><li>LINUX内核级SLUB分配器</li></ul><h2 id="分析工具-1"><a href="#分析工具-1" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>free</td><td>缓存容量统计信息</td></tr><tr><td>vmstat</td><td>虚拟内存统计信息</td></tr><tr><td>top</td><td>监视每个进程的内存使用情况</td></tr><tr><td>pidstat</td><td>显示活动进程的内存使用统计</td></tr><tr><td>pmap</td><td>查看进程的内存映像信息</td></tr><tr><td>sar -r</td><td>查看内存</td></tr><tr><td>dtrace</td><td>动态跟踪</td></tr><tr><td>valgrind</td><td>分析程序性能及程序中的内存泄露错误</td></tr></tbody></table><p><strong>说明</strong>：</p><ul><li>free,vmstat,top,pidstat,pmap只能统计内存信息以及进程的内存使用情况。</li><li>valgrind可以分析内存泄漏问题。</li><li>dtrace动态跟踪。需要对内核函数有很深入的了解，通过D语言编写脚本完成跟踪。</li></ul><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//查看系统内存使用情况</span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line">//虚拟内存统计信息</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">//查看系统内存情况</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">//1s采集周期，获取内存的统计信息</span><br><span class="line">pidstat -p pid -r 1</span><br><span class="line"></span><br><span class="line">//查看进程的内存映像信息</span><br><span class="line">pmap -d pid</span><br><span class="line"></span><br><span class="line">//检测程序内存问题</span><br><span class="line">valgrind --tool=memcheck --leak-check=full --<span class="built_in">log</span>-file=./log.txt  ./程序名</span><br></pre></td></tr></table></figure><h2 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h2><p>free 命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment"># free</span></span><br><span class="line"></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       3266180    3250000      10000          0     201000    3002000</span><br><span class="line">-/+ buffers/cache:      47000    3213000</span><br><span class="line">Swap:      2048276      80160    1968116</span><br></pre></td></tr></table></figure></p><p>这里的默认显示单位是kb。<br>各项指标解释</p><ul><li>total:总计物理内存的大小。</li><li>used:已使用多大。</li><li>free:可用有多少。</li><li>Shared:多个进程共享的内存总额。</li><li>buffers: 磁盘缓存的大小。</li><li>cache:磁盘缓存的大小。</li><li>-/+ buffers/cached): used:已使用多大，free:可用有多少。</li><li>已用内存 = 系统used memory - buffers - cached<br>（47000 = 3250000-201000-3002000）</li><li>可用内存 = 系统free memory + buffers + cached<br>（3213000 = 10000+201000+3002000）</li></ul><h3 id="什么是buffer-cache？"><a href="#什么是buffer-cache？" class="headerlink" title="什么是buffer/cache？"></a>什么是buffer/cache？</h3><ul><li>buffer 指 Linux 内存的：Buffer cache，缓冲区缓</li><li>cache 指 Linux内存中的：Page cache，页面缓存</li></ul><p><strong>page cache</strong><br>page cache 主要用来作为<strong>文件系统上的文件数据的缓存</strong>来用，尤其是针对当进程对文件有 read／write 操作的时候。如果你仔细想想的话，作为可以映射文件到内存的系统调用：mmap是不是很自然的也应该用到 page cache？在当前的系统实现里，page cache 也被作为其它文件类型的缓存设备来用，所以事实上 page cache 也负责了大部分的块设备文件的缓存工作。</p><p><strong>buffer cache</strong><br>buffer cache 主要用来在<strong>系统对块设备进行读写</strong>的时候，对块进行数据缓存的系统来使用。这意味着某些对块的操作会使用 buffer cache 进行缓存，比如我们在格式化文件系统的时候。一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候，page cache 的内容会被改变，而 buffer cache 则可以用来将 page 标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个 page 写回，而只需要写回修改的部分即可。</p><p>在当前的内核中，page cache 是针对内存页的缓存，说白了就是，如果有内存是以page进行分配管理的，都可以使用page cache作为其缓存来管理使用。<br>当然，不是所有的内存都是以页（page）进行管理的，也有很多是针对块（block）进行管理的，这部分内存使用如果要用到 cache 功能，则都集中到buffer cache中来使用。（从这个角度出发，是不是buffer cache改名叫做block cache更好？）然而，也不是所有块（block）都有固定长度，系统上块的长度主要是根据所使用的块设备决定的，而页长度在X86上无论是32位还是64位都是4k。</p><h3 id="系统如何回收cache？"><a href="#系统如何回收cache？" class="headerlink" title="系统如何回收cache？"></a>系统如何回收cache？</h3><p>Linux内核会在内存将要耗尽的时候，触发内存回收的工作，以便释放出内存给急需内存的进程使用。一般情况下，这个操作中主要的内存释放都来自于对buffer／cache的释放。尤其是被使用更多的cache空间。既然它主要用来做缓存，只是在内存够用的时候加快进程对文件的读写速度，那么在内存压力较大的情况下，当然有必要清空释放cache，作为free空间分给相关进程使用。所以一般情况下，我们认为buffer/cache空间可以被释放，这个理解是正确的。</p><p>但是这种清缓存的工作也并不是没有成本。理解cache是干什么的就可以明白清缓存必须保证cache中的数据跟对应文件中的数据一致，才能对cache进行释放。所以伴随着cache清除的行为的，一般都是系统IO飙高。因为内核要对比cache中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。</p><p>在系统中除了内存将被耗尽的时候可以清缓存以外，我们还可以人工触发缓存清除的操作。</p><h2 id="进程内存"><a href="#进程内存" class="headerlink" title="进程内存"></a>进程内存</h2><h3 id="进程内存统计"><a href="#进程内存统计" class="headerlink" title="进程内存统计"></a>进程内存统计</h3><p>/proc/[pid]/status<br>通过/proc//status可以查看进程的内存使用情况，包括虚拟内存大小（VmSize），物理内存大小（VmRSS），数据段大小（VmData），栈的大小（VmStk），代码段的大小（VmExe），共享库的代码段大小（VmLib）等等。</p><p>cat /proc/[pid]/status</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name</span>: <span class="string">gedit /*进程的程序名*/</span></span><br><span class="line"><span class="attr">State</span>: <span class="string">S (sleeping) /*进程的状态信息,具体参见http://blog.chinaunix.net/u2/73528/showart_1106510.html*/</span></span><br><span class="line"><span class="attr">Tgid</span>: <span class="string">9744 /*线程组号*/</span></span><br><span class="line"><span class="attr">Pid</span>: <span class="string">9744 /*进程pid*/</span></span><br><span class="line"><span class="attr">PPid</span>: <span class="string">7672 /*父进程的pid*/</span></span><br><span class="line"><span class="attr">TracerPid</span>: <span class="string">0 /*跟踪进程的pid*/</span></span><br><span class="line"><span class="attr">VmPeak</span>: <span class="string">60184 kB /*进程地址空间的大小*/</span></span><br><span class="line"><span class="attr">VmSize</span>: <span class="string">60180 kB /*进程虚拟地址空间的大小reserved_vm：进程在预留或特殊的内存间的物理页*/</span></span><br><span class="line"><span class="attr">VmLck</span>: <span class="string">0 kB /*进程已经锁住的物理内存的大小.锁住的物理内存不能交换到硬盘*/</span></span><br><span class="line"><span class="attr">VmHWM</span>: <span class="string">18020 kB /*文件内存映射和匿名内存映射的大小*/</span></span><br><span class="line"><span class="attr">VmRSS</span>: <span class="string">18020 kB /*应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss)*/</span></span><br><span class="line"><span class="attr">VmData</span>: <span class="string">12240 kB /*程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据*/</span></span><br><span class="line"><span class="attr">VmStk</span>: <span class="string">84 kB /*进程在用户态的栈的大小*/</span></span><br><span class="line"><span class="attr">VmExe</span>: <span class="string">576 kB /*程序所拥有的可执行虚拟内存的大小,代码段,不包括任务使用的库 */</span></span><br><span class="line"><span class="attr">VmLib</span>: <span class="string">21072 kB /*被映像到任务的虚拟内存空间的库的大小*/</span></span><br><span class="line"><span class="attr">VmPTE</span>: <span class="string">56 kB /*该进程的所有页表的大小*/</span></span><br><span class="line"><span class="attr">Threads</span>: <span class="string">1 /*共享使用该信号描述符的任务的个数*/</span></span><br></pre></td></tr></table></figure><h3 id="JVM-内存分配"><a href="#JVM-内存分配" class="headerlink" title="JVM 内存分配"></a>JVM 内存分配</h3><p>java内存组成介绍：堆(Heap)和非堆(Non-heap)内存</p><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出JVM主要管理两种类型的内存：堆和非堆。</p><p>简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p><ol><li>JVM本身需要的内存，包括其加载的第三方库以及这些库分配的内存</li><li>NIO的DirectBuffer是分配的native memory</li><li>内存映射文件，包括JVM加载的一些JAR和第三方库，以及程序内部用到的。上面 pmap 输出的内容里，有一些静态文件所占用的大小不在Java的heap里，因此作为一个Web服务器，赶紧把静态文件从这个Web服务器中人移开吧，放到nginx或者CDN里去吧。</li><li>JIT， JVM会将Class编译成native代码，这些内存也不会少，如果使用了Spring的AOP，CGLIB会生成更多的类，JIT的内存开销也会随之变大，而且Class本身JVM的GC会将其放到Perm Generation里去，很难被回收掉，面对这种情况，应该让JVM使用ConcurrentMarkSweep GC，并启用这个GC的相关参数允许将不使用的class从Perm Generation中移除， 参数配置： -XX:+UseConcMarkSweepGC -X:+CMSPermGenSweepingEnabled -X:+CMSClassUnloadingEnabled，如果不需要移除而Perm Generation空间不够，可以加大一点： -X:PermSize=256M -X:MaxPermSize=512M</li><li>JNI，一些JNI接口调用的native库也会分配一些内存，如果遇到JNI库的内存泄露，可以使用valgrind等内存泄露工具来检测</li><li>线程栈，每个线程都会有自己的栈空间，如果线程一多，这个的开销就很明显了</li><li>jmap/jstack 采样，频繁的采样也会增加内存占用，如果你有服务器健康监控，记得这个频率别太高，否则健康监控变成致病监控了。</li></ol><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>也称”永久代” 、“非堆”，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。</p><p>运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。</p><p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p><p>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p><h2 id="JVM-内存分析"><a href="#JVM-内存分析" class="headerlink" title="JVM 内存分析"></a>JVM 内存分析</h2><h3 id="查看-JVM-堆内存情况"><a href="#查看-JVM-堆内存情况" class="headerlink" title="查看 JVM 堆内存情况"></a>查看 JVM 堆内存情况</h3><p>jmap -heap [pid]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]$ jmap -heap 837</span><br><span class="line">Attaching to process ID 837, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)//GC 方式</span><br><span class="line"></span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">   MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">   MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">   SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage://堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space://Eden区内存分布</span><br><span class="line">   capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line">   used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line">   free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line">   4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line">   capacity = 86507520 (82.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 86507520 (82.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">   free     = 19523568 (18.619125366210938MB)</span><br><span class="line">   11.337498256138392% used</span><br><span class="line"></span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><p>关于这里的几个generation网上资料一大把就不细说了，这里算一下求和可以得知前者总共给Java环境分配了644M的内存，而ps输出的VSZ和RSS分别是7.4G和2.9G，这到底是怎么回事呢？<br>前面jmap输出的内容里，MaxHeapSize 是在命令行上配的，-Xmx4096m，这个java程序可以用到的最大堆内存。<br>VSZ是指已分配的线性空间大小，这个大小通常并不等于程序实际用到的内存大小，产生这个的可能性很多，比如内存映射，共享的动态库，或者向系统申请了更多的堆，都会扩展线性空间大小，要查看一个进程有哪些内存映射，可以使用 pmap 命令来查看：<br>pmap -x [pid]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]$ pmap -x 837</span><br><span class="line">837:   java</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode   Mapping</span><br><span class="line">0000000040000000      36       4       0 r-x--  java</span><br><span class="line">0000000040108000       8       8       8 rwx--  java</span><br><span class="line">00000000418c9000   13676   13676   13676 rwx--    [ anon ]</span><br><span class="line">00000006fae00000   83968   83968   83968 rwx--    [ anon ]</span><br><span class="line">0000000700000000  527168  451636  451636 rwx--    [ anon ]</span><br><span class="line">00000007202d0000  127040       0       0 -----    [ anon ]</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">00007f55ee124000       4       4       0 r-xs-  az.png</span><br><span class="line">00007fff017ff000       4       4       0 r-x--    [ anon ]</span><br><span class="line">ffffffffff600000       4       0       0 r-x--    [ anon ]</span><br><span class="line">----------------  ------  ------  ------</span><br><span class="line">total kB         7796020 3037264 3023928</span><br></pre></td></tr></table></figure><p>这里可以看到很多anon，这些表示这块内存是由mmap分配的。</p><p>RSZ是Resident Set Size，常驻内存大小，即进程实际占用的物理内存大小， 在现在这个例子当中，RSZ和实际堆内存占用差了2.3G，这2.3G的内存组成分别为：</p><h3 id="查看-JVM-堆各个分区的内存情况"><a href="#查看-JVM-堆各个分区的内存情况" class="headerlink" title="查看 JVM 堆各个分区的内存情况"></a>查看 JVM 堆各个分区的内存情况</h3><p>jstat -gcutil [pid]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]$ jstat -gcutil 837 1000 20</span><br><span class="line">  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00  80.43  24.62  87.44  98.29   7101  119.652    40   19.719  139.371</span><br><span class="line">  0.00  80.43  33.14  87.44  98.29   7101  119.652    40   19.719  139.371</span><br></pre></td></tr></table></figure><h3 id="分析-JVM-堆内存中的对象"><a href="#分析-JVM-堆内存中的对象" class="headerlink" title="分析 JVM 堆内存中的对象"></a>分析 JVM 堆内存中的对象</h3><p><strong>查看存活的对象统计</strong><br>jmap -histo:live [pid]</p><p><strong>dump 内存</strong><br>jmap -dump:format=b,file=heapDump [pid]</p><p>然后用jhat命令可以参看<br>jhat -port 5000 heapDump<br>在浏览器中访问：<a href="http://localhost:5000/" target="_blank" rel="noopener">http://localhost:5000/</a> 查看详细信息</p><h1 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h1><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像1天和1分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。</p><p>在理解磁盘IO之前，同样我们需要理解一些概念，例如：</p><ul><li>文件系统</li><li>VFS</li><li>文件系统缓存</li><li>页缓存page cache</li><li>缓冲区高速缓存buffer cache</li><li>目录缓存</li><li>inode</li><li>inode缓存</li><li>noop调用策略</li></ul><h2 id="分析工具-2"><a href="#分析工具-2" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>iostat</td><td>磁盘详细统计信息</td></tr><tr><td>iotop</td><td>按进程查看磁盘IO的使用情况</td></tr><tr><td>pidstat</td><td>按进程查看磁盘IO的使用情况</td></tr><tr><td>perf</td><td>动态跟踪工具</td></tr></tbody></table><h2 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//查看系统io信息</span><br><span class="line">iotop</span><br><span class="line"></span><br><span class="line">//统计io详细信息</span><br><span class="line">iostat -d -x -k 1 10</span><br><span class="line"></span><br><span class="line">//查看进程级io的信息</span><br><span class="line">pidstat -d 1 -p  pid</span><br><span class="line"></span><br><span class="line">//查看系统IO的请求，比如可以在发现系统IO异常时，可以使用该命令进行调查，就能指定到底是什么原因导致的IO异常</span><br><span class="line">perf record -e block:block_rq_issue -ag</span><br><span class="line">^C</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h2><p>网络的监测是所有 Linux 子系统里面最复杂的，有太多的因素在里面，比如：延迟、阻塞、冲突、丢包等，更糟的是与 Linux 主机相连的路由器、交换机、无线信号都会影响到整体网络并且很难判断是因为 Linux 网络子系统的问题还是别的设备的问题，增加了监测和判断的复杂度。现在我们使用的所有网卡都称为自适应网卡，意思是说能根据网络上的不同网络设备导致的不同网络速度和工作模式进行自动调整。</p><h2 id="分析工具-3"><a href="#分析工具-3" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>ping</td><td>主要透过 ICMP 封包 来进行整个网络的状况报告</td></tr><tr><td>traceroute</td><td>用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具</td></tr><tr><td>netstat</td><td>用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况</td></tr><tr><td>ss</td><td>可以用来获取socket统计信息，而且比netstat更快速更高效</td></tr><tr><td>host</td><td>可以用来查出某个主机名的 IP,跟nslookup作用一样</td></tr><tr><td>tcpdump</td><td>是以包为单位进行输出的，阅读起来不是很方便</td></tr><tr><td>tcpflow</td><td>是面向tcp流的, 每个tcp传输会保存成一个文件,很方便的查看</td></tr><tr><td>sar -n DEV</td><td>网卡流量情况</td></tr><tr><td>sar -n SOCK</td><td>查询网络以及tcp，udp状态信息</td></tr></tbody></table><h2 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//显示网络统计信息</span><br><span class="line">netstat -s</span><br><span class="line"></span><br><span class="line">//显示当前UDP连接状况</span><br><span class="line">netstat -nu</span><br><span class="line"></span><br><span class="line">//显示UDP端口号的使用情况</span><br><span class="line">netstat -apu</span><br><span class="line"></span><br><span class="line">//统计机器中网络连接各个状态个数</span><br><span class="line">netstat -a | awk <span class="string">'/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</span></span><br><span class="line"></span><br><span class="line">//显示TCP连接</span><br><span class="line">ss -t -a</span><br><span class="line"></span><br><span class="line">//显示sockets摘要信息</span><br><span class="line">ss -s</span><br><span class="line"></span><br><span class="line">//显示所有udp sockets</span><br><span class="line">ss -u -a</span><br><span class="line"></span><br><span class="line">//tcp,etcp状态</span><br><span class="line">sar -n TCP,ETCP 1</span><br><span class="line"></span><br><span class="line">//查看网络IO</span><br><span class="line">sar -n DEV 1</span><br><span class="line"></span><br><span class="line">//抓包以包为单位进行输出</span><br><span class="line">tcpdump -i eth1 host 192.168.1.1 and port 80 </span><br><span class="line"></span><br><span class="line">//抓包以流为单位显示数据内容</span><br><span class="line">tcpflow -cp host 192.168.1.1</span><br></pre></td></tr></table></figure><h1 id="服务指标"><a href="#服务指标" class="headerlink" title="服务指标"></a>服务指标</h1><h2 id="响应时间-RT"><a href="#响应时间-RT" class="headerlink" title="响应时间(RT)"></a>响应时间(RT)</h2><p>响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。</p><p>对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。</p><h2 id="吞吐量-Throughput"><a href="#吞吐量-Throughput" class="headerlink" title="吞吐量(Throughput)"></a>吞吐量(Throughput)</h2><p>吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。</p><p>对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。</p><h2 id="并发用户数"><a href="#并发用户数" class="headerlink" title="并发用户数"></a>并发用户数</h2><p>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。</p><h2 id="QPS每秒查询率-Query-Per-Second"><a href="#QPS每秒查询率-Query-Per-Second" class="headerlink" title="QPS每秒查询率(Query Per Second)"></a>QPS每秒查询率(Query Per Second)</h2><p>每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p>从以上概念来看吞吐量和响应时间是衡量系统性能的重要指标，QPS虽然和吞吐量的计量单位不同，但应该是成正比的，任何一个指标都可以含量服务器的并行处理能力。当然Throughput更关心数据量，QPS更关心处理笔数。</p><h2 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h2><p>CPU Load Average &lt; CPU个数 <em>核数</em> 0.7</p><p><strong>Context Switch Rate</strong><br>就是Process（Thread）的切换，如果切换过多，会让CPU忙于切换，也会导致影响吞吐量。《高性能服务器架构 》这篇文章的第2节就是说的是这个问题的。究竟多少算合适？google了一大圈，没有一个确切的解释。Context Switch大体上由两个部分组成：中断和进程(包括线程)切换，一次中断（Interrupt）会引起一次切换，进程（线程）的创建、激活之类的也会引起一次切换。CS的值也和TPS（Transaction Per Second）相关的，假设每次调用会引起N次CS，那么就可以得出</p><p>Context Switch Rate = Interrupt Rate + TPS* N</p><p>CSR减掉IR，就是进程/线程的切换，假如主进程收到请求交给线程处理，线程处理完毕归还给主进程，这里就是2次切换。也可以用CSR、IR、TPS的值代入公式中，得出每次事物导致的切换数。因此，要降低CSR，就必须在每个TPS引起的切换上下功夫，只有N这个值降下去，CSR就能降低，理想情况下N=0，但是无论如何如果N &gt;= 4，则要好好检查检查。另外网上说的CSR&lt;5000，我认为标准不该如此单一。</p><p>这三个指标在 LoadRunner 中可以监控到；另外，在 linux 中，也可以用 vmstat 查看r（Load Arerage），in（Interrupt）和cs（Context Switch）</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>uptime</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uptime</span><br><span class="line">  08:21:34 up 36 min,  2 users,  load average: 0.00, 0.00, 0.00</span><br><span class="line"> </span><br><span class="line"><span class="comment">#当前服务器时间：    08:21:34</span></span><br><span class="line"><span class="comment">#当前服务器运行时长  36 min</span></span><br><span class="line"><span class="comment">#当前用户数          2 users</span></span><br><span class="line"><span class="comment">#当前的负载均衡      load average  0.00, 0.00, 0.00，分别取1min,5min,15min的均值</span></span><br></pre></td></tr></table></figure><ul><li><p>dmesg</p><p>dmesg命令用于显示开机信息。</p><p>kernel会将开机信息存储在ring buffer中。您若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。</p><p><strong>语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg [-cn][-s &lt;缓冲区大小&gt;]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>-c 　显示信息后，清除ring buffer中的内容。</li><li>-s&lt;缓冲区大小&gt; 　预设置为8196，刚好等于ring buffer的大小。</li><li>-n 　设置记录信息的层级。</li></ul></li><li><p>top<br>查看进程活动状态以及一些系统状况</p></li><li><p>vmstat<br>查看系统状态、硬件和系统信息等</p></li><li><p>iostat<br>查看CPU 负载，硬盘状况</p></li><li><p>sar<br>综合工具，查看系统状况</p></li><li><p>mpstat<br>查看多处理器状况</p></li><li><p>netstat<br>查看网络状况</p></li><li><p>iptraf<br>实时网络状况监测</p></li><li><p>tcpdump<br>抓取网络数据包，详细分析</p></li><li><p>mpstat<br>查看多处理器状况</p></li><li><p>tcptrace<br>数据包分析工具</p></li><li><p>netperf<br>网络带宽工具</p></li><li><p>dstat<br>综合工具，综合了 vmstat, iostat, ifstat, netstat 等多个信息</p></li></ul><h1 id="系统负载"><a href="#系统负载" class="headerlink" title="系统负载"></a>系统负载</h1><h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><p>Load 就是对计算机干活多少的度量（WikiPedia：the system Load is a measure of the amount of work that a compute system is doing）简单的说是进程队列的长度。Load Average 就是一段时间（1分钟、5分钟、15分钟）内平均Load。</p><h2 id="分析工具-4"><a href="#分析工具-4" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>查看系统负载情况</td></tr><tr><td>uptime</td><td>查看系统负载情况</td></tr><tr><td>strace</td><td>统计跟踪内核态信息</td></tr><tr><td>vmstat</td><td>查看负载情况</td></tr><tr><td>dmesg</td><td>查看内核日志信息</td></tr></tbody></table><h2 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看负载情况</span></span><br><span class="line">uptime</span><br><span class="line"></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">vmstat</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计系统调用耗时情况</span></span><br><span class="line">strace -<span class="built_in">c</span> -p pid</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟踪指定的系统操作例如epoll_wait</span></span><br><span class="line">strace -<span class="type">T</span> -e epoll_wait -p pid</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看内核日志信息</span></span><br><span class="line">dmesg</span><br></pre></td></tr></table></figure><h1 id="实战场景一"><a href="#实战场景一" class="headerlink" title="实战场景一"></a>实战场景一</h1><p>某Java服务（假设PID=10765）出现了OOM，最常见的原因为：</p><ul><li>有可能是内存分配确实过小，而正常业务使用了大量内存</li><li>某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽</li><li>某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接</li></ul><p>更具体的，可以使用以下工具逐一排查。</p><h2 id="确认是不是内存本身就分配过小"><a href="#确认是不是内存本身就分配过小" class="headerlink" title="确认是不是内存本身就分配过小"></a>确认是不是内存本身就分配过小</h2><blockquote><p>方法：jmap -heap 10765</p></blockquote><p><img src="/2020/02/12/JAVA实用的服务异常处理指南/640-1582687536117.webp" alt="img"></p><p>如上图，可以查看新生代，老生代堆内存的分配大小以及使用情况，看是否本身分配过小。</p><h2 id="找到最耗内存的对象"><a href="#找到最耗内存的对象" class="headerlink" title="找到最耗内存的对象"></a>找到最耗内存的对象</h2><blockquote><p>方法：jmap -histo:live 10765 | more</p></blockquote><p><img src="/2020/02/12/JAVA实用的服务异常处理指南/640-1582687644456.jpg" alt="img"></p><p>如上图，输入命令后，会以表格的形式显示存活对象的信息，并按照所占内存大小排序：</p><ul><li><strong>实例数</strong></li><li><strong>所占内存大小</strong></li><li><strong>类名</strong></li></ul><p>是不是很直观？对于实例数较多，占用内存大小较多的实例/类，相关的代码就要针对性review了。</p><p>上图中占内存最多的对象是RingBufferLogEvent，共占用内存18M，属于正常使用范围。</p><p>如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放。例如：</p><ul><li>申请完资源后，未调用close()或dispose()释放资源</li><li>消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多</li></ul><p><em>ps：线上执行该命令会强制执行一次fgc。另外还可以dump内存进行分析。</em></p><h2 id="确认是否是资源耗尽"><a href="#确认是否是资源耗尽" class="headerlink" title="确认是否是资源耗尽"></a>确认是否是资源耗尽</h2><p>工具：</p><ul><li>pstree</li><li>netstat</li></ul><p>查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM。</p><p>这里介绍另一种方法，通过</p><ul><li>/proc/${PID}/fd</li><li>/proc/${PID}/task</li></ul><p>可以分别查看句柄详情和线程数。</p><p>例如，某一台线上服务器的sshd进程PID是9339，查看</p><ul><li>ll /proc/9339/fd</li><li>ll /proc/9339/task</li></ul><p><img src="/2020/02/12/JAVA实用的服务异常处理指南/640-1582687655625.webp" alt="img"></p><p>如上图，sshd共占用了四个句柄</p><ul><li>0 -&gt; 标准输入</li><li>1 -&gt; 标准输出</li><li>2 -&gt; 标准错误输出</li><li>3 -&gt; socket（容易想到是监听端口）</li></ul><p>sshd只有一个主线程PID为9339，并没有多线程。</p><p>所以，只要</p><ul><li>ll /proc/${PID}/fd | wc -l</li><li>ll /proc/${PID}/task | wc -l （效果等同pstree -p | wc -l）</li></ul><p>就能知道进程打开的句柄数和线程数。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://tmq.qq.com/2016/07/it-is-necessary-to-know-the-background-performance-test/" target="_blank" rel="noopener">http://tmq.qq.com/2016/07/it-is-necessary-to-know-the-background-performance-test/</a></li><li><a href="https://www.ibm.com/developerworks/java/library/j-nativememory-linux/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/java/library/j-nativememory-linux/</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/index-137495.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/index-137495.html</a></li><li><a href="http://www.hollischuang.com/archives/303" target="_blank" rel="noopener">http://www.hollischuang.com/archives/303</a></li><li><a href="https://www.jianshu.com/p/0bbac570fa4c" target="_blank" rel="noopener">https://www.jianshu.com/p/0bbac570fa4c</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;服务异常的处理流程&quot;&gt;&lt;a href=&quot;#服务异常的处理流程&quot; class=&quot;headerlink&quot; title=&quot;服务异常的处理流程&quot;&gt;&lt;/a&gt;服务异常的处理流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/12/JAVA实用的服务异常处理指南/0ce47abcae0d474bb5bf9ebc993e6ad3.jpeg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://vincentruan.github.io/categories/Linux/"/>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/tags/Java/"/>
    
      <category term="Linux" scheme="https://vincentruan.github.io/tags/Linux/"/>
    
      <category term="异常处理" scheme="https://vincentruan.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础概念简述</title>
    <link href="https://vincentruan.github.io/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%AE%80%E8%BF%B0/"/>
    <id>https://vincentruan.github.io/2020/02/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%AE%80%E8%BF%B0/</id>
    <published>2020-02-11T13:35:14.000Z</published>
    <updated>2020-02-25T15:09:15.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>大部分操作系统提供了特定的基础概念和抽象，例如进程、地址空间、文件等，它们是需要理解的核心内容。下面我们会简要介绍一些基本概念，为了说明这些概念，我们会不时的从 <code>UNIX</code> 中提出示例，相同的示例也会存在于其他系统中，我们后面会进行介绍。</p><a id="more"></a><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统一个很关键的概念就是 <code>进程(Process)</code>。进程的本质就是操作系统执行的一个程序。与每个进程相关的是<code>地址空间(address space)</code>，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。地址空间中存放有可执行程序，程序所需要的数据和它的栈。与每个进程相关的还有资源集，通常包括<code>寄存器(registers)</code>（寄存器一般包括<code>程序计数器(program counter)</code>和<code>堆栈指针(stack pointer)</code>）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。你可以把进程看作是容纳运行一个程序所有信息的一个容器。</p><p>对进程建立一种直观感觉的方式是考虑建立一种多程序的系统。考虑下面这种情况：用户启动一个视频编辑程序，指示它按照某种格式转换视频，然后再去浏览网页。同时，一个检查电子邮件的后台进程被唤醒并开始运行，这样，我们目前就会有三个活动进程：视频编辑器、Web 浏览器和电子邮件接收程序。操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于过去一两秒钟程序用完了 CPU 分配的时间片，而 CPU 转而运行另外的程序。</p><p>像这样暂时中断进程后，下次应用程序在此启动时，必须要恢复到与中断时刻相同的状态，这在我们用户看起来是习以为常的事情，但是操作系统内部却做了巨大的事情。<strong>这就像和足球比赛一样，一场完美精彩的比赛是可以忽略裁判的存在的</strong>。这也意味着在挂起时该进程的所有信息都要被保存下来。例如，进程可能打开了多个文件进行读取。与每个文件相关联的是提供当前位置的指针（即下一个需要读取的字节或记录的编号）。当进程被挂起时，必须要保存这些指针，以便在重新启动进程后执行的 <code>read</code>调用将能够正确的读取数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为 <code>进程表(process table)</code>，进程表是数组或者链表结构，当前存在每个进程都要占据其中的一项。</p><p>所以，一个挂起的进程包括：进程的地址空间（往往称作<code>磁芯映像</code>， core image，纪念过去的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后启动该进程所需要的许多其他信息）。</p><p>与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用。考虑一个典型的例子，有一个称为 <code>命令解释器(command interpreter)</code> 或 <code>shell</code> 的进程从终端上读取命令。此时，用户刚键入一条命令要求编译一个程序。shell 必须先创建一个新进程来执行编译程序，当编译程序结束时，它执行一个系统调用来终止自己的进程。</p><p>如果一个进程能够创建一个或多个进程（称为<code>子进程</code>），而且这些进程又可以创建子进程，则很容易找到进程数，如下所示</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNDgwNDc2MS05Mjg5OTEzMTUucG5n.jpg" alt="img"></p><p>上图表示一个进程树的示意图，进程 A 创建了两个子进程 B 和进程 C，子进程 B 又创建了三个子进程 D、E、F。</p><p>合作完成某些作业的相关进程经常需要彼此通信来完成作业，这种通信称为<code>进程间通信(interprocess communication)</code>。我们在后面会探讨进程间通信。</p><p>其他可用的进程系统调用包括：申请更多的内存（或释放不再需要的内存），等待一个子进程结束，用另一个程序覆盖该程序。</p><p>有时，需要向一个正在运行的进程传递信息，而该进程并没有等待接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进行通信。为了保证一条消息或消息的应答不丢失。发送者要求它所在的操作系统在指定的若干秒后发送一个通知，这样如果对方尚未收到确认消息就可以进行重新发送。在设定该定时器后，程序可以继续做其他工作。</p><p>在限定的时间到达后，操作系统会向进程发送一个 <code>警告信号(alarm signal)</code>。这个信号引起该进程暂时挂起，无论该进程正在做什么，系统将其寄存器的值保存到堆栈中，并开始重新启动一个特殊的信号处理程，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以通过各种原因产生。许多由硬件检测出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。</p><p>系统管理器授权每个进程使用一个给定的 <code>UID(User IDentification)</code>。每个启动的进程都会有一个操作系统赋予的 UID，子进程拥有与父进程一样的 UID。用户可以是某个组的成员，每个组也有一个 <code>GID(Group IDentification)</code>。</p><p>在 UNIX 操作系统中，有一个 UID 是 <code>超级用户(superuser)</code>，或者 Windows 中的<code>管理员(administrator)</code>，它具有特殊的权利，可以违背一些保护规则。在大型系统中，只有系统管理员掌握着那些用户可以称为超级用户。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>每台计算机都有一些主存用来保存正在执行的程序。在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中。为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存。</p><p>复杂一些的操作系统会允许多个应用程序同时装入内存中运行。为了防止应用程序之间相互干扰（包括操作系统），需要有某种保护机制。虽然此机制是在硬件中实现，但却是由操作系统控制的。</p><p>上述观点涉及对计算机主存的管理和保护。另一种同等重要并与存储器有关的内容是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p><p>但是，在许多 32 位或 64 位地址的计算机中，分别有 2^32 或 2^64 字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那该怎么处理？在早期的计算机中是无法处理的。但是现在有了一种<code>虚拟内存</code>的技术，正如前面讲到过的，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>几乎所有操作系统都支持的另一个关键概念就是文件系统。如前所述，操作系统的一项主要功能是屏蔽磁盘和其他 I/O 设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型。<strong>创建文件、删除文件、读文件和写文件</strong> 都需要系统调用。在文件可以读取之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文件，有关的系统调用则用于完成这类操作。</p><p>为了提供保存文件的地方，大多数个人计算机操作系统都有<code>目录(directory)</code> 的概念，从而可以把文件分组。比如，学生可以给每个课程都创建一个目录，用于保存该学科的资源，另一个目录可以存放电子邮件，再有一个目录可以存放万维网主页。这就需要系统调用创建和删除目录、将已有文件放入目录中，从目录中删除文件等。目录项可以是文件或者目录，目录和目录之间也可以嵌套，这样就产生了文件系统</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTY0MjkzNS0zMTEyNDY1NDQucG5n.jpg" alt="img"></p><p>进程和文件层次都是以树状的结构组织，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件系统的树状结构要深一些，通常会到四层甚至五层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在很长时间。进程和文件在权限保护方面也是有区别的。一般来说，父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也能访问该文件。</p><p>目录层结构中的每一个文件都可以通过从目录的顶部即 <code>根目录(Root directory)</code> 开始的<code>路径名(path name)</code> 来确定。绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用斜杠分隔符分开，在上面的大学院系文件系统中，文件 CS101 的路径名是 <code>/Faculty/Prof.Brown/Courses/CS101</code>。最开始的斜杠分隔符代表的是<code>根目录 /</code>，也就是文件系统的绝对路径。</p><blockquote><p>出于历史原因，Windows 下面的文件系统以 <code>\</code> 来作为分隔符，但是 Linux 会以 <code>/</code> 作为分隔符。</p></blockquote><p>在上面的系统中，每个进程会有一个 <code>工作目录(working directory)</code>，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下寻找。如果 <code>/Faculty/Prof.Brown</code> 是工作目录，那么 <code>/Courses/CS101</code> 与上面给定的绝对路径名表示的是同一个文件。进程可以通过使用系统调用指定新的工作目录，从而变更其工作目录。</p><p>在读写文件之前，首先需要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作<code>文件描述符(file descriptor)</code>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p><p>在 UNIX 中，另一个重要的概念是 <code>特殊文件(special file)</code>。提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可以通过同样的系统调用进行读写。特殊文件有两种，一种是<code>块儿特殊文件(block special file)</code> 和 <code>字符特殊文件(character special file)</code>。块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读取第4块，程序可以直接访问设备的第4块而不必考虑存放在该文件的文件系统结构。类似的，字符特殊文件用于打印机、调制解调器和其他接受或输出字符流的设备。按照惯例，特殊文件保存在 <code>/dev</code> 目录中。例如，/devv/lp 是打印机。</p><p>还有一种与进程和文件相关的特性是管道，<code>管道(pipe)</code> 是一种虚文件，他可以连接两个进程</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTY1MjEwMy0zNzQ4Nzc5NzYucG5n.jpg" alt="img"></p><p>如果 A 和 B 希望通过管道对话，他们必须提前设置管道。当进程 A 相对进程 B 发送数据时，它把数据写到管道上，相当于管道就是输出文件。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>计算机中含有大量的信息，用户希望能够对这些信息中有用而且重要的信息加以保护，这些信息包括电子邮件、商业计划等，管理这些信息的安全性完全依靠操作系统来保证。例如，文件提供授权用户访问。</p><p>比如 UNIX 操作系统，UNIX 操作系统通过对每个文件赋予一个 9 位二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个位子段，一个用于所有者，一个用于与所有者同组（用户被系统管理员划分成组）的其他成员，一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是著名的 <code>rwx位</code>。例如，保护代码<code>rwxr-x--x</code> 的含义是所有者可以读、写或执行该文件，其他的组成员可以读或执行（但不能写）此文件、而其他人可以执行（但不能读和写）该文件。</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>操作系统是执行系统调用的代码。编辑器、编译器、汇编程序、链接程序、使用程序以及命令解释符等，尽管非常重要，非常有用，但是它们确实不是操作系统的组成部分。下面我们着重介绍一下 UNIX 下的命令提示符，也就是 <code>shell</code>，shell 虽然有用，但它也不是操作系统的一部分，然而它却能很好的说明操作系统很多特性，下面我们就来探讨一下。</p><p>shell 有许多种，例如 <strong>sh、csh、ksh 以及 bash</strong>等，它们都支持下面这些功能，最早起的 shell 可以追溯到 sh</p><p>用户登录时，会同时启动一个 shell，它以终端作为标准输入和标准输出。首先显示<code>提示符(prompt)</code>，它可能是一个<code>美元符号($)</code>，提示用户 shell 正在等待接收命令，假如用户输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure><p>shell 会创建一个子进程，并运行 date 做为子进程。在该子进程运行期间，shell 将等待它结束。在子进程完成时，shell 会显示提示符并等待下一行输入。</p><p>用户可以将标准输出重定向到一个文件中，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date &gt; file</span><br></pre></td></tr></table></figure><p>同样的，也可以将标准输入作为重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort &lt;file1&gt; file2</span><br></pre></td></tr></table></figure><p>这会调用 sort 程序来接收 file1 的内容并把结果输出到 file2。</p><p>可以将一个应用程序的输出通过管道作为另一个程序的输入，因此有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 file3 | sort &gt; /dev/lp</span><br></pre></td></tr></table></figure><p>这会调用 cat 应用程序来合并三个文件，将其结果输送到 sort 程序中并按照字典进行排序。sort 应用程序又被重定向到 /dev/lp ，显然这是一个打印操作。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>我们已经可以看到操作系统提供了两种功能：为用户提供应用程序抽象和管理计算机资源。对于大部分在应用程序和操作系统之间的交互主要是应用程序的抽象，例如创建、写入、读取和删除文件。计算机的资源管理对用户来说基本上是透明的。因此，用户程序和操作系统之间的接口主要是处理抽象。为了真正理解操作系统的行为，我们必须仔细的分析这个接口。</p><p>多数现代操作系统都有功能相同但是细节不同的系统调用，引发操作系统的调用依赖于计算机自身的机制，而且必须用汇编代码表达。<strong>任何单 CPU 计算机一次执行执行一条指令</strong>。如果一个进程在用户态下运行用户程序，例如从文件中读取数据。那么如果想要把控制权交给操作系统控制，那么必须执行一个异常指令或者系统调用指令。操作系统紧接着需要参数检查找出所需要的调用进程。操作系统紧接着进行参数检查找出所需要的调用进程。然后执行系统调用，把控制权移交给系统调用下面的指令。大致来说，系统调用就像是执行了一个特殊的过程调用，但是只有<strong>系统调用能够进入内核态而过程调用则不能进入内核态</strong>。</p><p>为了能够了解具体的调用过程，下面我们以 <code>read</code> 方法为例来看一下调用过程。像上面提到的那样，会有三个参数，第一个参数是指定文件、第二个是指向缓冲区、第三个参数是给定需要读取的字节数。就像几乎所有系统调用一样，它通过使用与系统调用相同的名称来调用一个函数库，从而从C程序中调用：read。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="built_in">read</span>(fd,buffer,nbytes);</span><br></pre></td></tr></table></figure><p>系统调用在 count 中返回实际读出的字节数。这个值通常与 nbytes 相同，但也可能更小。比如在读过程中遇到了文件尾的情况。</p><p>如果系统调用不能执行，不管是因为无效的参数还是磁盘错误，count 的值都会被置成 -1，然后在全局变量 <code>errno</code> 中放入错误信号。程序应该进场检查系统调用的结果以了解是否出错。</p><p>系统调用是通过一系列的步骤实现的，为了更清楚的说明这个概念，我们还以 read 调用为例，在准备系统调用前，首先会把参数压入堆栈，如下所示</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTcwNzc2OC01ODY3NTgxNzUucG5n.jpg" alt="img"></p><p>C 和 C++ 编译器使用逆序（必须把第一个参数赋值给 printf(格式字符串)，放在堆栈的顶部）。第一个参数和第三个参数都是值调用，但是第二个参数通过引用传递，即传递的是缓冲区的地址（由 &amp; 指示），而不是缓冲的内容。然后是 C 调用系统库的 read 函数，这也是第四步。</p><p>在由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器（第五步）。然后执行一个 <code>TRAP</code> 指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行第六步。TRAP 指令实际上与过程调用指令非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。</p><p>TRAP 指令与过程调用指令存在两个方面的不同</p><ul><li>TRAP 指令会改变操作系统的状态，由用户态切换到内核态，而过程调用不改变模式</li><li>其次，TRAP 指令不能跳转到任意地址上。根据机器的体系结构，要么跳转到一个单固定地址上，或者指令中有一 8 位长的字段，它给定了内存中一张表格的索引，这张表格中含有跳转地址，然后跳转到指定地址上。</li></ul><p>跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后<code>dispatch</code>给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成第七步。此时，系统调用处理器运行第八步，一旦系统调用处理器完成工作，控制权会根据 TRAP 指令后面的指令中返回给函数调用库第九步。这个过程接着以通常的过程调用返回的方式，返回到客户应用程序，这是第十步。然后调用完成后，操作系统还必须清除用户堆栈，然后增加<code>堆栈指针(increment stackpointer)</code>，用来清除调用 read 之前压入的参数。从而完成整个 read 调用过程。</p><p>在上面的第九步中我们说道，控制可能返回 TRAP 指令后面的指令，把控制权再移交给调用者这个过程中，系统调用会发生阻塞，从而避免应用程序继续执行。这么做是有原因的。例如，如果试图读键盘，此时并没有任何输入，那么调用者就必须被阻塞。在这种情形下，操作系统会检查是否有其他可以运行的进程。这样，当有用户输入 时候，进程会提醒操作系统，然后返回第 9 步继续运行。</p><p>下面，我们会列出一些常用的 <code>POSIX</code> 系统调用，POSIX 系统调用大概有 100 多个，它们之中最重要的一些调用见下表</p><p><strong>进程管理</strong></p><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>pid = fork()</td><td>创建与父进程相同的子进程</td></tr><tr><td>pid = waitpid(pid, &amp;statloc,options)</td><td>等待一个子进程终止</td></tr><tr><td>s = execve(name,argv,environp)</td><td>替换一个进程的核心映像</td></tr><tr><td>exit(status)</td><td>终止进程执行并返回状态</td></tr></tbody></table><p><strong>文件管理</strong></p><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>fd = open(file, how,…)</td><td>打开一个文件使用读、写</td></tr><tr><td>s = close(fd)</td><td>关闭一个打开的文件</td></tr><tr><td>n = read(fd,buffer,nbytes)</td><td>把数据从一个文件读到缓冲区中</td></tr><tr><td>n = write(fd,buffer,nbytes)</td><td>把数据从缓冲区写到一个文件中</td></tr><tr><td>position = iseek(fd,offset,whence)</td><td>移动文件指针</td></tr><tr><td>s = stat(name,&amp;buf)</td><td>取得文件状态信息</td></tr></tbody></table><p><strong>目录和文件系统管理</strong></p><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>s = mkdir(nname,mode)</td><td>创建一个新目录</td></tr><tr><td>s = rmdir(name)</td><td>删去一个空目录</td></tr><tr><td>s = link(name1,name2)</td><td>创建一个新目录项 name2,并指向 name1</td></tr><tr><td>s = unlink(name)</td><td>删去一个目录项</td></tr><tr><td>s = mount(special,name,flag)</td><td>安装一个文件系统</td></tr><tr><td>s = umount(special)</td><td>卸载一个文件系统</td></tr></tbody></table><p><strong>其他</strong></p><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>s = chdir(dirname)</td><td>改变工作目录</td></tr><tr><td>s = chmod(name,mode)</td><td>修改一个文件的保护位</td></tr><tr><td>s = kill(pid, signal)</td><td>发送信号给进程</td></tr><tr><td>seconds = time(&amp;seconds)</td><td>获取从 1970 年1月1日至今的时间</td></tr></tbody></table><p>上面的系统调用参数中有一些公共部分，例如 pid 系统进程 id，fd 是文件描述符，n 是字节数，position 是在文件中的偏移量、seconds 是流逝时间。</p><p>从宏观角度上看，这些系统调所提供的服务确定了多数操作系统应该具有的功能，下面分别来对不同的系统调用进行解释</p><h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><p>在 UNIX 中，<code>fork</code> 是唯一可以在 POSIX 中创建进程的途径，它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。在 fork 之后，原有进程以及副本（父与子）就分开了。在 fork 过程中，所有的变量都有相同的值，虽然父进程的数据通过复制给子进程，但是后续对其中任何一个进程的修改不会影响到另外一个。fork 调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的 <code>进程标识符(Process IDentified,PID)</code>。使用返回的 PID，就可以看出来哪个是父进程和子进程。</p><p>在多数情况下， 在 fork 之后，子进程需要执行和父进程不一样的代码。从终端读取命令，创建一个子进程，等待子进程执行命令，当子进程结束后再读取下一个输入的指令。为了等待子进程完成，父进程需要执行 <code>waitpid</code> 系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个比较老的子进程。当 waitpid 完成后，会将第二个参数 <code>statloc</code> 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立刻返回。</p><p>那么 shell 该如何使用 fork 呢？在键入一条命令后，shell 会调用 fork 命令创建一个新的进程。这个子进程会执行用户的指令。通过使用 <code>execve</code>系统调用可以实现系统执行，这个系统调用会引起整个核心映像被一个文件所替代，该文件由第一个参数给定。下面是一个简化版的例子说明 fork、waitpid 和 execve 的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;<span class="comment">/* 一直循环下去 */</span></span><br><span class="line">type_prompt(); <span class="comment">/* 在屏幕上显示提示符 */</span></span><br><span class="line">read_command(command,parameters) <span class="comment">/* 从终端读取输入 */</span></span><br><span class="line"><span class="keyword">if</span>(fork() != <span class="number">0</span>)&#123; <span class="comment">/* fork 子进程 */</span></span><br><span class="line"><span class="comment">/* 父代码 */</span></span><br><span class="line">waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);<span class="comment">/* 等待子进程执行完毕 */</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">/* 子代码 */</span></span><br><span class="line">execve(command,parameters,<span class="number">0</span>)<span class="comment">/* 执行命令 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，execve 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。这里对这些参数做一个简要的说明。</p><p>先看一个 shell 指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure><p>此命令把 file1 复制到 file2 文件中，在 shell 执行 fork 之后，子进程定位并执行文件拷贝，并将源文件和目标文件的名称传递给它。</p><p>cp 的主程序（以及包含其他大多数 C 程序的主程序）包含声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(argc,argv,envp)</span><br></pre></td></tr></table></figure><p>其中 argc 是命令行中参数数目的计数，包括程序名称。对于上面的例子，<code>argc</code> 是3。第二个参数<code>argv</code> 是数组的指针。该数组的元素 i 是指向该命令行第 i 个字符串的指针。在上面的例子中，argv[0] 指向字符串 cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main 的第三个参数是指向环境的指针，该环境是一个数组，含有 <code>name = value</code> 的赋值形式，用以将诸如终端类型以及根目录等信息传送给程序。这些变量通常用来确定用户希望如何完成特定的任务（例如，使用默认打印机）。在上面的例子中，没有环境参数传递给 execve ，所以环境变量是 0 ，所以 execve 的第三个参数为 0 。</p><p>可能你觉得 execve 过于复杂，这时候我要鼓励一下你，execve 可能是 POSIX 的全部系统调用中最复杂的一个了，其他都比较简单。作为一个简单的例子，我们再来看一下 <code>exit</code> ，这是进程在执行完成后应执行的系统调用。这个系统调用有一个参数，它的退出状态是 0 - 255 之间，它通过 waitpid 系统调用中的 statloc 返回给父级。</p><p>UNIX 中的进程将内存划分成三个部分：<code>text segment,文本区</code>，例如程序代码，<code>data segment，数据区</code>，例如变量，<code>stack segment</code>，栈区域。数据向上增长而堆栈向下增长，如下图所示</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTczNzMyOC0xNzYzNDE4MzAxLnBuZw.jpg" alt="img"></p><p>上图能说明三个部分的内存分配情况，夹在中间的是空闲区，也就是未分配的区域，堆栈在需要时自动的挤压空闲区域，不过数据段的扩展是显示地通过系统调用 <code>brk</code> 进行的，在数据段扩充后，该系统调用指向一个新地址。但是，这个调用不是 POSIX 标准中定义的，对于存储器的动态分配，鼓励程序员使用 <code>malloc</code> 函数，而 malloc 的内部实现则不是一个适合标准化的主题，因为几乎没有程序员直接使用它。</p><h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><p>许多系统调用都与文件系统有关，要读写一个文件，必须先将其打开。这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开文件的名称，而代码 <code>O_RDONLY</code>、 <code>O_WRONLY</code> 或 <code>O_RDWR</code> 的含义分别是只读、只写或者两者都可以，为了创建一个新文件，使用 <code>O_CREATE</code>参数。然后可使用返回的文件描述符进行读写操作。接着，可以使用 close 关闭文件，这个调用使得文件描述符在后续的 open 中被再次使用。</p><p>最常用的调用还是 <code>read</code> 和 <code>write</code>，我们再前面探讨过 read 调用，write 具有与 read 相同的参数。</p><p>尽管多数程序频繁的读写文件，但是仍有一些应用程序需要能够随机访问一个文件的任意部分。与每个文件相关的是一个指向文件当前位置的指针。在顺序读写时，该指针通常指向要读出（写入）的下一个字节。<code>Iseek</code> 调用可以改变该位置指针的值，这样后续的 read 或 write 调用就可以在文件的任何地方开始。</p><p>Iseek 有三个参数，<code>position = iseek(fd,offset,whence)</code>，第一个是文件描述符，第二个是文件位置，第三个是说明该文件位置是相对于文件起始位置，当前位置还是文件的结尾。在修改了指针之后，Iseek 所返回的值是文件中的绝对位置。</p><p>UNIX 为每个文件保存了该文件的类型（普通文件、特殊文件、目录等）、大小，最后修改时间以及其他信息，程序可以通过 <code>stat</code> 系统调用查看这些信息。<code>s = stat(name,&amp;buf)</code>，第一个参数指定了被检查的文件；第二个参数是一个指针，该指针指向存放这些信息的结构。对于一个打开的文件而言，fstat 调用完成同样的工作。</p><h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><p>下面我们探讨目录和整个文件系统的系统调用，上面探讨的是和某个文件有关的系统调用。<code>mkdir</code> 和 <code>rmdir</code> 分别用于创建<code>s = mkdir(nname,mode)</code>和删除 <code>s = rmdir(name)</code> 空目录，下一个调用是 <code>s = link(name1,name2)</code> 它的作用是允许同一个文件以两个或者多个名称出现，多数情况下是在不同的目录中使用 link ，下面我们探讨一下 link 是如何工作的</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzMyNjk3My0xNDEyMzM0ODM5LnBuZw.jpg" alt="img"></p><p>图中有两个用户 <code>ast</code> 和 <code>jim</code>，每个用户都有他自己的一个目录和一些文件，如果 ast 要执行一个包含下面系统调用的应用程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link(<span class="string">"/usr/jim/memo"</span>, <span class="string">"/usr/ast/note"</span>);</span><br></pre></td></tr></table></figure><p>jim 中的 memo 文件现在会进入到 ast 的目录中，在 note 名称下。此后，<code>/usr/jim/memo</code>和 <code>/usr/ast/note</code> 会有相同的名称。</p><blockquote><p>用户目录是保存在 /usr，/user，/home 还是其他位置，都是由本地系统管理员决定的。</p></blockquote><p>要理解 link 是如何工作的需要清楚 link 做了什么操作。UNIX 中的每个文件都有一个独一无二的版本，也称作 <code>i - number，i-编号</code>，它标示着不同文件的版本。这个 i - 编号是 <code>i-nodes,i-节点</code> 表的索引。每个文件都会表明谁拥有这个文件，这个磁盘块的位置在哪，等等。目录只是一个包含一组（i编号，ASCII名称）对应的文件。UNIX 中的第一个版本中，每个目录项都会有 16 个字节，2 个字节对应 i - 编号和 14 个字节对应其名称。现在需要一个更复杂的结构需要支持长文件名，但是从概念上讲一个目录仍是一系列（i-编号，ASCII 名称）的集合。在上图中，<code>mail</code> 的 i-编号为 16，依此类推。link 只是利用某个已有文件的 i-编号，创建一个新目录项（也许用一个新名称）。在上图 b 中，你会发现有两个相同的 70 i-编号的文件，因此它们需要有相同的文件。如果其中一个使用了 <code>unlink</code> 系统调用的话，其中一个会被移除，另一个将保留。如果两个文件都移除了，则 UNIX 会发现该文件不存在任何没有目录项（i-节点中的一个域记录着指向该文件的目录项），就会把该文件从磁盘中移除。</p><p>就像我们上面提到过的那样，<code>mount</code> 系统 <code>s = mount(special,name,flag)</code>调用会将两个文件系统合并为一个。通常的情况是将根文件系统分布在硬盘（子）分区上，并将用户文件分布在另一个（子）分区上，该根文件系统包含常用命令的二进制（可执行）版本和其他使用频繁的文件。然后，用户就会插入可读取的 USB 硬盘。</p><p>通过执行 mount 系统调用，USB 文件系统可以被添加到根文件系统中，</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzMzNzc1My04NzYyOTI4OTgucG5n.jpg" alt="img"></p><p>图 a 是安装前的系统文件，图 b 是安装后的系统文件。</p><p>如果用 C 语言来执行那就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount(<span class="string">"/dev/sdb0"</span>,<span class="string">"/mnt"</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里，第一个参数是 USB 驱动器 0 的块特殊文件名称，第二个参数是被安装在树中的位置，第三个参数说明将要安装的文件系统是可读写的还是只读的。</p><p>当不再需要一个文件系统时，可以使用 umount 移除之。</p><h3 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h3><p>除了进程、文件、目录系统调用，也存在其他系统调用的情况，下面我们来探讨一下。我们可以看到上面其他系统调用只有四种，首先来看第一个 chdir，chdir 调用更改当前工作目录，在调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">"/usr/ast/test"</span>);</span><br></pre></td></tr></table></figure><p>后，打开 xyz 文件，会打开 <code>/usr/ast/test/xyz</code> 文件，工作目录的概念消除了总是需要输入长文件名的需要。</p><p>在 UNIX 系统中，每个文件都会有保护模式，这个模式会有一个<code>读-写-执行</code>位，它用来区分所有者、组和其他成员。<code>chmod</code> 系统调用提供改变文件模式的操作。例如，要使一个文件除了对所有者之外的用户可读，你可以执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod(<span class="string">"file"</span>,<span class="number">0644</span>);</span><br></pre></td></tr></table></figure><p><code>kill</code> 系统调用是用户和用户进程发送信号的方式，如果一个进程准备好捕捉一个特定的信号，那么在信号捕捉之前，会运行一个信号处理程序。如果进程没有准备好捕捉特定的信号，那么信号的到来会杀掉该进程（此名字的由来）。</p><p>POSIX 定义了若干时间处理的进程。例如，<code>time</code> 以秒为单位返回当前时间，0 对应着 1970 年 1月 1日。在一台 32 位字的计算机中，time 的最大值是 (2^32) - 1秒，这个数字对应 136 年多一点。所以在 2106 年，32 位的 UNIX 系统会发飙。如果读者现在有 32 位 UNIX 系统，建议在 2106 年更换位 64 位操作系统（偷笑～）。</p><h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>上面我们提到的都是 UNIX 系统调用，现在我们来聊聊 Win 32 中的系统调用。Windows 和 UNIX 在各自的编程方式上有着根本的不同。UNIX 程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。Windows 系统则不同，Windows 应用程序通常是由事件驱动的。主程序会等待一些事件发生，然后调用程序去处理。最简单的事件处理是键盘敲击和鼠标滑过，或者是鼠标点击，或者是插入 USB 驱动，然后操作系统调用处理器去处理事件，更新屏幕和更新程序内部状态。这是与 UNIX 不同的设计风格。</p><p>当然，Windows 也有系统调用。在 UNIX 中，系统调用（比如 read）和系统调用所使用的调用库（例如 read）几乎是一对一的关系。而在 Windows 中，情况则大不相同。首先，函数库的调用和实际的系统调用几乎是不对应的。微软定义了一系列过程，称为 <code>Win32应用编程接口(Application Programming Interface)</code>，程序员通过这套标准的接口来实现系统调用。这个接口支持从 Windows 95 版本以来所有的 Windows 版本。</p><p>Win32 API 调用的数量是非常巨大的，有数千个多。但这些调用并不都是在内核态的模式下运行时，有一些是在用户态的模型下运行。Win32 API 有大量的调用，用来管理视窗、几何图形、文本、字体、滚动条、对话框、菜单以及 GUI 的其他功能。为了使图形子系统在内核态下运行，需要系统调用，否则就只有函数库调用。</p><p>我们把关注点放在和 Win32 系统调用中来，我们可以简单看一下 Win32 API 中的系统调用和 UNIX 中有什么不同（并不是所有的系统调用）</p><table><thead><tr><th>UNIX</th><th>Win32</th><th>说明</th></tr></thead><tbody><tr><td>fork</td><td>CreateProcess</td><td>创建一个新进程</td></tr><tr><td>waitpid</td><td>WaitForSingleObject</td><td>等待一个进程退出</td></tr><tr><td>execve</td><td>none</td><td>CraeteProcess = fork + servvice</td></tr><tr><td>exit</td><td>ExitProcess</td><td>终止执行</td></tr><tr><td>open</td><td>CreateFile</td><td>创建一个文件或打开一个已有的文件</td></tr><tr><td>close</td><td>CloseHandle</td><td>关闭文件</td></tr><tr><td>read</td><td>ReadFile</td><td>从单个文件中读取数据</td></tr><tr><td>write</td><td>WriteFile</td><td>向单个文件写数据</td></tr><tr><td>lseek</td><td>SetFilePointer</td><td>移动文件指针</td></tr><tr><td>stat</td><td>GetFileAttributesEx</td><td>获得不同的文件属性</td></tr><tr><td>mkdir</td><td>CreateDirectory</td><td>创建一个新的目录</td></tr><tr><td>rmdir</td><td>RemoveDirectory</td><td>移除一个空的目录</td></tr><tr><td>link</td><td>none</td><td>Win32 不支持 link</td></tr><tr><td>unlink</td><td>DeleteFile</td><td>销毁一个已有的文件</td></tr><tr><td>mount</td><td>none</td><td>Win32 不支持 mount</td></tr><tr><td>umount</td><td>none</td><td>Win32 不支持 mount，所以也不支持mount</td></tr><tr><td>chdir</td><td>SetCurrentDirectory</td><td>切换当前工作目录</td></tr><tr><td>chmod</td><td>none</td><td>Win32 不支持安全</td></tr><tr><td>kill</td><td>none</td><td>Win32 不支持信号</td></tr><tr><td>time</td><td>GetLocalTime</td><td>获取当前时间</td></tr></tbody></table><p>上表中是 UNIX 调用大致对应的 Win32 API 系统调用，简述一下上表。<code>CreateProcess</code> 用于创建一个新进程，它把 UNIX 中的 fork 和 execve 两个指令合成一个，一起执行。它有许多参数用来指定新创建进程的性质。Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。<code>WaitForSingleObject</code> 用于等待一个事件，等待的事件可以是多种可能的事件。如果有参数指定了某个进程，那么调用者将等待指定的进程退出，这通过 <code>ExitProcess</code> 来完成。</p><p>然后是6个文件操作，在功能上和 UNIX 的调用类似，然而在参数和细节上是不同的。和 UNIX 中一样，文件可以打开，读取，写入，关闭。<code>SetFilePointer</code> 和 <code>GetFileAttributesEx</code> 设置文件的位置并取得文件的属性。</p><p>Windows 中有目录，目录分别用 <code>CreateDirectory</code> 以及 <code>RemoveDirectory</code>API 调用创建和删除。也有对当前的目录的标记，这可以通过 <code>SetCurrentDirectory</code> 来设置。使用<code>GetLocalTime</code> 可获得当前时间。</p><p>Win32 接口中没有文件的链接、文件系统的 mount、umount 和 stat ，当然， Win32 中也有大量 UNIX 中没有的系统调用，特别是对 GUI 的管理和调用。</p><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>下面我们会探讨操作系统的几种结构，主要包括<strong>单体结构、分层系统、微内核、客户-服务端系统、虚拟机和外核</strong>等。下面以此来探讨一下</p><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><p>到目前为止，在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序。使用此技术时，如果系统中的每个过程都提供了前者所需的一些有用的计算，则它可以自由调用任何其他过程。在单体系统中，调用任何一个所需要的程序都非常高效，但是上千个不受限制的彼此调用往往非常臃肿和笨拙，而且单体系统必然存在单体问题，那就是只要系统发生故障，那么任何系统和应用程序将不可用，这往往是灾难性的。</p><p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中</p><p>对于单体系统，往往有下面几种建议</p><ul><li>需要有一个主程序，用来调用请求服务程序</li><li>需要一套服务过程，用来执行系统调用</li><li>需要一套服务程序，用来辅助服务过程调用</li></ul><p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p><p><img src="/2020/02/11/操作系统基础概念简述/image-20200211213916896.png" alt="image-20200211213916896"></p><p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 <code>共享库(shared library)</code>，在 Windows 中则被称为 <code>动态链接库(Dynamic Link Library,DLL)</code>。他们的扩展名为 <code>.dll</code>，在 <code>C:\Windows\system32</code> 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzM1NjcxNy0yMTA5NjEwMTMyLnBuZw.jpg" alt="img"></p><p>分层系统是由 <code>E.W.Dijkstar</code> 和他的学生在荷兰技术学院所开发的 THE 系统。</p><p>把上面单体系统进一步通用化，就变为了一个层次式结构的操作系统，它的上层软件都是在下层软件的基础之上构建的。该系统分为六层，如下所示</p><table><thead><tr><th style="text-align:left">层号</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">5</td><td style="text-align:left">操作员</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">用户程序</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">输入/输出管理</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">操作员-进程通信</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">存储器和磁鼓管理</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">处理器分配和多道程序编程</td></tr></tbody></table><p>处理器在 0 层运行，当中断发生或定时器到期时，由该层完成进程切换；在第 0 层之上，系统由一些连续的进程组成，编写这些进程时不用再考虑在单处理器上多进程运行的细节。内存管理在第 1 层，它分配进程的主存空间。第 1 层软件保证一旦需要访问某一页面，该页面必定已经在内存中，并且在页面不需要的时候将其移出。</p><p>第 2 层处理进程与操作员控制台（即用户）之间的通信。第 3 层管理 I/O 设备和相关的信息流缓冲区。第 4 层是用户程序层，用户程序不用考虑进程、内存、控制台或 I/O 设备管理等细节。系统操作员在第 5 层。</p><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>在分层方式中，设计者要确定在哪里划分 <code>内核-用户</code> 的边界。传统上，所有的层都在内核中，但是这样做没有必要。事实上，尽可能减少内核态中功能可能是更好的做法。因为内核中的错误很难处理，一旦内核态中出错误会拖累整个系统。</p><p>所以，为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 — 微内核 — 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p><p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzQxNDIwMi0xNDMxMTgzMzcyLnBuZw.jpg" alt="img"></p><p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。</p><p>位于用户态的驱动程序上面是<code>服务器</code>层，包含有服务器，它们完成操作系统的多数工作。由一个或多个文件服务器管理着文件系统，进程管理器创建、销毁和管理进程。服务器中有一个特殊的服务器称为 <code>再生服务器(reincarnation server)</code>，它的任务就是检查服务器和驱动程序的功能是否正确，一旦检查出来错误，它就会补上去，无需用户干预。这种方式使得系统具有可恢复性，并具有较高的可靠性。</p><p>微内核中的内核还具有一种 <code>机制</code> 与 <code>策略</code> 分离的思想。比如系统调度，一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行具有最高优先级的进程。这里，内核机制就是寻找最高的优先级进程并运行。而策略（赋予进程优先级）可以在用户态中的进程完成。在这种模式中，策略和机制是分离的，从而使内核变得更小。</p><h3 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h3><p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的 <code>客户-服务器</code>模式。</p><p>客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p><p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzQyMjgzNC0xNTk3MjAxOTcucG5n.jpg" alt="img"></p><p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p><p>越来越多的系统，包括家里的 PC，都成为客户端，而在某地运行的大型机器则成为服务器。许多 web 就是以这种方式运行的。一台 PC 向某个服务器请求一个 Web 页面，服务器把 Web 页面返回给客户端，这就是典型的客服-服务器模式</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><ol><li><a href="第四版https://baike.baidu.com/item/操作系统/192?fr=aladdin">《现代操作系统》</a></li><li>《Modern Operating System》forth edition</li><li><a href="http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm" target="_blank" rel="noopener">http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm</a></li><li><a href="https://www.computerhope.com/jargon/c/clockcyc.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/c/clockcyc.htm</a></li></ol><blockquote><p>转载自<a href="https://blog.csdn.net/qq_36894974/article/details/104246844" target="_blank" rel="noopener">这些操作系统的概念，保你没听过！</a> 作者：cxuann</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;操作系统概念&quot;&gt;&lt;a href=&quot;#操作系统概念&quot; class=&quot;headerlink&quot; title=&quot;操作系统概念&quot;&gt;&lt;/a&gt;操作系统概念&lt;/h2&gt;&lt;p&gt;大部分操作系统提供了特定的基础概念和抽象，例如进程、地址空间、文件等，它们是需要理解的核心内容。下面我们会简要介绍一些基本概念，为了说明这些概念，我们会不时的从 &lt;code&gt;UNIX&lt;/code&gt; 中提出示例，相同的示例也会存在于其他系统中，我们后面会进行介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="操作系统" scheme="https://vincentruan.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>14个Java并发容器</title>
    <link href="https://vincentruan.github.io/2020/02/11/14%E4%B8%AAJava%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>https://vincentruan.github.io/2020/02/11/14%E4%B8%AAJava%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</id>
    <published>2020-02-11T09:00:26.000Z</published>
    <updated>2020-02-17T02:40:44.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a><strong>并发容器介绍</strong></h1><ol><li>ConcurrentHashMap：并发版HashMap</li><li>CopyOnWriteArrayList：并发版ArrayList</li><li>CopyOnWriteArraySet：并发Set</li><li>ConcurrentLinkedQueue：并发队列(基于链表)</li><li>ConcurrentLinkedDeque：并发队列(基于双向链表)</li><li>ConcurrentSkipListMap：基于跳表的并发Map</li><li>ConcurrentSkipListSet：基于跳表的并发Set</li><li>ArrayBlockingQueue：阻塞队列(基于数组)</li><li>LinkedBlockingQueue：阻塞队列(基于链表)</li><li>LinkedBlockingDeque：阻塞队列(基于双向链表)</li><li>PriorityBlockingQueue：线程安全的优先队列</li><li>SynchronousQueue：读写成对的队列</li><li>LinkedTransferQueue：基于链表的数据交换队列</li><li>DelayQueue：延时队列</li></ol><h2 id="1-ConcurrentHashMap-并发版HashMap"><a href="#1-ConcurrentHashMap-并发版HashMap" class="headerlink" title="1.ConcurrentHashMap 并发版HashMap"></a><strong>1.ConcurrentHashMap 并发版HashMap</strong></h2><p>最常见的并发容器之一，可以用作并发场景下的缓存。底层依然是哈希表，但在JAVA 8中有了不小的改变，而JAVA 7和JAVA 8都是用的比较多的版本，因此经常会将这两个版本的实现方式做一些比较（比如面试中）</p><p>一个比较大的差异就是，JAVA 7中采用分段锁来减少锁的竞争，JAVA 8中放弃了分段锁，采用CAS，同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）。</p><h2 id="2-CopyOnWriteArrayList-并发版ArrayList"><a href="#2-CopyOnWriteArrayList-并发版ArrayList" class="headerlink" title="2.CopyOnWriteArrayList 并发版ArrayList"></a><strong>2.CopyOnWriteArrayList 并发版ArrayList</strong></h2><p>并发版ArrayList，底层结构也是数组，和ArrayList不同之处在于：当新增和删除元素时会创建一个新的数组，在新的数组中增加或者排除指定对象，最后用新增数组替换原来的数组。</p><p>适用场景：由于读操作不加锁，写（增、删、改）操作加锁，因此适用于读多写少的场景。</p><p>局限：由于读的时候不会加锁（读的效率高，就和普通ArrayList一样），读取的当前副本，因此可能读取到脏数据。如果介意，建议不用。</p><p>看看源码感受下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">  <span class="comment">// 添加元素，有锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 修改时加锁，保证并发安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object[] elements = getArray(); <span class="comment">// 当前数组</span></span><br><span class="line">      <span class="keyword">int</span> len = elements.length;</span><br><span class="line">      Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 创建一个新数组，比老的大一个空间</span></span><br><span class="line">      newElements[len] = e; <span class="comment">// 要添加的元素放进新数组</span></span><br><span class="line">      setArray(newElements); <span class="comment">// 用新数组替换原来的数组</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读元素，不加锁，因此可能读取到旧数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-CopyOnWriteArraySet-并发Set"><a href="#3-CopyOnWriteArraySet-并发Set" class="headerlink" title="3.CopyOnWriteArraySet 并发Set"></a><strong>3.CopyOnWriteArraySet 并发Set</strong></h2><p>基于CopyOnWriteArrayList实现（内含一个CopyOnWriteArrayList成员变量），也就是说底层是一个数组，意味着每次add都要遍历整个集合才能知道是否存在，不存在时需要插入（加锁）。</p><p>适用场景：在CopyOnWriteArrayList适用场景下加一个，集合别太大（全部遍历伤不起）。</p><h2 id="4-ConcurrentLinkedQueue-并发队列-基于链表"><a href="#4-ConcurrentLinkedQueue-并发队列-基于链表" class="headerlink" title="4.ConcurrentLinkedQueue 并发队列(基于链表)"></a><strong>4.ConcurrentLinkedQueue 并发队列(基于链表)</strong></h2><p>基于链表实现的并发队列，使用乐观锁(CAS)保证线程安全。因为数据结构是链表，所以理论上是没有队列大小限制的，也就是说添加数据一定能成功。</p><h2 id="5-ConcurrentLinkedDeque-并发队列-基于双向链表"><a href="#5-ConcurrentLinkedDeque-并发队列-基于双向链表" class="headerlink" title="5.ConcurrentLinkedDeque 并发队列(基于双向链表)"></a><strong>5.ConcurrentLinkedDeque 并发队列(基于双向链表)</strong></h2><p>基于双向链表实现的并发队列，可以分别对头尾进行操作，因此除了先进先出(FIFO)，也可以先进后出（FILO），当然先进后出的话应该叫它栈了。</p><h2 id="6-ConcurrentSkipListMap-基于跳表的并发Map"><a href="#6-ConcurrentSkipListMap-基于跳表的并发Map" class="headerlink" title="6.ConcurrentSkipListMap 基于跳表的并发Map"></a><strong>6.ConcurrentSkipListMap 基于跳表的并发Map</strong></h2><p>SkipList即跳表，跳表是一种空间换时间的数据结构，通过冗余数据，将链表一层一层索引，达到类似二分查找的效果</p><p><img src="/2020/02/11/14个Java并发容器/640.webp" alt="img"></p><h2 id="7-ConcurrentSkipListSet-基于跳表的并发Set"><a href="#7-ConcurrentSkipListSet-基于跳表的并发Set" class="headerlink" title="7.ConcurrentSkipListSet 基于跳表的并发Set"></a><strong>7.ConcurrentSkipListSet 基于跳表的并发Set</strong></h2><p>类似HashSet和HashMap的关系，ConcurrentSkipListSet里面就是一个ConcurrentSkipListMap，就不细说了。</p><h2 id="8-ArrayBlockingQueue-阻塞队列-基于数组"><a href="#8-ArrayBlockingQueue-阻塞队列-基于数组" class="headerlink" title="8.ArrayBlockingQueue 阻塞队列(基于数组)"></a><strong>8.ArrayBlockingQueue 阻塞队列(基于数组)</strong></h2><p>基于数组实现的可阻塞队列，构造时必须制定数组大小，往里面放东西时如果数组满了便会阻塞直到有位置（也支持直接返回和超时等待），通过一个锁ReentrantLock保证线程安全。</p><p>用offer操作举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读写共用此锁，线程间通过下面两个Condition通信</span></span><br><span class="line"><span class="comment">   * 这两个Condition和lock有紧密联系（就是lock的方法生成的）</span></span><br><span class="line"><span class="comment">   * 类似Object的wait/notify</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">  <span class="comment">/** 队列不为空的信号，取数据的线程需要关注 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">  <span class="comment">/** 队列没满的信号，写数据的线程需要关注 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">  <span class="comment">// 一直阻塞直到有东西可以拿出来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在尾部插入一个元素，队列已满时等待指定时间，如果还是不能插入则返回</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 锁住</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 循环等待直到队列有空闲</span></span><br><span class="line">      <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 等待超时，返回</span></span><br><span class="line">        <span class="comment">// 暂时放出锁，等待一段时间（可能被提前唤醒并抢到锁，所以需要循环判断条件）</span></span><br><span class="line">        <span class="comment">// 这段时间可能其他线程取走了元素，这样就有机会插入了</span></span><br><span class="line">        nanos = notFull.awaitNanos(nanos);</span><br><span class="line">      &#125;</span><br><span class="line">      enqueue(e);<span class="comment">//插入一个元素</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看会有点疑惑，读和写都是同一个锁，那要是空的时候正好一个读线程来了不会一直阻塞吗？</p><p>答案就在notEmpty、notFull里，这两个出自lock的小东西让锁有了类似synchronized + wait + notify的功能。</p><h2 id="9-LinkedBlockingQueue-阻塞队列-基于链表"><a href="#9-LinkedBlockingQueue-阻塞队列-基于链表" class="headerlink" title="9.LinkedBlockingQueue 阻塞队列(基于链表)"></a><strong>9.LinkedBlockingQueue 阻塞队列(基于链表)</strong></h2><p>基于链表实现的阻塞队列，想比与不阻塞的ConcurrentLinkedQueue，它多了一个容量限制，如果不设置默认为int最大值。</p><h2 id="10-LinkedBlockingDeque-阻塞队列-基于双向链表"><a href="#10-LinkedBlockingDeque-阻塞队列-基于双向链表" class="headerlink" title="10.LinkedBlockingDeque 阻塞队列(基于双向链表)"></a><strong>10.LinkedBlockingDeque 阻塞队列(基于双向链表)</strong></h2><p>类似LinkedBlockingQueue，但提供了双向链表特有的操作。</p><h2 id="11-PriorityBlockingQueue-线程安全的优先队列"><a href="#11-PriorityBlockingQueue-线程安全的优先队列" class="headerlink" title="11.PriorityBlockingQueue 线程安全的优先队列"></a><strong>11.PriorityBlockingQueue 线程安全的优先队列</strong></h2><p>构造时可以传入一个比较器，可以看做放进去的元素会被排序，然后读取的时候按顺序消费。某些低优先级的元素可能长期无法被消费，因为不断有更高优先级的元素进来。</p><h2 id="12-SynchronousQueue-数据同步交换的队列"><a href="#12-SynchronousQueue-数据同步交换的队列" class="headerlink" title="12.SynchronousQueue 数据同步交换的队列"></a><strong>12.SynchronousQueue 数据同步交换的队列</strong></h2><p>一个虚假的队列，因为它实际上没有真正用于存储元素的空间，每个插入操作都必须有对应的取出操作，没取出时无法继续放入。</p><p>一个简单的例子感受一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有休息，疯狂写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">          System.out.println(<span class="string">"放入: "</span> + i);</span><br><span class="line">          queue.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 咸鱼模式取数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"取出: "</span> + queue.take());</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">2000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">放入: 0</span></span><br><span class="line"><span class="comment">取出: 0</span></span><br><span class="line"><span class="comment">放入: 1</span></span><br><span class="line"><span class="comment">取出: 1</span></span><br><span class="line"><span class="comment">放入: 2</span></span><br><span class="line"><span class="comment">取出: 2</span></span><br><span class="line"><span class="comment">放入: 3</span></span><br><span class="line"><span class="comment">取出: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到，写入的线程没有任何sleep，可以说是全力往队列放东西，而读取的线程又很不积极，读一个又sleep一会。输出的结果却是读写操作成对出现。</p><p>JAVA中一个使用场景就是Executors.newCachedThreadPool()，创建一个缓存线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">             <span class="number">0</span>, <span class="comment">// 核心线程为0，没用的线程都被无情抛弃</span></span><br><span class="line">             Integer.MAX_VALUE, <span class="comment">// 最大线程数理论上是无限了，还没到这个值机器资源就被掏空了</span></span><br><span class="line">             <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// 闲置线程60秒后销毁</span></span><br><span class="line">             <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); <span class="comment">// offer时如果没有空闲线程取出任务，则会失败，线程池就会新建一个线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-LinkedTransferQueue-基于链表的数据交换队列"><a href="#13-LinkedTransferQueue-基于链表的数据交换队列" class="headerlink" title="13.LinkedTransferQueue 基于链表的数据交换队列"></a><strong>13.LinkedTransferQueue 基于链表的数据交换队列</strong></h2><p>实现了接口TransferQueue，通过transfer方法放入元素时，如果发现有线程在阻塞在取元素，会直接把这个元素给等待线程。如果没有人等着消费，那么会把这个元素放到队列尾部，并且此方法阻塞直到有人读取这个元素。和SynchronousQueue有点像，但比它更强大。</p><h2 id="14-DelayQueue-延时队列"><a href="#14-DelayQueue-延时队列" class="headerlink" title="14.DelayQueue 延时队列"></a><strong>14.DelayQueue 延时队列</strong></h2><p>可以使放入队列的元素在指定的延时后才被消费者取出，元素需要实现Delayed接口。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>上面简单介绍了JAVA并发包下的一些容器类，知道有这些东西，遇到合适的场景时就能想起有个现成的东西可以用了。想要知其所以然，后续还得再深入探索一番。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发容器介绍&quot;&gt;&lt;a href=&quot;#并发容器介绍&quot; class=&quot;headerlink&quot; title=&quot;并发容器介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;并发容器介绍&lt;/strong&gt;&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ConcurrentHashMap：并发版HashMap&lt;/l
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="并发" scheme="https://vincentruan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java8开发的4个小技巧</title>
    <link href="https://vincentruan.github.io/2020/02/11/Java8%E5%BC%80%E5%8F%91%E7%9A%844%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://vincentruan.github.io/2020/02/11/Java8%E5%BC%80%E5%8F%91%E7%9A%844%E4%B8%AA%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-02-11T08:48:32.000Z</published>
    <updated>2020-02-28T08:38:44.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional是一个评价过低的特性，它可以显著的降低代码抛出NullPointerException的可能。它在边界代码(你正在使用的API或者你发布的API)中特别有用。</p><p>但是对于它的不适当的使用和设计很容易使一个小的变动影响到很多的类，或者降低代码的可阅读性。这里有一些如何更加高效使用Optional的建议。</p><a id="more"></a><h3 id="Optional应该仅仅用在返回类型中"><a href="#Optional应该仅仅用在返回类型中" class="headerlink" title="Optional应该仅仅用在返回类型中"></a>Optional应该仅仅用在返回类型中</h3><p>不要用在参数或者域中。<a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="noopener">阅读这篇博文</a>可以看到如何正确使用Optional进行编码。幸运的是，IntelliJ IDEA可以打开inspections去检查你是否遵循了这些推荐规范。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalParamWarning.png" alt="OptionalParamWarning.png"></p><p>要尽早在Optional出现的地方对它进行处理。IntelliJ IDEA会阻止Optional出现在你代码的各个地方，所以记住一定要在Optional出现的地方就对他进行处理。</p><p><img src="https://www.rowkey.me/images/blog_images/java8/OptionalUseImmediately.png" alt="OptionalUseImmediately.png"></p><h3 id="不能简单地调用get-方法"><a href="#不能简单地调用get-方法" class="headerlink" title="不能简单地调用get()方法"></a>不能简单地调用get()方法</h3><p>Optional是用来表示这个值是有可能为空的，让你做好应对的准备。因此，很重要的一点就是在使用这个值之前务必要检查其是否存在。简单地调用get方法而不是先调用isPresent可能会导致产生空指针异常。幸运的是，IntelliJ IDEA再一次提供了对此种方案的检查。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalGetWithoutIsPresent.png" alt="OptionalGetWithoutIsPresent.png"></p><h3 id="更加优雅的方案"><a href="#更加优雅的方案" class="headerlink" title="更加优雅的方案"></a>更加优雅的方案</h3><p>如下代码，isPresent和get当然能够解决这个问题。</p><p><img src="https://www.rowkey.me/images/blog_images/java8/OptionalSimple.png" alt="OptionalSimple.png"></p><p>但是这里有更加优雅的方式，你可以使用orElse来设置一个默认值。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalOrElse.png" alt="OptionalOrElse.png"></p><p>或者你可以使用orElseGet来设置当值为null的时候去调用的方法。虽然看着和前面的方案没有什么大的不同。但是提供的方法应该仅仅在需要调用的时候才被调用。那么当这是个代价昂贵的方法时，那么使用lambda会带来更好的性能提升。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalOrElseGet.png" alt="OptionalOrElseGet.png"></p><h2 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h2><p>Lambda表达式是Java8最主要的卖点。即使你现在用不到Java8，你也应该对它有了一些基本的了解。下面讲述了一种新的方式使用Java编程，虽然这并不是一个“最佳实践”，仅仅是一个使用的指导。</p><h3 id="保持简短"><a href="#保持简短" class="headerlink" title="保持简短"></a>保持简短</h3><p>函数式编程对于长的lambda表达式是欢迎的，但是对于仅仅使用Java开发很多年的人发现编写短的lambda表达式会更容易一些。你甚至会想把表达式缩减到一行，也很容易把长的表达式重构成一个方法。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExtractMethod.png" alt="LambdaExtractMethod.png"></p><p>当然，这些甚至牵扯到了方法引用(Method References)。方法引用可能看着有点陌生，但是由于其能让代码达到更好的阅读性，还是有很大应用价值的。后面，我会讲到这个概念。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaCollapseToMethodRef.png" alt="LambdaCollapseToMethodRef.png"></p><h3 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h3><p>在lambda表达式中是没有类型信息的，所以你会发现在参数中包含类型信息是非常有用的。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExplicitParamTypes.png" alt="LambdaExplicitParamTypes.png"></p><p>如你所见，这会变得很笨重。所以我更喜欢赋予参数有意义的名字。当然，无论你是否这么做，Intellij IDEA都会让你可以看到参数的类型信息。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaParamTypes.png" alt="LambdaParamTypes.png"></p><p>甚至lambda表示的函数接口也能看到。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterface.png" alt="LambdaFunctionalInterface.png"></p><h2 id="设计Lambda表达式"><a href="#设计Lambda表达式" class="headerlink" title="设计Lambda表达式"></a>设计Lambda表达式</h2><p>我认为lambda表达式有一点类似于泛型-我们会经常使用到泛型(例如，添加类型信息到List&lt;&gt;)，但是比较罕见的是我们去设计一个具有泛型的方法或者一个类(比如像Person<t>)。同样的，我们经常会在使用诸如Streams API的时候传递lambda，但是却很少会创建一个需要传递lambda参数的方法。</t></p><p>如果你发现自己处在这样一种境况，那么这里有一些提示。</p><h3 id="IntelliJ-IDEA能够帮助你引入函数参数"><a href="#IntelliJ-IDEA能够帮助你引入函数参数" class="headerlink" title="IntelliJ IDEA能够帮助你引入函数参数"></a>IntelliJ IDEA能够帮助你引入函数参数</h3><p>能够让你创建一个参数，这个参数是一个lambda而不是一个Object。这个特性的最好的一点就是它会智能建议一个匹配规格的已存在的函数接口。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExtractFunctionalParameter.png" alt="LambdaExtractFunctionalParameter.png"></p><h3 id="使用存在的函数接口"><a href="#使用存在的函数接口" class="headerlink" title="使用存在的函数接口"></a>使用存在的函数接口</h3><p>随着开发者变得对Java8越来越熟悉，当使用Supplier和Consumer这些接口时，我们将会知道什么是我们所期望的，比如创建一个ErrorMessageCreator(例子)会是令人迷惑和浪费的。可以看一下<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">函数包</a>获取已经存在的那些函数接口。</p><h3 id="给你的函数接口添加-FunctionalInterface"><a href="#给你的函数接口添加-FunctionalInterface" class="headerlink" title="给你的函数接口添加@FunctionalInterface"></a>给你的函数接口添加@FunctionalInterface</h3><p>如果你确实需要创建自己的函数接口，那么用这个注解去标记它。看起来不需要这么做，但是Intellij IDEA会在你的函数接口没有符合规范时提示你。当没有方法实现这个接口时，它会提示你。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterfaceNoMethod.png" alt="LambdaFunctionalInterfaceNoMethod.png"></p><p>当方法太多时，也会提示你。</p><p><img src="https://www.rowkey.me/images/blog_images/java8/LambdaFunctionalInterfaceTooManyMethods.png" alt="LambdaFunctionalInterfaceTooManyMethods.png"></p><p>当你把注解应用到一个类而不是接口时，也会发出提醒。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterfaceNotInterface.png" alt="LambdaFunctionalInterfaceNotInterface.png"></p><p>Lambda表达式可以被用在任何有一个Single Abstract Method的接口中，但是它不能够应用到一个抽象类中。看起来没有啥逻辑，但它就是这样的。</p><h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">Stream API</a>是Java8另一个最大的卖点，我认为我们到现在还是没有真的搞清楚这会如何改变我们的代码。这里有一些我自己发现很有用的东西。</p><h3 id="将点号对齐"><a href="#将点号对齐" class="headerlink" title="将点号对齐"></a>将点号对齐</h3><p>我个人比较喜欢对齐Stream操作。当然，你不需要非得这么做，但是我发现这样还是有很大好处的。</p><ul><li>一眼就看到所有的操作以及他们的顺序</li><li>更容易调试(虽然Intellij IDEA提供了在一行中的lambda表达式中任意地方打断点的功能，但是将他们分隔成单独的行会更简单)</li><li>可以很容易地注释掉一些操作以供测试</li><li>很容易地插入peek()供调试或者测试</li></ul><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamWrappingExample.png" alt="StreamWrappingExample.png"></p><p>这样做也会让代码看起来很舒服。当然，如果这么做，会增加代码的行数。</p><p>你可以修改一下格式化设置使点号对齐。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamWrapping.png" alt="StreamWrapping.png"></p><h3 id="使用方法引用-Method-References"><a href="#使用方法引用-Method-References" class="headerlink" title="使用方法引用(Method References)"></a>使用方法引用(Method References)</h3><p>你可能需要一会儿才能习惯这个奇怪的语法。但是，当我们能够正确地使用，它确实能够提高程序的可阅读性。考虑下面的代码：</p><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamSimpleFilter.png" alt="StreamSimpleFilter.png"></p><p>对比一下使用新引入的Objects类的辅助方法(helper methods)：</p><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamMethodRefFilter.png" alt="StreamMethodRefFilter.png"></p><p>后面的代码能够更加明显地表明它想保存的值。IntelliJ IDEA会提示你何时一个lambda可以被替换成方法引用。</p><h3 id="当迭代一个集合，尽可能地使用Streams-API"><a href="#当迭代一个集合，尽可能地使用Streams-API" class="headerlink" title="当迭代一个集合，尽可能地使用Streams API"></a>当迭代一个集合，尽可能地使用Streams API</h3><p>使用新的集合方法：forEach。IDEA会提示你。</p><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamRepalceForWithForEach.png" alt="StreamRepalceForWithForEach.png"></p><p>使用Streams API相比起使用循环和if语句更加清晰明了。例如：</p><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamBefore.png" alt="StreamBefore.png"></p><p>IDEA会建议重构为：</p><p><img src="/2020/02/11/Java8开发的4个小技巧/StreamAfter.png" alt="StreamAfter.png"></p><p>我做的性能测试表示这个重构是令人惊奇的-无论性能是不变、提升还是变差，都是不能被预测的。因此，当你的应用对性能要求很苛刻的话，重构的时候务必做好测试。</p><h3 id="当遍历数组时使用循环"><a href="#当遍历数组时使用循环" class="headerlink" title="当遍历数组时使用循环"></a>当遍历数组时使用循环</h3><p>使用Java8并不是意味着你必须到处都使用Stream和新的集合方法。IDEA会智能提示哪些地方可以转换为Stream操作，但是并不意味着你必须这么做。</p><p>特别是当遍历一个保存基本数据类型的小数组时，使用loop循环的性能是更加好的，而且更加可阅读(至少对哪些Stream的新手来说是这样的)。</p><p>以上的建议，并非是固定不变，也不是必须要遵守的。但是无论你倾向于继续使用loops做某些操作还是在能够使用的地方使用Stream API, 你都要做出你自己的决定。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><img src="/2020/02/11/Java8开发的4个小技巧/640-1581423585086.webp" alt="img"></p><h3 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h3><p>一行执行语句的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure><p>如果有多行执行语句，可以加上 <code>{}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;    <span class="keyword">return</span> x + y;&#125;</span><br></pre></td></tr></table></figure><p>转换成Lambda表达式有以下几种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定参数类型及</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="comment">// 指定参数类型，不指定</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y;</span><br><span class="line"><span class="comment">// 不指定参数类型和return，编译器会自动推断</span></span><br><span class="line">(x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure><h3 id="Lambda用途"><a href="#Lambda用途" class="headerlink" title="Lambda用途"></a>Lambda用途</h3><h4 id="1、只有一个抽象方法的函数式接口"><a href="#1、只有一个抽象方法的函数式接口" class="headerlink" title="1、只有一个抽象方法的函数式接口"></a>1、只有一个抽象方法的函数式接口</h4><p>Lambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。</p><p>下面拿创建线程来举例，用lambda表达式可以有以下几种写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line"><span class="meta">@Override</span>        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">System.out.println(<span class="string">"t1"</span>);        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;).start();    </span><br><span class="line">Runnable runnable = () -&gt; System.out.println(<span class="string">"t2"</span>);    </span><br><span class="line"><span class="keyword">new</span> Thread(runnable).start();    </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"t3"</span>)).start();    </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; run(<span class="string">"t4"</span>)).start();    </span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;        </span><br><span class="line">String str = <span class="string">"t5"</span>;        </span><br><span class="line">System.out.println(str);    </span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1t2t3t4t5</span><br></pre></td></tr></table></figure><h4 id="2、集合批量操作"><a href="#2、集合批量操作" class="headerlink" title="2、集合批量操作"></a>2、集合批量操作</h4><p>下面打印list集合的两种写法是等价的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : list) &#123;    </span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">list.forEach((e) -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure><h4 id="3、流操作"><a href="#3、流操作" class="headerlink" title="3、流操作"></a>3、流操作</h4><p>下面是流查询list集合中等于 <code>&quot;a&quot;</code>的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter((e) -&gt; <span class="string">"a"</span>.equals(e)).count();</span><br></pre></td></tr></table></figure><hr><p>原文：<a href="https://dzone.com/articles/java-8-top-tips" target="_blank" rel="noopener">https://dzone.com/articles/java-8-top-tips</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Optional&quot;&gt;&lt;a href=&quot;#Optional&quot; class=&quot;headerlink&quot; title=&quot;Optional&quot;&gt;&lt;/a&gt;Optional&lt;/h1&gt;&lt;p&gt;Optional是一个评价过低的特性，它可以显著的降低代码抛出NullPointerException的可能。它在边界代码(你正在使用的API或者你发布的API)中特别有用。&lt;/p&gt;
&lt;p&gt;但是对于它的不适当的使用和设计很容易使一个小的变动影响到很多的类，或者降低代码的可阅读性。这里有一些如何更加高效使用Optional的建议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/tags/Java/"/>
    
      <category term="Lambda" scheme="https://vincentruan.github.io/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>如何提高服务器的并发处理能力</title>
    <link href="https://vincentruan.github.io/2020/02/11/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B/"/>
    <id>https://vincentruan.github.io/2020/02/11/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B/</id>
    <published>2020-02-11T07:22:05.000Z</published>
    <updated>2020-02-25T15:09:15.067Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容为入门级介绍，意在对老技术作较全的总结而不是较深的研究。主要参考《构建高性能Web站点》一书。</p><h2 id="什么是服务器并发处理能力"><a href="#什么是服务器并发处理能力" class="headerlink" title="什么是服务器并发处理能力"></a>什么是服务器并发处理能力</h2><p>一台服务器在单位时间里能处理的请求越多，服务器的能力越高，也就是服务器并发处理能力越强</p><a id="more"></a><h2 id="有什么方法衡量服务器并发处理能力"><a href="#有什么方法衡量服务器并发处理能力" class="headerlink" title="有什么方法衡量服务器并发处理能力"></a>有什么方法衡量服务器并发处理能力</h2><h3 id="1-吞吐率"><a href="#1-吞吐率" class="headerlink" title="1. 吞吐率"></a><strong>1. 吞吐率</strong></h3><p>吞吐率，单位时间里服务器处理的最大请求数，单位req/s</p><p>从服务器角度，实际并发用户数的可以理解为服务器当前维护的代表不同用户的文件描述符总数，也就是并发连接数。</p><p>服务器一般会限制同时服务的最多用户数，比如apache的MaxClents参数。</p><p>这里再深入一下，对于服务器来说，服务器希望支持高吞吐率，对于用户来说，用户只希望等待最少的时间，显然，双方不能满足，所以双方利益的平衡点，就是我们希望的最大并发用户数。</p><h3 id="2-压力测试"><a href="#2-压力测试" class="headerlink" title="2. 压力测试"></a><strong>2. 压力测试</strong></h3><p>有一个原理一定要先搞清楚，假如100个用户同时向服务器分别进行10个请求，与1个用户向服务器连续进行1000次请求，对服务器的压力是一样吗？</p><p>实际上是不一样的，因对每一个用户，连续发送请求实际上是指发送一个请求并接收到响应数据后再发送下一个请求。</p><p>这样对于1个用户向服务器连续进行1000次请求, 任何时刻服务器的网卡接收缓冲区中只有1个请求，而对于100个用户同时向服务器分别进行10个请求，服务器的网卡接收缓冲区最多有100个等待处理的请求，显然这时的服务器压力更大。</p><p>压力测试前提考虑的条件</p><ul><li>并发用户数: 指在某一时刻同时向服务器发送请求的用户总数(HttpWatch)</li><li>总请求数</li><li>请求资源描述</li><li>请求等待时间(用户等待时间)</li><li>用户平均请求的等待时间</li><li>服务器平均请求处理的时间</li><li>硬件环境</li></ul><p>压力测试中关心的时间又细分以下2种:</p><ol><li>用户平均请求等待时间（这里暂不把数据在网络的传输时间，还有用户PC本地的计算时间计算入内）</li><li>服务器平均请求处理时间</li></ol><p>用户平均请求等待时间主要用于衡量服务器在一定并发用户数下，单个用户的服务质量；而服务器平均请求处理时间就是吞吐率的倒数。</p><p>一般来说，用户平均请求等待时间 = 服务器平均请求处理时间 * 并发用户数</p><h2 id="怎么提高服务器的并发处理能力"><a href="#怎么提高服务器的并发处理能力" class="headerlink" title="怎么提高服务器的并发处理能力"></a>怎么提高服务器的并发处理能力</h2><h3 id="1-提高CPU并发计算能力"><a href="#1-提高CPU并发计算能力" class="headerlink" title="1. 提高CPU并发计算能力"></a><strong>1. 提高CPU并发计算能力</strong></h3><p>服务器之所以可以同时处理多个请求，在于操作系统通过多执行流体系设计使得多个任务可以轮流使用系统资源。</p><p>这些资源包括CPU，内存以及I/O. 这里的I/O主要指磁盘I/O, 和网络I/O。</p><h5 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程 &amp; 多线程"></a><strong>多进程 &amp; 多线程</strong></h5><p>多执行流的一般便是进程，多进程的好处可以对CPU时间的轮流使用，对CPU计算和IO操作重叠利用。这里的IO主要是指磁盘IO和网络IO，相对CPU而言，它们慢的可怜。</p><p>而实际上，大多数进程的时间主要消耗在I/O操作上。</p><p>现代计算机的DMA技术可以让CPU不参与I/O操作的全过程，比如进程通过系统调用，使得CPU向网卡或者磁盘等I/O设备发出指令，然后进程被挂起，释放出CPU资源，等待I/O设备完成工作后通过中断来通知进程重新就绪。</p><p>对于单任务而言，CPU大部分时间空闲，这时候多进程的作用尤为重要。</p><p>多进程不仅能够提高CPU的并发度。其优越性还体现在独立的内存地址空间和生命周期所带来的稳定性和健壮性，其中一个进程崩溃不会影响到另一个进程。</p><p>但是进程也有如下<strong>缺点</strong>：</p><ol><li>fork()系统调用开销很大: prefork</li><li>进程间调度和上下文切换成本: 减少进程数量</li><li>庞大的内存重复：共享内存</li><li>IPC编程相对比较麻烦</li></ol><h4 id="减少进程切换"><a href="#减少进程切换" class="headerlink" title="减少进程切换"></a><strong>减少进程切换</strong></h4><p>当硬件上下文频繁装入和移出时，所消耗的时间是非常可观的。可用Nmon工具监视服务器每秒的上下文切换次数。</p><p>为了尽量减少上下文切换次数，最简单的做法就是减少进程数，尽量使用线程并配合其它I/O模型来设计并发策略。</p><p>还可以考虑使用进程绑定CPU技术，增加CPU缓存的命中率。若进程不断在各CPU上切换，这样旧的CPU缓存就会失效。</p><h4 id="减少使用不必要的锁"><a href="#减少使用不必要的锁" class="headerlink" title="减少使用不必要的锁"></a><strong>减少使用不必要的锁</strong></h4><p>服务器处理大量并发请求时，多个请求处理任务时存在一些资源抢占竞争，这时一般采用“锁”机制来控制资源的占用。到底<code>什么是重入锁</code>附录内容推荐大家看下。</p><p>当一个任务占用资源时，我们锁住资源，这时其它任务都在等待锁的释放，这个现象称为<strong>锁竞争</strong>。</p><p>通过锁竞争的本质，我们要意识到尽量减少并发请求对于共享资源的竞争。</p><p>比如在允许情况下关闭服务器访问日志，这可以大大减少在锁等待时的延迟时间。要最大程度减少无辜的等待时间。</p><p>这里说下无锁编程，就是由内核完成这个锁机制，主要是使用原子操作替代锁来实现对共享资源的访问保护。</p><p>使用原子操作时，在进行实际的写操作时，使用了lock指令，这样就可以阻止其他任务写这块内存，避免出现数据竞争现象。<strong>原子操作速度比锁快，一般要快一倍以上</strong>。</p><p>例如fwrite(), fopen()，其是使用append方式写文件，其原理就是使用了无锁编程，无锁编程的复杂度高，但是效率快，而且发生死锁概率低。</p><h4 id="考虑进程优先级"><a href="#考虑进程优先级" class="headerlink" title="考虑进程优先级"></a><strong>考虑进程优先级</strong></h4><p>进程调度器会动态调整运行队列中进程的优先级，通过top观察进程的PR值</p><h4 id="考虑系统负载"><a href="#考虑系统负载" class="headerlink" title="考虑系统负载"></a><strong>考虑系统负载</strong></h4><p>可在任何时刻查看/proc/loadavg, top中的load average也可看出</p><h4 id="考虑CPU使用率"><a href="#考虑CPU使用率" class="headerlink" title="考虑CPU使用率"></a><strong>考虑CPU使用率</strong></h4><p>除了用户空间和内核空间的CPU使用率以外，还要关注I/O wait,它是指CPU空闲并且等待I/O操作完成的时间比例（top中查看wa的值）。</p><h3 id="2-考虑减少内存分配和释放"><a href="#2-考虑减少内存分配和释放" class="headerlink" title="2. 考虑减少内存分配和释放"></a><strong>2. 考虑减少内存分配和释放</strong></h3><p>服务器的工作过程中，需要大量的内存，使得内存的分配和释放工作尤为重要。</p><p>可以通过改善数据结构和算法复制度来适当减少中间临时变量的内存分配及数据复制时间，而服务器本身也使用了各自的策略来提高效率。</p><p>例如Apache,在运行开始时一次申请大片的内存作为内存池，若随后需要时就在内存池中直接获取，不需要再次分配，避免了频繁的内存分配和释放引起的内存整理时间。</p><p>再如Nginx使用多线程来处理请求，使得多个线程之间可以共享内存资源，从而令它的内存总体使用量大大减少。</p><p>另外，Nginx分阶段的内存分配策略，按需分配，及时释放，使得内存使用量保持在很小的数量范围。</p><p>另外，还可以考虑<strong>共享内存</strong>。</p><p>共享内存指在多处理器的计算机系统中，可以被不同中央处理器（CPU）访问的大容量内存，也可以由不同进程共享，是非常快的进程通信方式。</p><p>但是使用共享内存也有不好的地方，就是对于多机器时数据不好统一。</p><p>shell命令ipcs可用来显示系统下共享内存的状态，函数shmget可以创建或打开一块共享内存区，函数shmat将一个存在的共享内存段连接到本进程空间, 函数shmctl可以对共享内存段进行多种操作，函数shmdt函数分离该共享内存。</p><h3 id="3-考虑使用持久连接"><a href="#3-考虑使用持久连接" class="headerlink" title="3. 考虑使用持久连接"></a><strong>3. 考虑使用持久连接</strong></h3><p>持久连接也为<strong>长连接</strong>，它本身是TCP通信的一种普通方式，即在一次TCP连接中持续发送多分数据而不断开连接。</p><p>与它相反的方式称为<strong>短连接</strong>，也就是建立连接后发送一份数据就断开，然后再次建立连接发送下一份数据， 周而复始。</p><p>是否采用持久连接，完全取决于应用特点。</p><p>从性能角度看，建立TCP连接的操作本身是一项不小的开销，在允许的情况下，连接次数越少，越有利于性能的提升; 尤其对于密集型的图片或网页等小数据请求处理有明显的加速所用。</p><p>HTTP长连接需要浏览器和web服务器的共同协作，目前浏览器普遍支持长连接，表现在其发出的HTTP请求数据头中包含关于长连接的声明，如下：Connection: Keep-Alive</p><p>主流的web服务器都支持长连接，比如apache中，可以用KeepAlive off关闭长连接。</p><p>对于长连接的有效使用，还有关键一点在于长连接超时时间的设置，即长连接在什么时候关闭吗？</p><p>Apache的默认设置为5s, 若这个时间设置过长，则可能导致资源无效占有，维持大量空闲进程，影响服务器性能。</p><h3 id="4-改进I-O-模型"><a href="#4-改进I-O-模型" class="headerlink" title="4. 改进I/O 模型"></a><strong>4. 改进I/O 模型</strong></h3><p>I/O操作根据设备的不同分为很多类型，比如内存I/O, 网络I/O, 磁盘I/O。</p><p>对于网络I/O和磁盘I/O, 它们的速度要慢很多，尽管使用RAID磁盘阵列可通过并行磁盘磁盘来加快磁盘I/O速度，购买大连独享网络带宽以及使用高带宽网络适配器可以提高网络I/O的速度。</p><p>但这些I/O操作需要内核系统调用来完成，这些需要CPU来调度，这使得CPU不得不浪费宝贵的时间来等待慢速I/O操作。</p><p>我们希望让CPU足够少的时间在i/O操作的调度上，如何让高速的CPU和慢速的I/O设备更好地协调工作，是现代计算机一直探讨的话题。各种I/O模型的本质区别在于CPU的参与方式。</p><h4 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a><strong>DMA技术</strong></h4><p>I/O设备和内存之间的数据传输方式由DMA控制器完成。在DMA模式下，CPU只需向DMA下达命令，让DMA控制器来处理数据的传送，这样可以大大节省系统资源。</p><h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a><strong>异步I/O</strong></h4><p>异步I/O指主动请求数据后便可以继续处理其它任务，随后等待I/O操作的通知，这样进程在数据读写时不发生阻塞。</p><p>异步I/O是非阻塞的，当函数返回时，真正的I/O传输已经完成，这让CPU处理和I/O操作达到很好的重叠。</p><h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a><strong>I/O多路复用</strong></h4><p>epoll服务器同时处理大量的文件描述符是必不可少的，若采用同步非阻塞I/O模型，若同时接收TCP连接的数据，就必须轮流对每个socket调用接收数据的方法，不管这些socket有没有可接收的数据，都要询问一次。</p><p>假如大部分socket并没有数据可以接收，那么进程便会浪费很多CPU时间用于检查这些socket有没有可以接收的数据。</p><p>多路I/O就绪通知的出现，提供了对大量文件描述符就绪检查的高性能方案，它允许进程通过一种方法同时监视所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。</p><p>epoll可以同时支持水平触发和边缘触发，理论上边缘触发性能更高，但是代码实现复杂，因为任何意外的丢失事件都会造成请求处理错误。</p><p>epoll主要有2大改进：</p><ol><li><p>epoll只告知就绪的文件描述符，而且当调用epoll_wait()获得文件描述符时，返回并不是实际的描述符，而是一个代表就绪描述符数量的值，然后只需去epoll指定的一个数组中依次取得相应数量的文件描述符即可。</p><p>这里使用了内存映射(mmap)技术，这样彻底省掉了这些文件描述符在系统调用时复制的开销。</p></li><li><p>epoll采用基于事件的就绪通知方式。其事先通过epoll_ctrl()注册每一个文件描述符，一旦某个文件描述符就绪时，内核会采用类似callback的回调机制，当进程调用epoll_wait()时得到通知</p></li></ol><p>关于IO模型，可以参考笔者前面写的相关文章Java NIO.2；关于epoll，可以参考笔者前面写的文章select、poll和epoll简介。</p><h4 id="Sendfile"><a href="#Sendfile" class="headerlink" title="Sendfile"></a><strong>Sendfile</strong></h4><p>大多数时候，我们都向服务器请求静态文件，比如图片，样式表等。</p><p>在处理这些请求时，磁盘文件的数据先经过内核缓冲区，然后到用户内存空间，不需经过任何处理，其又被送到网卡对应的内核缓冲区，接着再被送入网卡进行发送。</p><p>Linux提供sendfile()系统调用，可以讲磁盘文件的特定部分直接传送到代表客户端的socket描述符，加快了静态文件的请求速度，同时减少CPU和内存的开销。</p><p>适用场景：对于请求较小的静态文件，sendfile发挥的作用不那么明显，因发送数据的环节在整个过程中所占时间的比例相比于大文件请求时小很多。</p><h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a><strong>内存映射</strong></h4><p>Linux内核提供一种访问磁盘文件的特殊方式，它可以将内存中某块地址空间和我们指定的磁盘文件相关联，从而对这块内存的访问转换为对磁盘文件的访问。这种技术称为<strong>内存映射</strong>。</p><p>多数情况下，内存映射可以提高磁盘I/O的性能，无须使用read()或write()等系统调用来访问文件，而是通过mmap()系统调用来建立内存和磁盘文件的关联，然后像访问内存一样自由访问文件。</p><p><strong>缺点</strong>：在处理较大文件时，内存映射会导致较大的内存开销，得不偿失。</p><h4 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a><strong>直接I/O</strong></h4><p>在linux 2.6中，内存映射和直接访问文件没有本质差异，因为数据需要经过2次复制，即在磁盘与内核缓冲区之间以及在内核缓冲区与用户态内存空间。</p><p>引入内核缓冲区的目的在于<strong>提高磁盘文件的访问性能</strong>，然而对于一些复杂的应用，比如数据库服务器，它们为了进一步提高性能，希望绕过内核缓冲区，由自己在用户态空间实现并管理I/O缓冲区，比如数据库可根据更加合理的策略来提高查询缓存命中率。</p><p>另一方面，绕过内核缓冲区也可以减少系统内存的开销，因内核缓冲区本身就在使用系统内存。</p><p>Linux在open()系统调用中增加参数选项O_DIRECT,即可绕过内核缓冲区直接访问文件,实现直接I/O。</p><p>在Mysql中，对于Innodb存储引擎，自身进行数据和索引的缓存管理，可在my.cnf配置中分配raw分区跳过内核缓冲区，实现直接I/O。</p><h3 id="5-改进服务器并发策略"><a href="#5-改进服务器并发策略" class="headerlink" title="5. 改进服务器并发策略"></a><strong>5. 改进服务器并发策略</strong></h3><p>服务器并发策略的目的，是让I/O操作和CPU计算尽量重叠进行，一方面让CPU在I/O等待时不要空闲，另一方面让CPU在I/O调度上尽量花最少的时间。</p><h4 id="一个进程处理一个连接，非阻塞I-O"><a href="#一个进程处理一个连接，非阻塞I-O" class="headerlink" title="一个进程处理一个连接，非阻塞I/O"></a><strong>一个进程处理一个连接，非阻塞I/O</strong></h4><p>这样会存在多个并发请求同时到达时，服务器必然要准备多个进程来处理请求。其进程的开销限制了它的并发连接数。</p><p>但从稳定性和兼容性的角度，则其相对安全，任何一个子进程的崩溃不会影响服务器本身，父进程可以创建新的子进程；这种策略典型的例子就是Apache的fork和prefork模式。</p><p>对于并发数不高（如150以内）的站点同时依赖Apache其它功能时的应用选择Apache还是可以的。</p><h4 id="一个线程处理一个连接，非阻塞IO"><a href="#一个线程处理一个连接，非阻塞IO" class="headerlink" title="一个线程处理一个连接，非阻塞IO"></a><strong>一个线程处理一个连接，非阻塞IO</strong></h4><p>这种方式允许在一个进程中通过多个线程来处理多个连接，一个线程处理一个连接。Apache的worker模式就是这种典型例子，使其可支持更多的并发连接。不过这种模式的总体性能还不如prefork，所以一般不选用worker模式。</p><h4 id="一个进程处理多个连接，异步I-O"><a href="#一个进程处理多个连接，异步I-O" class="headerlink" title="一个进程处理多个连接，异步I/O"></a><strong>一个进程处理多个连接，异步I/O</strong></h4><p>一个线程同时处理多个连接，潜在的前提条件就是使用IO多路复用就绪通知。</p><p>这种情况下，将处理多个连接的进程叫做worker进程或服务进程。worker的数量可以配置，如Nginx中的worker_processes 4。</p><h4 id="一个线程处理多个连接，异步IO"><a href="#一个线程处理多个连接，异步IO" class="headerlink" title="一个线程处理多个连接，异步IO"></a><strong>一个线程处理多个连接，异步IO</strong></h4><p>即使有高性能的IO多路复用就绪通知，但磁盘IO的等待还是无法避免的。更加高效的方法是对磁盘文件使用异步IO，目前很少有Web服务器真正意义上支持这种异步IO。</p><h3 id="6-改进硬件环境"><a href="#6-改进硬件环境" class="headerlink" title="6. 改进硬件环境"></a><strong>6. 改进硬件环境</strong></h3><p>还有一点要提及的是硬件环境，服务器的硬件配置对应用程序的性能提升往往是最直接，也是最简单的方式，这就是所谓的scale up。这里不做论述。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h3><blockquote><p>java.util.concurrent.locks.ReentrantLock</p></blockquote><p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p><p><img src="/2020/02/11/如何提高服务器的并发处理能力/640.webp" alt="img"></p><p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p><blockquote><p>java.util.concurrent.locks.Lock</p></blockquote><p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p><h3 id="为什么叫重入锁呢？"><a href="#为什么叫重入锁呢？" class="headerlink" title="为什么叫重入锁呢？"></a>为什么叫重入锁呢？</h3><p><code>ReentrantLock</code>，我们把它拆开来看就明了了。</p><p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p><p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p><h3 id="重入锁最重要的几个方法"><a href="#重入锁最重要的几个方法" class="headerlink" title="重入锁最重要的几个方法"></a>重入锁最重要的几个方法</h3><p>这几个方法都是 Lock 接口中定义的：</p><p><img src="/2020/02/11/如何提高服务器的并发处理能力/640.webp" alt="img"></p><p><strong>1）lock()</strong></p><p>获取锁，有以下三种情况：</p><ul><li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li><li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li><li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li></ul><p><strong>2）lockInterruptibly()</strong></p><p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p><p><strong>3）tryLock()</strong></p><p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p><ul><li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li><li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li><li>其他线程持有锁：获取锁失败，返回：false；</li></ul><p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p><p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p><p><strong>5）unlock()</strong></p><p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p><p><strong>6）newCondition</strong></p><p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！</p><h3 id="重入锁大概的用法"><a href="#重入锁大概的用法" class="headerlink" title="重入锁大概的用法"></a>重入锁大概的用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p><h3 id="synchronized-是重入锁吗？"><a href="#synchronized-是重入锁吗？" class="headerlink" title="synchronized 是重入锁吗？"></a>synchronized 是重入锁吗？</h3><p>那么问题来了，synchronized 是重入锁吗？</p><p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p><p>答案是：yes，为什么？看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p><blockquote><p>转载自<a href="http://www.cnblogs.com/zengjin93/p/5569556.html" target="_blank" rel="noopener">www.cnblogs.com/zengjin93/p/5569556.html</a> 原作者：潇洒一剑，在原文基础上有修改。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容为入门级介绍，意在对老技术作较全的总结而不是较深的研究。主要参考《构建高性能Web站点》一书。&lt;/p&gt;
&lt;h2 id=&quot;什么是服务器并发处理能力&quot;&gt;&lt;a href=&quot;#什么是服务器并发处理能力&quot; class=&quot;headerlink&quot; title=&quot;什么是服务器并发处理能力&quot;&gt;&lt;/a&gt;什么是服务器并发处理能力&lt;/h2&gt;&lt;p&gt;一台服务器在单位时间里能处理的请求越多，服务器的能力越高，也就是服务器并发处理能力越强&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="分布式架构" scheme="https://vincentruan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="资源管理" scheme="https://vincentruan.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
      <category term="转载" scheme="https://vincentruan.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>分布式基础要点</title>
    <link href="https://vincentruan.github.io/2020/02/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%A6%81%E7%82%B9/"/>
    <id>https://vincentruan.github.io/2020/02/06/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%A6%81%E7%82%B9/</id>
    <published>2020-02-06T12:20:12.000Z</published>
    <updated>2020-02-25T15:09:15.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a><strong>模型</strong></h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h4><p>在具体的工程项目中，一个节点往往是一个操作系统上的进程。在本文的模型中，认为节点是一个完整的、不可分的整体，如果某个程序进程实际上由若干相对独立部分构成，则在模型中可以将一个进程划分为多个节点。</p><a id="more"></a><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><ol><li><strong>机器宕机</strong>：机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</li><li><strong>网络异常</strong>：消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</li><li><strong>分布式三态</strong>：如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</li><li><strong>存储数据丢失</strong>:对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。</li><li><strong><em>异常处理原则\</em></strong>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</li></ol><h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a><strong>副本</strong></h3><p>副本（replica/copy）指在分布式系统中为数据或服务提供的冗余。对于数据副本指在不同的节点上持久化同一份数据，当出现某一个节点的存储的数据丢失时，可以从副本上读到数据。数据副本是分布式系统解决数据丢失异常的唯一手段。另一类副本是服务副本，指数个节点提供某种相同的服务，这种服务一般并不依赖于节点的本地存储，其所需数据一般来自其他节点。</p><p>副本协议是贯穿整个分布式系统的理论核心。</p><h4 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a><strong>副本一致性</strong></h4><p>分布式系统通过副本控制协议，使得从系统外部读取系统内部各个副本的数据在一定的约束条件下相同，称之为副本一致性(consistency)。副本一致性是针对分布式系统而言的，不是针对某一个副本而言。</p><ol><li><strong>强一致性(strong consistency)</strong>：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。</li><li><strong>单调一致性(monotonic consistency)</strong>：任何时刻，任何用户一旦读到某个数据在某次更新后的值，这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。</li><li><strong>会话一致性(session consistency)</strong>：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的概念，例如php 中的session 概念。</li><li><strong>最终一致性(eventual consistency)</strong>：最终一致性要求一旦更新成功，各个副本上的数据最终将达 到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的副本，则无法保障任何一致性。</li><li><strong>弱一致性(week consistency)</strong>：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。</li></ol><h3 id="衡量分布式系统的指标"><a href="#衡量分布式系统的指标" class="headerlink" title="衡量分布式系统的指标"></a><strong>衡量分布式系统的指标</strong></h3><ol><li><strong>性能</strong>：系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</li><li><strong>可用性</strong>：系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</li><li><strong>可扩展性</strong>：系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</li><li><strong>一致性</strong>：分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单。</li></ol><h2 id="分布式系统原理"><a href="#分布式系统原理" class="headerlink" title="分布式系统原理"></a><strong>分布式系统原理</strong></h2><h3 id="数据分布方式"><a href="#数据分布方式" class="headerlink" title="数据分布方式**"></a>数据分布方式**</h3><p>所谓分布式系统顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计算、存储等问题。单机系统与分布式系统的最大的区别在于问题的规模，即计算、存储的数据量的区别。将一个单机问题使用分布式解决，首先要解决的就是如何将问题拆解为可以使用多机分布式解决，使得分布式系统中的每台机器负责原问题的一个子集。由于无论是计算还是存储，其问题输入对象都是数据，所以如何拆解分布式系统的输入数据成为分布式系统的基本问题。</p><h4 id="哈希方式"><a href="#哈希方式" class="headerlink" title="哈希方式"></a><strong>哈希方式</strong></h4><p><img src="/2020/02/06/分布式基础要点/image-20200206203106202.png" alt="image-20200206203106202"></p><p>哈希分布数据的缺点同样明显，突出表现为可扩展性不高，一旦集群规模需要扩展，则几乎所有的数据需要被迁移并重新分布。工程中，扩展哈希分布数据的系统时，往往使得集群规模成倍扩展，按照数据重新计算哈希，这样原本一台机器上的数据只需迁移一半到另一台对应的机器上即可完成扩展。</p><p>针对哈希方式扩展性差的问题，一种思路是不再简单的将哈希值与机器做除法取模映射，而是将对应关系作为元数据由专门的元数据服务器管理.同时，哈希值取模个数往往大于机器个数，这样同一台机器上需要负责多个哈希取模的余数。但需要以较复杂的机制维护大量的元数据。哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题。</p><p>哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题</p><p><img src="/2020/02/06/分布式基础要点/image-20200207095335209.png" alt="image-20200207095335209"></p><h4 id="按数据范围分布"><a href="#按数据范围分布" class="headerlink" title="按数据范围分布"></a><strong>按数据范围分布</strong></h4><p>按数据范围分布是另一个常见的数据分布式，将数据按特征值的值域范围划分为不同的区间，使得集群中每台（组）服务器处理不同区间的数据。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203344509.png" alt="image-20200206203344509"></p><p>工程中，为了数据迁移等负载均衡操作的方便，往往利用动态划分区间的技术，使得每个区间中服务的数据量尽量的一样多。当某个区间的数据量较大时，通过将区间“分裂”的方式拆分为两个区间，使得每个数据区间中的数据量都尽量维持在一个较为固定的阈值之下。</p><p>一般的，往往需要使用专门的服务器在内存中维护数据分布信息，称这种数据的分布信息为一种元信息。甚至对于大规模的集群，由于元信息的规模非常庞大，单台 计算机无法独立维护，需要使用多台机器作为元信息服务器。</p><h4 id="按数据量分布"><a href="#按数据量分布" class="headerlink" title="按数据量分布"></a><strong>按数据量分布</strong></h4><p>数据量分布数据与具体的数据特征无关，而是将数据视为一个顺序增长的文件，并将这个文件按照某一较为固定的大小划分为若干数据块（chunk），不同的数据块分布到不同的服务器上。与按数据范围分布数据的方式类似的是，按数据量分布数据也需要记录数据块的具体分布情况，并将该分布信息作为元数据使用元数据服务器管理。</p><p>由于与具体的数据内容无关，按数据量分布数据的方式一般没有数据倾斜的问题，数据总是被均匀切分并分布到集群中。当集群需要重新负载均衡时，只需通过迁移数据块即可完成。集群扩容也没有太大的限制，只需将部分数据库迁移到新加入的机器上即可以完成扩容。按数据量划分数据的缺点是需要管理较为复杂的元信息，与按范围分布数据的方式类似，当集群规模较大时，元信息的数据量也变得很大，高效的管理元信息成为新的课题。</p><h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a><strong>一致性哈希</strong></h4><p>一致性哈希（consistent hashing）是另一个种在工程中使用较为广泛的数据分布方式。一致性哈希最初在P2P 网络中作为分布式哈希表（DHT）的常用数据分布算法。一致性哈希的基本方式是使用一个哈希函数计算数据或数据特征的哈希值，令该哈希函数的输出值域为一个封闭的环，即哈希函数输出的最大值是最小值的前序。将节点随机分布到这个环上，每个节点负责处理从自己开始顺时针至下一个节点的全部哈希值域上的数据。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203409796.png" alt="image-20200206203409796"></p><p>使用一致性哈希的方式需要将节点在一致性哈希环上的位置作为元信息加以管理，这点比直接使用哈希分布数据的方式要复杂。然而，节点的位置信息只于集群中的机器规模相关，其元信息的量通常比按数据范围分布数据和按数据量分布数据的元信息量要小很多。</p><p>为此一种常见的改进算法是引入虚节点（virtual node）的概念，系统初始时就创建许多虚节点，虚节点的个数一般远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希值域环上，其功能与基本一致性哈希算法中的节点相同。为每个节点分配若干虚节点。操作数据时，首先通过数据的哈希值在环上找到对应的虚节点，进而查找元数据找到对应的真实节点。使用虚节点改进有多个优点。首先，一旦某个节点不可用，该节点将使得多个虚节点不可用，从而使得多个相邻的真实节点负载失效节点的压里。同理，一旦加入一个新节点，可以分配多个虚节点，从而使得新节点可以 负载多个原有节点的压力，从全局看，较容易实现扩容时的负载均衡。</p><h4 id="副本与数据分布"><a href="#副本与数据分布" class="headerlink" title="副本与数据分布"></a><strong>副本与数据分布</strong></h4><p>分布式系统容错、提高可用性的基本手段就是使用副本。对于数据副本的分布方式主要影响系统的可扩展性。一种基本的数据副本策略是以机器为单位，若干机器互为副本，副本机器之间的数据完全相同。这种策略适用于上述各种数据分布方式。其优点是非常简单，其缺点是恢复数据的效率不高、可扩展性也不高。</p><p>更合适的做法不是以机器作为副本单位，而是将数据拆为较合理的数据段，以数据段为单位作为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小以内。数据段有很多不同的称谓，segment，fragment，chunk，partition 等等。数据段的选择与数据分布方式直接相关。对于哈希分数据的方式，每个哈希分桶后的余数可以作为一个数据段，为了控制数据段的大小，常常使得分桶个数大于集群规模。一旦将数据分为数据段，则可以以数据段为单位管理副本，从而副本与机器不再硬相关，每台机器都可以负责一定数据段的副本。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203433498.png" alt="image-20200206203433498"></p><p>一旦副本分布与机器无关，数据丢失后的恢复效率将非常高。这是因为，一旦某台机器的数据丢失，其上数据段的副本将分布在整个集群的所有机器中，而不是仅在几个副本机器中，从而可以从整个集群同时拷贝恢复数据，而集群中每台数据源机器都可以以非常低的资源做拷贝。作为恢复数据源的机器即使都限速1MB/s，若有100 台机器参与恢复，恢复速度也能达到100MB/s。再者，副本分布与机器无关也利于集群容错。如果出现机器宕机，由于宕机机器上的副本分散于整个集群，其压力也自然分散到整个集群。最后，副本分布与机器无关也利于集群扩展。理论上，设集群规模 为N 台机器，当加入一台新的机器时，只需从各台机器上迁移1/N – 1/N+1 比例的数据段到新机器即实现了新的负载均衡。由于是从集群中各机器迁移数据，与数据恢复同理，效率也较高。工程中，完全按照数据段建立副本会引起需要管理的元数据的开销增大，副本维护的难度也相应增大。一种折中的做法是将某些数据段组成一个数据段分组，按数据段分组为粒度进行副本管理。这样做可以将副本粒度控制在一个较为合适的范围内。</p><h4 id="本地化计算"><a href="#本地化计算" class="headerlink" title="本地化计算"></a><strong>本地化计算</strong></h4><p>在分布式系统中，数据的分布方式也深深影响着计算的分布方式。在分布式系统中计算节点和保存计算数据的存储节点可以在同一台物理机器上，也可以位于不同的物理机器。如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此种方式的开销很大，甚至网络带宽会成为系统的总体瓶颈。另一种思路是，将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一种重要优化，其体现了一种重要的分布式调度思想：“移动数据不如移动计算”。</p><h4 id="数据分布方式的选择"><a href="#数据分布方式的选择" class="headerlink" title="数据分布方式的选择"></a><strong>数据分布方式的选择</strong></h4><p>在实际工程实践中，可以根据需求及实施复杂度合理选择数据分布方式。另外，数据分布方式是可以灵活组合使用的，往往可以兼备各种方式的优点，收到较好的综合效果。</p><p>例：数据倾斜问题，在按哈希分数据的基础上引入按数据量分布数据的方式，解决该数据倾斜问题。按用户id 的哈希值分数据，当某个用户id 的数据量特别大时，该用户的数据始终落在某一台机器上。此时，引入按数据量分布数据的方式，统计用户的数据量，并按某一阈值将用户的数据切为多个均匀的数据段，将这些数据段分布到集群中去。由于大部分用户的数据量不会超过阈值，所以元数据中仅仅保存超过阈值的用户的数据段分布信息，从而可以控制元数据的规模。这种哈希分布数据方式与按数据量分布数据方式组合使用的方案，在某真实系统中使用，取得了较好的效果。</p><h3 id="基本副本协议"><a href="#基本副本协议" class="headerlink" title="基本副本协议"></a><strong>基本副本协议</strong></h3><p>副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一致性要求的分布式协议。副本控制协议要具有一定的对抗异常状态的容错能力，从而使得系统具有一定的可用性，同时副本控制协议要能提供一定一致性级别。由CAP 原理（在2.9 节详细分析）可知，要设计一种满足强一致性，且在出现任何网络异常时都可用的副本协议是不可能的。为此，实际中的副本控制协议总是在可用性、一致性与性能等各要素之间按照具体需求折中。</p><p>副本控制协议可以分为两大类：“中心化(centralized)副本控制协议”和“去中心化(decentralized)副本控制协议”。</p><h4 id="中心化副本控制协议"><a href="#中心化副本控制协议" class="headerlink" title="中心化副本控制协议"></a><strong>中心化副本控制协议</strong></h4><p>中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之间的一致性。图给出了中心化副本协议的通用架构。中心化副本控制协议的优点是协议相对较为简单，所有的副本相关的控制交由中心节点完成。并发控制将由中心节点完成，从而使得一个分布式并发控制问题，简化为一个单机并发控制问题。所谓并发控制，即多个节点同时需要修改副本数据时，需要解决“写写”、“读写”等并发冲突。单机系统上常用加锁等方式进行并发控制。对于分布式并发控制，加锁也是一个常用的方法，但如果没有中心节点统一进行锁管理，就需要完全分布式化的锁系统，会使得协议非常复杂。中心化副本控制协议的缺点是系统的可用性依赖于中心化节点，当中心节点异常或与中心节点通信中断时，系统将失去某些服务（通常至少失去更新服务），所以中心化副本控制协议的缺点正是存在一定的停服务时间。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203512899.png" alt="image-20200206203512899"></p><h4 id="primary-secondary-协议"><a href="#primary-secondary-协议" class="headerlink" title="primary-secondary 协议"></a><strong>primary-secondary 协议</strong></h4><p>在primary-secondary 类型的协议中，副本被分为两大类，其中有且仅有一个副本作为primary 副本，除primary 以外的副本都作为secondary 副本。维护primary 副本的节点作为中心节点，中心节点负责维护数据的更新、并发控制、协调副本的一致性。</p><p>Primary-secondary 类型的协议一般要解决四大类问题：数据更新流程、数据读取方式、Primary 副本的确定和切换、数据同步（reconcile）。</p><h5 id="数据更新基本流程"><a href="#数据更新基本流程" class="headerlink" title="数据更新基本流程"></a>数据更新基本流程</h5><ol><li>数据更新都由primary 节点协调完成。</li><li>外部节点将更新操作发给primary 节点</li><li>primary 节点进行并发控制即确定并发更新操作的先后顺序</li><li>primary 节点将更新操作发送给secondary 节点</li><li>primary 根据secondary 节点的完成情况决定更新是否成功并将结果返回外部节点</li></ol><p><img src="/2020/02/06/分布式基础要点/image-20200206203526071.png" alt="image-20200206203526071"></p><p>在工程实践中，如果由primary 直接同时发送给其他N 个副本发送数据，则每个 secondary 的更新吞吐受限于primary 总的出口网络带宽，最大为primary 网络出口带宽的1/N。为了解决这个问题，有些系统（例如，GFS），使用接力的方式同步数据，即primary 将更新发送给第一 个secondary 副本，第一个secondary 副本发送给第二secondary 副本，依次类推。</p><h5 id="数据读取方式"><a href="#数据读取方式" class="headerlink" title="数据读取方式"></a><strong>数据读取方式</strong></h5><p>数据读取方式也与一致性高度相关。如果只需要最终一致性，则读取任何副本都可以满足需求。如果需要会话一致性，则可以为副本设置版本号，每次更新后递增版本号，用户读取副本时验证版本号，从而保证用户读到的数据在会话范围内单调递增。使用primary-secondary 比较困难的是实现强一致性。</p><ol><li>由于数据的更新流程都是由primary 控制的，primary 副本上的数据一定是最新的，所以 如果始终只读primary 副本的数据，可以实现强一致性。如果只读primary 副本，则secondary 副本将不提供读服务。实践中，如果副本不与机器绑定，而是按照数据段为单位维护副本，仅有primary 副本提供读服务在很多场景下并不会造出机器资源浪费。</li></ol><p>将副本分散到集群中个，假设primary 也是随机的确定的，那么每台机器上都有一些数据的primary 副本，也有另一些数据段的secondary 副本。从而某台服务器实际都提供读写服务。</p><ol><li>由primary 控制节点secondary 节点的可用性。当primary 更新某个secondary 副本不成功时，primary 将该secondary 副本标记为不可用，从而用户不再读取该不可用的副本。不可用的 secondary 副本可以继续尝试与primary 同步数据，当与primary 完成数据同步后，primary 可以副本标记为可用。这种方式使得所有的可用的副本，无论是primary 还是secondary 都是可读的，且在一个确定的时间内，某secondary 副本要么更新到与primary 一致的最新状态，要么被标记为不可用，从而符合较高的一致性要求。这种方式依赖于一个中心元数据管理系统，用于记录哪些副本可用，哪些副本不可用。某种意义上，该方式通过降低系统的可用性来提高系统的一致性。</li></ol><h5 id="primary-副本的确定与切换"><a href="#primary-副本的确定与切换" class="headerlink" title="primary 副本的确定与切换"></a><strong>primary 副本的确定与切换</strong></h5><p>在primary-secondary 类型的协议中，另一个核心的问题是如何确定primary 副本，尤其是在原primary 副本所在机器出现宕机等异常时，需要有某种机制切换primary 副本，使得某个secondary 副本成为新的primary 副本。</p><p>通常的，在primary-secondary 类型的分布式系统中，哪个副本是primary 这一信息都属于元信息，由专门的元数据服务器维护。执行更新操作时，首先查询元数据服务器获取副本的primary 信息，从而进一步执行数据更新流程。</p><p>由于分布式系统中可靠的发现节点异常是需要一定的探测时间的，这样的探测时间通常是10 秒级别，这也意味着一旦primary 异常，最多需要10 秒级别的发现时间，系统才能开始primary 的切换，在这10 秒时间内，由于没有primary，系统不能提供更 新服务，如果系统只能读primary 副本，则这段时间内甚至不能提供读服务。从这里可以看到，primary-backup 类副本协议的最大缺点就是由于primary 切换带来的一定的停服务时间。</p><h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a><strong>数据同步</strong></h5><p>不一致的secondary 副本需要与primary 进行同步（reconcile）。</p><p>通常不一致的形式有三种：一、由于网络分化等异常，secondary 上的数据落后于primary 上的数据。二、在某些协议下，secondary 上的数据有可能是脏数据，需要被丢弃。所谓脏数据是由于primary 副本没有进行某一更新操作，而secondary 副本上反而进行的多余的修改操作，从而造成secondary 副本数据错误。三、secondary 是一个新增加的副本，完全没有数据，需要从其他副本上拷贝数据。</p><p>对于第一种secondary 数据落后的情况，常见的同步方式是回放primary 上的操作日志（通常是redo 日志），从而追上primary 的更新进度。对于脏数据的情况，较好的做法是设计的分布式协议不产生脏数据。如果协议一定有产生脏数据的可能，则也应该使得产生脏数据的概率降到非常低得情况，从而一旦发生脏数据的情况可以简单的直接丢弃有脏数据的副本，这样相当于副本没有数据。另外，也可以设计一些基于undo 日志的方式从而可以删除脏数据。如果secondary 副本完全没有数据，则常见的做法是直接拷贝primary 副本的数据，这种方法往往比回放日志追更新进度的方法快很多。但拷贝数据时primary 副本需要能够继续提供更新服务，这就要求primary 副本支持快照(snapshot)功能。即对某一刻的副本数据形成快照，然后拷贝快照，拷贝完成后使用回放日志的方式追快照形成后的更新操作。</p><h4 id="去中心化副本控制协议"><a href="#去中心化副本控制协议" class="headerlink" title="去中心化副本控制协议"></a><strong>去中心化副本控制协议</strong></h4><p>去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商达到一致。从而去中心化协议没有因为中心化节点异常而带来的停服务等问题。</p><p>去中心化协议的最大的缺点是协议过程通常比较复杂。尤其当去中心化协议需要实现强一致性时，协议流程变得复杂且不容易理解。由于流程的复杂，去中心化协议的效率或者性能一般也较中心化协议低。一个不恰当的比方就是，中心化副本控制协议类似专制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影响较大；去中心化副本控制协议类似民主制度，节点集体协商，效率低下，但个别节点的异常不会对系统总体造成太大影响。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203546614.png" alt="image-20200206203546614"></p><h3 id="Lease-机制"><a href="#Lease-机制" class="headerlink" title="Lease 机制"></a><strong>Lease 机制</strong></h3><p>Lease 机制是最重要的分布式协议，广泛应用于各种实际的分布式系统中。</p><h4 id="基于lease-的分布式cache-系统"><a href="#基于lease-的分布式cache-系统" class="headerlink" title="基于lease 的分布式cache 系统"></a><strong>基于lease 的分布式cache 系统</strong></h4><p>基本的问题背景如下：在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据cache，在各个节点上 cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。另一方面，系统的正确运行严格依赖于元数据的正确，这就要求各个节点上cache 的数据始终与中心服务器上的数据一致，cache 中的数据不能是旧的脏数据。最后，设计的cache 系统要能最大可能的处理节点宕机、网络中断等异常，最大程度的提高系统的可用性。</p><p>为此，利用lease 机制设计一套cache 系统，其基本原理为如下。中心服务器在向各节点发送数据时同时向节点颁发一个lease。每个lease 具有一个有效期，和信用卡上的有效期类似，lease 上的 有效期通常是一个明确的时间点，例如12:00:10，一旦真实时间超过这个时间点，则lease 过期失效。这样lease 的有效期与节点收到lease 的时间无关，节点可能收到lease 时该lease 就已经过期失效。这里首先假设中心服务器与各节点的时钟是同步的，在下节中讨论时钟不同步对lease 的影响。中心服务器发出的lease 的含义为：在lease 的有效期内，中心服务器保证不会修改对应数据的值。因此，节点收到数据和lease 后，将数据加入本地Cache，一旦对应的lease 超时，节点将对应的本地cache 数据删除。中心服务器在修改数据时，首先阻塞所有新的读请求，并等待之前为该数据发出的所有lease 超时过期，然后修改数据的值。</p><p>基于lease 的cache，客户端节点读取元数据</p><ol><li>判断元数据是否已经处于本地cache 且lease 处于有效期内1.1 是：直接返回cache 中的元数据1.2 否：向中心服务器节点请求读取元数据信息1.2.1 服务器收到读取请求后，返回元数据及一个对应的lease 1.2.2 客户端是否成功收到服务器返回的数据  1.2.2.1 失败或超时：退出流程，读取失败，可重试1.2.2.2 成功：将元数据与该元数据的lease 记录到内存中，返回元数据</li><li>基于lease 的cache，客户端节点修改元数据流程2.1 节点向服务器发起修改元数据请求。2.2 服务器收到修改请求后，阻塞所有新的读数据请求，即接收读请求，但不返回数据。2.3 服务器等待所有与该元数据相关的lease 超时。2.4 服务器修改元数据并向客户端节点返回修改成功。</li></ol><p>上述机制可以保证各个节点上的cache 与中心服务器上的中心始终一致。这是因为中心服务器节点在发送数据的同时授予了节点对应的lease，在lease 有效期内，服务器不会修改数据，从而客户端节点可以放心的在lease 有效期内cache 数据。上述lease 机制可以容错的关键是：服务器一旦 发出数据及lease，无论客户端是否收到，也无论后续客户端是否宕机，也无论后续网络是否正常，服务器只要等待lease 超时，就可以保证对应的客户端节点不会再继续cache 数据，从而可以放心的修改数据而不会破坏cache 的一致性。</p><p>上述基础流程有一些性能和可用性上的问题，但可以很容易就优化改性。优化点一：服务器在修改元数据时首先要阻塞所有新的读请求，造成没有读服务。这是为了防止发出新的lease 从而引起不断有新客户端节点持有lease 并缓存着数据，形成“活锁”。优化的方法很简单，服务器在进入修改数据流程后，一旦收到读请求则只返回数据但不颁发lease。从而造成在修改流程执行的过程中，客户端可以读到元数据，只是不能缓存元数据。进一步的优化是，当进入修改流程，服务器颁发的lease 有效期限选择为已发出的lease 的最大有效期限。这样做，客户端可以继续在服务器进入修改流程后继续缓存元数据，但服务器的等待所有lease 过期的时间也不会因为颁发新的lease 而不断延长。</p><p>最后，cache 机制与多副本机制的区别。Cache 机制与多副本机制的相似之处都 是将一份数据保存在多个节点上。但Cache 机制却要简单许多，对于cache 的数据，可以随时删除丢弃，并命中cache 的后果仅仅是需要访问数据源读取数据；然而副本机制却不一样，副本是不能随意丢弃的，每失去一个副本，服务质量都在下降，一旦副本数下降到一定程度，则往往服务将不再可用。</p><h5 id="lease-机制的分析"><a href="#lease-机制的分析" class="headerlink" title="lease 机制的分析"></a><strong>lease 机制的分析</strong></h5><p>lease 的定义：Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发出lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要lease 不过期，颁发者一定严守承诺；另一方面，接收方在lease 的有效期内可以使用颁发者的承诺，但一旦lease 过期，接收方一定不能继续使用颁发者的承诺。</p><p>Lease 机制具有很高的容错能力。首先，通过引入有效期，Lease 机制能否非常好的容错网络异常。Lease 颁发过程只依赖于网络可以单向通信，即使接收方无法向颁发者发送消息，也不影响lease 的颁发。由于lease 的有效期是一个确定的时间点，lease 的语义与发送lease 的具体时间无关，所以 同一个lease 可以被颁发者不断重复向接受方发送。即使颁发者偶尔发送lease 失败，颁发者也可以 简单的通过重发的办法解决。一旦lease 被接收方成功接受，后续lease 机制不再依赖于网络通信，即使网络完全中断lease 机制也不受影响。再者，Lease 机制能较好的容错节点宕机。如果颁发者宕机，则宕机的颁发者通常无法改变之前的承诺，不会影响lease 的正确性。在颁发者机恢复后，如果颁发者恢复出了之前的lease 信息，颁发者可以继续遵守lease 的承诺。如果颁发者无法恢复lease 信息，则只需等待一个最大的lease 超时时间就可以使得所有的lease 都失效，从而不破坏lease机制。</p><p>例如上节中的cache 系统的例子中，一旦服务器宕机，肯定不会修改元数据，重新恢复后，只需等待一个最大的lease 超时时间，所有节点上的缓存信息都将被清空。对于接受方宕机的情况，颁发者 不需要做更多的容错处理，只需等待lease 过期失效，就可以收回承诺，实践中也就是收回之前赋予的权限、身份等。最后，lease 机制不依赖于存储。颁发者可以持久化颁发过的lease 信息，从而在 宕机恢复后可以使得在有效期的lease 继续有效。但这对于lease 机制只是一个优化，如之前的分析，即使颁发者没有持久化lease 信息，也可以通过等待一个最大的lease 时间的方式使得之前所有颁发 的lease 失效，从而保证机制继续有效。</p><p>Lease 机制依赖于有效期，这就要求颁发者和接收者的时钟是同步的。一方面，如果颁发者的 时钟比接收者的时钟慢，则当接收者认为lease 已经过期的时候，颁发者依旧认为lease 有效。接收者可以用在lease 到期前申请新的lease 的方式解决这个问题。另一方面，如果颁发者的时钟比接收 者的时钟快，则当颁发者认为lease 已经过期的时候，接收者依旧认为lease 有效，颁发者可能将lease 颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对lease 的有效性的影响。</p><h5 id="基于lease-机制确定节点状态"><a href="#基于lease-机制确定节点状态" class="headerlink" title="基于lease 机制确定节点状态"></a><strong>基于lease 机制确定节点状态</strong></h5><p>分布式协议依赖于对节点状态认知的全局一致性，即一旦节点Q 认为某个节点 A 异常，则节点A 也必须认为自己异常，从而节点A 停止作为primary，避免“双主”问题的出现。解决这种问题有两种思路，第一、设计的分布式协议可以容忍“双主”错误，即不依赖于对节点状 态的全局一致性认识，或者全局一致性状态是全体协商后的结果；第二、利用lease 机制。对于第一 种思路即放弃使用中心化的设计，而改用去中心化设计，超过本节的讨论范畴。下面着重讨论利用 lease 机制确定节点状态。</p><p>由中心节点向其他节点发送lease，若某个节点持有有效的lease，则认为该节点正常可以提供服 务。用于例2.3.1 中，节点A、B、C 依然周期性的发送heart beat 报告自身状态，节点Q 收到heart beat 后发送一个lease，表示节点Q 确认了节点A、B、C 的状态，并允许节点在lease 有效期内正常工 作。节点Q 可以给primary 节点一个特殊的lease，表示节点可以作为primary 工作。一旦节点Q 希望切换新的primary，则只需等前一个primary 的lease 过期，则就可以安全的颁发新的lease 给新的 primary 节点，而不会出现“双主”问题。</p><p>在实际系统中，若用一个中心节点发送lease 也有很大的风险，一旦该中心节点宕机或网络异常，则所有的节点没有lease，从而造成系统高度不可用。为此，实际系统总是使用多个中心节点互为副本，成为一个小的集群，该小集群具有高可用性，对外提供颁发lease 的功能。chubby 和zookeeper 都是基于这样的设计。</p><h5 id="lease-的有效期时间选择"><a href="#lease-的有效期时间选择" class="headerlink" title="lease 的有效期时间选择"></a><strong>lease 的有效期时间选择</strong></h5><p>工程中，常选择的lease 时长是10 秒级别，这是一个经过验证的经验值，实践中可以作为参考并综合选择合适的时长。</p><h3 id="Quorum-机制"><a href="#Quorum-机制" class="headerlink" title="Quorum 机制"></a><strong>Quorum 机制</strong></h3><p>先做这样的约定：更新操作（write）是一系列顺序的过程，通过其他机制确定更新操作的顺序（例如primary-secondary 架构中由primary 决定顺序），每个更新操作记为wi， i 为更新操作单调递增的序号，每个wi 执行成功后副本数据都发生变化，称为不同的数据版本，记 作vi。假设每个副本都保存了历史上所有版本的数据。</p><h4 id="write-all-read-one"><a href="#write-all-read-one" class="headerlink" title="write-all-read-one"></a><strong>write-all-read-one</strong></h4><p>Write-all-read-one（简称WARO）是一种最简单的副本控制规则，顾名思义即在更新时写所有的副本，只有在所有的副本上更新成功，才认为更新成功，从而保证所有的副本一致，这样在读取数据时可以读任一副本上的数据。</p><p>由于更新操作需要在所有的N 个副本上都成功，更新操作才能成 功，所以一旦有一个副本异常，更新操作失败，更新服务不可用。对于更新服务，虽然有N 个副本， 但系统无法容忍任何一个副本异常。另一方面，N 个副本中只要有一个副本正常，系统就可以提供读服务。对于读服务而言，当有N 个副本时，系统可以容忍N-1 个副本异常。从上述分析可以发现WARO 读服务的可用性较高，但更新服务的可用性不高，甚至虽然使用了副本，但更新服务的可用性等效于没有副本。</p><h4 id="Quorum-定义"><a href="#Quorum-定义" class="headerlink" title="Quorum 定义"></a><strong>Quorum 定义</strong></h4><p>在Quorum 机制下，当某次更新操作wi 一旦在所有N 个副本中的W 个副本上都成功，则就称 该更新操作为“成功提交的更新操作”，称对应的数据为“成功提交的数据”。令R&gt;N-W，由于更新 操作wi 仅在W 个副本上成功，所以在读取数据时，最多需要读取R 个副本则一定能读到wi 更新后 的数据vi 。如果某次更新wi 在W 个副本上成功，由于W+R&gt;N，任意R 个副本组成的集合一定与 成功的W个副本组成的集合有交集，所以读取R 个副本一定能读到wi 更新后的数据vi。如图 2-10， Quorum 机制的原理可以文森图表示。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203639455.png" alt="image-20200206203639455"></p><p>某系统有5 个副本，W=3，R=3，最初5 个副本的数据一致，都是v1，某次更新操作 w2 在前3 副本上成功，副本情况变成（v2 v2 v2 v1 v1）。此时，任意3 个副本组成的集合中一定包括 v2。在上述定义中，令W=N，R=1，就得到WARO，即WARO 是Quorum 机制的一种特例。与分析WARO 相似，分析Quorum 机制的可用性。限制Quorum 参数为W+R=N+1。由于更新 操作需要在W 个副本上都成功，更新操作才能成功，所以一旦N-W+1 个副本异常，更新操作始终无法在W 个副本上成功，更新服务不可用。另一方面，一旦N-R+1 个副本异常，则无法保证一定可以读到与W 个副本有交集的副本集合，则读服务的一致性下降。</p><p>再次强调：仅仅依赖quorum 机制是无法保证强一致性的。因为仅有quorum 机制时无法确定最新已成功提交的版本号，除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数据集群管理，否则很难确定最新成功提交的版本号。在下一节中，将讨论在哪些情况下，可以仅仅 通过quorum 机制来确定最新成功提交的版本号。</p><p>Quorum 机制的三个系统参数N、W、R 控制了系统的可用性，也是系统对用户的服务承诺：数据最多有N 个副本，但数据更新成功W 个副本即返回用户成功。对于一致性要求较高的Quorum 系统，系统还应该承诺任何时候不读取未成功提交的数据，即读取到的数据都是曾经在W 个副本上成功的数据。</p><h4 id="读取最新成功提交的数据"><a href="#读取最新成功提交的数据" class="headerlink" title="读取最新成功提交的数据"></a><strong>读取最新成功提交的数据</strong></h4><p>Quorum 机制只需成功更新N 个副本中的W 个，在读取R 个副本时，一定可以读到最新的成功提交的数据。但由于有不成功的更新情况存在，仅仅读取R 个副本却不一定能确定哪个版本的数据 是最新的已提交的数据。对于一个强一致性Quorum 系统，若存在个数据少于W 个，假设为X 个，则继续读取其他副本，直若成功读取到W 个 该版本的副本，则该数据为最新的成功提交的数据；如果在所有副本中该数据的个数肯定不满 足W 个，则R 中版本号第二大的为最新的成功提交的副本。例：在读取到（v2 v1 v1）时，继续读取剩余的副本，若读到剩余两个副本 为（v2 v2）则v2 是最新的已提交的副本；若读到剩余的两个副本为（v2 v1）或（v1 v1）则v1 是最新成功提交的版本；若读取后续两个副本有任一超时或失败，则无法判断哪个版本是最新的成功提交的版本。</p><p>可以看出，在单纯使用Quorum 机制时，若要确定最新的成功提交的版本，最多需要读取R+ （W-R-1）=N 个副本，当出现任一副本异常时，读最新的成功提交的版本这一功能都有可能不可用。实际工程中，应该尽量通过其他技术手段，回避通过Quorum 机制读取最新的成功提交的版本。例如，当quorum 机制与primary-secondary 控制协议结合使用时，可以通过读取primary 的方式读取到最新的已提交的数据。</p><h4 id="基于Quorum-机制选择primary副本"><a href="#基于Quorum-机制选择primary副本" class="headerlink" title="基于Quorum 机制选择primary副本"></a><strong>基于Quorum 机制选择primary副本</strong></h4><p>读取数据时依照一致性要求的不同可以有不同的做法：如果需要强一致性的立刻读取到最新的成功提交的数据，则可以简单的只读取primary 副本上的数据即可，也可以通过上节的方式读取；如果需要会话一致性，则可以根据之前已经读到的数据版本号在各个副本上进行选择性读取；如果只需要弱一致性，则可以选择任意副本读取。</p><p>在primary-secondary 协议中，当primary 异常时，需要选择出一个新的primary，之后secondary 副本与primary 同步数据。通常情况下，选择新的primary 的工作是由某一中心节点完成的，在引入 quorum 机制后，常用的primary 选择方式与读取数据的方式类似，即中心节点读取R 个副本，选择 R 个副本中版本号最高的副本作为新的primary。新primary 与至少W 个副本完成数据同步后作为新的primary 提供读写服务。首先，R 个副本中版本号最高的副本一定蕴含了最新的成功提交的数据。再者，虽然不能确定最高版本号的数是一个成功提交的数据，但新的primary 在随后与secondary 同 步数据，使得该版本的副本个数达到W，从而使得该版本的数据成为成功提交的数据。</p><p>例：在N=5，W=3，R=3 的系统中，某时刻副本最大版本号为（v2 v2 v1 v1 v1），此时v1 是系统的最新的成功提交的数据，v2 是一个处于中间状态的未成功提交的数据。假设此刻原primary 副本异常，中心节点进行primary 切换工作。这类“中间态”数据究竟作为“脏数据”被删除，还是作为新的数据被同步后成为生效的数据，完全取决于这个数据能否参与新primary 的选举。下面分别分析这两种情况。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203657503.png" alt="image-20200206203657503"></p><p>第一、如图 2-12，若中心节点与其中3 个副本通信成功，读取到的版本号为（v1 v1 v1），则任 选一个副本作为primary，新primary 以v1 作为最新的成功提交的版本并与其他副本同步，当与第1、第2 个副本同步数据时，由于第1、第2 个副本版本号大于primary，属于脏数据，可以按照2.2.2.4 节中介绍的处理脏数据的方式解决。实践中，新primary 也有可能与后两个副本完成同步后就提供数据服务，随后自身版本号也更新到v2，如果系统不能保证之后的v2 与之前的v2 完全一样，则新 primary 在与第1、2 个副本同步数据时不但要比较数据版本号还需要比较更新操作的具体内容是否一样。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203707864.png" alt="image-20200206203707864"></p><p>第二、若中心节点与其他3 个副本通信成功，读取到的版本号为（v2 v1 v1），则选取版本号为 v2 的副本作为新的primary，之后，一旦新primary 与其他2 个副本完成数据同步，则符合v2 的副 本个数达到W 个，成为最新的成功提交的副本，新primary 可以提供正常的读写服务。</p><h3 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a><strong>日志技术</strong></h3><p>日志技术是宕机恢复的主要技术之一。日志技术最初使用在数据库系统中。严格来说日志技术不是一种分布式系统的技术，但在分布式系统的实践中，却广泛使用了日志技术做宕机恢复，甚 至如BigTable 等系统将日志保存到一个分布式系统中进一步增强了系统容错能力。</p><h4 id="Redo-Log-与Check-point"><a href="#Redo-Log-与Check-point" class="headerlink" title="Redo Log 与Check point"></a><strong>Redo Log 与Check point</strong></h4><p>设计一个高速的单机查询系统，将数据全部存放在内存中以实现高速的数据查询，每次更新操作更新一小部分数据（例如 key-value 中的某一个key）。现在问题为利用日志技术实现该内存查询系统的宕机恢复。与数据库的事务不同的是，这个问题模型中的每个成功的更新操作都会生效。这也等效为数据库的每个事务只有一个更新操作，且每次更新操作都可以也必须立即提交（Auto commit）。</p><ul><li><h5 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h5></li></ul><ol><li>将更新操作的结果（例如Set K1=1，则记录K1=1）以追加写（append）的方式写入磁盘的 日志文件</li><li>按更新操作修改内存中的数据</li><li>返回更新成功</li></ol><p>从Redo Log 的流程可以看出，Redo 写入日志的是更新操作完成后的结果（虽然本文不讨论Undo Log，这点是与Undo Log 的区别之一），且由于是顺序追加写日志文件，在磁盘等对顺序写有力的 存储设备上效率较高。</p><p>用Redo Log 进行宕机恢复非常简单，只需要“回放”日志即可。</p><p>流程2.5.2：Redo Log 的宕机恢复</p><ol><li>从头读取日志文件中的每次更新操作的结果，用这些结果修改内存中的数据。</li></ol><p>从Redo Log 的宕机恢复流程也可以看出，只有写入日志文件的更新结果才能在宕机后恢复。这也是为什么在Redo Log 流程中需要先更新日志文件再更新内存中的数据的原因。假如先更新内存中的数据，那么用户立刻就能读到更新后的数据，一旦在完成内存修改与写入日志之间发生宕机，那么最后一次更新操作无法恢复，但之前用户可能已经读取到了更新后的数据，从而引起不一致的问题。</p><ul><li><h5 id="Check-point"><a href="#Check-point" class="headerlink" title="Check point"></a>Check point</h5></li></ul><p>。在简化的模型下，check point 技术的过程即将内存中的数据以某种易于重新加载的数据组织方式完整的dump 到磁盘，从而减少宕机恢复时需要回放的日志数据。</p><p>流程：check point</p><ol><li>向日志文件中记录“Begin Check Point”</li><li>将内存中的数据以某种易于重新加载的数据组织方式dump 到磁盘上</li><li>向日志文件中记录“End Check Point” 在check point 流程中，数据可以继续按照流程2.5.1 被更新，这段过程中新更新的数据可以dump 到磁盘也可以不dump 到磁盘，具体取决于实现。例如，check point 开始时k1=v1，check point 过程 中某次更新为k1 = v2，那么dump 到磁盘上的k1 的值可以是v1 也可以是v2。</li></ol><p>流程：基于check point 的宕机恢复流程</p><ol><li>将dump 到磁盘的数据加载到内存。</li><li>从后向前扫描日志文件，寻找最后一个“End Check Point”日志。</li><li>从最后一个“End Check Point”日志向前找到最近的一个“Begin Check Point”日志，并回 放该日志之后的所有更新操作日志。</li></ol><ul><li><h4 id="No-Undo-No-Redo-log"><a href="#No-Undo-No-Redo-log" class="headerlink" title="No Undo/No Redo log"></a>No Undo/No Redo log</h4></li></ul><p>若数据维护在磁盘中，某批更新由若干个更新操作组成，这些更新操作需要原子生效，即要么同时生效，要么都不生效。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203755875.png" alt="image-20200206203755875"></p><p>0/1 目录技术中有两个目录结构，称为目录0(Directory 0)和目录1(Directory 1)。另有一个结构称为主记录（Master record）记录当前正在使用的目录称为活动目录。主记录中要么记录使用目录0，要么记录使用目录1。目录0 或目录1 中记录了各个数据的在日志文件中的位置。0/1 目录的数据更新过程始终在非活动目录上进行，只是在数据生效前，将主记录中的0、1 值反转，从而切换主记录。</p><p>流程：0/1 目录数据更新流程</p><ol><li>将活动目录完整拷贝到非活动目录。</li><li>对于每个更新操作，新建一个日志项纪录操作后的值，并在非活动目录中将相应数据的位置修改为新建的日志项的位置。</li><li>原子性修改主记录：反转主记录中的值，使得非活动目录生效。</li></ol><p>0/1 目录的更新流程非常简单，通过0、1 目录的主记录切换使得一批修改的生效是原子的。0/1 目录将批量事务操作的原子性通过目录手段归结到主记录的原子切换。由于多条记录的原子修改一般较难实现而单条记录的原子修改往往可以实现，从而降低了问题实现的难度。在工程中0/1 目录的思想运用非常广泛，其形式也不局限在上述流程中，可以是内存中的两个数据结构来回切换，也可以是磁盘上的两个文件目录来回生效切换。</p><h3 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a><strong>两阶段提交协议</strong></h3><p>两阶段提交协议是一种经典的强一致性中心化副本控制协议。虽然在工程中该协议有较多的问题，但研究该协议能很好的理解分布式系统的几个典型问题。</p><h4 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a><strong>流程描述</strong></h4><p>两阶段提交协议是一种典型的“中心化副本控制”协议。在该协议中，参与的节点分为两类：一个中心化协调者节点（coordinator）和N 个参与者节点（participant）。每个参与者节点即上文背景介绍中的管理数据库副本的节点。</p><p>两阶段提交的思路比较简单，在第一阶段，协调者询问所有的参与者是否可以提交事务（请参与者投票），所有参与者向协调者投票。在第二阶段，协调者根据所有参与者的投票结果做出是否事务可以全局提交的决定，并通知所有的参与者执行该决定。在一个两阶段提交流程中，参与者不能改变自己的投票结果。两阶段提交协议的可以全局提交的前提是所有的参与者都同意提交事务，只要有一个参与者投票选择放弃(abort)事务，则事务必须被放弃。</p><p>流程：两阶段提交协调者流程</p><ol><li>写本地日志“begin_commit”，并进入WAIT 状态；</li><li>向所有参与者发送“prepare 消息”；</li><li>等待并接收参与者发送的对“prepare 消息”的响应；3.1 若收到任何一个参与者发送的“vote-abort 消息”；3.1.1 写本地“global-abort”日志，进入ABORT；3.1.2 向所有的参与者发送“global-abort 消息”；3.1.3 进入ABORT 状态；3.2 若收到所有参与者发送的“vote-commit”消息；3.2.1 写本地“global-commit”日志，进入COMMIT 状态；3.1.2 向所有的参与者发送“global-commit 消息”；</li><li>等待并接收参与者发送的对“global-abort 消息”或“global-commit 消息”的确认响应消息，一旦收到所有参与者的确认消息，写本地“end_transaction” 日志流程结束。</li></ol><p>流程：两阶段提交协调者流程</p><ol><li>写本地日志“init”记录，进入INIT 状态</li><li>等待并接受协调者发送的“prepare 消息”，收到后  2.1 若参与者可以提交本次事务 2.1.1 写本地日志“ready”，进入READY 状态 2.1.2 向协调者发送“vote-commit”消息 2.1.4 等待协调者的消息2.1.4.1 若收到协调者的“global-abort”消息2.1.4.1.1 写本地日志“abort”，进入ABORT 状态2.1.4.1.2 向协调者发送对“global-abort”的确认消息  2.1.4.2 若收到协调者的“global-commit”消息2.1.4.1.1 写本地日志“commit”，进入COMMIT 状态   2.1.4.1.2 向协调者发送对“global-commit”的确认消息  2.2 若参与者无法提交本次事务 2.2.1 写本地日志“abort”，进入ABORT 状态 2.2.2 向协调者发送“vote-abort”消息 2.2.3 流程对该参与者结束 2.2.4 若后续收到协调者的“global-abort”消息可以响应</li><li>即使流程结束，但任何时候收到协调者发送的“global-abort”消息或“global-commit”消息也都要发送一个对应的确认消息。</li></ol><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h4><h5 id="宕机恢复"><a href="#宕机恢复" class="headerlink" title="宕机恢复"></a>宕机恢复</h5><ol><li>协调者宕机恢复 协调者宕机恢复后，首先通过日志查找到宕机前的状态。如果日志中最后是“begin_commit”记录，说明宕机前协调者处于WAIT 状态，协调者可能已经发送过“prepare 消息”也可能还没发送，但协调者一定还没有发送过“global-commit 消息”或“global-abort 消息”，即事务的全局状态还没有确定。此时，协调者可以重新发送“prepare 消息” 继续两阶段提交流程，即使参与者已经发送过对“prepare 消息”的响应，也不过是再次重传之前的响应而不会影响协议的一致性。如果日志中最后是“global-commit”或“global-abort”记录，说明宕机前协调者处于COMMIT 或ABORT 状态。此时协调者只需重新向所有的参与者发送“global-commit 消息”或“global-abort 消息”就可以继续两阶段提交流程。</li><li>参与者宕机恢复参与者宕机恢复后，首先通过日志查找宕机前的状态。如果日志中最后是“init”记录，说明参与者处于INIT 状态，还没有对本次事务做出投票选择，参与者可以继续流程等待协调者发送的“prepare 消息”。如果日志中最后是“ready”记录，说明参与者处于REDAY 状态，此时说明参与者已经就本次 事务做出了投票选择，但宕机前参与者是否已经向协调者发送“vote-commit”消息并不可知。所以此时参与者可以向协调者重发“vote-commit”，并继续协议流程。如果日志中最后是“commit”或“abort”记录，说明参与者已经收到过协调者的“global-commit 消息”（处于COMMIT 状态）或者“global-abort 消息”（处于ABORT 状态）。至于是否向协调者发 送过对“global-commit”或“global-abort”的确认消息则未知。但即使没有发送过确认消息，由于协调者会不断重发“global-commit”或“global-abort”，只需在收到这些消息时发送确认消息既可，不影响协议的全局一致性。</li></ol><h4 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a><strong>协议分析</strong></h4><p>两阶段提交协议在工程实践中真正使用的较少，主要原因有以下几点：</p><ol><li>两阶段提交协议的容错能力较差。从上文的分析可以看出，两阶段提交协议在某些情况下存在流程无法执行下去的情况，且也无法判断流程状态。在工程中好的分布式协议往往总是可以在即使发生异常的情况下也能执行下去。例如，回忆Lease 机制（2.3 ），一旦lease 发出，无论出现任何异常，Lease 服务器节点总是可以通过时间判定出Lease 是否有效，也可以用等待Lease 超时的方法收回Lease 权限，整个Lease 协议的流程不存在任何流程被阻塞而无法执行下去的情况。与Lease 机制的简单有效相比，两阶段提交的协议显得较为复杂且容错能力差。</li><li>两阶段提交协议的性能较差。一次成功的两阶段提交协议流程中，协调者与每个参与者 之间至少需要两轮交互4 个消息“prepare”、“vote-commit”、“global-commit”、“确认global-commit”。过多的交互次数会降低性能。另一方面，协调者需要等待所有的参与者的投票结果，一旦存在较慢的参与者，会影响全局流程执行速度。</li></ol><p>虽然存在一些改进的两阶段提交协议可以提高容错能力和性能，然而这类协议依旧是在工程中使用较少的一类协议，其理论价值大于实践意义。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><p>MVCC(Multi-version Cocurrent Control，多版本并发控制)技术。MVCC 技术最初也是在数据库系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系统中同样有效。</p><p>MVCC 即多个不同版本的数据实现并发控制的技术，其基本思想是为每次事务生成 一个新版本的数据，在读数据时选择不同版本的数据即可以实现对事务结果的完整性读取。在使用MVCC 时，每个事务都是基于一个已生效的基础版本进行更新，事务可以并行进行，从而可以产生一种图状结构。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206203851316.png" alt="image-20200206203851316"></p><p>基础数据的版本为1，同时产生了两个事务：事务A 与事务B。这两个事务都各自对数据进行了一些本地修改（这些修改只有事务自己可见，不影响真正的数据），之后事务A 首先提交，生成数据版本2；基于数据版本2，又发起了事务C，事务C 继续提交，生成了数据版 本3；最后事务B 提交，此时事务B 的结果需要与事务C 的结果合并，如果数据没有冲突，即事务 B 没有修改事务A 与事务C 修改过的变量，那么事务B 可以提交，否则事务B 提交失败。MVCC 的流程过程非常类似于SVN 等版本控制系统的流程，或者说SVN 等版本控制系统就是 使用的MVCC 思想。事务在基于基础数据版本做本地修改时，为了不影响真正的数据，通常有两种做法，一是将基础数据版本中的数据完全拷贝出来再修改，SVN 即使用了这种方法，SVN check out 即是拷贝的过程；二是每个事务中只记录更新操作，而不记录完整的数据，读取数据时再将更新操作应用到用基础版本的数据从而计算出结果，这个过程也类似SVN 的增量提交。</p><h3 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a><strong>Paxos协议</strong></h3><p>Paxos 协议是少数在工程实践中证实的强一致性、高可用的去中心化分布式协议。Paxos 协议的流程较为复杂，但其基本思想却不难理解，类似于人类社会的投票过程。Paxos 协议中，有一组完全对等的参与节点（称为accpetor），这组节点各自就某一事件做出决议，如果某个决议获得了超过半数节点的同意则生效。Paxos 协议中只要有超过一半的节点正常，就可以工作，能很好对抗宕机、网络分化等异常情况。</p><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h4><p>Proposer：提案者。Proposer 可以有多个，Proposer 提出议案（value）。所谓value，在工程中可以是任何操作，例如“修改某个变量的值为某个值”、“设置当前primary 为某个节点”等等。Paxos 协议中统一将这些操作抽象为value。不同的Proposer 可以提出不同的甚至矛盾的value，例如某个Proposer 提议“将变量X 设置为1”，另一个Proposer 提议“将变量X 设置为2”，但对同一轮Paxos 过程，最多只有一个value 被批准。Acceptor：批准者。Acceptor 有N 个，Proposer 提出的value 必须获得超过半数(N/2+1)的Acceptor 批准后才能通过。Acceptor 之间完全对等独立。Learner：学习者。Learner 学习被批准的value。所谓学习就是通过读取各个Proposer 对value 的选择结果，如果某个value 被超过半数Proposer 通过，则Learner 学习到了这个value。回忆（2.4 ） 不难理解，这里类似Quorum 机制，某个value 需要获得W=N/2 + 1 的Acceptor 批准，从而学习者需要至少读取N/2+1 个Accpetor，至多读取N 个Acceptor 的结果后，能学习到一个通过的value。上述三类角色只是逻辑上的划分，实践中一个节点可以同时充当这三类角色。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h4><p>Paxos 协议一轮一轮的进行，每轮都有一个编号。每轮Paxos 协议可能会批准一个value，也可 能无法批准一个value。如果某一轮Paxos 协议批准了某个value，则以后各轮Paxos 只能批准这个 value。上述各轮协议流程组成了一个Paxos 协议实例，即一次Paxos 协议实例只能批准一个value，这也是Paxos 协议强一致性的重要体现。每轮Paxos 协议分为阶段，准备阶段和批准阶段，在这两个阶段Proposer 和Acceptor 有各自的处理流程。</p><p>流程：Proposer 的流程 （准备阶段）</p><ol><li>向所有的Acceptor 发送消息“Prepare(b)”；这里b 是Paxos 的轮数，每轮递增</li><li>如果收到任何一个Acceptor 发送的消息“Reject(B)”，则对于这个Proposer 而言本轮Paxos 失败，将轮数b 设置为B+1 后重新步骤1；（批准阶段，根据收到的Acceptor 的消息作出不同选择）</li><li>如果接收到的Acceptor 的“Promise(b, v_i)”消息达到N/2+1 个（N 为Acceptor 总数，除法取整， 下同）；v_i 表示Acceptor 最近一次在i 轮批准过value v。3.1 如果收到的“Promise(b, v)”消息中，v 都为空，Proposer 选择一个value v，向所有Acceptor 广播Accept(b, v)；3.2 否则，在所有收到的“Promise(b, v_i)”消息中，选择i 最大的value v，向所有Acceptor 广播消息Accept(b，v)；</li><li>如果收到Nack(B)，将轮数b 设置为B+1 后重新步骤1；</li></ol><p>流程：Accpetor 流程 （准备阶段）</p><ol><li>接受某个Propeser 的消息Prepare(b)。参数B 是该Acceptor 收到的最大Paxos 轮数编号；V 是Acceptor 批准的value，可以为空 1.1 如果b&gt;B，回复Promise(b, V_B)，设置B=b; 表示保证不再接受编号小于b 的提案。1.2 否则，回复Reject(B) （批准阶段）</li><li>接收Accept(b, v)， 2.1 如果b &lt; B, 回复Nack(B)，暗示proposer 有一个更大编号的提案被这个Acceptor 接收了 2.2 否则设置V=v。表示这个Acceptor 批准的Value 是v。广播Accepted 消息。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p>基本例子里有5 个Acceptor，1 个Proposer，不存在任何网络、宕机异常。我们着重考察各个Accpetor 上变量B 和变量V 的变化，及Proposer 上变量b 的变化。</p><ol><li><p>初始状态</p><p><img src="/2020/02/06/分布式基础要点/image-20200206204136621.png" alt="image-20200206204136621"></p></li><li><p>Proposer 向所有Accpetor 发送“Prepare(1)”，所有Acceptor 正确处理，并回复Promise(1, NULL)</p><p><img src="/2020/02/06/分布式基础要点/image-20200206204147068.png" alt="image-20200206204147068"></p></li><li><p>Proposer 收到5 个Promise(1, NULL)，满足多余半数的Promise 的value 为空，此时发送 Accept(1, v1)，其中v1 是Proposer 选择的Value。</p><p><img src="/2020/02/06/分布式基础要点/image-20200206204211472.png" alt="image-20200206204211472"></p></li><li><p>此时，v1 被超过半数的Acceptor 批准，v1 即是本次Paxos 协议实例批准的Value。如果Learner 学习value，学到的只能是v1</p></li></ol><p>在同一个Paxos 实例中，批准的Value 是无法改变的，即使后续Proposer 以更高的序号发起Paxos 协议也无法改变value。Paxos 协议的核心就在于“批准的value 无法改变”，这也是整个协议正确性的基础。</p><p>Paxos 协议是被人为设计出来，其设计过程也是协议的推导过程。Paxos 协议利用了Quorom 机 制，选择的W=R=N/2+1。简单而言，协议就是Proposer 更新Acceptor 的过程，一旦某个Acceptor 成功更新了超过半数的Acceptor，则更新成功。Learner 按Quorum 去读取Acceptor，一旦某个value 在超过半数的Proposer 上被成功读取，则说明这是一个被批准的value。协议通过引入轮次，使得高轮次的提议抢占低轮次的提议来避免死锁。协议设计关键点是如何满足“在一次Paxos 算法实例过程中只批准一个Value”这一约束条件。</p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a><strong>CAP</strong></h3><p>CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性：</p><ul><li>Consistency (一致性)：CAP 理论中的副本一致性特指强一致性（1.3.4 ）；</li><li>Availiablity(可用性)：指系统在出现异常时已经可以提供服务；</li><li>Tolerance to the partition of network (分区容忍)：指系统可以对网络分区（1.1.4.2 ）这种异常情 况进行容错处理；</li></ul><p>CAP 理论指出：无法设计一种分布式协议，使得同时完全具备CAP 三个属性，即1)该种协议下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统协议只能在CAP 这三者间所有折中。</p><p>热力学第二定律说明了永动机是不可能存在的，不要去妄图设计永动机。与之类似，CAP 理论的意义就在于明确提出了不要去妄图设计一种对CAP 三大属性都完全拥有的完美系统，因为这种系统在理论上就已经被证明不存在。</p><ul><li>Lease 机制: Lease 机制牺牲了部分异常情况下的A，从而获得了完全的C 与很好的P。</li><li>Quorum 机制: Quorum 机制，在CAP 三大因素中都各做了折中，有一定的C，有较好 的A，也有较好的P，是一种较为平衡的分布式协议。</li><li>两阶段提交协议: 两阶段提交系统具有完全的C，很糟糕的A，很糟糕的P。</li><li>Paxos 协议：同样是强一致性协议，Paxos 在CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的C，较好的A，较好的P。Paxos 的A 与P 的属性与Quorum 机制类似，因为Paxos 的协议本 身就具有Quorum 机制的因素。</li></ul><h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><p>目前业界比较流行的分布式服务框架有：阿里的Dubbo、Spring Cloud。这里不对这些分布式服务框架做对比，简单的说说他们都做了些什么，能使我们掉用远程服务就像掉用本地服务那么简单高效。除下述内容外，分布式系统涉及到的东西还有很多，如：分布式锁、定时调度、数据分片、性能问题、各种中间件的使用等。</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务是对使用用户有功能输出的模块，以技术框架作为基础，能实现用户的需求。比如日志记录服务、权限管理服务、后台服务、配置服务、缓存服务、存储服务、消息服务等，这些服务可以灵活的组合在一起，也可以独立运行。服务需要有接口，与系统进行对接。面向服务的开发，应该是把服务拆分开发，把服务组合运行。更加直接的例子如：历史详情、留言板、评论、评级服务等。他们之间能独立运行，也要能组合在一起作为一个整体。</p><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>注册中心对整个分布式系统起着最为核心的整合作用，支持对等集群，需要提供<strong>CRUD</strong>接口，支持订阅发布机制且可靠性要求非常之高，一般拿zookeeper集群来做为注册中心。<br> 分布式环境中服务提供方的服务会在多台服务器上部署，每台服务器会向注册中心提供服务方标识、服务列表、地址、对应端口、序列化协议等信息。注册中心记录下服务和服务地址的映射关系，一般一个服务会对应多个地址,这个过程我们称之为<strong>服务发布</strong>或<strong>服务注册</strong>。服务调用方会根据服务方标识、服务列表从注册中心获取所需服务的信息（<strong>地址端口信息、序列化协议等</strong>），这些信息会缓存至本地。当服务需要调用其它服务时，直接在这里找到服务的地址，进行调用，这个过程我们称之为<strong>服务发现</strong>。</p><p><img src="/2020/02/06/分布式基础要点/168fba730ed6c7ea" alt="分布式系统网络拓扑图">注册中心</p><p>下面是以zookeeper作为注册中心的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建node节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNode</span><span class="params">(String node, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            <span class="comment">//同步创建临时顺序节点</span></span><br><span class="line">            String path = zk.create(ZkConstant.ZK_RPC_DATA_PATH+<span class="string">"/"</span>+node+<span class="string">"-"</span>, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            log.info(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">        log.error(<span class="string">""</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">        log.error(<span class="string">""</span>, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如下面zookeeper中写入的临时顺序节点信息：</p><p><img src="/2020/02/06/分布式基础要点/16934302e903e720" alt="子节点1"></p><center>子节点1</center><br><img src="/2020/02/06/分布式基础要点/16934329ec3a33b7" alt="子节点2"><br><br><center>子节点2</center><br>- com.black.blackrpc.test.HelloWord （发布服务时对外的名称）<br>- 00000000010，00000000011          （zk 顺序节点id）<br>- 127.0.0.1:8888，127.0.0.1:8889    （服务地址端口）<br>- Protostuff                        （序列化方式） 1.0                               （权值，负载均衡策略使用）<br><br>这里使用的是zookeeper的临时顺序节点，为什么使用临时顺序节点。主要是考虑以下两点：<br><br><strong>一、</strong> 当服务提供者异常下线时，与zookeeper的连接会中断，zookeeper服务器会主动删除临时节点，同步给服务消费者。这样就能避免服务消费者去请求异常的服务器。<br><br>&gt; 校稿注： 一般消费方也会在实际发起请求前，对当前获取到的服务提供方节点进行心跳，避免请求连接有问题的节点<br><br><strong>二、</strong> zk下面是不允许创建2个名称相同的zk子节点的，通过顺序节点就能避免创建相同的名称。当然也可以不用顺序节点的方式,直接以com.black.blackrpc.test.HelloWord创建节点，在该节点下创建数据节点。<br><br>下面是zk的数据同步过程：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步节点 （通知模式）</span></span><br><span class="line"><span class="comment">     * syncNodes会通过级联方式，在每次watcher被触发后，就会再挂上新的watcher。完成了类似链式触发的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">syncNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; nodeList = zk.getChildren(ZkConstant.ZK_RPC_DATA_PATH, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                    syncNodes();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Map&lt;String,List&lt;String&gt;&gt; map =<span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : nodeList) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = zk.getData(ZkConstant.ZK_RPC_DATA_PATH + <span class="string">"/"</span> + node, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                String key =node.substring(<span class="number">0</span>, node.lastIndexOf(ZkConstant.DELIMITED_MARKER));</span><br><span class="line">                String value=<span class="keyword">new</span> String(bytes);</span><br><span class="line">                Object object =map.get(key);</span><br><span class="line">                <span class="keyword">if</span>(object!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                ((List&lt;String&gt;)object).add(value);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                dataList.add(value);</span><br><span class="line">                map.put(key,dataList);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">"node: [&#123;&#125;] data: [&#123;&#125;]"</span>,node,<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**修改连接的地址缓存*/</span></span><br><span class="line">            <span class="keyword">if</span>(MapUtil.isNotEmpty(map))&#123;</span><br><span class="line">                log.debug(<span class="string">"invoking service cache updateing...."</span>);</span><br><span class="line">            InvokingServiceCache.updataInvokingServiceMap(map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">        log.error(e.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br>当数据同步到本地时，一般会写入到本地文件中，防止因zookeeper集群异常下线而无法获取服务提者信息。<br><br>### 通讯与协议<br><br>服务消费者无论是与注册中心还是与服务提供者，都需要存在网络连接传输数据，而这就涉及到通讯。笔者之前也做过这方面的工作，当时使用的是<strong>java BIO</strong>简单的写了一个通讯包，使用场景没有多大的并发,阻塞式的<strong>BIO</strong>也未暴露太多问题。<strong>java BIO</strong>因其建立连接之后会阻塞线程等待数据，这种方式必须以一连接一线程的方式，即客户端有连接请求时服务器端就需要启动一个线程进行处理。当连接数过大时，会建立相当多的线程，性能直线下降。<br><br>- <strong>Java NIO</strong> : 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br><br>- <strong>Java AIO</strong> : 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， <strong>BIO、NIO、AIO</strong>适用场景分析:<br><br>- <strong>BIO</strong> 用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，但程序直观简单易理解。<br><br>- <strong>NIO</strong> 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，目前主流的通讯框架 <strong>Netty、Apache Mina、Grizzl、NIO Framework</strong>都是基于其实现的。<br><br>- <strong>AIO</strong> 用于连接数目多且连接比较长（重操作）的架构，比如图片服务器，文件传输等，充分调用OS参与并发操作，编程比较复杂。<br>   (有兴趣可以看看这篇文章：<a href="https://blog.csdn.net/ty497122758/article/details/78979302" target="_blank" rel="noopener">BIO与NIO、AIO的区别</a> )<br><br>  ​        作为基石的通讯，其实要考虑很多东西。如：丢包粘包的情况，心跳机制，断连重连，消息缓存重发，资源的优雅释放，长连接还是短连接等。<br><br>下面是<strong>Netty</strong>建立服务端，客户端的简单实现：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldPrepender;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayEncoder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * netty tcp 服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> v_wangshiyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTcpService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(NettyTcpService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">private</span> String host;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyTcpService</span><span class="params">(String address)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String str[] = address.split(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">this</span>.host=str[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.port=Integer.valueOf(str[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyTcpService</span><span class="params">(String host,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.host=host;</span><br><span class="line"><span class="keyword">this</span>.port=port;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**用于分配处理业务线程的线程组个数 */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZGROUPSIZE = Runtime.getRuntime().availableProcessors()*<span class="number">2</span>; <span class="comment">//默认  </span></span><br><span class="line">    <span class="comment">/** 业务出现线程大小*/</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZTHREADSIZE = <span class="number">4</span>;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * NioEventLoopGroup实际上就是个线程,</span></span><br><span class="line"><span class="comment">     * NioEventLoopGroup在后台启动了n个NioEventLoop来处理Channel事件, </span></span><br><span class="line"><span class="comment">     * 每一个NioEventLoop负责处理m个Channel, </span></span><br><span class="line"><span class="comment">     * NioEventLoopGroup从NioEventLoop数组里挨个取出NioEventLoop来处理Channel</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(BIZGROUPSIZE);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(BIZTHREADSIZE);  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Netty Tcp Service Run..."</span>);</span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();  </span><br><span class="line">        b.group(bossGroup, workerGroup);  </span><br><span class="line">        b.channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();  </span><br><span class="line">                pipeline.addLast(<span class="string">"frameDecoder"</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"frameEncoder"</span>, <span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ByteArrayDecoder());  </span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ByteArrayEncoder());  </span><br><span class="line">              <span class="comment">//  pipeline.addLast(new Encoder());</span></span><br><span class="line">              <span class="comment">//  pipeline.addLast(new Decoder());</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> TcpServerHandler());</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        b.bind(host, port).sync();  </span><br><span class="line">        log.info(<span class="string">"Netty Tcp Service Success!"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止服务并释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        workerGroup.shutdownGracefully();  </span><br><span class="line">        bossGroup.shutdownGracefully();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(TcpServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] data=(<span class="keyword">byte</span>[])msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldPrepender;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.Future;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty tcp 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> v_wangshiyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTcpClient</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(NettyTcpClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">private</span> String host;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port;  </span><br><span class="line"><span class="keyword">private</span> Bootstrap bootstrap;  </span><br><span class="line"><span class="keyword">private</span> Channel channel;</span><br><span class="line"><span class="keyword">private</span> EventLoopGroup group;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyTcpClient</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">bootstrap=getBootstrap();</span><br><span class="line">channel= getChannel(host,port);</span><br><span class="line"><span class="keyword">this</span>.host=host;</span><br><span class="line"><span class="keyword">this</span>.port=port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> host;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 初始化Bootstrap </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bootstrap <span class="title">getBootstrap</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    group = <span class="keyword">new</span> NioEventLoopGroup();  </span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();  </span><br><span class="line">        b.group(group).channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        b.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();  </span><br><span class="line">                 <span class="comment">// pipeline.addLast(new Encoder());</span></span><br><span class="line">                 <span class="comment">// pipeline.addLast(new Decoder());</span></span><br><span class="line">                pipeline.addLast(<span class="string">"frameDecoder"</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"frameEncoder"</span>, <span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ByteArrayDecoder());  </span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ByteArrayEncoder());  </span><br><span class="line">                </span><br><span class="line">                pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> TcpClientHandler());</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);  </span><br><span class="line">        <span class="keyword">return</span> b;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接，获取Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Channel <span class="title">getChannel</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;  </span><br><span class="line">        Channel channel = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            channel = bootstrap.connect(host, port).sync().channel();  </span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        log.info(String.format(<span class="string">"connect Server(IP[%s],PORT[%s]) fail!"</span>, host,port));  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMsg</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            channel.writeAndFlush(msg).sync();  </span><br><span class="line">            log.debug(<span class="string">"msg flush success"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        log.debug(<span class="string">"msg flush fail,connect is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接断开</span></span><br><span class="line"><span class="comment">     * 并且释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">disconnectConnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//channel.close().awaitUninterruptibly();</span></span><br><span class="line">    Future&lt;?&gt; future =group.shutdownGracefully();<span class="comment">//shutdownGracefully释放所有资源，并且关闭所有当前正在使用的channel</span></span><br><span class="line">    future.syncUninterruptibly();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(TcpClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] data=(<span class="keyword">byte</span>[])msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>说到通讯就不能不说协议，通信时所遵守的规则，访问什么，传输的格式等都属于协议。作为一个开发人员，应该都了解TCP/IP协议，它是一个网络通信模型，以及一整套网络传输协议家族，是互联网的基础通信架构。也都应该用过http（超文本传输协议），Web服务器传输超文本到本地浏览器的传送协议，该协议建立在TCP/IP协议之上。分布式服务框架服务间的调用也会规定协议。为了支持不同场景，分布式服务框架会存在多种协议，如<strong>Dubbo</strong>就支持7种协议：<strong>dubbo协议(默认)</strong>，<strong>rmi协议</strong>，<strong>hessian协议</strong>，<strong>http协议</strong>，<strong>webservice协议</strong>，<strong>thrift协议</strong>，<strong>memcached协议</strong>，<strong>redis协议</strong>每种协议应对的场景不尽相同，具体场景具体对待。<br> (这里详细介绍了Dubbo 的协议：<a href="https://blog.csdn.net/xiaojin21cen/article/details/79834222" target="_blank" rel="noopener">Dubbo 的7种协议</a> )<br><br>### 服务路由<br><br>分布式服务上线时都是集群组网部署，集群中会存在某个服务的多实例，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。分布式服务框架需要能够满足用户灵活的路由需求。<br><br>#### 透明化路由<br><br>很多开源的RPC框架调用者需要配置服务提供者的地址信息，尽管可以通过读取数据库的服务地址列表等方式避免硬编码地址信息，但是消费者依然要感知服务提供者的地址信息，这违反了透明化路由原则。而基于服务注册中心的服务订阅发布，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不再需要通过硬编码方式得到提供者的地址信息，只需要知道当前系统发布了那些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。  <br><br>#### 负载均衡<br><br>负载均衡策略是服务的重要属性，分布式服务框架通常会提供多种负载均衡策略，同时支持用户扩展负载均衡策略。<br><br>##### 随机<br><br>通常在对等集群组网中，采用随机算法进行负债均衡，随机路由算法消息分发还是比较均匀的，采用JDK提供的<strong>java.util.Random</strong>或者<strong>java.security.SecureRandom</strong>在指定服务提供者列表中生成随机地址。消费者基于随机生成的服务提供者地址进行远程调用。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> MAX_LEN = list.size();</span><br><span class="line">        <span class="keyword">int</span> index = RandomUtil.nextInt(MAX_LEN);</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>随机还是存在缺点的，可能出现部分节点的碰撞的概率较高，另外硬件配置差异较大时，会导致各节点负载不均匀。为避免这些问题，需要对服务列表加权，性能好的机器接收的请求的概率应该高于一般机器。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加权随机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightingRandomStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//存放加权后的服务提供者列表</span></span><br><span class="line">        List&lt;RemoteServiceBase&gt; weightingList = <span class="keyword">new</span> ArrayList&lt;RemoteServiceBase&gt;();</span><br><span class="line">        <span class="keyword">for</span> (RemoteServiceBase remoteServiceBase : list) &#123;</span><br><span class="line">            <span class="comment">//扩大10倍</span></span><br><span class="line">            <span class="keyword">int</span> weight = (<span class="keyword">int</span>) (remoteServiceBase.getWeight()*<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++) &#123;</span><br><span class="line">            weightingList.add(remoteServiceBase);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> MAX_LEN = weightingList.size();</span><br><span class="line">        <span class="keyword">int</span> index = RandomUtil.nextInt(MAX_LEN);</span><br><span class="line">        <span class="keyword">return</span> weightingList.get(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 轮询<br><br>逐个请求服务地址，到达边界之后，继续绕接。主要缺点：慢的提供者会累积请求。例如第二台机器很慢，但没挂。当请求第二台机器时被卡在那。久而久之，所有请求都卡在第二台机器上。 轮询策略实现非常简单，顺序循环遍历服务提供者列表，达到边界之后重新归零开始，继续顺序循环。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PollingStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line"><span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line">RemoteServiceBase service = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="comment">//若计数大于服务提供者个数,将计数器归0</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= list.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            service = list.get(index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//兜底,保证程序健壮性,若未取到服务,则直接取第一个</span></span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            service = list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>加权轮询的话，需要给服务地址添加权重。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加权轮询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightingPollingStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line"><span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计数器锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line">    RemoteServiceBase service = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="comment">//存放加权后的服务提供者列表</span></span><br><span class="line">            List&lt;RemoteServiceBase&gt; weightingList = <span class="keyword">new</span> ArrayList&lt;RemoteServiceBase&gt;();</span><br><span class="line">            <span class="keyword">for</span> (RemoteServiceBase remoteServiceBase : list) &#123;</span><br><span class="line">                <span class="comment">//扩大10倍</span></span><br><span class="line">                <span class="keyword">int</span> weight = (<span class="keyword">int</span>) (remoteServiceBase.getWeight()*<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++) &#123;</span><br><span class="line">                weightingList.add(remoteServiceBase);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若计数大于服务提供者个数,将计数器归0</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= weightingList.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            service = weightingList.get(index);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//兜底,保证程序健壮性,若未取到服务,则直接取第一个</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 服务调用时延<br><br>消费者缓存所有服务提供者的调用时延，周期性的计算服务调用平均时延。然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积。 该策略的特点：保证处理能力强的服务接受更多的消息，通过动态的权重分配消除服务调用时延的震荡范围，使所有服务的调用时延接近平均值，实现负载均衡。<br><br>##### 一致性哈希<br><br>相同参数的请求总是发送到统一服务提供者，当某一台服务提供者宕机时，原本发往跟提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动，平台提供默认的虚拟节点数，可以通过配置文件修改虚拟节点个数。一致性Hash环工作原理如下图所示：<br><br><img src="/2020/02/06/分布式基础要点/169314f26588cc57" alt="一致性哈希">一致性哈希<br><br><br>#### 路由规则<br><br>负载均衡只能保证服务提供者压力的平衡，但是在一些业务场景中需要设置一些过滤规则，比较常用的是基本表达式的条件路由。<br> 通过IP条件表达式配置黑白名单访问控制：consumerIP != 192.168.1.1。<br> 只暴露部分服务提供者，防止这个集群服务都被冲垮，导致其他服务也不可用。例如providerIP = 192.168.3<em>。 读写分离：method=find</em>,list<em>,get</em>,query<em>=&gt;providerIP=192.168.1.</em>。 前后台分离：app=web<em>=&gt;providerIP=192.168.1.</em>,app=java<em>=&gt;providerIP=192.168.2.</em>。 灰度升级：将WEB前台应用理由到新的服务版本上：app=web<em>=&gt;provicerIP=192.168.1.</em>。<br><br>由于篇幅原因这里不细说，还是丢个说的比较详细的文章地址： <a href="https://blog.csdn.net/zhengzhaoyang122/article/details/80842859" target="_blank" rel="noopener">服务路由</a><br><br>### 序列化与反序列化<br><br>把对象转换为字节序列的过程称为序列化，把字节序列恢复为对象的过程称为反序列化。运程调用的时候，我们需要先将Java对象进行序列化，然后通过网络，IO进行传输，当到达目的地之后，再进行反序列化获取到我们想要的结果对象。分布式系统中，传输的对象会很多，这就要求序列化速度快，产生字节序列小的序列化技术。<br> 序列化技术：<strong>Serializable, xml, Jackson, MessagePack, fastjson, Protocol Buffer, Thrift,Gson, Avro,Hessian</strong>等<br><br>- <strong>Serializable</strong> 是java自带的序列化技术，无法跨平台，序列化和反序列化的速度相对较慢。<br>- <strong>XML</strong>技术多平台支持好，常用于与银行交互的报文，但是其字节序列产生较大，不太适合用作分布式通讯框架。<br>- <strong>Fastjson</strong>是Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发,字节序列为json串，可读性好，序列化也速度非常的快。<br>- <strong>Protocol Buffer</strong> 序列化速度非常快，字节序列较小，但是可读性较差。<br>   ( 这里就不一一介绍，有兴趣可以看看这篇文章：<a href="https://www.jianshu.com/p/937883b6b2e5" target="_blank" rel="noopener">序列化技术比较</a> )<br>   一般分布式服务框架会内置多种序列化协议可供选择，如<strong>Dubbo</strong> 支持的7种协议用到的序列化技术就不完全相同。<br><br>### 服务调用<br><br>本地环境下，使用某个接口很简单，直接调用就行。分布式环境下就不是那么简单了，消费者方只会存在接口的定义，没有具体的实现。想要像本地环境下直接调用远程接口那就得耗费一些功夫了，需要用到<strong>远程代理</strong>。<br> 下面是我盗的图：<br><br><br><br><img src="/2020/02/06/分布式基础要点/1692da5592a081c3" alt="远程代理"><center>远程代理</center><p>通信时序如下：</p><p><img src="/2020/02/06/分布式基础要点/1692da62bcb186fe" alt="通信时序">通信时序</p><p>消费者端没有具体的实现，需要调用接口时会动态的去创建一个代理类。与spirng集成的情况，那直接在bean构建的时候注入代理类。</p><p>下面是构建代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; cls)</span></span>&#123;       </span><br><span class="line">    JdkMethodProxy invocationHandler = <span class="keyword">new</span> JdkMethodProxy();</span><br><span class="line">        Object newProxyInstance = Proxy.newProxyInstance(  </span><br><span class="line">                cls.getClassLoader(),  </span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; cls &#125;, </span><br><span class="line">                invocationHandler); </span><br><span class="line">        <span class="keyword">return</span> (Object)newProxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkMethodProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] parameters)</span>  <span class="keyword">throws</span> Throwable </span>&#123;        </span><br><span class="line">        <span class="comment">//如果传进来是一个已实现的具体类</span></span><br><span class="line">        <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, parameters);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">                t.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="comment">//如果传进来的是一个接口</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//实现接口的核心方法 </span></span><br><span class="line">            <span class="comment">//return RemoteInvoking.invoking(serviceName, serializationType, //timeOut,loadBalanceStrategy,method, parameters);</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理会做很多事情，对请求服务的名称及参数信息的的序列化、通过路由选择最为合适服务提供者、建立通讯连接发送请求信息（或者直接发起http请求）、最后返回获取到的结果。当然这里面需要考虑很多问题，如调用超时，请求异常，通讯连接的缓存，同步服务调用还是异步服务调用等等。</p><ul><li><p><strong>同步服务调用</strong>：客户端发起远程服务调用请求，用户线程完成消息序列化之后，将消息投递到通信框架，然后同步阻塞，等待通信线程发送请求并接收到应答之后，唤醒同步等待的用户线程，用户线程获取到应答之后返回。</p></li><li><p><strong>异步服务调用</strong>：基于JAVA的<strong>Future</strong>机制，客户端发起远程服务调用请求，该请求会被标上<strong>requestId</strong>,同时建立一个与<strong>requestId</strong>对应 <strong>Future</strong>，客户端通过<strong>Future</strong> 的 get方法获取结果时会被阻塞。服务端收到请求应达会回传<strong>requestId</strong>，通过<strong>requestId</strong>去解除对应<strong>Future</strong>的阻塞，同时set对应结果，最后客户端获取到结果。</p></li></ul><p>构建Future，以requestId为key，put到线程安全的map中。get结果时需要写入timeOut超时时间，防止由于结果的未返回而导致的长时间的阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SyncFuture&lt;RpcResponse&gt; syncFuture =<span class="keyword">new</span> SyncFuture&lt;RpcResponse&gt;();</span><br><span class="line">SyncFutureCatch.syncFutureMap.put(rpcRequest.getRequestId(), syncFuture);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RpcResponse rpcResponse= syncFuture.get(timeOut,TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">return</span> rpcResponse.getResult();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">SyncFutureCatch.syncFutureMap.remove(rpcRequest.getRequestId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果返回时通过回传的requestId获取对应Future写入Response,Future线程解除阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">"Tcp Client receive head："</span>+headAnalysis+<span class="string">"Tcp Client receive data："</span> +rpcResponse);</span><br><span class="line">SyncFuture&lt;RpcResponse&gt; syncFuture= SyncFutureCatch.syncFutureMap.get(rpcResponse.getRequestId());</span><br><span class="line"><span class="keyword">if</span>(syncFuture!=<span class="keyword">null</span>)&#123;</span><br><span class="line">syncFuture.setResponse(rpcResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 因为请求和响应是一一对应的，因此初始化CountDownLatch值为1。</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 需要响应线程设置的响应结果</span></span><br><span class="line">    <span class="keyword">private</span> T response;</span><br><span class="line">    <span class="comment">// Futrue的请求时间，用于计算Future是否超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取响应结果，直到有结果才返回。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取响应结果，直到有结果或者超过指定时间就返回。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeOut, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (latch.await(timeOut, unit)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于设置响应结果，并且做countDown操作，通知请求线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponse</span><span class="params">(T response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getBeginTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beginTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SyncFuture&lt;RpcResponse&gt; syncFuture =<span class="keyword">new</span> SyncFuture&lt;RpcResponse&gt;();</span><br><span class="line">SyncFutureCatch.syncFutureMap.put(rpcRequest.getRequestId(), syncFuture);</span><br><span class="line">RpcResponse rpcResponse= syncFuture.get(timeOut,TimeUnit.MILLISECONDS);</span><br><span class="line">SyncFutureCatch.syncFutureMap.remove(rpcRequest.getRequestId());</span><br></pre></td></tr></table></figure><p>除了同步服务调用，异步服务调用，还有并行服务调用，泛化调用等调用形式<br> ( 这里就不做介绍，有兴趣可以看看这篇文章：<a href="http://www.voidcn.com/article/p-fdoonxif-mr.html" target="_blank" rel="noopener">服务框架多形式的服务调用：同步、异步、并用、泛化</a> )</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>简单的介绍了下分布式服务框架，下面来说下分布式系统的高可用。一个系统设计开发出来，三天两晚就出个大问题，导致无法使用，那这个系统也不是什么好系统。业界流传一句话：”我们系统支持X个9的可靠性”。这个X是代表一个数字，X个9表示在系统1年时间的使用过程中，系统可以正常使用时间与总时间（1年）之比。<br> 3个9：(1-99.9%)<em>365</em>24=8.76小时，表示该系统在连续运行1年时间里最多可能的业务中断时间是8.76小时，4个9即52.6分钟，5个9即5.26分钟。要做到如此高的可靠性，是非常大的挑战。一个大型分布式项目可能是由几十上百个项目构成，涉及到的服务成千上万，主链上的一个流程就需要流转多个团队维护的项目。拿4个9的可靠性来说，平摊到每个团队的时间可能不到10分钟。这10分钟内需要顶住压力，以最快的时间找到并解决问题，恢复系统的可用。<br> 下面说说为了提高系统的可靠性都有哪些方案：</p><ul><li><strong>服务检测</strong>：某台服务器与注册中心的连接中断，其提供的服务也无响应时，系统应该能主动去重启该服务，使其能正常对外提供。</li><li><strong>故障隔离</strong>：集群环境下，某台服务器能对外提供服务，但是因为其他原因，请求结果始终异常。这时就需要主动将该节点从集群环境中剔除，避免继续对后面的请求造成影响，非高峰时期再尝试修复该问题。至于机房故障的情况，只能去屏蔽整个机房了。目前饿了么做的是异地多活，即便单边机房挂了，流量也可以全量切换至另外一边机房，保证系统的可用。</li><li><strong>监控</strong>：包含业务监控、服务异常监控、db中间件性能的监控等，系统出现异常的时候能及时的通知到开发人员。等到线下报上来的时候，可能影响已经很大了。</li><li><strong>压测</strong>：产线主链路的压测是必不可少的，单靠集成测试，有些高并发的场景是无法覆盖到的，压测能暴露平常情况无法出现的问题，也能直观的提现系统的吞吐能力。当业务激增时，可以考虑直接做系统扩容。</li><li><strong>sop方案与演练</strong>：产线上随时都可能会发生问题，抱着出现问题时再想办法解决的态度是肯定不行的，时间根本来不及。提前做好对应问题的sop方案，能节省大量时间，尽快的恢复系统的正常。当然平常的演练也是不可少的，一旦产线故障可以做到从容不迫的去应对和处理。</li></ul><p>除了上述方案外，还可以考虑<strong>服务策略</strong>的使用：</p><h3 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h3><p>业务高峰期，为了保证核心服务，需要停掉一些不太重要的业务，如双十一期间不允许发起退款(*￣▽￣)、只允许查看3个月之内的历史订单等业务的降级，调用服务接口时，直接返回的空结果或异常等服务的降级,都属于分布式系统的降级策略。服务降级是可逆操作，当系统压力恢复到一定值不需要降级服务时，需要去除降级，将服务状态恢复正常。 服务降级主要包括<strong>屏蔽降级</strong>和<strong>容错降级</strong>：<br> <strong>屏蔽降级</strong>:分布式服务框架直接屏蔽对远程接口的请求，不发起对远程服务的调用，直接返回空结果、抛出指定异常、执行本地模拟接口实现等方式。<br> <strong>容错降级</strong>：非核心服务不可调用时，可以对故障服务做业务放通，保证主流程不受影响。如请求超时、消息解码异常、系统拥塞保护异常， 服务提供方系统异常等情况。 笔者之前就碰到过因双方没有做容错降级导致的系统故障的情况。午高峰时期，对方调用我们的一个非核心查询接口，我们系统因为bug问题一直异常，导致对方调用这个接口的页面异常而无法跳转到主流程页面，影响了产线的生产。当时对方紧急发版才使系统恢复正常。</p><h3 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h3><p>说到限流，最先想到的就是秒杀活动了，一场秒杀活动的流量可能是正常流量的几百至几千倍，如此高的流量系统根本无法处理，只能通过限流来避免系统的崩溃。服务的限流本质和秒杀活动的限流是一样的，都是限制请求的流入，防止服务提供方因大量的请求而崩溃。<br> 限流算法：<strong>令牌桶、漏桶、计数器算法</strong><br> 上述算法适合单机的限流，但涉及到整个集群的限流时，得考虑使用缓存中间件了。例如：某个服务1分钟内只允许请求2次，或者一天只允许使用1000次。由于负载均衡存在，可能集群内每台机器都会收到请求，这种时候就需要缓存来记录调用方某段时间内的请求次数，再做限流处理。redis就很适合做此事。 <a href="https://www.jianshu.com/p/76cc8ba5ca91" target="_blank" rel="noopener">限流算法的实现</a></p><h3 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h3><p>熔断本质上是一种过载保护机制，这一概念来源于电子工程中的断路器，当电流过大时，保险丝会熔断，从而保护整个电路。同样在分布式系统中，当被调用的远程服务无法使用时，如果没有过载保护，就会导致请求的资源阻塞在远程服务器上耗尽资源。很多时候，刚开始可能只是出现了局部小规模的故障，然而由于种种原因，故障影响范围越来越大，最终导致全局性的后果。当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护自己以及系统整体的可用性，可以暂时切断对下游服务的调用。<br> <strong>熔断器的设计思路</strong><br> <strong>Closed</strong>：初始状态，熔断器关闭，正常提供服务<br> <strong>Open</strong>: 失败次数，失败百分比达到一定的阈值之后，熔断器打开，停止访问服务<br> <strong>Half-Open</strong>：熔断一定时间之后，小流量尝试调用服务，如果成功则恢复，熔断器变为<strong>Closed</strong>状态</p><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>一个系统设计开发出来，必须保证其运行的数据准确和一致性。拿支付系统来说：用户银行卡已经扣款成功，系统里却显示失败，没有给用户的虚拟帐户充值上，这会引起客诉。说的再严重点，用户发起提现，资金已经转到其银行账户，系统却没扣除对应虚拟帐号的余额，直接导致资金损失了。如果这时候用户一直发起提现，那就酸爽了。</p><h3 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h3><p>说到数据一致性，就不得不说到<strong>CAP原则</strong>。<strong>CAP原则</strong>中指出任何一个分布式系统中，<strong>Consistency（一致性 C）</strong>、 <strong>Availability（可用性 A）</strong>、<strong>Partition tolerance（分区容错性P）</strong>，三者不可兼得。传统单机数据库基于<strong>ACID特性（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability））</strong> ，放弃了分区容错性，能做到可用性和一致性。对于一个分布式系统而言，分区容错性是一个最基本的要求。既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，会出现节点与节点之间的网络通讯，而网络问题又是一定会出现的异常情况，<strong>分区容错性</strong>也就成为了一个分布式系统必然需要面对和解决的问题。系统架构师往往需要把精力花在如何根据业务特点在<strong>一致性</strong>和<strong>可用性</strong>之间寻求平衡。</p><p>集中式系统，通过数据库事务的控制，能做到数据的强一致性。但是分布式系统中，涉及多服务间的调用，通过分布式事务的方案：<strong>两阶段提交（2PC）</strong>、<strong>三阶段提交（3PC）</strong>、<strong>补偿事务（TCC）</strong>等虽然能实现数据的强一致，但是都是通过牺牲可用性来实现。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p><strong>BASE理论</strong>是对<strong>CAP原则</strong>中一致性和可用性权衡的结果：<strong>Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</strong>。BASE理论，其来源于对大规模互联网系统分布式实践的总结，是基于<strong>CAP原则</strong>逐步演化而来的。其最核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><ul><li><strong>基本可用</strong><br>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，这不等价于系统不可用。</li><li><strong>软状态</strong><br>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li><li><strong>最终一致性</strong><br>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li></ul><p>总的来说，<strong>BASE理论</strong>面向的是大型高可用可扩展的分布式系统，和传统的事物<strong>ACID特性</strong>是相反的，它完全不同于<strong>ACID</strong>的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p><p>下面2篇文章对分布式事务和数据一致性这块有较深的讲解。</p><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案 </a></li><li><a href="https://www.jianshu.com/p/b264a196b177" target="_blank" rel="noopener">微服务下的数据一致性的几种实现方式之概述 </a></li></ul><h2 id="微服务下的数据一致性的几种实现方式之概述"><a href="#微服务下的数据一致性的几种实现方式之概述" class="headerlink" title="微服务下的数据一致性的几种实现方式之概述"></a>微服务下的数据一致性的几种实现方式之概述</h2><h3 id="传统应用的事务管理"><a href="#传统应用的事务管理" class="headerlink" title="传统应用的事务管理"></a>传统应用的事务管理</h3><h4 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h4><p>再介绍微服务下的数据一致性之前，先简单地介绍一下事务的背景。传统单机应用使用一个RDBMS作为数据源。应用开启事务，进行CRUD，提交或回滚事务，统统发生在本地事务中，由资源管理器（RM）直接提供事务支持。数据的一致性在一个本地事务中得到保证。</p><p><img src="/2020/02/06/分布式基础要点/5618351-9ec90b4be2f13084.webp" alt="img"></p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>#####两阶段提交（2PC）</p><p>当应用逐渐扩展，出现一个应用使用多个数据源的情况，这个时候本地事务已经无法满足数据一致性的要求。由于多个数据源的同时访问，事务需要跨多个数据源管理，分布式事务应运而生。其中最流行的就是两阶段提交（2PC），分布式事务由事务管理器（TM）统一管理。</p><p>两阶段提交分为准备阶段和提交阶段。</p><p><img src="/2020/02/06/分布式基础要点/5618351-87d7372a81a076d9.webp" alt="img"></p><p><center>两阶段提交-commit</center><br><img src="/2020/02/06/分布式基础要点/5618351-60418578c36b49a6.webp" alt="img"></p><p><center>两阶段提交-rollback</center><br>然而两阶段提交也不能完全保证数据一致性问题，并且有同步阻塞的问题，所以其优化版本三阶段提交（3PC）被发明了出来。</p><p>#####三阶段提交（3PC）</p><p><img src="/2020/02/06/分布式基础要点/5618351-eda6a74280b005f1.webp" alt="img"></p><p><center>三阶段提交</center><br>然而3PC也只能保证绝大多数情况下的数据一致性。</p><p>具体分布式事务2PC和3PC的详细介绍请见<a href="https://cloud.tencent.com/developer/article/1334942" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议</a>。分布式事务不是本文的重点，故不展开。</p><p>###微服务下的事务管理</p><p>那么，分布式事务2PC或者3PC是否适合于微服务下的事务管理呢？答案是否定的，原因有三点：</p><ol><li>由于微服务间无法直接进行数据访问，微服务间互相调用通常通过RPC（dubbo）或Http API（SpringCloud）进行，所以已经无法使用TM统一管理微服务的RM。</li><li>不同的微服务使用的数据源类型可能完全不同，如果微服务使用了NoSQL之类不支持事务的数据库，则事务根本无从谈起。</li><li>即使微服务使用的数据源都支持事务，那么如果使用一个大事务将许多微服务的事务管理起来，这个大事务维持的时间，将比本地事务长几个数量级。如此长时间的事务及跨服务的事务，将为产生很多锁及数据不可用，严重影响系统性能。</li></ol><p>由此可见，传统的分布式事务已经无法满足微服务架构下的事务管理需求。那么，既然无法满足传统的ACID事务，在微服务下的事务管理必然要遵循新的法则－－BASE理论。</p><p>BASE理论由eBay的架构师Dan Pritchett提出，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性，应用应该可以采用合适的方式达到最终一致性。BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p><p><code>基本可用</code>：指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p><p><code>软状态</code>：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。</p><p><code>最终一致性</code>：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p><p>BASE中的<code>最终一致性</code>是对于微服务下的事务管理的根本要求，既基于微服务的事务管理无法达到强一致性，但必须保证最重一致性。那么，有哪些方法可以保证微服务下的事务管理的最终一致性呢，按照实现原理分主要有两类，事件通知型和补偿型，其中事件通知型又可分为可靠事件通知模式及最大努力通知模式，而补偿型又可分为TCC模式、和业务补偿模式两种。这四种模式都可以达到微服务下的数据最终一致性。</p><h3 id="实现微服务下数据一致性的方式"><a href="#实现微服务下数据一致性的方式" class="headerlink" title="实现微服务下数据一致性的方式"></a>实现微服务下数据一致性的方式</h3><h4 id="可靠事件通知模式"><a href="#可靠事件通知模式" class="headerlink" title="可靠事件通知模式"></a>可靠事件通知模式</h4><h5 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h5><p>可靠事件通知模式的设计理念比较容易理解，即是主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性。首先能想到的也是最简单的就是同步事件通知，业务处理与消息发送同步执行，实现逻辑见下方代码及时序图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 操作数据库</span></span><br><span class="line">        <span class="keyword">bool</span> result = dao.update(data);<span class="comment">// 操作数据库失败，会抛出异常</span></span><br><span class="line">    <span class="comment">// 2. 如果数据库操作成功则发送消息</span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            mq.send(data);<span class="comment">// 如果方法执行失败，会抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        roolback();<span class="comment">// 如果发生异常，就回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/分布式基础要点/5618351-fc7a0d55a3e9a50a.webp" alt="img"></p><p>上面的逻辑看上去天衣无缝，如果数据库操作失败则直接退出，不发送消息；如果发送消息失败，则数据库回滚；如果数据库操作成功且消息发送成功，则业务成功，消息发送给下游消费。然后仔细思考后，同步消息通知其实有两点不足的地方。</p><ol><li><p>在微服务的架构下，有可能出现网络IO问题或者服务器宕机的问题，如果这些问题出现在时序图的第7步，使得消息投递后无法正常通知主服务（网络问题），或无法继续提交事务（宕机），那么主服务将会认为消息投递失败，会滚主服务业务，然而实际上消息已经被从服务消费，那么就会造成主服务和从服务的数据不一致。具体场景可见下面两张时序图。</p><p><img src="/2020/02/06/分布式基础要点/5618351-7bdb231cc5a94f60.webp" alt="img"></p></li></ol><p><img src="/2020/02/06/分布式基础要点/5618351-2cc0b39471d0aa4a.webp" alt="img"></p><ol><li>事件服务（在这里就是消息服务）与业务过于耦合，如果消息服务不可用，会导致业务不可用。应该将事件服务与业务解耦，独立出来异步执行，或者在业务执行后先尝试发送一次消息，如果消息发送失败，则降级为异步发送。</li></ol><h5 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h5><h6 id="本地事件服务"><a href="#本地事件服务" class="headerlink" title="本地事件服务"></a>本地事件服务</h6><p>为了解决3.1.1中描述的同步事件的问题，异步事件通知模式被发展了出来，既业务服务和事件服务解耦，事件异步进行，由单独的事件服务保证事件的可靠投递。</p><p><img src="/2020/02/06/分布式基础要点/5618351-8ba6d36120dee489.webp" alt="img"></p><p><em>异步事件通知－本地事件服务</em></p><p>当业务执行时，在同一个本地事务中将事件写入本地事件表，同时投递该事件，如果事件投递成功，则将该事件从事件表中删除。如果投递失败，则使用事件服务定时地异步统一处理投递失败的事件，进行重新投递，直到事件被正确投递，并将事件从事件表中删除。这种方式最大可能地保证了事件投递的实效性，并且当第一次投递失败后，也能使用异步事件服务保证事件至少被投递一次。</p><p>然而，这种使用本地事件服务保证可靠事件通知的方式也有它的不足之处，那便是业务仍旧与事件服务有一定耦合（第一次同步投递时），更为严重的是，本地事务需要负责额外的事件表的操作，为数据库带来了压力，在高并发的场景，由于每一个业务操作就要产生相应的事件表操作，几乎将数据库的可用吞吐量砍了一半，这无疑是无法接受的。正是因为这样的原因，可靠事件通知模式进一步地发展－外部事件服务出现在了人们的眼中。</p><h6 id="外部事件服务"><a href="#外部事件服务" class="headerlink" title="外部事件服务"></a>外部事件服务</h6><p>外部事件服务在本地事件服务的基础上更进了一步，将事件服务独立出主业务服务，主业务服务不在对事件服务有任何强依赖。</p><p><img src="/2020/02/06/分布式基础要点/5618351-50c94922574a439d.webp" alt="img"></p><p><em>异步事件通知－外部事件服务</em></p><p>业务服务在提交前，向事件服务发送事件，事件服务只记录事件，并不发送。业务服务在提交或回滚后通知事件服务，事件服务发送事件或者删除事件。不用担心业务系统在提交或者会滚后宕机而无法发送确认事件给事件服务，因为事件服务会定时获取所有仍未发送的事件并且向业务系统查询，根据业务系统的返回来决定发送或者删除该事件。</p><p>外部事件虽然能够将业务系统和事件系统解耦，但是也带来了额外的工作量：外部事件服务比起本地事件服务来说多了两次网络通信开销（提交前、提交／回滚后），同时也需要业务系统提供单独的查询接口给事件系统用来判断未发送事件的状态。</p><h6 id="可靠事件通知模式的注意事项"><a href="#可靠事件通知模式的注意事项" class="headerlink" title="可靠事件通知模式的注意事项"></a>可靠事件通知模式的注意事项</h6><p>可靠事件模式需要注意的有两点，1. 事件的正确发送； 2. 事件的重复消费。<br> 通过异步消息服务可以确保事件的正确发送，然而事件是有可能重复发送的，那么就需要消费端保证同一条事件不会重复被消费，简而言之就是保证事件消费的<code>幂等性</code>。</p><p>如果事件本身是具备幂等性的状态型事件，如订单状态的通知（已下单、已支付、已发货等），则需要判断事件的顺序。一般通过时间戳来判断，既消费过了新的消息后，当接受到老的消息直接丢弃不予消费。如果无法提供全局时间戳，则应考虑使用全局统一的序列号。</p><p>对于不具备幂等性的事件，一般是动作行为事件，如扣款100，存款200，则应该将事件id及事件结果持久化，在消费事件前查询事件id，若已经消费则直接返回执行结果；若是新消息，则执行，并存储执行结果。</p><h4 id="最大努力通知模式"><a href="#最大努力通知模式" class="headerlink" title="最大努力通知模式"></a>最大努力通知模式</h4><p>相比可靠事件通知模式，最大努力通知模式就容易理解多了。最大努力通知型的特点是，业务服务在提交事务后，进行有限次数（设置最大次数限制）的消息发送，比如发送三次消息，若三次消息发送都失败，则不予继续发送。所以有可能导致消息的丢失。同时，主业务方需要提供查询接口给从业务服务，用来恢复丢失消息。最大努力通知型对于时效性保证比较差（既可能会出现较长时间的软状态），所以对于数据一致性的时效性要求比较高的系统无法使用。这种模式通常使用在不同业务平台服务或者对于第三方业务服务的通知，如银行通知、商户通知等，这里不再展开。</p><h4 id="业务补偿模式"><a href="#业务补偿模式" class="headerlink" title="业务补偿模式"></a>业务补偿模式</h4><p>接下来介绍两种补偿模式，补偿模式比起事件通知模式最大的不同是，补偿模式的上游服务依赖于下游服务的运行结果，而事件通知模式上游服务不依赖于下游服务的运行结果。首先介绍业务补偿模式，业务补偿模式是一种纯补偿模式，其设计理念为，业务在调用的时候正常提交，当一个服务失败的时候，所有其依赖的上游服务都进行业务补偿操作。举个例子，小明从杭州出发，去往美国纽约出差，现在他需要定从杭州去往上海的火车票，以及从上海飞往纽约的飞机票。如果小明成功购买了火车票之后发现那天的飞机票已经售空了，那么与其在上海再多待一天，小明还不如取消去上海的火车票，选择飞往北京再转机纽约，所以小明就取消了去上海的火车票。这个例子中购买杭州到上海的火车票是服务a，购买上海到纽约的飞机票是服务b，业务补偿模式就是在服务b失败的时候，对服务a进行补偿操作，在例子中就是取消杭州到上海的火车票。</p><p>补偿模式要求每个服务都提供补偿借口，且这种补偿一般来说是<code>不完全补偿</code>，既即使进行了补偿操作，那条取消的火车票记录还是一直存在数据库中可以被追踪（一般是有相信的状态字段“已取消”作为标记），毕竟已经提交的线上数据一般是不能进行物理删除的。</p><p>业务补偿模式最大的缺点是软状态的时间比较长，既数据一致性的时效性很低，多个服务常常可能处于数据不一致的情况。</p><h4 id="TCC-Try-Confirm-Cancel模式"><a href="#TCC-Try-Confirm-Cancel模式" class="headerlink" title="TCC/Try Confirm Cancel模式"></a>TCC/Try Confirm Cancel模式</h4><p>TCC模式是一种优化了的业务补偿模式，它可以做到<code>完全补偿</code>，既进行补偿后不留下补偿的纪录，就好像什么事情都没有发生过一样。同时，TCC的软状态时间很短，原因是因为TCC是一种两阶段型模式（已经忘了两阶段概念的可以回顾一下1.2.1），只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（Confirm）操作，否则进行补偿(Cancel)操作，而在try阶段是不会进行真正的业务处理的。</p><p><img src="/2020/02/06/分布式基础要点/5618351-dcbf289d3013b723.webp" alt="img"></p><p><em>TCC模式</em></p><p>TCC模式的具体流程为两个阶段：</p><ol><li>Try，业务服务完成所有的业务检查，预留必需的业务资源</li><li>如果Try在所有服务中都成功，那么执行Confirm操作，Confirm操作不做任何的业务检查（因为try中已经做过），只是用Try阶段预留的业务资源进行业务处理；否则进行Cancel操作，Cancel操作释放Try阶段预留的业务资源。</li></ol><p>这么说可能比较模糊，下面我举一个具体的例子，小明在线从招商银行转账100元到广发银行。这个操作可看作两个服务，服务a从小明的招行账户转出100元，服务b从小明的广发银行帐户汇入100元。</p><p>服务a（小明从招行转出100元）:</p><p>try: update cmb_account set balance=balance-100, freeze=freeze+100 where acc_id=1 and balance&gt;100;</p><p>confirm: update cmb_account set freeze=freeze-100 where acc_id=1;</p><p>cancel: update cmb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;</p><p>服务b（小明往广发银行汇入100元）:</p><p>try: update cgb_account set freeze=freeze+100 where acc_id=1;</p><p>confirm: update cgb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;</p><p>cancel: update cgb_account set freeze=freeze-100 where acc_id=1;</p><p>具体说明：<br> a的try阶段，服务做了两件事，1：业务检查，这里是检查小明的帐户里的钱是否多余100元；2:预留资源，将100元从余额中划入冻结资金。</p><p>a的confirm阶段，这里不再进行业务检查，因为try阶段已经做过了，同时由于转账已经成功，将冻结资金扣除。</p><p>a的cancel阶段，释放预留资源，既100元冻结资金，并恢复到余额。</p><p>b的try阶段进行，预留资源，将100元冻结。</p><p>b的confirm阶段，使用try阶段预留的资源，将100元冻结资金划入余额。</p><p>b的cancel阶段，释放try阶段的预留资源，将100元从冻结资金中减去。</p><p>从上面的简单例子可以看出，TCC模式比纯业务补偿模式更加复杂，所以在实现上每个服务都需要实现Cofirm和Cancel两个接口。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下面的表格对这四种常用的模式进行了比较：</p><table><thead><tr><th>类型</th><th>名称</th><th>数据一致性的实时性</th><th>开发成本</th><th>上游服务是否依赖下游服务结果</th></tr></thead><tbody><tr><td>通知型</td><td>最大努力</td><td>低</td><td>低</td><td>不依赖</td></tr><tr><td>通知型</td><td>可靠事件</td><td>高</td><td>高</td><td>不依赖</td></tr><tr><td>补偿型</td><td>业务补偿</td><td>低</td><td>低</td><td>依赖</td></tr><tr><td>补偿型</td><td>TCC</td><td>高</td><td>高</td><td>依赖</td></tr></tbody></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://juejin.im/post/5c7cd6eee51d457c042d4b52" target="_blank" rel="noopener">https://juejin.im/post/5c7cd6eee51d457c042d4b52</a></li><li><a href="https://www.jianshu.com/p/b264a196b177" target="_blank" rel="noopener">https://www.jianshu.com/p/b264a196b177</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;概念&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;模型&quot;&gt;&lt;a href=&quot;#模型&quot; class=&quot;headerlink&quot; title=&quot;模型&quot;&gt;&lt;/a&gt;&lt;strong&gt;模型&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;节点&quot;&gt;&lt;a href=&quot;#节点&quot; class=&quot;headerlink&quot; title=&quot;节点&quot;&gt;&lt;/a&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;在具体的工程项目中，一个节点往往是一个操作系统上的进程。在本文的模型中，认为节点是一个完整的、不可分的整体，如果某个程序进程实际上由若干相对独立部分构成，则在模型中可以将一个进程划分为多个节点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="分布式架构" scheme="https://vincentruan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
