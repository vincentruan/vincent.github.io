<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星辰大海</title>
  
  <subtitle>My Conquest Is the Sea of Stars.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vincentruan.github.io/"/>
  <updated>2020-06-12T12:49:13.828Z</updated>
  <id>https://vincentruan.github.io/</id>
  
  <author>
    <name>Vincent</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在docker-compose环境下以ws+tls方式一键搭建v2ray(So easy)</title>
    <link href="https://vincentruan.github.io/2020/06/12/%E5%9C%A8docker-compose%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BB%A5ws-tls%E6%96%B9%E5%BC%8F%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BAv2ray-So-easy/"/>
    <id>https://vincentruan.github.io/2020/06/12/%E5%9C%A8docker-compose%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BB%A5ws-tls%E6%96%B9%E5%BC%8F%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BAv2ray-So-easy/</id>
    <published>2020-06-12T12:47:27.000Z</published>
    <updated>2020-06-12T12:49:13.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自<a href="https://www.4spaces.org/docker-compose-install-v2ray-ws-tls/" target="_blank" rel="noopener">在docker-compose环境下以ws+tls方式一键搭建v2ray(So easy)</a>，根据实际搭建情况，略有修改</p></blockquote><p>通常以ws+tls方式搭建v2ray的步骤比较繁琐，比如安装v2ray、安装nginx、申请证书等等。那有没有比较简便的方法自动完成这一系列工作呢？答案就在下面。</p><p>在docker-compose环境下以ws+tls方式搭建v2ray的具体步骤如下：</p><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><p><strong>1.获取域名及VPS</strong></p><p>第一步你应该先拥有一个VPS和一个域名，获取VPS和域名的方法如下：</p><ul><li>免费域名注册： <a href="https://www.freenom.com/zh/index.html?lang=zh" target="_blank" rel="noopener">免费域名申请</a>；；</li><li>VPS推荐搬瓦工，支持支付宝付款，注册地址：<a href="https://www.4spaces.org/go/bwg/" target="_blank" rel="noopener">注册搬瓦工</a>，注册教程：<a href="https://www.4spaces.org/best-details-to-buy-banwagonhost/" target="_blank" rel="noopener">史上最详细搬瓦工VPS注册/购买图文教程(内附优惠券)</a>，特价促销款：<a href="https://www.4spaces.org/bwg/static/promotion.html" target="_blank" rel="noopener">搬瓦工促销</a>。</li><li>通过此【<a href="https://www.vultr.com/?ref=7365575" target="_blank" rel="noopener">链接</a>】注册Vultr VPS，即可获得$100，推荐刚上新的韩国机房，参考： <a href="https://www.aliyunhost.net/vultr-korea-datacenter-launch/" target="_blank" rel="noopener">Vultr韩国机房上线，韩国SK线路，附简单测试和新用户优惠</a>。</li></ul><p>然后将域名解析到你VPS的对应的IP地址。</p><p>通过<a href="https://www.4spaces.org/best-details-to-buy-banwagonhost/" target="_blank" rel="noopener">史上最详细搬瓦工VPS注册/购买图文教程(内附优惠券)</a>这篇文章，你应该知道如何使用xshell进行VPS的连接工作了。使用xshell远程连接后进行下面操作。</p><p><strong>2.安装docker-ce并启动</strong></p><p>以下操作我都是以root用户进行的。</p><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -fsSL https://get.docker.com -o get-docker.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sh get-docker.sh</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong> 这一步如果是CENTOS 8，可能会出现 <code>requires containerd.io &gt;= 1.2.2-3错误</code> -&gt; <a href="https://www.4spaces.org/docker-ce-install-containerd-io-error/" target="_blank" rel="noopener">解决办法</a>。</p><ul><li>添加用户到用户组</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -a $USER docker</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><ul><li>设置docker开机自启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>3.安装<code>docker-compose</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.4/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span></span><br></pre></td></tr></table></figure><p><strong>4.安装git并clone代码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git clone https://github.com/aitlp/docker-v2ray.git</span><br></pre></td></tr></table></figure><p>或者你可以下载后在上传到你的VPS。</p><h2 id="二、修改v2ray配置"><a href="#二、修改v2ray配置" class="headerlink" title="二、修改v2ray配置"></a>二、修改v2ray配置</h2><p>下载部署配置文件，然后使用<code>WinSCP</code>等工具上传到你的VPS(当然，也可以安装git后直接clone)，地址： <a href="https://github.com/aitlp/docker-v2ray，如果不会下载请邮件联系" target="_blank" rel="noopener">https://github.com/aitlp/docker-v2ray，如果不会下载请邮件联系</a> <code>aitlpmw(at)gmail.com</code>，我发送给你。</p><p><strong>1.<code>init-letsencrypt.sh</code></strong></p><p>将里面的<code>domains</code>和<code>email</code>修改为自己的域名和邮箱。</p><p><strong>2.<code>docker-compose.yml</code></strong></p><p>可以不用动。</p><p><strong>3.<code>data/v2ray/config.json</code></strong></p><p>修改ID，<code>&quot;id&quot;: &quot;bae399d4-13a4-46a3-b144-4af2c0004c2e&quot;</code>，也可以不修改。</p><p><strong>4.<code>data/nginx/conf.d/v2020_v2ray.conf</code></strong></p><p>修改所有<code>your_domain</code>为自己的域名，其他地方，如果上面可以修改的地方你没修改，那么除了域名之外的也不用修改了。</p><h2 id="三、一键部署v2ray"><a href="#三、一键部署v2ray" class="headerlink" title="三、一键部署v2ray"></a>三、一键部署v2ray</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chomod +x ./init-letsencrypt.sh</span><br><span class="line"></span><br><span class="line">sudo ./init-letsencrypt.sh</span><br></pre></td></tr></table></figure><p>下面是我运行的详细过程：</p><p><img src="/2020/06/12/在docker-compose环境下以ws-tls方式一键搭建v2ray-So-easy/docker-compose-install-v2ray-ws-tls-1.jpg" alt="docker-compose-install-v2ray-ws-tls-1.jpg"></p><h2 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h2><p>现在你可以开始使用了。</p><p>参考： <a href="https://www.4spaces.org/build-v2ray-from-0-to-1/" target="_blank" rel="noopener">2020年最新v2ray搭建详细图文教程(从小白到老炮)</a></p><p>相关配置参考： <a href="https://www.4spaces.org/v2ray-nginx-tls-websocket/" target="_blank" rel="noopener">centos7基于nginx搭建v2ray服务端配置vmess+tls+websocket完全手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;文章转载自&lt;a href=&quot;https://www.4spaces.org/docker-compose-install-v2ray-ws-tls/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在docker-compose环境
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nginx启用Let’s Encrypt SSL证书</title>
    <link href="https://vincentruan.github.io/2020/06/07/Nginx%E5%90%AF%E7%94%A8Let%E2%80%99s-Encrypt-SSL%E8%AF%81%E4%B9%A6/"/>
    <id>https://vincentruan.github.io/2020/06/07/Nginx%E5%90%AF%E7%94%A8Let%E2%80%99s-Encrypt-SSL%E8%AF%81%E4%B9%A6/</id>
    <published>2020-06-07T14:24:56.000Z</published>
    <updated>2020-06-12T12:44:16.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自<a href="https://www.4spaces.org/nginx-lets-encrypt-ssl/" target="_blank" rel="noopener">Nginx启用Let’s Encrypt SSL证书</a>，根据实际搭建情况，略有修改</p></blockquote><p>Let’ s Encrypt 是一个免费的 SSL/TLS 证书发行机构, 证书有效期为90天, 到期前30内可续期，因此不需要担心费用问题。</p><h2 id="服务器环境："><a href="#服务器环境：" class="headerlink" title="服务器环境："></a>服务器环境：</h2><ul><li>nginx-1.10.1</li><li>php-7.0.4</li><li>mariadb-10.1.13</li></ul><p>启用证书的主要过程包括：客户端安装、获取证书、配置Nginx、证书自动续期等几个方面。</p><h2 id="客户端下载"><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h2><p>Let’ s Encrypt客户端现已更名为certbot，客户端的地址为<a href="https://github.com/certbot/certbot/releases" target="_blank" rel="noopener">https://github.com/certbot/certbot/releases</a> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载</span></span><br><span class="line">wget  https://github.com/certbot/certbot/archive/v1.5.0.tar.gz -O certbos.releases.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar xzvf certbos.releases.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入目录</span></span><br><span class="line">cd certbot-1.5.0</span><br></pre></td></tr></table></figure><p>运行一次客户端，进行检查升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入目录</span></span><br><span class="line">cd ~/certbot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行检查</span></span><br><span class="line">./certbot-auto --help</span><br></pre></td></tr></table></figure><p>如果没什么问题的话，会显示帮助文档。</p><h2 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h2><p>申请过程中要验证绑定的域名是否属于申请人, 其原理就是申请人在域名所在的服务器上申请证书, 然后 Let’ s Encrypt 会访问绑定的域名与客户端通信成功即可通过。</p><p>验证的方式有两种，一种是停止当前的 web server 服务, 让出 80 端口, 由客户端内置的 web server 启动与 Let’ s Encrypt 通信；一种是在域名根目录下创建一个临时目录, 并要保证外网通用域名可以访问这个目录，这种方式不需要停止当前的 web server 服务。</p><p>证书获取方式1：通过访问80端口方式验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">停止nginx</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取证书, --standalone 参数:使用内置web server. --email 参数:管理员邮箱,证书到期前会发邮件到此邮箱提醒. -d 参数:要绑定的域名,同一域的不同子域都要输入.</span></span><br><span class="line">./certbot-auto certonly --standalone --email admin@4spaces.org -d ray.servehttp.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动nginx</span></span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>证书获取方式2：通过临时目录验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">--webroot 参数:指定使用临时目录的方式. -w 参数:指定后面-d 域名所在的根目录, 如果一次申请多个域的, 可以附加更多 -w...-d... 这段.</span></span><br><span class="line">./certbot-auto certonly --webroot --email admin@4spaces.org -w /usr/share/nginx/html -d 4spaces.org -d www.4spaces.org</span><br></pre></td></tr></table></figure><p>完成上面的操作即可获得 SSL 证书, 保存在 “/etc/letsencrypt/live/根域名/” 目录下, 会产生 4 个文件, 其中3个证书文件, 1个私钥文件. 不要移动证书的位置, 以免续期时出现错误。关于Letsencrypt使用的更多命令参见「<a href="https://www.4spaces.org/certbot-command-line-tool-usage-document/" target="_blank" rel="noopener">这里</a>」。</p><p>我这里是通过方式2申请的证书。</p><h2 id="配置Nginx启用https"><a href="#配置Nginx启用https" class="headerlink" title="配置Nginx启用https"></a>配置Nginx启用https</h2><p>上面你的Nginx配置并没有启用ssl，下面我们需要开始配置nginx，让其支持https。进行这一步的前提是你前面已经成功生成证书。</p><p>编辑文件/etc/nginx/conf.d/default.conf(我是通过yum的方式安装的nginx，配置目录在这里，你根据自己的情况来)，进行如下配置（这个是我的完整配置）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置非安全连接永久跳转到安全连接</span></span><br><span class="line"><span class="attr">server&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">4spaces.org www.4spaces.org;</span></span><br><span class="line"><span class="comment">    #告诉浏览器有效期内只准用 https 访问</span></span><br><span class="line">    <span class="attr">add_header</span> <span class="string">Strict-Transport-Security max-age=15768000;</span></span><br><span class="line"><span class="comment">    #永久重定向到 https 站点</span></span><br><span class="line">    <span class="attr">return</span> <span class="string">301 https://$server_name$request_uri;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">   #启用 https, 使用 http/2 协议, nginx 1.9.11 启用 http/2 会有bug, 已在 1.9.12 版本中修复.</span></span><br><span class="line">   <span class="attr">listen</span> <span class="string">443 ssl http2;</span></span><br><span class="line">   <span class="attr">server_name</span> <span class="string">4spaces.org www.4spaces.org;</span></span><br><span class="line"><span class="comment">   #首页</span></span><br><span class="line">   <span class="attr">index</span>  <span class="string">index.php index.html index.htm;</span></span><br><span class="line"><span class="comment">   #网站根目录</span></span><br><span class="line">   <span class="attr">root</span>   <span class="string">/usr/share/nginx/4spaces;</span></span><br><span class="line"><span class="comment">   #告诉浏览器当前页面禁止被frame</span></span><br><span class="line">   <span class="attr">add_header</span> <span class="string">X-Frame-Options DENY;</span></span><br><span class="line"><span class="comment">   #告诉浏览器不要猜测mime类型</span></span><br><span class="line">   <span class="attr">add_header</span> <span class="string">X-Content-Type-Options nosniff;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">   #证书路径</span></span><br><span class="line">   <span class="attr">ssl_certificate</span> <span class="string">/etc/letsencrypt/live/4spaces.org/fullchain.pem;</span></span><br><span class="line"><span class="comment">   #私钥路径</span></span><br><span class="line">   <span class="attr">ssl_certificate_key</span> <span class="string">/etc/letsencrypt/live/4spaces.org/privkey.pem;</span></span><br><span class="line"><span class="comment">   #安全链接可选的加密协议</span></span><br><span class="line">   <span class="attr">ssl_protocols</span> <span class="string">TLSv1 TLSv1.1 TLSv1.2;</span></span><br><span class="line"><span class="comment">   #可选的加密算法,顺序很重要,越靠前的优先级越高.</span></span><br><span class="line">   <span class="attr">ssl_ciphers</span> <span class="string">EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span></span><br><span class="line"><span class="comment">   #在 SSLv3 或 TLSv1 握手过程一般使用客户端的首选算法,如果启用下面的配置,则会使用服务器端的首选算法.</span></span><br><span class="line">   <span class="attr">ssl_prefer_server_ciphers</span> <span class="string">on;</span></span><br><span class="line"><span class="comment">   #储存SSL会话的缓存类型和大小</span></span><br><span class="line">   <span class="attr">ssl_session_cache</span> <span class="string">shared:SSL:10m;</span></span><br><span class="line"><span class="comment">   #缓存有效期</span></span><br><span class="line">   <span class="attr">ssl_session_timeout</span> <span class="string">60m;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">try_files</span> <span class="string">$uri $uri/ /index.php?$args;  #修改内容</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    #修改此处内容支持php</span></span><br><span class="line">    <span class="attr">location</span> <span class="string">~ \.php$ &#123;</span></span><br><span class="line">        <span class="attr">fastcgi_pass</span>   <span class="string">127.0.0.1:9000;</span></span><br><span class="line">        <span class="attr">fastcgi_index</span>  <span class="string">index.php;</span></span><br><span class="line">        <span class="attr">fastcgi_param</span>  <span class="string">SCRIPT_FILENAME  $document_root/$fastcgi_script_name;</span></span><br><span class="line">        <span class="attr">include</span>        <span class="string">fastcgi_params;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="证书续期"><a href="#证书续期" class="headerlink" title="证书续期"></a>证书续期</h2><p>前面说了，证书的有效期是3个月，你可以在证书过期前的30天内，进行续期，也可以进行脚本自动续期。</p><p><strong>方式1</strong><br>进入你在下载的certbot客户端目录，执行证书续期的脚本命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto renew</span><br></pre></td></tr></table></figure><blockquote><p>renew 参数是官方推荐的续期方式, 使用这个参数会遍历 /etc/letsencrypt/live 下所有的证书, 如果证书在可续期的时间范围内(过期前30天内), 就会申请新的证书并替换原有证书, 否则跳过。</p></blockquote><p><strong>方式2</strong></p><p>如果要指定更新某个域名的证书, 则要使用 certonly 参数, 其实和新申请证书时的命令差不多.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto certonly --webroot --renew-by-default --email admin@4spaces.org -w /usr/share/nginx/html -d 4spaces.org -d www.4spaces.org</span><br></pre></td></tr></table></figure><p><strong>方式3</strong></p><p>上面两种方式，都是手动去执行的，我们可以将上面两种方式跟linux的定时任务进行结合，最终脚本如下：</p><p>1）通过端口验证的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">停止 nginx 服务,使用 --standalone 独立服务器验证需要停止当前 web server.</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line">if ! /path/to/certbot-auto renew -nvv --standalone &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; then</span><br><span class="line">    echo Automated renewal failed:</span><br><span class="line">    cat /var/log/letsencrypt/renew.log</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">启动 nginx</span></span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure><p>2）通过临时目录的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script renews all the Let<span class="string">'s Encrypt certificates with a validity &lt; 30 days</span></span></span><br><span class="line"></span><br><span class="line">if ! /path/to/certbot-auto renew &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; then</span><br><span class="line">    echo Automated renewal failed:</span><br><span class="line">    cat /var/log/letsencrypt/renew.log</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要重启nginx证书才能生效</span></span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>上面两个脚本中的<code>/path/to/certbot-auto</code>代表你下载客户端解压后的目录，其中目录下有个<code>certbot-auto</code>。</p><p>选取一种方式，将对应的脚本保存为 <code>certbotrenew.sh</code>。</p><p>添加可执行权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x certbotrenew.sh</span><br></pre></td></tr></table></figure><p>编辑 crontab 配置文件或执行 <code>crontab -e</code> 添加 cron 任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编辑定时任务</span></span><br><span class="line">sudo crontab -e</span><br></pre></td></tr></table></figure><p>我这里设置为每月28号23点执行此脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 28 * * /bin/sh /home/michael/certbot/certbotrenew.sh</span><br></pre></td></tr></table></figure><p>保存退出即可。</p><p>内容参考：</p><ul><li><a href="https://blog.itnmg.net/letsencrypt-ssl/；" target="_blank" rel="noopener">https://blog.itnmg.net/letsencrypt-ssl/；</a></li><li><a href="https://community.letsencrypt.org/t/certbot-auto-deployment-best-practices/91979/" target="_blank" rel="noopener">https://community.letsencrypt.org/t/certbot-auto-deployment-best-practices/91979/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;文章转载自&lt;a href=&quot;https://www.4spaces.org/nginx-lets-encrypt-ssl/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nginx启用Let’s Encrypt SSL证书&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>centos7基于nginx搭建v2ray服务端配置vmess+tls+websocket完全手册</title>
    <link href="https://vincentruan.github.io/2020/06/07/centos7%E5%9F%BA%E4%BA%8Enginx%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AEvmess-tls-websocket%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://vincentruan.github.io/2020/06/07/centos7%E5%9F%BA%E4%BA%8Enginx%E6%90%AD%E5%BB%BAv2ray%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AEvmess-tls-websocket%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/</id>
    <published>2020-06-07T13:36:21.000Z</published>
    <updated>2020-06-12T14:06:08.431Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自<a href="https://www.4spaces.org/v2ray-nginx-tls-websocket/" target="_blank" rel="noopener">centos7基于nginx搭建v2ray服务端配置vmess+tls+websocket完全手册</a>，根据实际搭建情况，略有修改</p></blockquote><p>一直都是使用<a href="https://www.4spaces.org/0-1-shadowsocks-start/" target="_blank" rel="noopener">自建shadowsocks科学上网</a>，服务很稳定，虽然v2ray出现了很久，但是没花心思研究两者之间有什么区别。后来无意间查询自己手机的上网记录，出现下图信息，我感觉还是让上网更隐蔽一点更好。</p><blockquote><p>注意：使用下文的方法出现rejected  v2ray.com/core/proxy/vmess/encoding: invalid user，搞不通，有空再验证试试</p></blockquote><a id="more"></a><p><img src="/2020/06/07/centos7基于nginx搭建v2ray服务端配置vmess-tls-websocket完全手册/shadowsocks-tcp.jpg" alt="shadowsocks-tcp.jpg"></p><p>怎么让手机上网记录看起来更正常一点呢？v2ray服务端配置vmess+tls+websocket就是一种解决方式，下面是我使用这种方式之后手机上网记录信息：</p><p><img src="/2020/06/07/centos7基于nginx搭建v2ray服务端配置vmess-tls-websocket完全手册/v2ray-ssl.jpg" alt="v2ray-ssl上网记录"></p><p>接下来就是我实现上述情形的解决过程记录。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>VPS : <a href="https://www.4spaces.org/best-details-to-buy-banwagonhost/" target="_blank" rel="noopener">推荐一下搬瓦工：史上最详细搬瓦工VPS注册/购买图文教程(内附优惠券)</a>；</li><li>一个域名，推荐去godaddy注册，注册之前最好找一下优惠券；</li><li>vps部署Nginx并启用tls安装证书；</li></ul><p>相关文章推荐：</p><ul><li><a href="https://www.4spaces.org/create-a-dg-account-and-connect-droplets/" target="_blank" rel="noopener">如何在Digitalocean上构建一个服务器？</a></li><li><a href="https://www.4spaces.org/centos-yum-install-nginx/" target="_blank" rel="noopener">CentOS 7通过yum安装Nginx</a></li><li><a href="https://www.4spaces.org/nginx-lets-encrypt-ssl/" target="_blank" rel="noopener">Nginx启用Let’s Encrypt SSL证书。</a></li></ul><p>请继续下一步之前，先依次完成下列步骤：</p><ul><li>注册一个自己的VPS服务器；</li><li>注册一个自己的域名并解析到自己的VPS；(可通过<a href="https://www.noip.com/" target="_blank" rel="noopener">noip</a>免费获取三个域名)</li><li>登录VPS并安装部署Nginx；</li><li>完成域名的https SSL安全证书启用；</li></ul><p>只有完成上面的步骤在继续下面操作，才能实现v2ray服务端配置vmess+tls+websocket。</p><p>我的环境：</p><ul><li>服务器系统：Digitalocean CentOS 7.5 x64 ；</li><li>v2ray版本：v4.17.0；</li><li>nginx版本：nginx/1.14.2 (CentOS)；</li><li>证书：Let’s Encrypt certbot-0.31.0；</li><li>v2rayN：2.22</li></ul><h2 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h2><p>安装过程很简单，只要能正常连接自己的VPS并进行登录，然后执行一下安装命令即可，安装过程参考：<a href="https://www.4spaces.org/build-v2ray-from-0-to-1/" target="_blank" rel="noopener">2020年最新v2ray搭建详细图文教程(从小白到老炮)</a>，重要的接下来的配置过程。</p><h2 id="配置v2ray服务端"><a href="#配置v2ray服务端" class="headerlink" title="配置v2ray服务端"></a>配置v2ray服务端</h2><p>假设你的域名是v2ray.com，并将二级域名<code>hi.v2ray.com</code>解析到你的VPS。</p><p>执行下面的命令，开始配置v2ray:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ss-us ~]# vi /etc/v2ray/config.json</span><br></pre></td></tr></table></figure><p>按<code>i</code>键编辑文件，把内容更改为下面的内容：【注意这里要执行】</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"access"</span>: <span class="string">"/var/log/v2ray/access.log"</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"/var/log/v2ray/error.log"</span>,</span><br><span class="line">    <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">33684</span>,</span><br><span class="line">      <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"clients"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"0c67ca68-63ad-40c5-898e-9cf1925c8694"</span>,</span><br><span class="line">            <span class="attr">"level"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"network"</span>: <span class="string">"ws"</span>,</span><br><span class="line">        <span class="attr">"wsSettings"</span>: &#123;</span><br><span class="line">          <span class="attr">"path"</span>: <span class="string">"/v2ray"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>执行下面的命令，开始配置nginx:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ss-us ~]# vi /etc/nginx/conf.d/v2ray.conf</span><br></pre></td></tr></table></figure><p>按<code>i</code>键编辑文件，把内容更改为下面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name hi.v2ray.com;</span><br><span class="line">    root /etc/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2 default_server;</span><br><span class="line">    server_name hi.v2ray.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/hi.v2ray.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/hi.v2ray.com/privkey.pem;</span><br><span class="line"></span><br><span class="line">    root /etc/nginx/html;</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location /v2ray &#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http://127.0.0.1:33684;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>proxy_pass http://127.0.0.1:33684;</code> 这里的<code>33684</code>需要跟v2ray配置文件<code>config.json</code>端口对应；</li><li><code>root /etc/nginx/html</code>及<code>location /etc/nginx/html</code>行，需要与nginx实际根目录对应；</li></ul><h2 id="重启v2ray、nginx服务"><a href="#重启v2ray、nginx服务" class="headerlink" title="重启v2ray、nginx服务"></a>重启v2ray、nginx服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart v2ray</span><br><span class="line"></span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h2 id="客户端界面配置"><a href="#客户端界面配置" class="headerlink" title="客户端界面配置"></a>客户端界面配置</h2><p>这里我是用<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">v2rayN</a>，配置如下：</p><p><img src="/2020/06/07/centos7基于nginx搭建v2ray服务端配置vmess-tls-websocket完全手册/v2rayn-config-windows.png" alt="v2rayn-config-windows.png"></p><p><img src="/2020/06/07/centos7基于nginx搭建v2ray服务端配置vmess-tls-websocket完全手册/v2rayn-config-windows-1.png" alt="v2rayn-config-windows-1.png"></p><h2 id="配置CloudFlare"><a href="#配置CloudFlare" class="headerlink" title="配置CloudFlare"></a>配置CloudFlare</h2><p>注册CloudFlare账户并配置domain域名CDN 配置完了再用 curl 测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -i https://example.com/v2ray</span><br><span class="line">HTTP/2 400</span><br><span class="line">date: Sun, 12 Jan 2020 08:44:07 GMT</span><br><span class="line">content-type: text/plain; charset=utf-8</span><br><span class="line">content-length: 12</span><br><span class="line">sec-websocket-version: 13</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">cf-cache-status: DYNAMIC</span><br><span class="line">expect-ct: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot; server: cloudflare</span><br><span class="line"></span><br><span class="line">Bad Request</span><br></pre></td></tr></table></figure><p>同样也是出现 400 Bad Request 就对了。</p><p>如果你像我上面一样在 Nginx 中配置了 <code>$http_upgrade = &quot;websocket&quot;</code> 的判断的话，这里返回的会是用于伪装的那个页面（而且 Nginx 的 <code>$http_upgrade</code> 变量不知道是按什么赋值的，直接 <code>curl --header &quot;Upgrade: websocket&quot;</code> 的话还不认，怪得很）。可以使用 <code>wscat</code> 来测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wscat -c wss://example.com/whatever</span><br><span class="line">Connected (press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>这里因为我的域名用的noip分配的免费域名，因此没连接成功，如果需要真实搭建的，可以参考这篇<a href="https://zhuanlan.zhihu.com/p/63866401" target="_blank" rel="noopener">文章</a>搞个最便宜的国外域名</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="使用v2ray访问谷歌提示异常流量-没遇到"><a href="#使用v2ray访问谷歌提示异常流量-没遇到" class="headerlink" title="使用v2ray访问谷歌提示异常流量[没遇到]"></a>使用v2ray访问谷歌提示异常流量[没遇到]</h3><p>按照这篇文章搭建了v2ray服务之后，又尝试启用cloudflare cdn来隐藏自己的真实IP，但是启用cdn之后就无法访问了。</p><p><img src="/2020/06/07/centos7基于nginx搭建v2ray服务端配置vmess-tls-websocket完全手册/v2ray-cloudflare-cdn-403-error.jpg" alt="v2ray-cloudflare-cdn-403-error.jpg"></p><p>这是因为我增加了header伪装域名，去掉之后v2ray就能正常使用了。也就是cloudflare的cdn功能和v2ray的伪装功能不能同时使用。</p><p>另外：</p><p><strong>Cloudflare的“SSL/TLS”配置为”Full”或”Full(strict)”</strong>。</p><h3 id="启用cloudflare-cdn之后v2ray报403错误"><a href="#启用cloudflare-cdn之后v2ray报403错误" class="headerlink" title="启用cloudflare cdn之后v2ray报403错误"></a>启用cloudflare cdn之后v2ray报403错误</h3><p>按照这篇文章【<a href="https://www.4spaces.org/v2ray-nginx-tls-websocket/" target="_blank" rel="noopener">centos7基于nginx搭建v2ray服务端配置vmess+tls+websocket完全手册</a>】搭建了v2ray服务之后，使用google搜索的时候经常提示：我们的系统检测到您的计算机网络中存在异常流量，需要进行人验证，对于离不开google的人来说比较烦人。</p><p><img src="/2020/06/07/centos7基于nginx搭建v2ray服务端配置vmess-tls-websocket完全手册/v2ray-google-abnormal-traffic.jpg" alt="v2ray-google-abnormal-traffic.jpg"></p><p>网上出现的解决办法有：</p><ol><li>更换ip；</li><li>配置v2ray让google走ipv6；</li><li>配置v2ray让google走ipv4；</li><li>更换域名，可能你的域名以前被不正当的使用过；</li></ol><p>我是通过<code>配置v2ray让google走ipv4</code>+<code>更换域名</code>解决的。下面是配置让google走ipv4的配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"access"</span>: <span class="string">"/var/log/v2ray/access.log"</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"/var/log/v2ray/error.log"</span>,</span><br><span class="line">    <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"inbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">33684</span>,</span><br><span class="line">      <span class="attr">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"clients"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"0c67ca68-63ad-40c5-898e-9cf1925c8694"</span>,</span><br><span class="line">            <span class="attr">"level"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"network"</span>: <span class="string">"ws"</span>,</span><br><span class="line">        <span class="attr">"wsSettings"</span>: &#123;</span><br><span class="line">          <span class="attr">"path"</span>: <span class="string">"/etc/nginx/html"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"outbounds"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"domainStrategy"</span>: <span class="string">"UseIPv4"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"ip4-out"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;</span><br><span class="line">    <span class="attr">"rules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"domain"</span>: [</span><br><span class="line">          <span class="string">"domain:google.com"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"ip4-out"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">        <span class="attr">"ip"</span>: [</span><br><span class="line">          <span class="string">"0.0.0.0/8"</span>,</span><br><span class="line">          <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">          <span class="string">"100.64.0.0/10"</span>,</span><br><span class="line">          <span class="string">"127.0.0.0/8"</span>,</span><br><span class="line">          <span class="string">"169.254.0.0/16"</span>,</span><br><span class="line">          <span class="string">"172.16.0.0/12"</span>,</span><br><span class="line">          <span class="string">"192.0.0.0/24"</span>,</span><br><span class="line">          <span class="string">"192.0.2.0/24"</span>,</span><br><span class="line">          <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">          <span class="string">"198.18.0.0/15"</span>,</span><br><span class="line">          <span class="string">"198.51.100.0/24"</span>,</span><br><span class="line">          <span class="string">"203.0.113.0/24"</span>,</span><br><span class="line">          <span class="string">"::1/128"</span>,</span><br><span class="line">          <span class="string">"fc00::/7"</span>,</span><br><span class="line">          <span class="string">"fe80::/10"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体修改的地方有两个，一是增加了一个outbound，而是rules增加一个让google走刚增加的outbound</p><h3 id="连接失败"><a href="#连接失败" class="headerlink" title="连接失败"></a>连接失败</h3><p>access.log日志提示<code>rejected  v2ray.com/core/proxy/vmess/encoding: invalid user</code></p><p>这里是因为没有重新配置/etc/v2ray/config.json，参考上面的配置v2ray服务端</p><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><p>上述文章是<code>ws + tls</code>搭建v2ray的详细步骤，如果想快速、简洁、标准搭建，请参考：<a href="https://www.4spaces.org/docker-compose-install-v2ray-ws-tls/" target="_blank" rel="noopener">在docker-compose环境下以ws+tls方式搭建v2ray(So easy)</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章转载自&lt;a href=&quot;https://www.4spaces.org/v2ray-nginx-tls-websocket/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;centos7基于nginx搭建v2ray服务端配置vmess+tls+websocket完全手册&lt;/a&gt;，根据实际搭建情况，略有修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一直都是使用&lt;a href=&quot;https://www.4spaces.org/0-1-shadowsocks-start/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自建shadowsocks科学上网&lt;/a&gt;，服务很稳定，虽然v2ray出现了很久，但是没花心思研究两者之间有什么区别。后来无意间查询自己手机的上网记录，出现下图信息，我感觉还是让上网更隐蔽一点更好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：使用下文的方法出现rejected  v2ray.com/core/proxy/vmess/encoding: invalid user，搞不通，有空再验证试试&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="LINUX" scheme="https://vincentruan.github.io/categories/LINUX/"/>
    
    
      <category term="v2ray" scheme="https://vincentruan.github.io/tags/v2ray/"/>
    
      <category term="科学上网" scheme="https://vincentruan.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java开发必须掌握的线上问题排查命令 - 常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等</title>
    <link href="https://vincentruan.github.io/2020/06/06/Java%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E3%80%81JPS%E3%80%81JSTACK%E3%80%81JMAP%E3%80%81JSTAT%E3%80%81JHAT%E3%80%81JINFO%E3%80%81JAVAP%E7%AD%89/"/>
    <id>https://vincentruan.github.io/2020/06/06/Java%E5%BC%80%E5%8F%91%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%91%BD%E4%BB%A4-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E3%80%81JPS%E3%80%81JSTACK%E3%80%81JMAP%E3%80%81JSTAT%E3%80%81JHAT%E3%80%81JINFO%E3%80%81JAVAP%E7%AD%89/</id>
    <published>2020-06-06T14:29:47.000Z</published>
    <updated>2020-06-06T15:42:40.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="http://www.hollischuang.com/archives/tag/java%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97" target="_blank" rel="noopener">java命令学习系列</a>，文章内容略有调整。</p></blockquote><h1 id="Java开发必须掌握的线上问题排查命令"><a href="#Java开发必须掌握的线上问题排查命令" class="headerlink" title="Java开发必须掌握的线上问题排查命令"></a>Java开发必须掌握的线上问题排查命令</h1><p>作为一个合格的开发人员，不仅要能写得一手还代码，还有一项很重要的技能就是排查问题。这里提到的排查问题不仅仅是在coding的过程中debug等，还包括的就是线上问题的排查。由于在生产环境中，一般没办法debug（其实有些问题，debug也白扯。。。）,所以我们需要借助一些常用命令来查看运行时的具体情况，这些运行时信息包括但不限于运行日志、异常堆栈、堆使用情况、GC情况、JVM参数情况、线程情况等。</p><p>给一个系统定位问题的时候，知识、经验是关键，数据是依据，工具是运用知识处理数据的手段。为了便于我们排查和解决问题，Sun公司为我们提供了一些常用命令。这些命令一般都是jdk/lib/tools.jar中类库的一层薄包装。随着JVM的安装一起被安装到机器中，在bin目录中。下面就来认识一下这些命令以及具体使用方式。</p><a id="more"></a><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>显示当前所有java进程pid的命令。</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><code>jps</code>：显示当前用户的所有java进程的PID</p><p><code>jps -v 3331</code>：显示虚拟机参数</p><p><code>jps -m 3331</code>：显示传递给main()函数的参数</p><p><code>jps -l 3331</code>：显示主类的全路径</p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>实时查看和调整虚拟机参数，可以显示未被显示指定的参数的默认值（<code>jps -v 则不能</code>）。</p><blockquote><p>jdk8中已经不支持该命令。</p></blockquote><h3 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h3><p><code>jinfo -flag CMSIniniatingOccupancyFration 1444</code>：查询CMSIniniatingOccupancyFration参数值</p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>显示进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><h3 id="常用指令-2"><a href="#常用指令-2" class="headerlink" title="常用指令"></a>常用指令</h3><p><code>jstat -gc 3331 250 20</code> ：查询进程2764的垃圾收集情况，每250毫秒查询一次，一共查询20次。</p><p><code>jstat -gccause</code>：额外输出上次GC原因</p><p><code>jstat -calss</code>：件事类装载、类卸载、总空间以及所消耗的时间</p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p>生成堆转储快照（heapdump）</p><h3 id="常用指令-3"><a href="#常用指令-3" class="headerlink" title="常用指令"></a>常用指令</h3><p><code>jmap -heap 3331</code>：查看java 堆（heap）使用情况</p><p><code>jmap -histo 3331</code>：查看堆内存(histogram)中的对象数量及大小</p><p><code>jmap -histo:live 3331</code>：JVM会先触发gc，然后再统计信息</p><p><code>jmap -dump:format=b,file=heapDump 3331</code>：将内存使用的详细情况输出到文件，之后一般使用其他工具进行分析。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><h3 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h3><p>一般与jmap搭配使用，用来分析jmap生成的堆转储文件。</p><blockquote><p>由于有很多可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）可以替代，所以很少用。不过在没有可视化工具的机器上也是可用的。</p></blockquote><h3 id="常用指令-4"><a href="#常用指令-4" class="headerlink" title="常用指令"></a>常用指令</h3><p><code>jmap -dump:format=b,file=heapDump 3331</code> + <code>jhat heapDump</code>：解析Java堆转储文件,并启动一个 web server</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h3 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h3><p>生成当前时刻的线程快照。</p><h3 id="常用指令-5"><a href="#常用指令-5" class="headerlink" title="常用指令"></a>常用指令</h3><p><code>jstack 3331</code>：查看线程情况</p><p><code>jstack -F 3331</code>：正常输出不被响应时，使用该指令</p><p><code>jstack -l 3331</code>：除堆栈外，显示关于锁的附件信息</p><h2 id="常见问题定位过程"><a href="#常见问题定位过程" class="headerlink" title="常见问题定位过程"></a>常见问题定位过程</h2><h3 id="频繁GC问题或内存溢出问题"><a href="#频繁GC问题或内存溢出问题" class="headerlink" title="频繁GC问题或内存溢出问题"></a>频繁GC问题或内存溢出问题</h3><p>一、使用<code>jps</code>查看线程ID</p><p>二、使用<code>jstat -gc 3331 250 20</code> 查看gc情况，一般比较关注PERM区的情况，查看GC的增长情况。</p><p>三、使用<code>jstat -gccause</code>：额外输出上次GC原因</p><p>四、使用<code>jmap -dump:format=b,file=heapDump 3331</code>生成堆转储文件</p><p>五、使用jhat或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。</p><p>六、结合代码解决内存溢出或泄露问题。</p><h3 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h3><p>一、使用<code>jps</code>查看线程ID，转换为16进制<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf %x 线程号</span><br></pre></td></tr></table></figure></p><p>二、使用<code>jstack 3331</code>：查看线程情况</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经常使用适当的虚拟机监控和分析工具可以加快我们分析数据、定位解决问题的速度，但也要知道，工具永远都是知识技能的一层包装，没有什么工具是包治百病的。</p><h1 id="Java命令学习系列（零）—-常见命令及Java-Dump介绍"><a href="#Java命令学习系列（零）—-常见命令及Java-Dump介绍" class="headerlink" title="Java命令学习系列（零）— 常见命令及Java Dump介绍"></a>Java命令学习系列（零）— 常见命令及Java Dump介绍</h1><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p>在JDK的bin目彔下,包含了java命令及其他实用工具。</p><blockquote><p>jps:查看本机的Java中进程信息。</p><p>jstack:打印线程的栈信息,制作线程Dump。</p><p>jmap:打印内存映射,制作堆Dump。</p><p>jstat:性能监控工具。</p><p>jhat:内存分析工具。</p><p>jconsole:简易的可视化控制台。</p><p>jvisualvm:功能强大的控制台。</p></blockquote><h2 id="认识Java-Dump："><a href="#认识Java-Dump：" class="headerlink" title="认识Java Dump："></a>认识Java Dump：</h2><h3 id="什么是Java-Dump？"><a href="#什么是Java-Dump？" class="headerlink" title="什么是Java Dump？"></a>什么是Java Dump？</h3><blockquote><p>Java虚拟机的运行时快照。将Java虚拟机运行时的状态和信息保存到文件。</p><p><strong>线程Dump</strong>,包含所有线程的运行状态。纯文本格式。</p><p><strong>堆Dump</strong>,包含线程Dump,幵包含所有堆对象的状态。二进制格式。</p></blockquote><h3 id="Java-Dump有什么用？"><a href="#Java-Dump有什么用？" class="headerlink" title="Java Dump有什么用？"></a>Java Dump有什么用？</h3><blockquote><p>补足传统Bug分析手段的不足: 可在任何Java环境使用;信息量充足。 针对非功能正确性的Bug,主要为:多线程幵发、内存泄漏。</p></blockquote><h2 id="制作Java-Dump"><a href="#制作Java-Dump" class="headerlink" title="制作Java Dump"></a>制作Java Dump</h2><p><strong>使用Java虚拟机制作Dump</strong></p><p>指示虚拟机在发生内存不足错误时,自动生成堆Dump</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure><p><strong>使用图形化工具制作Dump</strong></p><p>使用JDK(1.6)自带的工具:Java VisualVM。</p><p><strong>使用命令行制作Dump</strong></p><p><code>jstack</code>:打印线程的栈信息,制作线程Dump。</p><p><code>jmap</code>:打印内存映射,制作堆Dump。</p><p><strong>步骤：</strong></p><ol><li>检查虚拟机版本（java -version）</li><li>找出目标Java应用的进程ID（jps）</li><li>使用jstack命令制作线程Dump• Linux环境下使用kill命令制作线程Dump</li><li>使用jmap命令制作堆Dump</li></ol><h1 id="Java命令学习系列（一）—-Jps"><a href="#Java命令学习系列（一）—-Jps" class="headerlink" title="Java命令学习系列（一）— Jps"></a>Java命令学习系列（一）— Jps</h1><blockquote><p>jps位于jdk的bin目录下，其作用是显示当前系统的java进程情况，及其id号。 jps相当于Solaris进程工具ps。不象”pgrep java”或”ps -ef grep java”，jps并不使用应用程序名来查找JVM实例。因此，它查找所有的Java应用程序，包括即使没有使用java执行体的那种（例如，定制的启动 器）。另外，jps仅查找当前用户的Java进程，而不是当前系统中的所有进程。</p></blockquote><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>我们知道，很多Java命令都在jdk的JAVA_HOME/bin/目录下面，jps也不例外，他就在bin目录下，所以，他是java自带的一个命令。</p><h2 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h2><p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>jdk中的jps命令可以显示当前运行的java进程以及相关参数，它的实现机制如下：<br>java程序在启动以后，会在<code>java.io.tmpdir</code>指定的目录下，就是临时文件夹里，生成一个类似于<code>hsperfdata_User</code>的文件夹，这个文件夹里（在Linux中为/tmp/hsperfdata_{userName}/），有几个文件，名字就是java进程的pid，因此列出当前运行的java进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ pwd</span><br><span class="line">/tmp/hsperfdata_hollis</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ ll</span><br><span class="line">total 48</span><br><span class="line">drwxr-xr-x 2 hollis hollis  4096  4月 16 10:54 ./</span><br><span class="line">drwxrwxrwt 7 root   root   12288  4月 16 10:56 ../</span><br><span class="line">-rw------- 1 hollis hollis 32768  4月 16 10:57 2679</span><br><span class="line">hollis@hos:/tmp/hsperfdata_hollis$</span><br></pre></td></tr></table></figure><p>上面的内容就是我机器中/tmp/hsperfdata_hollis目录下的内容，其中2679就是我机器上当前运行中的java的进程的pid，我们执行jps验证一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps</span><br><span class="line">2679 org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar</span><br><span class="line">4445 Jps</span><br></pre></td></tr></table></figure><p>执行了jps命令之后，我们发现有两个java进程，一个是pid为2679的eclipse运行的进程，另外一个是pid为4445的jps使用的进程（他也是java命令，也要开一个进程）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>想要学习一个命令，先来看看帮助，使用<code>jps -help</code>查看帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps -help</span><br><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>接下来，为了详细介绍这些参数，我们编写几个类，在main方法里写一个while(true)的循环，查看java进程情况。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaCommand;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hollis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps -q</span><br><span class="line">2679</span><br><span class="line">11421</span><br></pre></td></tr></table></figure><p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null，</strong> 在这里，在启动main方法的时候，我给String[] args传递两个参数。hollis,chuang,执行<code>jsp -m</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps -m</span><br><span class="line">12062 JpsDemo hollis,chuang</span><br></pre></td></tr></table></figure><p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps -l</span><br><span class="line">12356 sun.tools.jps.Jps</span><br><span class="line">2679 /home/hollis/tools/eclipse//plugins/org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar</span><br><span class="line">12329 com.JavaCommand.JpsDemo</span><br></pre></td></tr></table></figure><p><strong>-v 输出传递给JVM的参数</strong> 在这里，在启动main方法的时候，我给jvm传递一个参数：-Dfile.encoding=UTF-8,执行<code>jps -v</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:/tmp/hsperfdata_hollis$ jps -v</span><br><span class="line">2679 org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar -Djava.library.path=/usr/lib/jni:/usr/lib/x86_64-linux-gnu/jni -Dosgi.requiredJavaVersion=1.6 -XX:MaxPermSize=256m -Xms40m -Xmx512m</span><br><span class="line">13157 Jps -Denv.class.path=/home/hollis/tools/java/jdk1.7.0_71/lib:/home/hollis/tools/java/jdk1.7.0_71/jre/lib: -Dapplication.home=/home/hollis/tools/java/jdk1.7.0_71 -Xms8m</span><br><span class="line">13083 JpsDemo -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><p>PS:jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</p><blockquote><p><strong>jps是我最常用的java命令。使用jps可以查看当前有哪些Java进程处于运行状态。如果我运行了一个web应用（使用tomcat、jboss、jetty等启动）的时候，我就可以使用jps查看启动情况。有的时候我想知道这个应用的日志会输出到哪里，或者启动的时候使用了哪些javaagent，那么我可以使用<code>jps -v</code> 查看进程的jvm参数情况。</strong></p></blockquote><h2 id="JPS失效处理"><a href="#JPS失效处理" class="headerlink" title="JPS失效处理"></a>JPS失效处理</h2><p><strong>现象：</strong> 用ps -ef|grep java能看到启动的java进程，但是用jps查看却不存在该进程的id。待会儿解释过之后就能知道在该情况下，jconsole、jvisualvm可能无法监控该进程，其他java自带工具也可能无法使用</p><p><strong>分析：</strong> jps、jconsole、jvisualvm等工具的数据来源就是这个文件（/tmp/hsperfdata_userName/pid)。所以当该文件不存在或是无法读取时就会出现jps无法查看该进程号，jconsole无法监控等问题</p><p><strong>原因：</strong></p><p>（1）、磁盘读写、目录权限问题 若该用户没有权限写/tmp目录或是磁盘已满，则无法创建/tmp/hsperfdata_userName/pid文件。或该文件已经生成，但用户没有读权限</p><p>（2）、临时文件丢失，被删除或是定期清理 对于linux机器，一般都会存在定时任务对临时文件夹进行清理，导致/tmp目录被清空。这也是我第一次碰到该现象的原因。常用的可能定时删除临时目录的工具为crontab、redhat的tmpwatch、ubuntu的tmpreaper等等</p><p>这个导致的现象可能会是这样，用jconsole监控进程，发现在某一时段后进程仍然存在，但是却没有监控信息了。</p><p>（3）、java进程信息文件存储地址被设置，不在/tmp目录下 上面我们在介绍时说默认会在/tmp/hsperfdata_userName目录保存进程信息，但由于以上1、2所述原因，可能导致该文件无法生成或是丢失，所以java启动时提供了参数(-Djava.io.tmpdir)，可以对这个文件的位置进行设置，而jps、jconsole都只会从/tmp目录读取，而无法从设置后的目录读物信息，这是我第二次碰到该现象的原因</p><h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><p>1.如何给main传递参数 在eclipse中，鼠标右键-&gt;Run As-&gt;Run COnfiguations-&gt;Arguments-&gt;在Program arguments中写下要传的参数值</p><p>1.如何给JVM传递参数 在eclipse中，鼠标右键-&gt;Run As-&gt;Run COnfiguations-&gt;Arguments-&gt;在VM arguments中写下要传的参数值（一般以-D开头）</p><h1 id="Java命令学习系列（二）—-Jstack"><a href="#Java命令学习系列（二）—-Jstack" class="headerlink" title="Java命令学习系列（二）— Jstack"></a>Java命令学习系列（二）— Jstack</h1><blockquote><p>jstack是java虚拟机自带的一种堆栈跟踪工具。</p></blockquote><h2 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h2><p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p><blockquote><p>So,<strong>jstack命令主要用来查看Java线程的调用堆栈的，可以用来分析线程问题（如死锁）。</strong></p></blockquote><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>想要通过jstack命令来分析线程的情况的话，首先要知道线程都有哪些状态，下面这些状态是我们使用jstack命令查看线程堆栈信息时可能会看到的<strong>线程的几种状态</strong>：</p><blockquote><p>NEW,未启动的。不会出现在Dump中。</p><p>RUNNABLE,在虚拟机内执行的。</p><p>BLOCKED,受阻塞并等待监视器锁。</p><p>WATING,无限期等待另一个线程执行特定操作。</p><p>TIMED_WATING,有时限的等待另一个线程的特定操作。</p><p>TERMINATED,已退出的。</p></blockquote><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>在多线程的 JAVA程序中，实现线程之间的同步，就要说说 Monitor。 <strong>Monitor是 Java中用以实现线程之间的互斥与协作的主要手段</strong>，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。下 面这个图，描述了线程和 Monitor之间关系，以 及线程的状态转换图：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/thread.bmp" alt="thread"></p><p><strong>进入区(Entrt Set)</strong>:表示线程通过synchronized要求获取对象的锁。如果对象未被锁住,则迚入拥有者;否则则在进入区等待。一旦对象锁被其他线程释放,立即参与竞争。</p><p><strong>拥有者(The Owner)</strong>:表示某一线程成功竞争到对象锁。</p><p><strong>等待区(Wait Set)</strong>:表示线程通过对象的wait方法,释放对象的锁,并在等待区等待被唤醒。</p><p>从图中可以看出，一个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 <code>“Active Thread”</code>，而其它线程都是 <code>“Waiting Thread”</code>，分别在两个队列 <code>“ Entry Set”</code>和 <code>“Wait Set”</code>里面等候。在 <code>“Entry Set”</code>中等待的线程状态是 <code>“Waiting for monitor entry”</code>，而在 <code>“Wait Set”</code>中等待的线程状态是 <code>“in Object.wait()”</code>。 先看 “Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应的 code就像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用修饰"><a href="#调用修饰" class="headerlink" title="调用修饰"></a>调用修饰</h3><p>表示线程在方法调用时,额外的重要的操作。线程Dump分析的重要信息。修饰上方的方法调用。</p><blockquote><p>locked &lt;地址&gt; 目标：使用synchronized申请对象锁成功,监视器的拥有者。</p><p>waiting to lock &lt;地址&gt; 目标：使用synchronized申请对象锁未成功,在迚入区等待。</p><p>waiting on &lt;地址&gt; 目标：使用synchronized申请对象锁成功后,释放锁幵在等待区等待。</p><p>parking to wait for &lt;地址&gt; 目标</p></blockquote><p><strong>locked</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at oracle.jdbc.driver.PhysicalConnection.prepareStatement</span><br><span class="line">- locked &lt;0x00002aab63bf7f58&gt; (a oracle.jdbc.driver.T4CConnection)</span><br><span class="line">at oracle.jdbc.driver.PhysicalConnection.prepareStatement</span><br><span class="line">- locked &lt;0x00002aab63bf7f58&gt; (a oracle.jdbc.driver.T4CConnection)</span><br><span class="line">at com.jiuqi.dna.core.internal.db.datasource.PooledConnection.prepareStatement</span><br></pre></td></tr></table></figure><p>通过synchronized关键字,成功获取到了对象的锁,成为监视器的拥有者,在临界区内操作。对象锁是可以线程重入的。</p><p><strong>waiting to lock</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at com.jiuqi.dna.core.impl.CacheHolder.isVisibleIn(CacheHolder.java:165)</span><br><span class="line">- waiting to lock &lt;0x0000000097ba9aa8&gt; (a CacheHolder)</span><br><span class="line">at com.jiuqi.dna.core.impl.CacheGroup$Index.findHolder</span><br><span class="line">at com.jiuqi.dna.core.impl.ContextImpl.find</span><br><span class="line">at com.jiuqi.dna.bap.basedata.common.util.BaseDataCenter.findInfo</span><br></pre></td></tr></table></figure><p>通过synchronized关键字,没有获取到了对象的锁,线程在监视器的进入区等待。在调用栈顶出现,线程状态为Blocked。</p><p><strong>waiting on</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x00000000da2defb0&gt; (a WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingManager.getWorkToDo</span><br><span class="line">- locked &lt;0x00000000da2defb0&gt; (a WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingThread.run</span><br></pre></td></tr></table></figure><p>通过synchronized关键字,成功获取到了对象的锁后,调用了wait方法,进入对象的等待区等待。在调用栈顶出现,线程状态为WAITING或TIMED_WATING。</p><p><strong>parking to wait for</strong></p><p>park是基本的线程阻塞原语,不通过监视器在对象上阻塞。随concurrent包会出现的新的机制,不synchronized体系不同。</p><h3 id="线程动作"><a href="#线程动作" class="headerlink" title="线程动作"></a>线程动作</h3><p>线程状态产生的原因</p><blockquote><p>runnable:状态一般为RUNNABLE。</p><p>in Object.wait():等待区等待,状态为WAITING或TIMED_WAITING。</p><p>waiting for monitor entry:进入区等待,状态为BLOCKED。</p><p>waiting on condition:等待区等待、被park。</p><p>sleeping:休眠的线程,调用了Thread.sleep()。</p></blockquote><p><strong>Wait on condition</strong> 该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace来分析。 最常见的情况就是线程处于sleep状态，等待被唤醒。 常见的情况还有等待网络IO：在java引入nio之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 NewIO里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读 写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制 ; 观察 cpu的利用率，如果系统态的 CPU时间，相对于用户态的 CPU时间比例较高；如果程序运行在 Solaris 10平台上，可以用 dtrace工具看系统调用的情况，如果观察到 read/write的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。</p><h2 id="线程Dump的分析"><a href="#线程Dump的分析" class="headerlink" title="线程Dump的分析"></a>线程Dump的分析</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><blockquote><p>结合代码阅读的推理。需要线程Dump和源码的相互推导和印证。</p><p>造成Bug的根源往往丌会在调用栈上直接体现,一定格外注意线程当前调用之前的所有调用。</p></blockquote><h3 id="入手点"><a href="#入手点" class="headerlink" title="入手点"></a>入手点</h3><p><strong>进入区等待</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"d&amp;a-3588" daemon waiting for monitor entry [0x000000006e5d5000]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()</span><br><span class="line">- waiting to lock &lt;0x0000000602f38e90&gt; (a java.lang.Object)</span><br><span class="line">at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()</span><br></pre></td></tr></table></figure><p>线程状态BLOCKED,线程动作wait on monitor entry,调用修饰waiting to lock总是一起出现。表示在代码级别已经存在冲突的调用。必然有问题的代码,需要尽可能减少其发生。</p><p><strong>同步块阻塞</strong></p><p>一个线程锁住某对象,大量其他线程在该对象上等待。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"blocker" runnable</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$1.run(Blocker.java:23)</span><br><span class="line">- locked &lt;0x00000000eb8eff68&gt; (a java.lang.Object)</span><br><span class="line">"blockee-11" waiting for monitor entry</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$2.run(Blocker.java:41)</span><br><span class="line">- waiting to lock &lt;0x00000000eb8eff68&gt; (a java.lang.Object)</span><br><span class="line">"blockee-86" waiting for monitor entry</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$2.run(Blocker.java:41)</span><br><span class="line">- waiting to lock &lt;0x00000000eb8eff68&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><p><strong>持续运行的IO</strong> IO操作是可以以RUNNABLE状态达成阻塞。例如:数据库死锁、网络读写。 格外注意对IO线程的真实状态的分析。 一般来说,被捕捉到RUNNABLE的IO调用,都是有问题的。</p><p>以下堆栈显示： 线程状态为RUNNABLE。 调用栈在SocketInputStream或SocketImpl上,socketRead0等方法。 调用栈包含了jdbc相关的包。很可能发生了数据库死锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"d&amp;a-614" daemon prio=6 tid=0x0000000022f1f000 nid=0x37c8 runnable</span><br><span class="line">[0x0000000027cbd000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">at java.net.SocketInputStream.read(Unknown Source)</span><br><span class="line">at oracle.net.ns.Packet.receive(Packet.java:240)</span><br><span class="line">at oracle.net.ns.DataPacket.receive(DataPacket.java:92)</span><br><span class="line">at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:172)</span><br><span class="line">at oracle.net.ns.NetInputStream.read(NetInputStream.java:117)</span><br><span class="line">at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:1034)</span><br><span class="line">at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:588)</span><br></pre></td></tr></table></figure><p><strong>分线程调度的休眠</strong></p><p>正常的线程池等待</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"d&amp;a-131" in Object.wait()</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingManager.getWorkToDo(WorkingManager.java:322)</span><br><span class="line">- locked &lt;0x0000000313f656f8&gt; (a com.jiuqi.dna.core.impl.WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingThread.run(WorkingThread.java:40)</span><br></pre></td></tr></table></figure><p>可疑的线程等待</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"d&amp;a-121" in Object.wait()</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:485)</span><br><span class="line">at com.jiuqi.dna.core.impl.AcquirableAccessor.exclusive()</span><br><span class="line">- locked &lt;0x00000003011678d8&gt; (a com.jiuqi.dna.core.impl.CacheGroup)</span><br><span class="line">at com.jiuqi.dna.core.impl.Transaction.lock()</span><br></pre></td></tr></table></figure><h3 id="入手点总结"><a href="#入手点总结" class="headerlink" title="入手点总结"></a>入手点总结</h3><p><strong>wait on monitor entry：</strong> 被阻塞的,肯定有问题</p><p><strong>runnable</strong> ： 注意IO线程</p><p><strong>in Object.wait()</strong>： 注意非线程池等待</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>想要学习一个命令，先来看看帮助，使用jstack -help查看帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:~$ jstack -help</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure><p><code>-F</code>当’jstack [-l] pid’没有相应的时候强制打印栈信息 <code>-l</code>长列表. 打印关于锁的附加信息,例如属于java.util.concurrent的ownable synchronizers列表. <code>-m</code>打印java和native c/c++框架的所有栈信息. <code>-h</code> | -help打印帮助信息 <code>pid</code> 需要被打印配置信息的java进程id,可以用jps查询.</p><p>首先，我们分析这么一段程序的线程情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hollis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JStackDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//Do Nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是有jps查看进程号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:~$ jps</span><br><span class="line">29788 JStackDemo1</span><br><span class="line">29834 Jps</span><br><span class="line">22385 org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar</span><br></pre></td></tr></table></figure><p>然后使用jstack 查看堆栈信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hollis@hos:~$ jstack 29788</span><br><span class="line">2015-04-17 23:47:31</span><br><span class="line">...此处省略若干内容...</span><br><span class="line">"main" prio=10 tid=0x00007f197800a000 nid=0x7462 runnable [0x00007f197f7e1000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at javaCommand.JStackDemo1.main(JStackDemo1.java:7)</span><br></pre></td></tr></table></figure><p>我们可以从这段堆栈信息中看出什么来呢？我们可以看到，当前一共有一条用户级别线程,线程处于runnable状态，执行到JStackDemo1.java的第七行。 看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hollis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JStackDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程堆栈信息如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"Reference Handler" daemon prio=10 tid=0x00007fbbcc06e000 nid=0x286c in Object.wait() [0x00007fbbc8dfc000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;0x0000000783e066e0&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">    at java.lang.Object.wait(Object.java:503)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)</span><br><span class="line">    - locked &lt;0x0000000783e066e0&gt; (a java.lang.ref.Reference$Lock)</span><br></pre></td></tr></table></figure><p>我们能看到：</p><blockquote><p>线程的状态： WAITING 线程的调用栈 线程的当前锁住的资源： <0x0000000783e066e0> 线程当前等待的资源：<0x0000000783e066e0></0x0000000783e066e0></0x0000000783e066e0></p></blockquote><p>为什么同时锁住的等待同一个资源：</p><blockquote><p>线程的执行中，先获得了这个对象的 Monitor（对应于 locked <0x0000000783e066e0>）。当执行到 obj.wait(), 线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on <0x0000000783e066e0> ）。</0x0000000783e066e0></0x0000000783e066e0></p></blockquote><h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h3><p>学会了怎么使用jstack命令之后，我们就可以看看，如何使用jstack分析死锁了，这也是我们一定要掌握的内容。 <strong>啥叫死锁？</strong> 所谓<a href="http://zh.wikipedia.org/wiki/死锁" target="_blank" rel="noopener">死锁</a>： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 说白了，我现在想吃鸡蛋灌饼，桌子上放着鸡蛋和饼，但是我和我的朋友同时分别拿起了鸡蛋和病，我手里拿着鸡蛋，但是我需要他手里的饼。他手里拿着饼，但是他想要我手里的鸡蛋。就这样，如果不能同时拿到鸡蛋和饼，那我们就不能继续做后面的工作（做鸡蛋灌饼）。所以，这就造成了死锁。 <strong>看一段死锁的程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javaCommand;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hollis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JStackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLockclass(<span class="keyword">true</span>));<span class="comment">//建立一个线程</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DeadLockclass(<span class="keyword">false</span>));<span class="comment">//建立另一个线程</span></span><br><span class="line">        t1.start();<span class="comment">//启动一个线程</span></span><br><span class="line">        t2.start();<span class="comment">//启动另一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockclass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> falg;<span class="comment">// 控制线程</span></span><br><span class="line">    DeadLockclass(<span class="keyword">boolean</span> falg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.falg = falg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果falg的值为true则调用t1线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (falg) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Suo.o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"o1 "</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (Suo.o2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"o2 "</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果falg的值为false则调用t2线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Suo.o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"o2 "</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (Suo.o1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"o1 "</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我启动该程序时，我们看一下控制台：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/QQ20160118-0.png" alt="thread_meitu_1"></p><p>我们发现，程序只输出了两行内容，然后程序就不再打印其它的东西了，但是程序并没有停止。这样就产生了死锁。 当线程1使用<code>synchronized</code>锁住了o1的同时，线程2也是用<code>synchronized</code>锁住了o2。当两个线程都执行完第一个打印任务的时候，线程1想锁住o2，线程2想锁住o1。但是，线程1当前锁着o1，线程2锁着o2。所以两个想成都无法继续执行下去，就造成了死锁。</p><p>然后，我们使用<strong>jstack来看一下线程堆栈信息</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"Thread-1":</span><br><span class="line">  waiting to lock monitor 0x00007f0134003ae8 (object 0x00000007d6aa2c98, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-0"</span><br><span class="line">"Thread-0":</span><br><span class="line">  waiting to lock monitor 0x00007f0134006168 (object 0x00000007d6aa2ca8, a java.lang.Object),</span><br><span class="line">  which is held by "Thread-1"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"Thread-1":</span><br><span class="line">    at javaCommand.DeadLockclass.run(JStackDemo.java:40)</span><br><span class="line">    - waiting to lock &lt;0x00000007d6aa2c98&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x00000007d6aa2ca8&gt; (a java.lang.Object)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">"Thread-0":</span><br><span class="line">    at javaCommand.DeadLockclass.run(JStackDemo.java:27)</span><br><span class="line">    - waiting to lock &lt;0x00000007d6aa2ca8&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x00000007d6aa2c98&gt; (a java.lang.Object)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>哈哈，堆栈写的很明显，它告诉我们 <code>Found one Java-level deadlock</code>，然后指出造成死锁的两个线程的内容。然后，又通过 <code>Java stack information for the threads listed above</code>来显示更详细的死锁的信息。 他说</p><blockquote><p>Thread-1在想要执行第40行的时候，当前锁住了资源<code>&lt;0x00000007d6aa2ca8&gt;</code>,但是他在等待资源<code>&lt;0x00000007d6aa2c98&gt;</code> Thread-0在想要执行第27行的时候，当前锁住了资源<code>&lt;0x00000007d6aa2c98&gt;</code>,但是他在等待资源<code>&lt;0x00000007d6aa2ca8&gt;</code> 由于这两个线程都持有资源，并且都需要对方的资源，所以造成了死锁。 原因我们找到了，就可以具体问题具体分析，解决这个死锁了。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>虚拟机执行Full GC时,会阻塞所有的用户线程。因此,即时获取到同步锁的线程也有可能被阻塞。</strong> 在查看线程Dump时,首先查看内存使用情况。</p><h1 id="Java命令学习系列（三）—-Jmap"><a href="#Java命令学习系列（三）—-Jmap" class="headerlink" title="Java命令学习系列（三）— Jmap"></a>Java命令学习系列（三）— Jmap</h1><blockquote><p>jmap是JDK自带的工具软件，主要用于打印指定Java进程(或核心文件、远程调试服务器)的共享对象内存映射或堆内存细节。可以使用jmap生成Heap Dump。在<code>Java命令学习系列（零）— 常见命令及Java Dump</code>介绍中分别有关于Java Dump以及线程 Dump的介绍。 <strong>这篇文章主要介绍Java的堆Dump以及jamp命令</strong></p></blockquote><h2 id="什么是堆Dump"><a href="#什么是堆Dump" class="headerlink" title="什么是堆Dump"></a>什么是堆Dump</h2><p>堆Dump是反应Java堆使用情况的内存镜像，其中主要包括<strong>系统信息</strong>、<strong>虚拟机属性</strong>、<strong>完整的线程Dump</strong>、<strong>所有类和对象的状态</strong>等。 一般，在内存不足、GC异常等情况下，我们就会怀疑有<a href="http://zh.wikipedia.org/zh-cn/内存泄漏" target="_blank" rel="noopener">内存泄露</a>。这个时候我们就可以制作堆Dump来查看具体情况。分析原因。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>《Java虚拟机的内存组成以及堆内存介绍》《Java GC工作原理》常见内存错误：</p><blockquote><p>outOfMemoryError <strong>年老代内存不足。</strong><br>outOfMemoryError:PermGen Space <strong>永久代内存不足。</strong><br>outOfMemoryError:GC overhead limit exceed <strong>垃圾回收时间占用系统运行时间的98%或以上。</strong></p></blockquote><h2 id="jmap-1"><a href="#jmap-1" class="headerlink" title="jmap"></a>jmap</h2><p><strong>用法摘要</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the "live"</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -permstat            to print permanent generation statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The "live" suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><blockquote><p><strong>指定进程号(pid)的进程</strong> jmap [ option ] <strong>指定核心文件</strong> jmap [ option ] <strong>指定远程调试服务器</strong> jmap [ option ] [server-id@]</p></blockquote><hr><blockquote><p><strong>参数：</strong></p><blockquote><p><strong>option</strong> 选项参数是互斥的(不可同时使用)。想要使用选项参数，直接跟在命令名称后即可。<br><strong>pid</strong> 需要打印配置信息的进程ID。该进程必须是一个Java进程。想要获取运行的Java进程列表，你可以使用jps。<br><strong>executable</strong> 产生核心dump的Java可执行文件。<br><strong>core</strong> 需要打印配置信息的核心文件。<br><strong>remote-hostname-or-IP</strong> 远程调试服务器的(请查看jsadebugd)主机名或IP地址。<br><strong>server-id</strong> 可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。</p></blockquote><p><strong>选项:</strong></p><blockquote><p><code>&lt;no option&gt;</code> 如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。这与Solaris的pmap工具比较相似。<br><code>-dump:[live,]format=b,file=&lt;filename&gt;</code> 以hprof二进制格式转储Java堆到指定<code>filename</code>的文件中。live子选项是可选的。如果指定了live子选项，堆中只有活动的对象会被转储。想要浏览heap dump，你可以使用jhat(Java堆分析工具)读取生成的文件。<br><code>-finalizerinfo</code> 打印等待终结的对象信息。<br><code>-heap</code> 打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和generation wise heap usage。<br><code>-histo[:live]</code> 打印堆的柱状图。其中包括每个Java类、对象数量、内存大小(单位：字节)、完全限定的类名。打印的虚拟机内部的类名称将会带有一个’*’前缀。如果指定了live子选项，则只计算活动的对象。<br><code>-permstat</code> 打印Java堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。<br><code>-F</code> 强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项。<br><code>-h</code> 打印帮助信息。<br><code>-help</code> 打印帮助信息。<br><code>-J&lt;flag&gt;</code> 指定传递给运行jmap的JVM的参数。</p></blockquote></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><strong>查看java 堆（heap）使用情况,</strong>执行命令： <code>hollis@hos:~/workspace/design_apaas/apaasweb/control/bin$ jmap -heap 31846</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 31846, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)//GC 方式</span><br><span class="line"></span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">   MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">   MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">   SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage://堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space://Eden区内存分布</span><br><span class="line">   capacity = 33030144 (31.5MB)//Eden区总容量</span><br><span class="line">   used     = 1524040 (1.4534378051757812MB)  //Eden区已使用</span><br><span class="line">   free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量</span><br><span class="line">   4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line">   capacity = 86507520 (82.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 86507520 (82.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">   free     = 19523568 (18.619125366210938MB)</span><br><span class="line">   11.337498256138392% used</span><br><span class="line"></span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><hr><p><strong>查看堆内存(histogram)中的对象数量及大小</strong>。执行命令： <code>hollis@hos:~/workspace/design_apaas/apaasweb/control/bin$ jmap -histo 3331</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line">编号     个数                字节     类名</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:             7        1322080  [I</span><br><span class="line">   2:          5603         722368  &lt;methodKlass&gt;</span><br><span class="line">   3:          5603         641944  &lt;constMethodKlass&gt;</span><br><span class="line">   4:         34022         544352  java.lang.Integer</span><br><span class="line">   5:           371         437208  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:           336         270624  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   7:           371         253816  &lt;instanceKlassKlass&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>jmap -histo:live 这个命令执行，JVM会先触发gc，然后再统计信息。</strong></p></blockquote><p><strong>将内存使用的详细情况输出到文件</strong>，执行命令： <code>hollis@hos:~/workspace/design_apaas/apaasweb/control/bin$ jmap -dump:format=b,file=heapDump 6900</code></p><p>然后用<code>jhat</code>命令可以参看 <code>jhat -port 5000 heapDump</code> 在浏览器中访问：<code>http://localhost:5000/</code> 查看详细信息</p><blockquote><p><strong>这个命令执行，JVM会将整个heap的信息dump写入到一个文件，heap如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用。</strong></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>如果程序内存不足或者频繁GC，很有可能存在内存泄露情况，这时候就要借助Java堆Dump查看对象的情况。</li><li>要制作堆Dump可以直接使用jvm自带的jmap命令</li><li>可以先使用<code>jmap -heap</code>命令查看堆的使用情况，看一下各个堆空间的占用情况。</li><li>使用<code>jmap -histo:[live]</code>查看堆内存中的对象的情况。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露，就要结合代码，把不用的对象释放掉。</li><li>也可以使用 <code>jmap -dump:format=b,file=&lt;fileName&gt;</code>命令将堆信息保存到一个文件中，再借助jhat命令查看详细内容</li><li>在内存出现泄露、溢出或者其它前提条件下，建议多dump几次内存，把内存文件进行编号归档，便于后续内存整理分析。</li></ol><p><strong>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can’t attach to the process</strong></p><p>在ubuntu中第一次使用jmap会报错：<code>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can&#39;t attach to the process</code>，这是oracla文档中提到的一个bug:<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,解决方式如下：" target="_blank" rel="noopener">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,解决方式如下：</a></p><blockquote><ol><li>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 该方法在下次重启前有效。</li><li>永久有效方法 sudo vi /etc/sysctl.d/10-ptrace.conf 编辑下面这行: kernel.yama.ptrace_scope = 1 修改为: kernel.yama.ptrace_scope = 0 重启系统，使修改生效。</li></ol></blockquote><h1 id="Java命令学习系列（四）—-jstat"><a href="#Java命令学习系列（四）—-jstat" class="headerlink" title="Java命令学习系列（四）— jstat"></a>Java命令学习系列（四）— jstat</h1><blockquote><p>jstat(JVM Statistics Monitoring Tool)是用于监控虚拟机各种运行状态信息的命令行工具。他可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形的服务器上，它是运行期定位虚拟机性能问题的首选工具。</p></blockquote><p>jstat位于java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具，非常适用。</p><h2 id="jstat-命令格式"><a href="#jstat-命令格式" class="headerlink" title="jstat 命令格式"></a>jstat 命令格式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure><h2 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h2><p>Option — 选项，我们一般使用 -gcutil 查看gc情况</p><p>vmid — VM的进程号，即当前运行的java进程号</p><p>interval– 间隔时间，单位为秒或者毫秒</p><p>count — 打印次数，如果缺省则打印无数次</p><p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程5828垃圾收集状况，一共查询5次，那命令行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 5828 250 5</span><br></pre></td></tr></table></figure><blockquote><p>对于命令格式中的<code>VMID</code>与<code>LVMID</code>需要特别说明下：如果是本地虚拟机进程，<code>VMID</code>(Virtual Machine IDentifier,虚机标识符)和<code>LVMID</code>(Local Virtual Machine IDentifier,虚机标识符)是一致的，如果是远程虚拟机进程，那VMID的格式应当是：<code>[protocol:][//] lvmid [@hostname[:port]/servername]</code></p></blockquote><h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><p>选项option代表这用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用如下：</p><blockquote><p>–<code>class</code> 监视类装载、卸载数量、总空间及类装载所耗费的时间 –<code>gc</code> 监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量 –<code>gccapacity</code> 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最小空间 –<code>gcutil</code> 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 –<code>gccause</code> 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因 –<code>gcnew</code> 监视新生代GC的状况 –<code>gcnewcapacity</code> 监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间 –<code>gcold</code> 监视老年代GC的状况 –<code>gcoldcapacity</code> 监视内容与——gcold基本相同，输出主要关注使用到的最大和最小空间 –<code>gcpermcapacity</code> 输出永久代使用到的最大和最小空间 –<code>compiler</code> 输出JIT编译器编译过的方法、耗时等信息 –<code>printcompilation</code> 输出已经被JIT编译的方法</p></blockquote><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><h3 id="1、jstat-–class-lt-pid-gt-显示加载class的数量，及所占空间等信息。"><a href="#1、jstat-–class-lt-pid-gt-显示加载class的数量，及所占空间等信息。" class="headerlink" title="1、jstat –class&lt;pid&gt; : 显示加载class的数量，及所占空间等信息。"></a>1、<code>jstat –class&lt;pid&gt; :</code> 显示加载class的数量，及所占空间等信息。</h3><blockquote><p><code>Loaded</code> 装载的类的数量 <code>Bytes</code> 装载类所占用的字节数 <code>Unloaded</code> 卸载类的数量 <code>Bytes</code> 卸载类的字节数 <code>Time</code> 装载和卸载类所花费的时间</p></blockquote><h3 id="2、jstat-compiler-lt-pid-gt-显示VM实时编译的数量等信息。"><a href="#2、jstat-compiler-lt-pid-gt-显示VM实时编译的数量等信息。" class="headerlink" title="2、jstat -compiler &lt;pid&gt;显示VM实时编译的数量等信息。"></a>2、<code>jstat -compiler &lt;pid&gt;</code>显示VM实时编译的数量等信息。</h3><blockquote><p><code>Compiled</code> 编译任务执行数量 <code>Failed</code> 编译任务执行失败数量 <code>Invalid</code> 编译任务执行失效数量 <code>Time</code> 编译任务消耗时间 <code>FailedType</code> 最后一个编译失败任务的类型 <code>FailedMethod</code> 最后一个编译失败任务所在的类及方法</p></blockquote><h3 id="3、jstat-gc-lt-pid-gt-可以显示gc的信息，查看gc的次数，及时间。"><a href="#3、jstat-gc-lt-pid-gt-可以显示gc的信息，查看gc的次数，及时间。" class="headerlink" title="3、jstat -gc &lt;pid&gt;: 可以显示gc的信息，查看gc的次数，及时间。"></a>3、<code>jstat -gc &lt;pid&gt;</code>: 可以显示gc的信息，查看gc的次数，及时间。</h3><blockquote><p><code>S0C</code> 年轻代中第一个survivor（幸存区）的容量 (字节) <code>S1C</code> 年轻代中第二个survivor（幸存区）的容量 (字节) <code>S0U</code> 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) <code>S1U</code> 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) <code>EC</code> 年轻代中Eden（伊甸园）的容量 (字节) <code>EU</code> 年轻代中Eden（伊甸园）目前已使用空间 (字节) <code>OC</code> Old代的容量 (字节) <code>OU</code> Old代目前已使用空间 (字节) <code>PC</code> Perm(持久代)的容量 (字节) <code>PU</code> Perm(持久代)目前已使用空间 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>YGCT</code> 从应用程序启动到采样时年轻代中gc所用时间(s) <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数 <code>FGCT</code> 从应用程序启动到采样时old代(全gc)gc所用时间(s) <code>GCT</code> 从应用程序启动到采样时gc用的总时间(s)</p></blockquote><h3 id="4、jstat-gccapacity-lt-pid-gt-可以显示，VM内存中三代（young-old-perm）对象的使用和占用大小"><a href="#4、jstat-gccapacity-lt-pid-gt-可以显示，VM内存中三代（young-old-perm）对象的使用和占用大小" class="headerlink" title="4、jstat -gccapacity &lt;pid&gt;:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小"></a>4、<code>jstat -gccapacity &lt;pid&gt;:</code>可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小</h3><blockquote><p><code>NGCMN</code> 年轻代(young)中初始化(最小)的大小(字节) <code>NGCMX</code> 年轻代(young)的最大容量 (字节) <code>NGC</code> 年轻代(young)中当前的容量 (字节) <code>S0C</code> 年轻代中第一个survivor（幸存区）的容量 (字节) <code>S1C</code> 年轻代中第二个survivor（幸存区）的容量 (字节) <code>EC</code> 年轻代中Eden（伊甸园）的容量 (字节) <code>OGCMN</code> old代中初始化(最小)的大小 (字节) <code>OGCMX</code> old代的最大容量(字节) <code>OGC</code> old代当前新生成的容量 (字节) <code>OC</code> Old代的容量 (字节) <code>PGCMN</code> perm代中初始化(最小)的大小 (字节) <code>PGCMX</code> perm代的最大容量 (字节)<br><code>PGC</code> perm代当前新生成的容量 (字节) <code>PC</code> Perm(持久代)的容量 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数</p></blockquote><h3 id="5、jstat-gcutil-lt-pid-gt-统计gc信息"><a href="#5、jstat-gcutil-lt-pid-gt-统计gc信息" class="headerlink" title="5、jstat -gcutil &lt;pid&gt;:统计gc信息"></a>5、<code>jstat -gcutil &lt;pid&gt;</code>:统计gc信息</h3><blockquote><p><code>S0</code> 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 <code>S1</code> 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 <code>E</code> 年轻代中Eden（伊甸园）已使用的占当前容量百分比 <code>O</code> old代已使用的占当前容量百分比 <code>P</code> perm代已使用的占当前容量百分比 <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>YGCT</code> 从应用程序启动到采样时年轻代中gc所用时间(s) <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数 <code>FGCT</code> 从应用程序启动到采样时old代(全gc)gc所用时间(s) <code>GCT</code> 从应用程序启动到采样时gc用的总时间(s)</p></blockquote><h3 id="6、jstat-gcnew-lt-pid-gt-年轻代对象的信息。"><a href="#6、jstat-gcnew-lt-pid-gt-年轻代对象的信息。" class="headerlink" title="6、jstat -gcnew &lt;pid&gt;:年轻代对象的信息。"></a>6、<code>jstat -gcnew &lt;pid&gt;</code>:年轻代对象的信息。</h3><blockquote><p><code>S0C</code> 年轻代中第一个survivor（幸存区）的容量 (字节) <code>S1C</code> 年轻代中第二个survivor（幸存区）的容量 (字节) <code>S0U</code> 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) <code>S1U</code> 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) <code>TT</code> 持有次数限制 <code>MTT</code> 最大持有次数限制 <code>EC</code> 年轻代中Eden（伊甸园）的容量 (字节) <code>EU</code> 年轻代中Eden（伊甸园）目前已使用空间 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>YGCT</code> 从应用程序启动到采样时年轻代中gc所用时间(s)</p></blockquote><h3 id="7、jstat-gcnewcapacity-lt-pid-gt-年轻代对象的信息及其占用量。"><a href="#7、jstat-gcnewcapacity-lt-pid-gt-年轻代对象的信息及其占用量。" class="headerlink" title="7、jstat -gcnewcapacity&lt;pid&gt;: 年轻代对象的信息及其占用量。"></a>7、<code>jstat -gcnewcapacity&lt;pid&gt;</code>: 年轻代对象的信息及其占用量。</h3><blockquote><p><code>NGCMN</code> 年轻代(young)中初始化(最小)的大小(字节) <code>NGCMX</code> 年轻代(young)的最大容量 (字节) <code>NGC</code> 年轻代(young)中当前的容量 (字节) <code>S0CMX</code> 年轻代中第一个survivor（幸存区）的最大容量 (字节) <code>S0C</code> 年轻代中第一个survivor（幸存区）的容量 (字节) <code>S1CMX</code> 年轻代中第二个survivor（幸存区）的最大容量 (字节) <code>S1C</code> 年轻代中第二个survivor（幸存区）的容量 (字节) <code>ECMX</code> 年轻代中Eden（伊甸园）的最大容量 (字节) <code>EC</code> 年轻代中Eden（伊甸园）的容量 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数</p></blockquote><h3 id="8、jstat-gcold-lt-pid-gt-：old代对象的信息。"><a href="#8、jstat-gcold-lt-pid-gt-：old代对象的信息。" class="headerlink" title="8、jstat -gcold &lt;pid&gt;：old代对象的信息。"></a>8、<code>jstat -gcold &lt;pid&gt;：</code>old代对象的信息。</h3><blockquote><p><code>PC</code> Perm(持久代)的容量 (字节) <code>PU</code> Perm(持久代)目前已使用空间 (字节) <code>OC</code> Old代的容量 (字节) <code>OU</code> Old代目前已使用空间 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数 <code>FGCT</code> 从应用程序启动到采样时old代(全gc)gc所用时间(s) <code>GCT</code> 从应用程序启动到采样时gc用的总时间(s)</p></blockquote><h3 id="9、stat-gcoldcapacity-lt-pid-gt-old代对象的信息及其占用量。"><a href="#9、stat-gcoldcapacity-lt-pid-gt-old代对象的信息及其占用量。" class="headerlink" title="9、stat -gcoldcapacity &lt;pid&gt;: old代对象的信息及其占用量。"></a>9、<code>stat -gcoldcapacity &lt;pid&gt;</code>: old代对象的信息及其占用量。</h3><blockquote><p><code>OGCMN</code> old代中初始化(最小)的大小 (字节) <code>OGCMX</code> old代的最大容量(字节) <code>OGC</code> old代当前新生成的容量 (字节) <code>OC</code> Old代的容量 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数 <code>FGCT</code> 从应用程序启动到采样时old代(全gc)gc所用时间(s) <code>GCT</code> 从应用程序启动到采样时gc用的总时间(s)</p></blockquote><h3 id="10、jstat-gcpermcapacity-lt-pid-gt-perm对象的信息及其占用量。"><a href="#10、jstat-gcpermcapacity-lt-pid-gt-perm对象的信息及其占用量。" class="headerlink" title="10、jstat -gcpermcapacity&lt;pid&gt;: perm对象的信息及其占用量。"></a>10、<code>jstat -gcpermcapacity&lt;pid&gt;</code>: perm对象的信息及其占用量。</h3><blockquote><p><code>PGCMN</code> perm代中初始化(最小)的大小 (字节) <code>PGCMX</code> perm代的最大容量 (字节)<br><code>PGC</code> perm代当前新生成的容量 (字节) <code>PC</code> Perm(持久代)的容量 (字节) <code>YGC</code> 从应用程序启动到采样时年轻代中gc次数 <code>FGC</code> 从应用程序启动到采样时old代(全gc)gc次数 <code>FGCT</code> 从应用程序启动到采样时old代(全gc)gc所用时间(s) <code>GCT</code> 从应用程序启动到采样时gc用的总时间(s)</p></blockquote><h3 id="11、jstat-printcompilation-lt-pid-gt-：当前VM执行的信息。"><a href="#11、jstat-printcompilation-lt-pid-gt-：当前VM执行的信息。" class="headerlink" title="11、jstat -printcompilation &lt;pid&gt;：当前VM执行的信息。"></a>11、<code>jstat -printcompilation &lt;pid&gt;</code>：当前VM执行的信息。</h3><blockquote><p><code>Compiled</code> 编译任务的数目 <code>Size</code> 方法生成的字节码的大小 <code>Type</code> 编译类型 <code>Method</code> 类名和方法名用来标识编译的方法。类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的</p></blockquote><h1 id="Java命令学习系列（五）—-jhat"><a href="#Java命令学习系列（五）—-jhat" class="headerlink" title="Java命令学习系列（五）— jhat"></a>Java命令学习系列（五）— jhat</h1><blockquote><p>jhat(Java Heap Analysis Tool),是一个用来分析java的堆情况的命令。之前的文章讲到过，使用jmap可以生成Java堆的Dump文件。生成dump文件之后就可以用jhat命令，将dump文件转成html的形式，然后通过http访问可以查看堆情况。</p></blockquote><p>jhat命令解析会Java堆dump并启动一个web服务器，然后就可以在浏览器中查看堆的dump文件了。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="导出dump文件"><a href="#导出dump文件" class="headerlink" title="导出dump文件"></a>导出dump文件</h3><p>关于dump文件的生成可以看<code>jmap</code>命令的详细介绍.</p><p><strong>1、运行java程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hollis on 16/1/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JhatTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String string = <span class="keyword">new</span> String(<span class="string">"hollis"</span>);</span><br><span class="line">            System.out.println(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、查看该进程的ID</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HollisMacBook-Air:apaas hollis$ jps -l</span><br><span class="line">68680 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">62247 com.intellij.rt.execution.application.AppMain</span><br><span class="line">69038 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>使用<code>jps</code>命令查看发现有三个java进程在运行，一个是我的IDEA使用的进程68680，一个是JPS命令使用的进程69038，另外一个就是上面那段代码运行的进程62247。</p><p><strong>3、生成dump文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HollisMacBook-Air:test hollis$ jmap -dump:format=b,file=heapDump 62247</span><br><span class="line">Dumping heap to /Users/hollis/workspace/test/heapDump ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>以上命令可以将进程6900的堆dump文件导出到heapDump文件中。<br>查看当前目录就能看到heapDump文件。</p><p>除了使用jmap命令，还可以通过以下方式：</p><blockquote><p>1、使用 jconsole 选项通过 HotSpotDiagnosticMXBean 从运行时获得堆转储（生成dump文件）、</p><p>2、虚拟机启动时如果指定了 -XX:+HeapDumpOnOutOfMemoryError 选项, 则在抛出 OutOfMemoryError 时, 会自动执行堆转储。</p><p>3、使用 hprof 命令</p></blockquote><h3 id="解析Java堆转储文件-并启动一个-web-server"><a href="#解析Java堆转储文件-并启动一个-web-server" class="headerlink" title="解析Java堆转储文件,并启动一个 web server"></a>解析Java堆转储文件,并启动一个 web server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HollisMacBook-Air:apaas hollis$ jhat heapDump</span><br><span class="line">Reading from heapDump...</span><br><span class="line">Dump file created Thu Jan 21 18:59:51 CST 2016</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 341297 objects...</span><br><span class="line">Chasing references, expect 68 dots....................................................................</span><br><span class="line">Eliminating duplicate references....................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>使用jhat命令，就启动了一个http服务，端口是7000</p><p>然后在访问<a href="http://localhost:7000/" target="_blank" rel="noopener">http://localhost:7000/</a></p><p>页面如下：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/QQ20160121-1.png" alt="QQ20160121-1"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在浏览器里面看到dump文件之后就可以进行分析了。这个页面会列出当前进程中的所有对像情况。</p><p>该页面提供了几个查询功能可供使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">All classes including platform//</span><br><span class="line">Show all members of the rootset</span><br><span class="line">Show instance counts for all classes (including platform)</span><br><span class="line">Show instance counts for all classes (excluding platform)</span><br><span class="line">Show heap histogram</span><br><span class="line">Show finalizer summary</span><br><span class="line">Execute Object Query Language (OQL) query</span><br></pre></td></tr></table></figure><p>一般查看堆异常情况主要看这个两个部分：</p><p><strong>Show instance counts for all classes (excluding platform)</strong>，平台外的所有对象信息。如下图：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/QQ20160121-3-1024x234.png" alt="QQ20160121-3"></p><p><strong>Show heap histogram</strong> 以树状图形式展示堆情况。如下图：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/QQ20160121-2.png" alt="QQ20160121-2"></p><p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。</p><h2 id="用法摘要"><a href="#用法摘要" class="headerlink" title="用法摘要"></a>用法摘要</h2><p>这一部分放在后面介绍的原因是一般不太使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">HollisMacBook-Air:~ hollis$ jhat -help</span><br><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">    -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">              example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">    -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">    -refs false:      Turn off tracking of references to objects</span><br><span class="line">    -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">    -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">              be excluded from the reachableFrom query.</span><br><span class="line">    -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">              both heap dumps with the same ID and same class will</span><br><span class="line">              be marked as not being "new".</span><br><span class="line">    -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                0:  No debug output</span><br><span class="line">                1:  Debug hprof file parsing</span><br><span class="line">                2:  Debug hprof file parsing, no server</span><br><span class="line">    -version          Report version number</span><br><span class="line">    -h|-help          Print this help and exit</span><br><span class="line">    &lt;file&gt;            The file to read</span><br></pre></td></tr></table></figure><blockquote><p>-stack false|true</p><p>关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.</p><p>-refs false|true</p><p>关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。</p><p><strong>-port port-number</strong></p><p>设置 jhat HTTP server 的端口号. 默认值 7000.</p><p>-exclude exclude-file</p><p>指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。</p><p>-baseline exclude-file</p><p>指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.</p><p>-debug int</p><p>设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.</p><p>-version</p><p>启动后只显示版本信息就退出</p><p>-J&lt; flag &gt;</p><p>因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</p></blockquote><h2 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h2><p>jhat还提供了一种对象查询语言(Object Query Language)，OQL有点类似SQL,可以用来查询。</p><p>OQL语句的执行页面: <a href="http://localhost:7000/oql/" target="_blank" rel="noopener">http://localhost:7000/oql/</a></p><p>OQL帮助信息页面为: <a href="http://localhost:7000/oqlhelp/" target="_blank" rel="noopener">http://localhost:7000/oqlhelp/</a></p><p>OQL的预发可以在帮助页面查看，这里就不详细讲解了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">jhat</a></p><h1 id="Java命令学习系列（六）—-jinfo"><a href="#Java命令学习系列（六）—-jinfo" class="headerlink" title="Java命令学习系列（六）— jinfo"></a>Java命令学习系列（六）— jinfo</h1><p>jinfo可以输出java进程、core文件或远程debug服务器的配置信息。这些配置信息包括JAVA系统参数及命令行参数,如果进程运行在64位虚拟机上，需要指明<code>-J-d64</code>参数，如：<code>jinfo -J-d64 -sysprops pid</code></p><p>另外，Java7的官方文档指出，这一命令在后续的版本中可能不再使用。笔者使用的版本(jdk8)中已经不支持该命令(笔者翻阅了<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html" target="_blank" rel="noopener">java8中该命令的文档</a>，其中已经明确说明不再支持)。提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HollisMacBook-Air:test-workspace hollis$ jinfo 92520</span><br><span class="line">Attaching to process ID 92520, please wait...</span><br><span class="line">^@</span><br><span class="line"></span><br><span class="line">Exception in thread "main" java.lang.reflect.InvocationTargetException</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)</span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:606)</span><br><span class="line">    at sun.tools.jinfo.JInfo.runTool(JInfo.java:97)</span><br><span class="line">    at sun.tools.jinfo.JInfo.main(JInfo.java:71)</span><br><span class="line">Caused by: sun.jvm.hotspot.runtime.VMVersionMismatchException: Supported versions are 24.79-b02. Target VM is 25.40-b25</span><br><span class="line">    at sun.jvm.hotspot.runtime.VM.checkVMVersion(VM.java:234)</span><br><span class="line">    at sun.jvm.hotspot.runtime.VM.&lt;init&gt;(VM.java:297)</span><br><span class="line">    at sun.jvm.hotspot.runtime.VM.initialize(VM.java:368)</span><br><span class="line">    at sun.jvm.hotspot.bugspot.BugSpotAgent.setupVM(BugSpotAgent.java:598)</span><br><span class="line">    at sun.jvm.hotspot.bugspot.BugSpotAgent.go(BugSpotAgent.java:493)</span><br><span class="line">    at sun.jvm.hotspot.bugspot.BugSpotAgent.attach(BugSpotAgent.java:331)</span><br><span class="line">    at sun.jvm.hotspot.tools.Tool.start(Tool.java:163)</span><br><span class="line">    at sun.jvm.hotspot.tools.JInfo.main(JInfo.java:128)</span><br><span class="line">    ... 6 more</span><br></pre></td></tr></table></figure><p>由于打印jvm常用信息可以使用<code>jps</code>命令，并且在后续的java版本中可能不再支持，所以这个命令笔者就不详细介绍了。下面给出help信息，读者可自行阅读使用。（这就好像上高中，老师讲到一些难点的时候说，不明白也不要紧，知道有这么一回事就可以了！）</p><h2 id="用法摘要-1"><a href="#用法摘要-1" class="headerlink" title="用法摘要"></a>用法摘要</h2><p>以键值对的形式打印出JAVA系统参数及命令行参数的名称和内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-flag name</span><br><span class="line">prints the name and value of the given command line flag.</span><br><span class="line">-flag [+|-]name</span><br><span class="line">enables or disables the given boolean command line flag.</span><br><span class="line">-flag name=value</span><br><span class="line">sets the given command line flag to the specified value.</span><br><span class="line">-flags</span><br><span class="line">prints command line flags passed to the JVM. pairs.</span><br><span class="line">-sysprops</span><br><span class="line">prints Java System properties as name, value pairs.</span><br><span class="line">-h</span><br><span class="line">prints a help message</span><br><span class="line">-help</span><br><span class="line">prints a help message</span><br></pre></td></tr></table></figure><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html" target="_blank" rel="noopener">jinfo</a></p><h1 id="Java命令学习系列（七）—-javap"><a href="#Java命令学习系列（七）—-javap" class="headerlink" title="Java命令学习系列（七）— javap"></a>Java命令学习系列（七）— javap</h1><blockquote><p>javap是jdk自带的一个工具，可以对代码<code>反编译</code>，也可以查看java编译器生成的字节码。</p></blockquote><p>一般情况下，很少有人使用javap对class文件进行反编译，因为有很多成熟的反编译工具可以使用，比如jad。但是，javap还可以查看java编译器为我们生成的字节码。通过它，可以对照源代码和字节码，从而了解很多编译器内部的工作。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>javap命令分解一个class文件，它根据options来决定到底输出什么。如果没有使用options,那么javap将会输出包，类里的protected和public域以及类里的所有方法。<code>javap</code>将会把它们输出在标准输出上。来看这个例子，先编译(<code>javac</code>)下面这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.applet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocFooter</span> <span class="keyword">extends</span> <span class="title">Applet</span> </span>&#123;</span><br><span class="line">        String date;</span><br><span class="line">        String email;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                resize(<span class="number">500</span>,<span class="number">100</span>);</span><br><span class="line">                date = getParameter(<span class="string">"LAST_UPDATED"</span>);</span><br><span class="line">                email = getParameter(<span class="string">"EMAIL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">                g.drawString(date + <span class="string">" by "</span>,<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line">                g.drawString(email,<span class="number">290</span>,<span class="number">15</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行上键入javap DocFooter后，输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Compiled from "DocFooter.java"</span><br><span class="line">public class DocFooter extends java.applet.Applet &#123;</span><br><span class="line">  java.lang.String date;</span><br><span class="line">  java.lang.String email;</span><br><span class="line">  public DocFooter();</span><br><span class="line">  public void init();</span><br><span class="line">  public void paint(java.awt.Graphics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果加入了-c，即javap -c DocFooter，那么输出结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Compiled from "DocFooter.java"</span><br><span class="line">public class DocFooter extends java.applet.Applet &#123;</span><br><span class="line">  java.lang.String date;</span><br><span class="line"></span><br><span class="line">  java.lang.String email;</span><br><span class="line"></span><br><span class="line">  public DocFooter();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/applet/Applet."&lt;init&gt;":()V</span><br><span class="line">       4: return        </span><br><span class="line"></span><br><span class="line">  public void init();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: sipush        500</span><br><span class="line">       4: bipush        100</span><br><span class="line">       6: invokevirtual #2                  // Method resize:(II)V</span><br><span class="line">       9: aload_0       </span><br><span class="line">      10: aload_0       </span><br><span class="line">      11: ldc           #3                  // String LAST_UPDATED</span><br><span class="line">      13: invokevirtual #4                  // Method getParameter:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      16: putfield      #5                  // Field date:Ljava/lang/String;</span><br><span class="line">      19: aload_0       </span><br><span class="line">      20: aload_0       </span><br><span class="line">      21: ldc           #6                  // String EMAIL</span><br><span class="line">      23: invokevirtual #4                  // Method getParameter:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      26: putfield      #7                  // Field email:Ljava/lang/String;</span><br><span class="line">      29: return        </span><br><span class="line"></span><br><span class="line">  public void paint(java.awt.Graphics);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_1       </span><br><span class="line">       1: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">       4: dup           </span><br><span class="line">       5: invokespecial #9                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">       8: aload_0       </span><br><span class="line">       9: getfield      #5                  // Field date:Ljava/lang/String;</span><br><span class="line">      12: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      15: ldc           #11                 // String  by </span><br><span class="line">      17: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: invokevirtual #12                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      23: bipush        100</span><br><span class="line">      25: bipush        15</span><br><span class="line">      27: invokevirtual #13                 // Method java/awt/Graphics.drawString:(Ljava/lang/String;II)V</span><br><span class="line">      30: aload_1       </span><br><span class="line">      31: aload_0       </span><br><span class="line">      32: getfield      #7                  // Field email:Ljava/lang/String;</span><br><span class="line">      35: sipush        290</span><br><span class="line">      38: bipush        15</span><br><span class="line">      40: invokevirtual #13                 // Method java/awt/Graphics.drawString:(Ljava/lang/String;II)V</span><br><span class="line">      43: return        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面输出的内容就是字节码。</p><h2 id="用法摘要-2"><a href="#用法摘要-2" class="headerlink" title="用法摘要"></a>用法摘要</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-help 帮助</span><br><span class="line">-l 输出行和变量的表</span><br><span class="line">-public 只输出public方法和域</span><br><span class="line">-protected 只输出public和protected类和成员</span><br><span class="line">-package 只输出包，public和protected类和成员，这是默认的</span><br><span class="line">-p -private 输出所有类和成员</span><br><span class="line">-s 输出内部类型签名</span><br><span class="line">-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，</span><br><span class="line">-verbose 输出栈大小，方法参数的个数</span><br><span class="line">-constants 输出静态final常量</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>javap可以用于反编译和查看编译器编译后的字节码。平时一般用<code>javap -c</code>比较多，该命令用于列出每个方法所执行的JVM指令，并显示每个方法的字节码的实际作用。可以通过字节码和源代码的对比，深入分析java的编译原理，了解和解决各种Java原理级别的问题。</p><h1 id="Java代码的编译与反编译那些事儿"><a href="#Java代码的编译与反编译那些事儿" class="headerlink" title="Java代码的编译与反编译那些事儿"></a>Java代码的编译与反编译那些事儿</h1><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>在介绍编译和反编译之前，我们先来简单介绍下编程语言（Programming Language）。编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。</p><p>机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。</p><p>而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序，语句是计算机指令的抽象表示。</p><p>举个例子，同样一个语句用C语言、汇编语言和机器语言分别表示如下：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/WechatIMG363.jpeg" alt="img"></p><p>计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外，上表中的机器语言完全由十六进制数字组成。最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错，于是有了汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序，然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言。</p><p>但是，汇编语言用起来同样比较复杂，后面，就衍生出了Java、C、C++等高级语言。</p><h2 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h2><p>上面提到语言有两种，一种低级语言，一种高级语言。可以这样简单的理解：低级语言是计算机认识的语言、高级语言是程序员认识的语言。</p><p>那么如何从高级语言转换成低级语言呢？这个过程其实就是编译。</p><p>从上面的例子还可以看出，C语言的语句和低级语言的指令之间不是简单的一一对应关系，一条<code>a=b+1</code>;语句要翻译成三条汇编或机器指令，这个过程称为编译（Compile），由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多。用C语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点。首先，用C语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正。</p><p><strong>将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器</strong></p><p>现在我们知道了什么是编译，也知道了什么是编译器。不同的语言都有自己的编译器，Java语言中负责编译的编译器是一个命令：<code>javac</code></p><blockquote><p>javac是收录于JDK中的Java语言编译器。该工具可以将后缀名为.java的源文件编译为后缀名为.class的可以运行于Java虚拟机的字节码。</p></blockquote><p><strong>当我们写完一个<code>HelloWorld.java</code>文件后，我们可以使用<code>javac HelloWorld.java</code>命令来生成<code>HelloWorld.class</code>文件，这个<code>class</code>类型的文件是JVM可以识别的文件。通常我们认为这个过程叫做Java语言的编译。其实，<code>class</code>文件仍然不是机器能够识别的语言，因为机器只能识别机器语言，还需要JVM再将这种<code>class</code>文件类型字节码转换成机器可以识别的机器语言。</strong></p><h2 id="什么是反编译"><a href="#什么是反编译" class="headerlink" title="什么是反编译"></a>什么是反编译</h2><p>反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将<code>class</code>文件转换成<code>java</code>文件。</p><p>有了反编译工具，我们可以做很多事情，最主要的功能就是有了反编译工具，我们就能读得懂Java编译器生成的字节码。如果你想问读懂字节码有啥用，那么我可以很负责任的告诉你，好处大大的。比如我的博文几篇典型的原理性文章，都是通过反编译工具得到反编译后的代码分析得到的。如深入理解多线程（一）— Synchronized的实现原理、深度分析Java的枚举类型—-枚举的线程安全性及序列化问题、Java中的Switch对整型、字符型、字符串型的具体实现细节、Java的类型擦除等。我最近在GitChat写了一篇关于Java语法糖的文章，其中大部分内容都用到反编译工具来洞悉语法糖背后的原理。</p><h2 id="Java反编译工具"><a href="#Java反编译工具" class="headerlink" title="Java反编译工具"></a>Java反编译工具</h2><p>本文主要介绍3个Java的反编译工具：<strong>javap</strong>、<strong>jad</strong>和<strong>cfr</strong></p><h3 id="javap"><a href="#javap" class="headerlink" title="javap"></a>javap</h3><p><code>javap</code>是jdk自带的一个工具，可以对代码反编译，也可以查看java编译器生成的字节码。<code>javap</code>和其他两个反编译工具最大的区别是他生成的文件并不是<code>java</code>文件，也不像其他两个工具生成代码那样更容易理解。拿一段简单的代码举例，如我们想分析Java 7中的<code>switch</code>是如何支持<code>String</code>的，我们先有以下可以编译通过的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以下两个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac switchDemoString.java</span><br><span class="line">javap -c switchDemoString.class</span><br></pre></td></tr></table></figure><p>生成代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class com.hollis.suguar.switchDemoString &#123;</span><br><span class="line">  public com.hollis.suguar.switchDemoString();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String world</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: aload_1</span><br><span class="line">       4: astore_2</span><br><span class="line">       5: iconst_m1</span><br><span class="line">       6: istore_3</span><br><span class="line">       7: aload_2</span><br><span class="line">       8: invokevirtual #3                  // Method java/lang/String.hashCode:()I</span><br><span class="line">      11: lookupswitch  &#123; // 2</span><br><span class="line">              99162322: 36</span><br><span class="line">             113318802: 50</span><br><span class="line">               default: 61</span><br><span class="line">          &#125;</span><br><span class="line">      36: aload_2</span><br><span class="line">      37: ldc           #4                  // String hello</span><br><span class="line">      39: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      42: ifeq          61</span><br><span class="line">      45: iconst_0</span><br><span class="line">      46: istore_3</span><br><span class="line">      47: goto          61</span><br><span class="line">      50: aload_2</span><br><span class="line">      51: ldc           #2                  // String world</span><br><span class="line">      53: invokevirtual #5                  // Method java/lang/String.equals:(Ljava/lang/Object;)Z</span><br><span class="line">      56: ifeq          61</span><br><span class="line">      59: iconst_1</span><br><span class="line">      60: istore_3</span><br><span class="line">      61: iload_3</span><br><span class="line">      62: lookupswitch  &#123; // 2</span><br><span class="line">                     0: 88</span><br><span class="line">                     1: 99</span><br><span class="line">               default: 110</span><br><span class="line">          &#125;</span><br><span class="line">      88: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      91: ldc           #4                  // String hello</span><br><span class="line">      93: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      96: goto          110</span><br><span class="line">      99: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     102: ldc           #2                  // String world</span><br><span class="line">     104: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">     107: goto          110</span><br><span class="line">     110: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人的理解，<code>javap</code>并没有将字节码反编译成<code>java</code>文件，而是生成了一种我们可以看得懂字节码。其实javap生成的文件仍然是字节码，只是程序员可以稍微看得懂一些。如果你对字节码有所掌握，还是可以看得懂以上的代码的。其实就是把String转成hashcode，然后进行比较。</p><p>个人认为，一般情况下我们会用到<code>javap</code>命令的时候不多，一般只有在真的需要看字节码的时候才会用到。但是字节码中间暴露的东西是最全的，你肯定有机会用到，比如我在分析<code>synchronized</code>的原理的时候就有是用到<code>javap</code>。通过<code>javap</code>生成的字节码，我发现<code>synchronized</code>底层依赖了<code>ACC_SYNCHRONIZED</code>标记和<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步。</p><h3 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h3><p>jad是一个比较不错的反编译工具，只要下载一个执行工具，就可以实现对<code>class</code>文件的反编译了。还是上面的源代码，使用jad反编译后内容如下：</p><p>命令：<code>jad switchDemoString.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">switchDemoString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，这个代码你肯定看的懂，因为这不就是标准的java的源代码么。这个就很清楚的可以看到原来<strong>字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的</strong>。</p><p>但是，jad已经很久不更新了，在对Java7生成的字节码进行反编译时，偶尔会出现不支持的问题，在对Java 8的lambda表达式反编译时就彻底失败。</p><h3 id="CFR"><a href="#CFR" class="headerlink" title="CFR"></a>CFR</h3><p>jad很好用，但是无奈的是很久没更新了，所以只能用一款新的工具替代他，CFR是一个不错的选择，相比jad来说，他的语法可能会稍微复杂一些，但是好在他可以work。</p><p>如，我们使用cfr对刚刚的代码进行反编译。执行一下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar cfr_0_125.jar switchDemoString.class --decodestringswitch false</span><br></pre></td></tr></table></figure><p>得到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arrstring)</span> </span>&#123;</span><br><span class="line">        String string;</span><br><span class="line">        String string2 = string = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (string2.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string2.equals(<span class="string">"hello"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string2.equals(<span class="string">"world"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码也能得到字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的结论。</p><p>相比Jad来说，CFR有很多参数，还是刚刚的代码，如果我们使用以下命令，输出结果就会不同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar cfr_0_125.jar switchDemoString.class</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arrstring)</span> </span>&#123;</span><br><span class="line">        String string;</span><br><span class="line">        <span class="keyword">switch</span> (string = <span class="string">"world"</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>--decodestringswitch</code>表示对于switch支持string的细节进行解码。类似的还有<code>--decodeenumswitch</code>、<code>--decodefinally</code>、<code>--decodelambdas</code>等。在我的关于语法糖的文章中，我使用<code>--decodelambdas</code>对lambda表达式警进行了反编译。 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">"Hollis"</span>, <span class="string">"公众号：Hollis"</span>, <span class="string">"博客：www.hollischuang.com"</span>);</span><br><span class="line"></span><br><span class="line">    strList.forEach( s -&gt; &#123; System.out.println(s); &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>java -jar cfr_0_125.jar lambdaDemo.class --decodelambdas false</code>反编译后代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/* varargs */</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span> </span>&#123;</span><br><span class="line">    ImmutableList strList = ImmutableList.of((Object)<span class="string">"Hollis"</span>, (Object)<span class="string">"\u516c\u4f17\u53f7\uff1aHollis"</span>, (Object)<span class="string">"\u535a\u5ba2\uff1awww.hollischuang.com"</span>);</span><br><span class="line">    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, (Ljava/lang/Object;)V, lambda$main$<span class="number">0</span>(java.lang.String ), (Ljava/lang/String;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(String s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CFR还有很多其他参数，均用于不同场景，读者可以使用<code>java -jar cfr_0_125.jar --help</code>进行了解。这里不逐一介绍了。</p><h2 id="如何防止反编译"><a href="#如何防止反编译" class="headerlink" title="如何防止反编译"></a>如何防止反编译</h2><p>由于我们有工具可以对<code>Class</code>文件进行反编译，所以，对开发人员来说，如何保护Java程序就变成了一个非常重要的挑战。但是，魔高一尺、道高一丈。当然有对应的技术可以应对反编译咯。但是，这里还是要说明一点，和网络安全的防护一样，无论做出多少努力，其实都只是提高攻击者的成本而已。无法彻底防治。</p><p>典型的应对策略有以下几种：</p><ul><li>隔离Java程序<ul><li>让用户接触不到你的Class文件</li></ul></li><li>对Class文件进行加密<ul><li>提到破解难度</li></ul></li><li>代码混淆<ul><li>将代码转换成功能上等价，但是难于阅读和理解的形式</li></ul></li></ul><h1 id="Java虚拟机的内存组成以及堆内存介绍"><a href="#Java虚拟机的内存组成以及堆内存介绍" class="headerlink" title="Java虚拟机的内存组成以及堆内存介绍"></a>Java虚拟机的内存组成以及堆内存介绍</h1><p>什么是Java虚拟机这里就不介绍了，不明白的可以另外一篇博文：<code>JDK,JRE,JVM区别与联系</code></p><h2 id="java内存组成介绍：堆-Heap-和非堆-Non-heap-内存"><a href="#java内存组成介绍：堆-Heap-和非堆-Non-heap-内存" class="headerlink" title="java内存组成介绍：堆(Heap)和非堆(Non-heap)内存"></a>java内存组成介绍：<code>堆(Heap)</code>和<code>非堆(Non-heap)</code>内存</h2><blockquote><p>按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。可以看出<strong>JVM主要管理两种类型的内存：堆和非堆</strong>。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。</p></blockquote><h2 id="JVM内存区域模型"><a href="#JVM内存区域模型" class="headerlink" title="JVM内存区域模型"></a>JVM内存区域模型</h2><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/2354447461-300x217.jpg" alt="2354447461"></p><p><strong>1.方法区</strong> 也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过<code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 参数限制方法区的大小。</p><p>运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</p><p><strong>2.虚拟机栈</strong></p><p>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。</p><p>局部变量表存放了编译器可知的各种基本数据类型(<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p><p><strong>3.本地方法栈</strong></p><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p><p><strong>4.堆</strong></p><p>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过<code>-Xms</code>(最小值)和<code>-Xmx</code>(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，<code>-Xmx</code>为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到<code>-Xmx</code>指定的大小，可通过<code>-XX:MinHeapFreeRation=</code>来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过<code>XX:MaxHeapFreeRation=</code>来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p><p>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。</p><blockquote><p>新生代： 程序新创建的对象都是从新生代分配内存，新生代由<code>Eden Space</code>和两块相同大小的<code>Survivor Space</code>(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过<code>-XX:SurvivorRation</code>来调整<code>Eden Space</code>及<code>Survivor Space</code>的大小。 老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置<code>-XX:PretenureSizeThreshold=1024</code>(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</p></blockquote><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/2838681554-300x169.jpg" alt="2838681554"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Young Generation        即图中的Eden + From Space + To Space</span><br><span class="line">Eden                    存放新生的对象</span><br><span class="line">Survivor Space          有两个，存放每次垃圾回收后存活的对象</span><br><span class="line">Old Generation          Tenured Generation 即图中的Old Space </span><br><span class="line">                        主要存放应用程序中生命周期长的存活对象</span><br></pre></td></tr></table></figure><p><strong>5.程序计数器</strong></p><p>是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。</p><h2 id="Java堆内存的10个要点"><a href="#Java堆内存的10个要点" class="headerlink" title="Java堆内存的10个要点"></a>Java堆内存的10个要点</h2><blockquote><ol><li>Java堆内存是操作系统分配给JVM的内存的一部分。</li><li>当我们创建对象时，它们存储在Java堆内存中。</li><li>为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。</li><li>你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。</li><li>你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。</li><li>你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。</li><li>Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。</li><li>Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。</li><li>当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。</li><li>请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。</li></ol></blockquote><h1 id="Java-GC工作原理"><a href="#Java-GC工作原理" class="headerlink" title="Java GC工作原理"></a>Java GC工作原理</h1><h2 id="GC的基本原理"><a href="#GC的基本原理" class="headerlink" title="GC的基本原理"></a>GC的基本原理</h2><p>GC是什么?为什么要有GC呢?</p><blockquote><p>GC是垃圾收集的意思（<code>GarbageCollection</code>）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><p>所以，Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。<br>对于程序员来说，分配对象使用<code>new</code>关键字；释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”.GC将负责回收所有”不可达”对象的内存空间。<br>对于GC来说，<strong>当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”.当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。但是，为了保证GC能够在不同平台实现的问题，Java规范对GC的很多行为都没有进行严格的规定。例如，对于采用什么类型的回收算法、什么时候进行回收等重要问题都没有明确的规定。因此，不同的JVM的实现者往往有不同的实现算法。这也给Java程序员的开发带来行多不确定性。</strong>本文研究了几个与GC工作相关的问题，努力减少这种不确定性给Java程序带来的负面影响。</p></blockquote><h2 id="增量式GC（IncrementalGC）"><a href="#增量式GC（IncrementalGC）" class="headerlink" title="增量式GC（IncrementalGC）"></a>增量式GC（IncrementalGC）</h2><p>GC在JVM中通常是由一个或一组进程来实现的，它本身也和用户程序一样占用heap空间，运行时也占用CPU.当GC进程运行时，应用程序停止运行。因此，当GC运行时间较长时，用户能够感到Java程序的停顿，另外一方面，如果GC运行时间太短，则可能对象回收率太低，这意味着还有很多应该回收的对象没有被回收，仍然占用大量内存。因此，在设计GC的时候，就必须在停顿时间和回收率之间进行权衡。一个好的GC实现允许用户定义自己所需要的设置，例如有些内存有限有设备，对内存的使用量非常敏感，希望GC能够准确的回收内存，它并不在意程序速度的放慢。另外一些实时网络游戏，就不能够允许程序有长时间的中断。增量式GC就是通过一定的回收算法，把一个长时间的中断，划分为很多个小的中断，通过这种方式减少GC对用户程序的影响。虽然，增量式GC在整体性能上可能不如普通GC的效率高，但是它能够减少程序的最长停顿时间。<br>SunJDK提供的HotSpotJVM就能支持增量式GC.HotSpotJVM缺省GC方式为不使用增量GC，为了启动增量GC，我们必须在运行Java程序时增加-Xincgc的参数。HotSpotJVM增量式GC的实现是采用TrainGC算法。它的基本想法就是，将堆中的所有对象按照创建和使用情况进行分组（分层），将使用频繁高和具有相关性的对象放在一队中，随着程序的运行，不断对组进行调整。当GC运行时，它总是先回收最老的（最近很少访问的）的对象，如果整组都为可回收对象，GC将整组回收。这样，每次GC运行只回收一定比例的不可达对象，保证程序的顺畅运行。</p><h2 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h2><p>分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。<br>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。<br>试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p><p>虚拟机中的共划分为三个代：年轻代(Young Generation)、年老点(Old Generation)和持久代(Permanent Generation)。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。</p><p><strong>年轻代</strong>:</p><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区(两个中的一个)，当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的(多于两个)，这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><p><strong>年老代</strong>:</p><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p><strong>持久代</strong>:</p><p>用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显着影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。</p><p>什么情况下触发垃圾回收<br>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：<code>Scavenge GC</code>和<code>Full GC</code>。</p><blockquote><p><code>Scavenge GC</code><br>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。<br><code>Full GC</code><br>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：<br>· 年老代(Tenured)被写满<br>· 持久代(Perm)被写满<br>· System.gc()被显示调用<br>·上一次GC之后Heap的各域分配策略动态变化</p></blockquote><h2 id="详解finalize函数"><a href="#详解finalize函数" class="headerlink" title="详解finalize函数"></a>详解<code>finalize</code>函数</h2><p><code>finalize</code>是位于Object类的一个方法，该方法的访问修饰符为<code>protected</code>，由于所有类为Object的子类，因此用户类很容易访问到这个方法。由于，finalize函数没有自动实现链式调用，我们必须手动的实现，因此finalize函数的最后一个语句通常是<code>super.finalize（）</code>。通过这种方式，我们可以实现从下到上实现finalize的调用，即先释放自己的资源，然后再释放父类的资源。<br><strong>根据Java语言规范，JVM保证调用finalize函数之前，这个对象是不可达的，但是JVM不保证这个函数一定会被调用。另外，规范还保证finalize函数最多运行一次。</strong><br>很多Java初学者会认为这个方法类似与C++中的析构函数，将很多对象、资源的释放都放在这一函数里面。其实，这不是一种很好的方式。原因有三，其一，GC为了能够支持finalize函数，要对覆盖这个函数的对象作很多附加的工作。其二，在finalize运行完成之后，该对象可能变成可达的，GC还要再检查一次该对象是否是可达的。因此，使用finalize会降低GC的运行性能。其三，由于GC调用finalize的时间是不确定的，因此通过这种方式释放资源也是不确定的。<br>通常，finalize用于一些不容易控制、并且非常重要资源的释放，例如一些I/O的操作，数据的连接。这些资源的释放对整个应用程序是非常关键的。在这种情况下，程序员应该以通过程序本身管理（包括释放）这些资源为主，以finalize函数释放资源方式为辅，形成一种双保险的管理机制，而不应该仅仅依靠finalize来释放资源。<br>下面给出一个例子说明，finalize函数被调用以后，仍然可能是可达的，同时也可说明一个对象的finalize只可能运行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line">　　Testmain;<span class="comment">//记录Test对象，在finalize中时用于恢复可达性</span></span><br><span class="line">　　publicMyObject(Testt)</span><br><span class="line">　　&#123;</span><br><span class="line">　　main=t;<span class="comment">//保存Test对象</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　protectedvoidfinalize()</span><br><span class="line">　　&#123;</span><br><span class="line">　　main.ref=<span class="keyword">this</span>;<span class="comment">//恢复本对象，让本对象可达</span></span><br><span class="line">　　System.out.println(<span class="string">"Thisisfinalize"</span>);<span class="comment">//用于测试finalize只运行一次</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">classTest&#123;</span><br><span class="line">　　MyObjectref;</span><br><span class="line">　　publicstaticvoidmain(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">　　Testtest=newTest();</span><br><span class="line">　　test.ref=newMyObject(test);</span><br><span class="line">　　test.ref=<span class="keyword">null</span>;<span class="comment">//MyObject对象为不可达对象，finalize将被调用</span></span><br><span class="line">　　System.gc();</span><br><span class="line">　　<span class="keyword">if</span>(test.ref!=<span class="keyword">null</span>)System.out.println(<span class="string">"MyObject还活着"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Thisisfinalize</span><br></pre></td></tr></table></figure><p><code>MyObject</code>还活着：此例子中，需要注意的是虽然MyObject对象在finalize中变成可达对象，但是下次回收时候，finalize却不再被调用，因为finalize函数最多只调用一次。</p><h2 id="程序如何与GC进行交互"><a href="#程序如何与GC进行交互" class="headerlink" title="程序如何与GC进行交互"></a>程序如何与GC进行交互</h2><p>Java2增强了内存管理功能，增加了一个<code>java.lang.ref</code>包，其中定义了三种引用类。这三种引用类分别为<code>SoftReference</code>、<code>WeakReference</code>和<code>PhantomReference</code>.通过使用这些引用类，程序员可以在一定程度与GC进行交互，以便改善GC的工作效率。这些引用类的引用强度介于可达对象和不可达对象之间。<br>创建一个引用对象也非常容易，例如如果你需要创建一个<code>SoftReference</code>对象，那么首先创建一个对象，并采用普通引用方式（可达对象）；然后再创建一个<code>SoftReference</code>引用该对象；最后将普通引用设置为<code>null</code>.通过这种方式，这个对象就只有一个<code>SoftReference</code>引用。同时，我们称这个对象为<code>SoftReference</code>对象。<br><code>SoftReference</code>的主要特点是据有较强的引用功能。只有当内存不够的时候，才进行回收这类内存，因此在内存足够的时候，它们通常不被回收。另外，这些引用对象还能保证在Java抛出<code>OutOfMemory</code>异常之前，被设置为null.它可以用于实现一些常用图片的缓存，实现Cache的功能，保证最大限度的使用内存而不引起<code>OutOfMemory</code>.以下给出这种引用类型的使用伪代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请一个图像对象</span></span><br><span class="line">Imageimage=newImage();<span class="comment">//创建Image对象</span></span><br><span class="line">　　…</span><br><span class="line"><span class="comment">//使用image</span></span><br><span class="line">　　…</span><br><span class="line"><span class="comment">//使用完了image，将它设置为soft引用类型，并且释放强引用；</span></span><br><span class="line">SoftReferencesr=newSoftReference(image);</span><br><span class="line">image=<span class="keyword">null</span>;</span><br><span class="line">　　…</span><br><span class="line"><span class="comment">//下次使用时</span></span><br><span class="line"><span class="keyword">if</span>(sr!=<span class="keyword">null</span>)image=sr.get();</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//由于GC由于低内存，已释放image，因此需要重新装载；</span></span><br><span class="line">image=newImage();</span><br><span class="line">sr=newSoftReference(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Weak引用对象与Soft引用对象的最大不同就在于：GC在进行回收时，需要通过算法检查是否回收Soft引用对象，而对于Weak引用对象，GC总是进行回收。Weak引用对象更容易、更快被GC回收。虽然，GC在运行时一定回收Weak对象，但是复杂关系的Weak对象群常常需要好几次GC的运行才能完成。Weak引用对象常常用于Map结构中，引用数据量较大的对象，一旦该对象的强引用为null时，GC能够快速地回收该对象空间。<br>Phantom引用的用途较少，主要用于辅助finalize函数的使用。Phantom对象指一些对象，它们执行完了finalize函数，并为不可达对象，但是它们还没有被GC回收。这种对象可以辅助finalize进行一些后期的回收工作，我们通过覆盖Reference的clear（）方法，增强资源回收机制的灵活性。</p><h2 id="一些Java编程的建议"><a href="#一些Java编程的建议" class="headerlink" title="一些Java编程的建议"></a>一些Java编程的建议</h2><p>根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议：</p><p>　　1. 最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null.这样可以加速GC的工作。<br>  　　2. 尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。<br>  　　3. 如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory.<br>  　　4. 注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（danglingreference），造成内存浪费。<br>  　　5. 当程序有一定的等待时间，程序员可以手动执行System.gc（），通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。</p><h2 id="Java的垃圾回收机制"><a href="#Java的垃圾回收机制" class="headerlink" title="Java的垃圾回收机制"></a>Java的垃圾回收机制</h2><p><strong>a、 停止—复制(stop-and-copy)</strong>：先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，紧凑的。效率很低：首先，得有两个堆空间占用率200%;其次，垃圾较少时，复制大量的活着的对象，是很大的浪费。</p><p><strong>b、 标记—清扫(mark-and-sweep)</strong>：从对战和静态存储区出发，遍历所有的引用，进而找出所有存活的对象，如果活着，就标记。只有全部标记完毕的时候，清理动作才开始。在清理的时候，没有标记的对象将会被释放，不会发生任何肤质动作。但是盛夏的对空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。</p><p>c、 注意：“停止—复制”的意思是这种垃圾回收动作不是在后台进行的;相反，垃圾回收动作发生的同时，程序将会被暂停。有人将垃圾回收视为低优先级的后台进程，而事实上并不是这样，当可用内存数量比较低的时候，Sun版本的垃圾回收器就会暂停运行程序。同样，“标记-清扫”工作也必须在程序暂停的情况下才能进行。</p><p>d、 在java虚拟机中，内存分配是以较大的块为单位的。每个块内都用相应的代数(generation count)来记录它是否还存活。代数随着引用的次数而增加。垃圾回收器将对上次回收动作之后的新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作——大型对象仍然不会被复制(只是代数增加)，内涵小型对象的那些块则被复制并整理。Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记—清扫”方式;同样，java虚拟机会追踪“标记—清扫”的效果，要是堆空间出现很多碎片，就会切换到“停止—复制”方式。这就是“自适应”技术。</p><p><strong>总结：Java垃圾回收器是一种“自适应的、分代的、停止—复制、标记-清扫”式的垃圾回收器</strong></p><h1 id="JAVA线程dump的分析-—-jstack-pid"><a href="#JAVA线程dump的分析-—-jstack-pid" class="headerlink" title="JAVA线程dump的分析 — jstack pid"></a>JAVA线程dump的分析 — jstack pid</h1><h2 id="Java-的线程"><a href="#Java-的线程" class="headerlink" title="Java 的线程"></a>Java 的线程</h2><p>线程是指能独立于程序的其它部分运行的执行单元。 JAVA语言能够很好的实现多线程的程序。我们在调试程序，或者在开发后期需要做性能调优的时候，往往也需要了解当前程序正在运行的线程的状态，正在执行的操作，从而分析系统可能存在的问题。</p><p>在阅读本文之间，应对 Java线程的编程原理，同步机制有一定了解 </p><h2 id="产生-JAVA线程-dump"><a href="#产生-JAVA线程-dump" class="headerlink" title="产生 JAVA线程 dump"></a>产生 JAVA线程 dump</h2><p>JAVA 的线程 DUMP，就象当前 JAVA进程的一个快照，打印出所有线程的状态和调用堆栈，以及 Monitor的状态。在不同的操作系统下，产生线程 DUMP的方式是不同的。</p><ul><li><p>在 windows环境中，<br>在启动程序的控制台里敲： Ctrl - Break，线程的 dump会产生在标准输出中（ 缺省标准输出就是控制台，如果对输出进行了重定向，则要查看输出文件）。</p></li><li><p>在 unix， linux和 MacOS 环境中，<br>在控制台中敲： Ctrl-\，或者，<br>用 “kill -3 <pid>” ，或者 “kill – QUIT <pid>”。 Pid是用所关注的 JAVA进程号，您可以用 “ps -ef | grep java” 找到，或者使用 JDK 5.0中的 “jps -v” 命令获得。</pid></pid></p></li><li><p>在各个操作系统平台，都可以用 JDK 5.0工具包中的 jstack <pid></pid></p></li></ul><p>这里要注意的是：</p><ol><li>不同的 JAVA虚机的线程 DUMP的创建方法和文件格式是不一样的，不同的 JVM版本， dump信息也有差别。本文中，只以 SUN的 hotspot JVM 5.0_06 为例。</li><li>在实际运行中，往往一次 dump的信息，还不足以确认问题。建议产生三次 dump信息，如果每次 dump都指向同一个问题，我们才确定问题的典型性。</li></ol><h2 id="线程分析"><a href="#线程分析" class="headerlink" title="线程分析"></a>线程分析</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><p>在线程中，有一些 JVM内部的后台线程，来执行譬如垃圾回收，或者低内存的检测等等任务，这些线程往往在 JVM初始化的时候就存在，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">"Low Memory Detector" daemon prio=10 tid=0x081465f8 nid=0x7 runnable [0x00000000..0x00000000]</span><br><span class="line"></span><br><span class="line">"CompilerThread0" daemon prio=10 tid=0x08143c58 nid=0x6 waiting on condition [0x00000000..0xfb5fd798]</span><br><span class="line"></span><br><span class="line">"Signal Dispatcher" daemon prio=10 tid=0x08142f08 nid=0x5 waiting on condition [0x00000000..0x00000000]</span><br><span class="line"></span><br><span class="line">"Finalizer" daemon prio=10 tid=0x08137ca0 nid=0x4 in Object.wait() [0xfbeed000..0xfbeeddb8]</span><br><span class="line"></span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line"></span><br><span class="line">- waiting on &lt;0xef600848&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line"></span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:116)</span><br><span class="line"></span><br><span class="line">- locked &lt;0xef600848&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line"></span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:132)</span><br><span class="line"></span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)</span><br><span class="line"></span><br><span class="line">"Reference Handler" daemon prio=10 tid=0x081370f0 nid=0x3 in Object.wait() [0xfbf4a000..0xfbf4aa38]</span><br><span class="line"></span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line"></span><br><span class="line">- waiting on &lt;0xef600758&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line"></span><br><span class="line">at java.lang.Object.wait(Object.java:474)</span><br><span class="line"></span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:116)</span><br><span class="line"></span><br><span class="line">- locked &lt;0xef600758&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line"></span><br><span class="line">"VM Thread" prio=10 tid=0x08134878 nid=0x2 runnable</span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" prio=10 tid=0x08147768 nid=0x8 waiting on condition</span><br></pre></td></tr></table></figure><p>我们更多的是要观察用户级别的线程，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"Thread-1" prio=10 tid=0x08223860 nid=0xa waiting on condition [0xef47a000..0xef47ac38]</span><br><span class="line"></span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line"></span><br><span class="line">at testthread.MySleepingThread.method2(MySleepingThread.java:53)</span><br><span class="line"></span><br><span class="line">- locked &lt;0xef63d600&gt; (a testthread.MySleepingThread)</span><br><span class="line"></span><br><span class="line">at testthread.MySleepingThread.run(MySleepingThread.java:35)</span><br><span class="line"></span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure><p>我们能看到：</p><ul><li><p>线程的状态： waiting on condition</p></li><li><p>线程的调用栈</p></li><li><p>线程的当前锁住的资源： <0xef63d600></0xef63d600></p></li></ul><pre><code>这些信息对我们随后的分析都有用处。</code></pre><h3 id="线程的状态分析"><a href="#线程的状态分析" class="headerlink" title="线程的状态分析"></a>线程的状态分析</h3><p>正如我们刚看到的那样，线程的状态是一个重要的指标，它会显示在线程 Stacktrace的头一行结尾的地方。那么线程常见的有哪些状态呢？线程在什么样的情况下会进入这种状态呢？我们能从中发现什么线索？&lt; /span&gt;</p><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。</p><h4 id="Wait-on-condition"><a href="#Wait-on-condition" class="headerlink" title="Wait on condition"></a>Wait on condition</h4><p>该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace来分析。最常见的情况是线程在等待网络的读写，比如当网络数据没有准备好读时，线程处于这种等待状态，而一旦有数据准备好读之后，线程会重新激活，读取并处理数据。在 Java引入 NewIO之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 NewIO里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。</p><p>如果发现有大量的线程都在处在 Wait on condition，从线程 stack看， 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几 乎消耗了所有的带宽，仍然有大量数据等待网络读 写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制 ; 观察 cpu的利用率，如果系统态的 CPU时间，相对于用户态的 CPU时间比例较高；如果程序运行在 Solaris 10平台上，可以用 dtrace工具看系统调用的情况，如果观察到 read/write的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。</p><p>另外一种出现 Wait on condition的常见情况是该线程在 sleep，等待 sleep的时间到了时候，将被唤醒。</p><p>1.3 Waiting for monitor entry 和 in Object.wait()</p><p>在多线程的 JAVA程序中，实现线程之间的同步，就要说说 Monitor。 Monitor是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。下 面这个图，描述了线程和 Monitor之间关系，以 及线程的状态转换图：<br><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/thread.jpg" alt="img"></p><p>从图中可以看出，每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是 “in Object.wait()”。</p><p>先看 “Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应的 code就像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时有两种可能性：</p><ol><li>该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码</li><li>该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。</li></ol><p>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"Thread-0" prio=10 tid=0x08222eb0 nid=0x9 waiting for monitor entry [0xf927b000..0xf927bdb8]</span><br><span class="line"></span><br><span class="line">at testthread.WaitThread.run(WaitThread.java:39)</span><br><span class="line"></span><br><span class="line">- waiting to lock &lt;0xef63bf08&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList)</span><br><span class="line"></span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure><p>临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这 和我们多线程的程序的初衷是相反的。 如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。</p><p>现在我们再来看现在线程为什么会进入 “Wait Set”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ， “ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()，类似于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"Thread-1" prio=10 tid=0x08223250 nid=0xa in Object.wait() [0xef47a000..0xef47aa38]</span><br><span class="line"></span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line"></span><br><span class="line">- waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList)</span><br><span class="line"></span><br><span class="line">at java.lang.Object.wait(Object.java:474)</span><br><span class="line"></span><br><span class="line">at testthread.MyWaitThread.run(MyWaitThread.java:40)</span><br><span class="line"></span><br><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList)</span><br><span class="line"></span><br><span class="line">at java.lang.Thread.run(Thread.java:595)</span><br></pre></td></tr></table></figure><p>仔细观察上面的 DUMP信息，你会发现它有以下两行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- locked &lt;0xef63beb8&gt; (a java.util.ArrayList)</span><br><span class="line"></span><br><span class="line">- waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList)</span><br></pre></td></tr></table></figure><p>这里需要解释一下，为什么先 lock了这个对象，然后又 waiting on同一个对象呢？让我们看看这个线程对应的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    .........</span><br><span class="line">    obj.wait();</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于 locked <0xef63beb8> ）。当执行到 obj.wait(), 线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on <0xef63beb8> ）。</0xef63beb8></0xef63beb8></p><p>往往在你的程序中，会出现多个类似的线程，他们都有相似的 DUMP信息。这也可能是正常的。比如，在程序中，有多个服务线程，设计成从一个队列里面读取请求数据。这个队列就是 lock以及 waiting on的对象。当队列为空的时候，这些线程都会在这个队列上等待，直到队列有了数据，这些线程被 Notify，当然只有一个线程获得了 lock，继续执行，而其它线程继续等待。</p><ol start="3"><li>JDK 5.0 的 lock</li></ol><p>上面我们提到如果 synchronized和 monitor机制运用不当，可能会造成多线程程序的性能问题。在 JDK 5.0中，引入了 Lock机制，从而使开发者能更灵活的开发高性能的并发多线程程序，可以替代以往 JDK中的 synchronized和 Monitor的 机制。但是，要注意的是，因为 Lock类只是一个普通类， JVM无从得知 Lock对象的占用情况，所以在线程 DUMP中，也不会包含关于 Lock的信息， 关于死锁等问题，就不如用 synchronized的编程方式容易识别。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在多线程程序的编写中，如果不适当的运用同步机制，则有可能造成程序的死锁，经常表现为程序的停顿，或者不再响应用户的请求。</p><p>比如在下面这个示例中，是个较为典型的死锁情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">"Thread-1" prio=5 tid=0x00acc490 nid=0xe50 waiting for monitor entry [0x02d3f000</span><br><span class="line"></span><br><span class="line">..0x02d3fd68]</span><br><span class="line"></span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31)</span><br><span class="line"></span><br><span class="line">- waiting to lock &lt;0x22c19f18&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">- locked &lt;0x22c19f20&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"Thread-0" prio=5 tid=0x00accdb0 nid=0xdec waiting for monitor entry [0x02cff000</span><br><span class="line"></span><br><span class="line">..0x02cff9e8]</span><br><span class="line"></span><br><span class="line">at deadlockthreads.TestThread.run(TestThread.java:31)</span><br><span class="line"></span><br><span class="line">- waiting to lock &lt;0x22c19f20&gt; (a java.lang.Object)</span><br><span class="line"></span><br><span class="line">- locked &lt;0x22c19f18&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><p>在 JAVA 5中加强了对死锁的检测。线程 Dump中可以直接报告出 Java级别的死锁，如下所示：</p><p>Found one Java-level deadlock:</p><p>=============================<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"Thread-1":</span><br><span class="line"></span><br><span class="line">waiting to lock monitor 0x0003f334 (object 0x22c19f18, a java.lang.Object),</span><br><span class="line"></span><br><span class="line">which is held by "Thread-0"</span><br><span class="line"></span><br><span class="line">"Thread-0":</span><br><span class="line"></span><br><span class="line">waiting to lock monitor 0x0003f314 (object 0x22c19f20, a java.lang.Object),</span><br><span class="line"></span><br><span class="line">which is held by "Thread-1"</span><br></pre></td></tr></table></figure></p><h3 id="热锁"><a href="#热锁" class="headerlink" title="热锁"></a>热锁</h3><p>热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为，由于多个线程对临界区，或者锁的竞争，可能出现：</p><ul><li><p>频繁的线程的上下文切换：从操作系统对线程的调度来看，当 线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。</p></li><li><p>大量的系统调用：因为线程的上下文切换，以及热锁的竞争，或 者临界区的频繁的进出，都可能导致大量的系统调用。</p></li><li><p>大部分 CPU开销用在 “系统态 ”：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是 CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。</p></li><li><p>随着 CPU数目的增多，系统的性能反而下降。因为 CPU数目多，同 时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的 CPU开销，从而导致更糟糕的性能。</p></li></ul><p>上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。&lt; /span&gt;</p><p>那么，怎么去了解 “热锁 ”出现在什么地方呢？一个重要的方法还是结合操作系统的各种工具观察系统资源使用状况，以及收集 Java线程的 DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。</p><p>我们曾经遇到过这样的例子，程序运行时，出现了以上指出的各种现象，通过观察操作系统的资源使用统计信息，以及线程 DUMP信息，确定了程序中热锁的存在，并发现大多数的线程状态都是 Waiting for monitor entry或者 Wait on monitor，且是阻塞在压缩和解压缩的方法上。后来采用第三方的压缩包 javalib替代 JDK自带的压缩包后，系统的性能提高了几倍。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本文就介绍了 Java线程 DUMP的基本知识和分析的基本方法，并且解释了如何利用线程的 DUMP信息，以及结合操作系统的各种资源使用情况，分析程序的性能问题，从而达到改进程序，提高性能的目的。</p><h1 id="JDK-JRE-JVM区别与联系"><a href="#JDK-JRE-JVM区别与联系" class="headerlink" title="JDK,JRE,JVM区别与联系"></a>JDK,JRE,JVM区别与联系</h1><p><strong>JDK</strong> : <code>Java Development ToolKit</code>(Java开发工具包)。JDK是整个JAVA的核心，<em>包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）</em>。</p><blockquote><p>JDK有以下三种版本： <code>J2SE</code>，standard edition，标准版，是我们通常用的一个版本 <code>J2EE</code>，enterpsise edtion，企业版，使用这种JDK开发J2EE应用程序 <code>J2ME</code>，micro edtion，主要用于移动设备、嵌入式设备上的java应用程序</p></blockquote><p>我们常常用JDK来代指<code>Java API</code>，Java API是Java的应用程序接口，其实就是前辈们写好的一些java Class，包括一些重要的语言结构以及基本图形，网络和文件I/O等等 ，我们在自己的程序中，调用前辈们写好的这些Class，来作为我们自己开发的一个基础。当然，现在已经有越来越多的性能更好或者功能更强大的第三方类库供我们使用。</p><p><strong>JRE</strong>:<code>Java Runtime Enviromental</code>(java运行时环境)。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行。包括JVM和JAVA核心类库和支持文件。<strong>与JDK相比，它不包含开发工具——编译器、调试器和其它工具。</strong></p><p><code>JVM</code>：<code>Java Virtual Mechinal</code>(JAVA虚拟机)。JVM是JRE的一部分，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。Java语言是跨平台运行的，其实就是不同的操作系统，使用不同的JVM映射规则，让其与操作系统无关，完成了跨平台性。JVM 对上层的 Java 源文件是不关心的，它关注的只是由源文件生成的类文件（ class file ）。类文件的组成包括 JVM 指令集，符号表以及一些补助信息。 关于JVM的内存结构请看这篇文章：<code>Java虚拟机的内存组成以及堆内存介绍</code></p><p>下图很好的表面了JDK,JRE,JVM三者间的关系：</p><p><img src="/2020/06/06/Java开发必须掌握的线上问题排查命令-常见命令、JPS、JSTACK、JMAP、JSTAT、JHAT、JINFO、JAVAP等/2932682015-300x184.gif" alt="2932682015"></p><p>#Linux端口被占用的解决</p><blockquote><p>Error: JBoss port is in use. Please check</p></blockquote><p>原因：原因很简单，端口被占用</p><p>解决：</p><p><strong>知道端口号，直接查找进程ID，杀掉进程</strong></p><ol><li>知道端口号，查看是否被占用，比如说知道jboss用的是8080端口，那就直接使用命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tln | grep 8080</span><br></pre></td></tr></table></figure><p><code>netstat -tln</code> 查看端口使用情况，而<code>netstat -tln | grep 8080</code> 则是只查看端口8080的使用情况</p><ol start="2"><li>查看端口属于哪个程序？端口被哪个进程占用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8080</span><br></pre></td></tr></table></figure><p>可以看到端口使用情况如下</p><blockquote><p>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>java 8253 hollis 143u IPv4 757826 0t0 TCP *:http-alt (LISTEN)<br>java 8253 hollis 737u IPv4 756898 0t0 TCP 10.16.47.163:39451-&gt;10.101.104.55:http-alt (ESTABLISHED)<br>java 8253 hollis 806u IPv4 757695 0t0 TCP 10.16.47.163:50381-&gt;10.101.104.50:http-alt (ESTABLISHED)</p></blockquote><ol start="3"><li>使用命令 <code>kill -9 进程id(8253)</code>杀掉进程</li></ol><p><strong>不知道知道端口号，但是知道进程的名字，比如知道是个java进程，找到进程ID，直接杀死</strong></p><ol><li>使用命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep java</span><br></pre></td></tr></table></figure><p>查找哪些进程适合java相关的进程</p><blockquote><p>hollis 15690 1.2 6.4 3537252 524812 pts/28 Sl 3月12 0:17 /home/hollis/tools/java/jdk1.7.0_71/bin/java -D[Standalone] -XX:+UseCompressedOops -server -Xms1024m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=192m -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true -Dorg.jboss.boot.log.file=/home/hollis/out/logs/jboss_stdout.log -Dlogging.configuration=file:/home/hollis/workspace/stand/standalone/control/jboss/config/logging.properties -Djboss.modules.system.pkgs=com.sun.btrace -Dapplication.name=standalone-sync-appinfo -Dlog4j.ignoreTCL=true -Dlogback.ignoreTCL=true -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=7001,server=y,suspend=n -Dproject.name=standalone-sync-appinfo -Dorg.apache.tomcat.util.http.ServerCookie.ALLOW_EQUALS_IN_VALUE=true -DloggingRoot=/home/hollis/out/logs -DloggingCharset=UTF-8 -DloggingLevel=DEBUG -jar /opt/taobao/install/jboss-7.2.0/jboss-modules.jar -mp /opt/taobao/install/jboss-7.2.0/modules:/home/hollis/workspace/stand/standalone/control/jboss/hilton/modules -jaxpmodule javax.xml.jaxp-provider org.jboss.as.standalone -Djboss.home.dir=/opt/taobao/install/jboss-7.2.0 -Djboss.server.base.dir=/home/hollis/workspace/stand/standalone/deploy/target -Djboss.server.config.dir=/home/hollis/workspace/stand/standalone/control/jboss/config -Djboss.server.log.dir=/home/hollis/out/logs</p></blockquote><ol start="2"><li>使用命令 <code>kill -9 进程id(15690)</code>杀掉进程</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;http://www.hollischuang.com/archives/tag/java%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java命令学习系列&lt;/a&gt;，文章内容略有调整。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Java开发必须掌握的线上问题排查命令&quot;&gt;&lt;a href=&quot;#Java开发必须掌握的线上问题排查命令&quot; class=&quot;headerlink&quot; title=&quot;Java开发必须掌握的线上问题排查命令&quot;&gt;&lt;/a&gt;Java开发必须掌握的线上问题排查命令&lt;/h1&gt;&lt;p&gt;作为一个合格的开发人员，不仅要能写得一手还代码，还有一项很重要的技能就是排查问题。这里提到的排查问题不仅仅是在coding的过程中debug等，还包括的就是线上问题的排查。由于在生产环境中，一般没办法debug（其实有些问题，debug也白扯。。。）,所以我们需要借助一些常用命令来查看运行时的具体情况，这些运行时信息包括但不限于运行日志、异常堆栈、堆使用情况、GC情况、JVM参数情况、线程情况等。&lt;/p&gt;
&lt;p&gt;给一个系统定位问题的时候，知识、经验是关键，数据是依据，工具是运用知识处理数据的手段。为了便于我们排查和解决问题，Sun公司为我们提供了一些常用命令。这些命令一般都是jdk/lib/tools.jar中类库的一层薄包装。随着JVM的安装一起被安装到机器中，在bin目录中。下面就来认识一下这些命令以及具体使用方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="JPS" scheme="https://vincentruan.github.io/tags/JPS/"/>
    
      <category term="JMAP" scheme="https://vincentruan.github.io/tags/JMAP/"/>
    
      <category term="JSTACK" scheme="https://vincentruan.github.io/tags/JSTACK/"/>
    
      <category term="JSTAT" scheme="https://vincentruan.github.io/tags/JSTAT/"/>
    
      <category term="JHAT" scheme="https://vincentruan.github.io/tags/JHAT/"/>
    
      <category term="JINFO" scheme="https://vincentruan.github.io/tags/JINFO/"/>
    
      <category term="JAVAP" scheme="https://vincentruan.github.io/tags/JAVAP/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令整理</title>
    <link href="https://vincentruan.github.io/2020/06/06/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>https://vincentruan.github.io/2020/06/06/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</id>
    <published>2020-06-06T14:24:04.000Z</published>
    <updated>2020-06-06T14:40:55.785Z</updated>
    
    <content type="html"><![CDATA[<p>本文并不会对所有命令进行详细讲解，只给出常见用法和解释。具体用法可以使用<code>--help</code>查看帮助或者直接通过google搜索学习。</p><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p><code>find / -name filename.txt</code> 根据名称查找/目录下的filename.txt文件。</p><p><code>find . -name &quot;*.xml&quot;</code> 递归查找所有的xml文件</p><p><code>find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot;</code> 递归查找所有文件内容中包含hello world的xml文件</p><p><code>grep -H &#39;spring&#39; *.xml</code> 查找所以有的包含spring的xml文件</p><p><code>find ./ -size 0 | xargs rm -f &amp;</code> 删除文件大小为零的文件</p><p><code>ls -l | grep &#39;.jar&#39;</code> 查找当前目录中的所有jar文件</p><p><code>grep &#39;test&#39; d*</code> 显示所有以d开头的文件中包含test的行。</p><p><code>grep &#39;test&#39; aa bb cc</code> 显示在aa，bb，cc文件中匹配test的行。</p><p><code>grep &#39;[a-z]\{5\}&#39; aa</code> 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><a id="more"></a><h2 id="查看一个程序是否运行"><a href="#查看一个程序是否运行" class="headerlink" title="查看一个程序是否运行"></a>查看一个程序是否运行</h2><p><code>ps –ef|grep tomcat</code> 查看所有有关tomcat的进程</p><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p><code>kill -9 19979</code> 终止线程号位19979的进程</p><h2 id="查看文件，包含隐藏文件"><a href="#查看文件，包含隐藏文件" class="headerlink" title="查看文件，包含隐藏文件"></a>查看文件，包含隐藏文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p><code>cp source dest</code> 复制文件</p><p><code>cp -r sourceFolder targetFolder</code> 递归复制整个文件夹</p><p><code>scp sourecFile romoteUserName@remoteIp:remoteAddr</code> 远程拷贝</p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir newfolder</span><br></pre></td></tr></table></figure><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p><code>rmdir deleteEmptyFolder</code> 删除空目录 <code>rm -rf deleteFile</code> 递归删除目录中所有内容</p><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /temp/movefile /targetFolder</span><br></pre></td></tr></table></figure><h2 id="重命令"><a href="#重命令" class="headerlink" title="重命令"></a>重命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv oldNameFile newNameFile</span><br></pre></td></tr></table></figure><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su -username</span><br><span class="line">sudo su - username</span><br></pre></td></tr></table></figure><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><p><code>chmod 777 file.java</code> //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</p><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf test.tar.gz /test1 /test2</span><br></pre></td></tr></table></figure><h2 id="列出压缩文件列表"><a href="#列出压缩文件列表" class="headerlink" title="列出压缩文件列表"></a>列出压缩文件列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tzf test.tar.gz</span><br></pre></td></tr></table></figure><h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf test.tar.gz</span><br></pre></td></tr></table></figure><h2 id="查看文件头10行"><a href="#查看文件头10行" class="headerlink" title="查看文件头10行"></a>查看文件头10行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 10 example.txt</span><br></pre></td></tr></table></figure><h2 id="查看文件尾10行"><a href="#查看文件尾10行" class="headerlink" title="查看文件尾10行"></a>查看文件尾10行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 10 example.txt</span><br></pre></td></tr></table></figure><h2 id="查看日志类型文件"><a href="#查看日志类型文件" class="headerlink" title="查看日志类型文件"></a>查看日志类型文件</h2><p><code>tail -f exmaple.log</code> //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</p><h2 id="使用超级管理员身份执行命令"><a href="#使用超级管理员身份执行命令" class="headerlink" title="使用超级管理员身份执行命令"></a>使用超级管理员身份执行命令</h2><p><code>sudo rm a.txt</code> 使用管理员身份删除文件</p><h2 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h2><p><code>netstat -tln | grep 8080</code> 查看端口8080的使用情况</p><h2 id="查看端口属于哪个程序"><a href="#查看端口属于哪个程序" class="headerlink" title="查看端口属于哪个程序"></a>查看端口属于哪个程序</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8080</span><br></pre></td></tr></table></figure><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p><code>ps aux|grep java</code> 查看java进程</p><p><code>ps aux</code> 查看所有进程</p><h2 id="以树状图列出目录的内容"><a href="#以树状图列出目录的内容" class="headerlink" title="以树状图列出目录的内容"></a>以树状图列出目录的内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree a</span><br></pre></td></tr></table></figure><p>ps:<a href="http://www.hollischuang.com/archives/546" target="_blank" rel="noopener">Mac下使用tree命令</a></p><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><code>wget http://file.tgz</code> <a href="http://www.hollischuang.com/archives/548" target="_blank" rel="noopener">mac下安装wget命令</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://file.tgz</span><br></pre></td></tr></table></figure><h2 id="网络检测"><a href="#网络检测" class="headerlink" title="网络检测"></a>网络检测</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.just-ping.com</span><br></pre></td></tr></table></figure><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh userName@ip</span><br></pre></td></tr></table></figure><h2 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h2><p><code>echo $JAVA_HOME</code> 打印java home环境变量的值</p><h2 id="java-常用命令"><a href="#java-常用命令" class="headerlink" title="java 常用命令"></a>java 常用命令</h2><p>参考站点内关于的文章，java javac, jps ,jstat,jmap, jstack</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>svn git maven</p><h2 id="linux命令学习网站"><a href="#linux命令学习网站" class="headerlink" title="linux命令学习网站:"></a>linux命令学习网站:</h2><p><a href="http://explainshell.com/" target="_blank" rel="noopener">http://explainshell.com/</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.hollischuang.com/archives/239" target="_blank" rel="noopener">Linux端口被占用的解决(Error: JBoss port is in use. Please check)</a></p><p><a href="https://linux.cn/article-1672-1.html" target="_blank" rel="noopener">linux 中强大且常用命令：find、grep</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文并不会对所有命令进行详细讲解，只给出常见用法和解释。具体用法可以使用&lt;code&gt;--help&lt;/code&gt;查看帮助或者直接通过google搜索学习。&lt;/p&gt;
&lt;h2 id=&quot;查找文件&quot;&gt;&lt;a href=&quot;#查找文件&quot; class=&quot;headerlink&quot; title=&quot;查找文件&quot;&gt;&lt;/a&gt;查找文件&lt;/h2&gt;&lt;p&gt;&lt;code&gt;find / -name filename.txt&lt;/code&gt; 根据名称查找/目录下的filename.txt文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find . -name &amp;quot;*.xml&amp;quot;&lt;/code&gt; 递归查找所有的xml文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find . -name &amp;quot;*.xml&amp;quot; |xargs grep &amp;quot;hello world&amp;quot;&lt;/code&gt; 递归查找所有文件内容中包含hello world的xml文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep -H &amp;#39;spring&amp;#39; *.xml&lt;/code&gt; 查找所以有的包含spring的xml文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find ./ -size 0 | xargs rm -f &amp;amp;&lt;/code&gt; 删除文件大小为零的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls -l | grep &amp;#39;.jar&amp;#39;&lt;/code&gt; 查找当前目录中的所有jar文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep &amp;#39;test&amp;#39; d*&lt;/code&gt; 显示所有以d开头的文件中包含test的行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep &amp;#39;test&amp;#39; aa bb cc&lt;/code&gt; 显示在aa，bb，cc文件中匹配test的行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep &amp;#39;[a-z]\{5\}&amp;#39; aa&lt;/code&gt; 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LINUX" scheme="https://vincentruan.github.io/categories/LINUX/"/>
    
    
      <category term="Linux" scheme="https://vincentruan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【转载】Nginx反向代理，负载均衡，redis session共享，keepalived高可用</title>
    <link href="https://vincentruan.github.io/2020/03/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8Credis-session%E5%85%B1%E4%BA%AB%EF%BC%8Ckeepalived%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>https://vincentruan.github.io/2020/03/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8Credis-session%E5%85%B1%E4%BA%AB%EF%BC%8Ckeepalived%E9%AB%98%E5%8F%AF%E7%94%A8/</id>
    <published>2020-03-23T08:47:55.000Z</published>
    <updated>2020-06-06T15:43:39.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>来自：MrLinFeng - 博客园</strong> 链接：<a href="http://www.cnblogs.com/mrlinfeng/p/6146866.html" target="_blank" rel="noopener">www.cnblogs.com/mrlinfeng/p/6146866.html</a></p></blockquote><p>使用的资源：</p><p>nginx主服务器一台，nginx备服务器一台，使用keepalived进行宕机切换。</p><p>tomcat服务器两台，由nginx进行反向代理和负载均衡，此处可搭建服务器集群。</p><p>redis服务器一台，用于session的分离共享。</p><p>nginx主服务器：192.168.50.133</p><p>nginx备服务器：192.168.50.135</p><p>tomcat项目服务器1:192.168.50.137</p><p>tomcat项目服务器2:192.168.50.139</p><p>redis服务器：192.168.50.140</p><p>注意访问时需要配置防火墙规则，或者关闭防火墙</p> <a id="more"></a><h1 id="Nginx反向代理与负载均衡"><a href="#Nginx反向代理与负载均衡" class="headerlink" title="Nginx反向代理与负载均衡"></a>Nginx反向代理与负载均衡</h1><p>架构图：</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210013029741-1131403264.png" alt="img"><strong>此时需要用到三台服务器，一台nginx服务器，两台正式部署项目的服务器：选择的是192.168.50.133主nginx和192.168.50.137,192.168.50.139两台tomcat服务器</strong></p><p><strong>首先在两台服务器上安装tomcat：这个也是简单，不多说</strong></p><p>安装tomcat：上传解压即可使用，bin目录下 startup.sh启动，shutdown.sh关闭</p><p>配置防火墙端口：vim /etc/sysconfig/iptables 编辑，开放8080端口，80端口等一些常用端口，当然后边有用到一些端口都是需要配置开放的，不建议关闭防火墙</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161208231925601-1474979822.png" alt="img"></p><p>编辑好后 service iptables restart 重新加载防火墙配置</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161208232235554-821786257.png" alt="img"></p><p>如果是自己测试嫌配置麻烦，关闭防火墙： service iptables stop 重启后防火墙打开，即在此次开机状态下有效，完全关闭再使用 chkconfig iptables off ,即会在重启后也关闭防火墙，注意有时候服务都起了但访问出错，可能就是防火墙问题哦</p><p>启动tomcat访问：192.168.50.137:8080，192.168.50.139:8080，打开tomcat首页即成功。</p><p>然后编写测试项目，部署到两台tomcat上，eclipse新建web项目，项目名为testproject，在webapp下新建一个jsp页面为index.jsp,添加如下内容</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210021128741-783517177.png" alt="img"><strong>将项目中web.xml中的访问顺序index.jsp上移到第一个访问</strong></p><p><strong>然后右键导出为war包，testproject.war，将该war包上传到两台服务器的tomcat的webapps中</strong></p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210021748835-63821191.png" alt="img"></p><p> <strong>然后修改tomcat的server.xml文件，在tomcat conf目录中：可以使用notepad++的插件NppFTP直接连上linux，然后使用notepad++修改文件哦，保存记得使用UTF-8无BOM格式，具体去百度吧，哈哈</strong></p><p>修改Engine标签中，添加jvmRoute，用于标识nginx访问的是哪个服务器tomcat，137服务器标识为137Server1，139服务器标识为139Server2</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210022536257-563796782.png" alt="img"></p><p>在两台tomcat的server.xml文件，Host标签中添加：<context path docbase="testproject">，path标识访问路径，docBase为项目名，表示访问项目</context></p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210022853491-1479908862.png" alt="img"></p><p>此时，重新启动tomcat，访问192.168.50.137:8080，192.168.50.139:8080,显示index.jsp内容：两台服务器访问显示如下</p><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210024245991-1200437408.png" alt="img"></p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210024301116-1896852396.png" alt="img"></p><p>至此，两台tomcat服务器搭建完成。</p><p>在nginx主机192.168.50.133上安装nginx：</p><p> 先使用yum命令安装gcc，安装pcre，zlib，openssl：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc``yum install -y pcre pcre-devel``yum install -y zlib zlib-devel``yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p> 在/usr/local/目录下新建nginx-src目录，将nginx-1.8.0.tar.gz放到此处，解压 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.8.0.tar.gz</span><br></pre></td></tr></table></figure><p>进入解压后目录</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161208233450960-1697266825.png" alt="img"></p><p>依次执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure` `make` `mkae install</span><br></pre></td></tr></table></figure><p> 此时nginx安装完毕，安装目录是/usr/local/nginx，nginx默认占用80端口</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161208233822866-868810441.png" alt="img"></p><p>其中，sbin目录为nginx执行命令，conf目录下的nginx.conf为默认加载的配置文件</p><p>启动nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx</span><br></pre></td></tr></table></figure><p>关闭nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p> 启动nginx后访问192.168.50.133:80即可访问nginx：显示nginx欢迎页</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161208234258757-1246458568.png" alt="img"></p><p> 至此，nginx安装完毕。</p><h1 id="反向代理与负载均衡配置"><a href="#反向代理与负载均衡配置" class="headerlink" title="反向代理与负载均衡配置"></a>反向代理与负载均衡配置</h1><p>现有两台服务器，一台为192.168.50.137，一台为192.168.50.139，服务器上各有一台tomcat，端口均为8080，在192.168.50.133上有nginx，经过配置nginx，当访问192.168.50.133:80时，即可访问192.168.50.137:8080，192.168.50.139:8080中随机一台，此时192.168.50.133:80被nginx监听，当有请求时，代理到192.168.50.137:8080，192.168.50.139:8080随机一台即可，即为nginx反向代理功能，同时此时可以通过nginx将请求进行转发，保证了一个入口，将所有请求转发到两台服务器上也减轻了任何一台的负载压力，当有大量请求时，可以搭建大量服务器，在入口代理服务器上使用nginx进行转发，即是负载均衡功能。</p><p> <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAEAAAAAAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAJHBC8DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoozRmgAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiijOKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKCcUARsM0AZbpx39qC4XFeAftm/t+6H+xr4k8H6PqHhXxt4w1rxt9r/ALN0/wAM6cl9dOtqqPKxQuh4WRTxno3pWdatCnHmqOyOzAZficbWWHwseaTvp6K7+5Js+g6K+L/+HxBH/Nuf7TH/AIRf/wBupP8Ah8S3/RuP7TX/AIRX/wBtrl/tDD/zfmev/qnmv/Pr/wAmj/mfZ5K5oytfGH/D4qT/AKNw/aY/8Io//HaP+HxUn/RuH7TH/hFH/wCO0f2jQ/m/Bj/1RzX/AJ9f+TR/zPs/K0ZWvjD/AIfFSf8ARuH7TH/hFH/47R/w+Kk/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/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dy/AX/ojfw2/8Ju0/+N17Vs96NnvR9Xp/yr7g/trMP+f8/wDwJ/5niv8Aw7l+Av8A0Rv4bf8AhN2n/wAbo/4dzfAX/ojvw0/8Juz/APjde1eXSNFuFH1el/KvuD+2sw/5/wA//An/AJnlnw//AGNPhP8ACjxLb614X+G/gjw9rFsCIr7T9Dtra4jyMHa6KrDKkj8a9Qi4XinBM/xYpyAlKqnGMNIKyOTEYqtXlz1pOT823+Y4dKKKK0MAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACjFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9k=" alt="img"></p><p> 配置即是配置nginx安装目录中conf目录下的nginx.conf文件即可：具体配置如下，重点是红色部分</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Nginx所用用户和组</span></span><br><span class="line"><span class="comment">#user  niumd niumd;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#工作的子进程数量（通常等于CPU数量或者2倍于CPU）</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志存放路径</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定pid存放文件</span></span><br><span class="line"><span class="attribute">pid</span>        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment">#使用网络IO模型linux建议epoll，FreeBSD建议采用kqueue</span></span><br><span class="line">    <span class="comment">#use epoll;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#允许最大连接数</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#定义日志格式</span></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] $request '</span></span><br><span class="line">    <span class="comment">#                  '"$status" $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  off;</span></span><br><span class="line">    <span class="attribute">access_log</span>  logs/access.log;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">client_header_timeout</span>  <span class="number">3m</span>;</span><br><span class="line">    <span class="attribute">client_body_timeout</span>    <span class="number">3m</span>;</span><br><span class="line">    <span class="attribute">send_timeout</span>           <span class="number">3m</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">client_header_buffer_size</span>    <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span>  <span class="number">4</span> <span class="number">4k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>      <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>     <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#fastcgi_intercept_errors on; </span></span><br><span class="line">   </span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span>  /<span class="number">404</span>.html;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  75 20;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span>                 <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span>      <span class="number">1000</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span>           text/plain text/css application/x-javascript;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#配置被代理的服务器</span></span><br><span class="line">    <span class="attribute">upstream</span> blank &#123;</span><br><span class="line">        <span class="comment">#ip_hash;</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.50.137:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.50.139:8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">            <span class="comment">#nginx监听80端口，请求该端口时转发到真实目标</span></span><br><span class="line">            <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">            <span class="comment">#配置访问域名</span></span><br><span class="line">            <span class="attribute">server_name</span>  localhost;                  </span><br><span class="line">        </span><br><span class="line">            <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="comment">#这里配置代理是指上面定义的两个被代理目标，blank名字必须一致</span></span><br><span class="line">                <span class="attribute">proxy_pass</span> http://blank;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#proxy_redirect          off;</span></span><br><span class="line">                <span class="comment">#如果是非80端口，配置为Host $host：端口号，目的是将代理服务器收到的用户的信息传到真实服务器上</span></span><br><span class="line">                <span class="attribute">proxy_set_header</span>        Host <span class="variable">$host</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span>        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">                <span class="attribute">client_max_body_size</span>    <span class="number">10m</span>;</span><br><span class="line">                <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line">                <span class="attribute">proxy_connect_timeout</span>   <span class="number">300</span>;</span><br><span class="line">                <span class="attribute">proxy_send_timeout</span>      <span class="number">300</span>;</span><br><span class="line">                <span class="attribute">proxy_read_timeout</span>      <span class="number">300</span>;</span><br><span class="line">                <span class="attribute">proxy_buffer_size</span>       <span class="number">4k</span>;</span><br><span class="line">                <span class="attribute">proxy_buffers</span>           <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">                <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>;</span><br><span class="line">                <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">                <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#此处定义500 502 503 504的错误页面</span></span><br><span class="line">            <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">            <span class="comment">#错误页面位置</span></span><br><span class="line">            <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="comment">#root表示路径 html为nginx安装目录中的html文件夹</span></span><br><span class="line">            <span class="comment">#位于/usr/local/nginx/html/下</span></span><br><span class="line">               <span class="attribute">root</span>   html;</span><br><span class="line">            &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动两台tomcat，重新启动nginx：</p><p>访问192.168.50.133:80将会随机访问192.168.50.137:8080和192.168.50.139:8080其中一台。（问题：每次刷新nginx服务器地址sessionid会变，session不能共享。）</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210040326319-1999583685.png" alt="img"></p><p><strong>nginx轮询策略：</strong></p><p><strong>nginx负载均衡到多台服务器上时，默认采用轮询策略：</strong></p><p><strong>常见策略：</strong></p><p>1、轮询</p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>2、weight<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况，数字越大命中率越高。<br>例如：轮询几率是2:1<br>upstream bakend {<br>server 192.168.0.14 weight=2;<br>server 192.168.0.15 weight=1;<br>}</p><p>2、ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>例如：<br>upstream bakend {<br>ip_hash;<br>server 192.168.0.14:88;<br>server 192.168.0.15:80;<br>}</p><p>其他策略可以自行查询学习,nginx还有很多其他可配置项，静态资源缓存，重定向等，想深入的童鞋请自行学习</p><p>nginx配置详解</p><p><strong>实际问题：虽然解决了，但是不是很理解，记录一下</strong></p><p>其中192.168.50.133:80是有外网映射的，外网55.125.55.55:5555映射到192.168.50.133:80上，此时使用55.125.55.55:5555访问，会映射到192.168.50.133:80上，然后会被转发到192.168.50.137:8080或192.168.50.139:8080，但是此时却出现图片，js，css等静态文件无法访问的情况，通过两种方法解决。</p><p><strong><1>.映射非80端口</1></strong></p><p>让55.125.55.55:5555映射192.168.50.133的非80端口，例如55.125.55.55:5555映射192.168.50.133:5555，然后再在nginx配置文件中配置如下，注意红色加大部分：这地方不理解</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">........ upstream blank &#123;</span><br><span class="line">        <span class="comment">#ip_hash;</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.50.137:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.50.139:8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#nginx监听5555端口，请求该端口时转发到真实目标</span></span><br><span class="line">            <span class="attribute">listen</span>       <span class="number">5555</span>;</span><br><span class="line">        <span class="comment">#配置访问域名</span></span><br><span class="line">            <span class="attribute">server_name</span>  <span class="number">192.168.11.133</span>;              </span><br><span class="line">         </span><br><span class="line">            <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment">#这里配置代理是指上面定义的两个被代理目标，blank名字必须一致</span></span><br><span class="line">                <span class="attribute">proxy_pass</span> http://blank;</span><br><span class="line">                 </span><br><span class="line">        <span class="comment">#proxy_redirect          off;</span></span><br><span class="line">        <span class="comment">#非80端口使用，目的是将代理服务器收到的用户的信息传到真实服务器上</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span>        Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    　　　　 <span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span>   <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">proxy_send_timeout</span>      <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span>      <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">proxy_buffer_size</span>       <span class="number">4k</span>;</span><br><span class="line">        <span class="attribute">proxy_buffers</span>           <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">        <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">            &#125;........</span><br></pre></td></tr></table></figure><p> 此时访问55.125.55.55:5555，映射到192.168.50.133:5555上，然后转发到192.168.50.137:8080或192.168.50.139:8080上，此时静态文件均能访问。</p><p> <strong><2>.使用域名在外网服务器上使用nginx进行转发</2></strong></p><p>将55.125.55.55绑定域名为test.baidubaidu.com，此时在55.125.55.55服务器上使用nginx,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">........location / &#123;</span><br><span class="line">        <span class="comment">#加入判断，如果域名为test.baidubaidu.com，转发到192.168.50.133:80，然后再进行转发，注意，此处未进行测试，貌似是这么写的，$host为nginx变量，可以获取域名    </span></span><br><span class="line">        if($host = "test.baidubaidu.com" )&#123;</span><br><span class="line">        　　<span class="attribute">proxy_pass</span> http://192.168.50.133:80;</span><br><span class="line">        &#125;</span><br><span class="line">                 </span><br><span class="line">        <span class="comment">#proxy_redirect          off;</span></span><br><span class="line">        <span class="comment">#非80端口使用，目的是将代理服务器收到的用户的信息传到真实服务器上，我也不是很理解</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span>        Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">client_max_body_size</span>    <span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span>   <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">proxy_send_timeout</span>      <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span>      <span class="number">300</span>;</span><br><span class="line">        <span class="attribute">proxy_buffer_size</span>       <span class="number">4k</span>;</span><br><span class="line">        <span class="attribute">proxy_buffers</span>           <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">        <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">            &#125;........</span><br></pre></td></tr></table></figure><p> 以上即nginx反向代理与负载均衡介绍，经过此次学习，发现nginx确实是博大精深，一个配置文件搞得我不要不要的。。。</p><h1 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h1><p>由于nginx是随机分配请求，假设一个用户登录时访问网站登录时被分配到192.168.50.137:8080上，然后进行了登录操作，此时该服务器上就会有该用户登录的session信息，然后登陆后重定向到网站首页或个人中心时，此时如果被分配到192.168.50.139:8080上，那么这台服务器上没有该用户session信息，于是又会变成未登录状态，所以由于nginx的负载均衡会导致session共享的问题。</p><p><strong>解决方法：</strong></p><p>1.nginx提供了ip_hash策略，可以保持用户ip进行hash值计算固定分配到某台服务器上，然后只要是该ip则会保持分配到该服务器上，保证用户访问的是同一台服务器，那么session问题就不存在了。这也是解决session共享的一种方式，也称为黏性session。但是假设一台tomcat服务器挂了的话，那么session也会丢失。所以比较好的方案是抽取session。</p><p>2.session存在memcache或者redis中，以这种方式来同步session，把session抽取出来，放到内存级数据库里面，解决了session共享问题，同时读取速度也是非常之快。</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161209013336616-1475474059.png" alt="img"></p><p>本例中：</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210032226226-287390560.png" alt="img"></p><p> <strong>Redis解决session共享：</strong></p><p>在redis服务器192.168.50.140上搭建redis，redis默认端口为6379</p><p><strong>Redis搭建：</strong></p><p>redis依赖gcc，先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++</span><br></pre></td></tr></table></figure><p>下载redis，我使用的是redis-3.2.1.tar.gz，上传至linux /usr/local/redis-src/中，解压</p><p>进入解压后目录redis-3.2.1，执行make命令进行编译</p><p>安装到目录/usr/local/redis</p><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis install</span><br></pre></td></tr></table></figure><p>安装完成之后将redis配置文件拷贝到安装目录下，redis.conf是redis的配置文件，redis.conf在redis源码目录,port默认6379。</p><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/redis-src/redis-``3.2``.``1``/redis.conf /usr/<span class="built_in">local</span>/redis/</span><br></pre></td></tr></table></figure><p>在redis安装目录启动和关闭redis：</p><p>启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210035234491-2112324971.png" alt="img"></p><p>这种启动方式叫做前端启动，必须保持在当前窗口，如果ctrl + c 退出，那么redis也就退出了，不建议使用</p><p>那么后端启动：</p><p>首先修改redis.conf中daemonize的值，打开可以看到默认是no，修改为daemonize yes，启动即可。也可以在该配置文件中修改redis默认端口6379为其他值。</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210035545319-539003657.png" alt="img"></p><p>关闭redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/redis-cli shutdown</span><br></pre></td></tr></table></figure><p>  至此，redis服务器搭建完成。</p><p> <strong>tomcat与redis集成实现session共享：</strong></p><p>环境为tomcat7 + jdk1.6的话：</p><p>在所有需要共享session的服务器的tomcat中目录下：</p><p>lib目录中添加以下三个jar包，注意版本最好一致，不然极容易出现错误，下边的测试是可用的：</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161209011942835-1106019887.png" alt="img"></p><p>conf目录中content.xml中加入：配置redis服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionHandlerValve"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.radiadesign.catalina.session.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">host</span>=<span class="string">"192.168.50.140"</span></span></span><br><span class="line"><span class="tag"><span class="attr">port</span>=<span class="string">"6379"</span></span></span><br><span class="line"><span class="tag"><span class="attr">database</span>=<span class="string">"0"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>环境为tomcat7 + jdk1.7或1.8的话：</p><p>在所有需要共享session的服务器的tomcat中目录下：</p><p>lib目录中添加以下三个jar包，测试通过：</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161209012259272-825047638.png" alt="img"></p><p>conf目录中content.xml中加入：配置redis服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">host</span>=<span class="string">"192.168.50.140"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">port</span>=<span class="string">"6379"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">database</span>=<span class="string">"0"</span>              </span></span><br><span class="line"><span class="tag"><span class="attr">maxInactiveInterval</span>=<span class="string">"60"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>根据我这测试，是jkd1.8+tomcat7，在137和139两台tomcat中加入jar包且进行如上配置：</p><p>上传jar包</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210041217944-704715113.png" alt="img"></p><p> 修改content.xml</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210041412757-1950717785.png" alt="img"></p><p><strong>启动redis服务，重新启动所有tomcat，启动nginx，刷新nginx页面,两台tomcat页面可以看到sessionid值不变，关闭某台tomcat，nginx中sessionid不变，说明session是共享的。</strong></p><p><strong>问题：</strong></p><p>有可能此时访问会报错，redis无法访问，这是由于redis的安全机制，默认只有127.0.0.1才能访问，在redis.conf中可以找到bind 127.0.0.1，你可以将此ip改为访问者ip，</p><p>如果有多个访问者，也可以把bind 127.0.0.1注释掉，然后在配置文件中找到protected-mode，修改protected-mode yes改为protected-mode no 关闭redis保护模式即可</p><p>详细可以参考这：<a href="http://www.cnblogs.com/liusxg/p/5712493.html" target="_blank" rel="noopener">http://www.cnblogs.com/liusxg/p/5712493.html</a></p><p><strong>经过大牛指点：添加两个注意点：</strong></p><p>1.按照如上配置,使用redis数据库,放入session中的对象必须要实现java.io.Serializable接口，使用memcache的可以不用实现Serializable接口</p><p>原因是:因为tomcat里使用的将session放置redis使用的工具类,是使用的jdk序列化模式存储的，这一点也是很容易理解的，session.setAttribute(String key, Object value)，存储Object类型</p><p>object放入redis中又要能取出来，只能是序列化进行存储了，然后取出的时候进行反序列化。</p><p>所以我们在session中存储的任何对象，都必须实现序列化接口。</p><p>2.按照如上配置,使用redis做session存储空间时,web应用的session-time的时间单位会变成[秒],而不是原本的[分]</p><p>原因是:因为tomcat里使用的将session放置redis使用的工具类,在存储时为对tomcat容器时间做转换，</p><p>在redis中设置过期时间是使用秒作为单位的，有个命令叫expire可以设置redis键值过期时间，所以在context.xml配置文件中我们需要制定session过期时间（默认是60秒，配成1800即30分钟），这一点很重要。</p><p><strong>请注意！！！！</strong></p><p><strong>context.xml配置说明：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve"</span> /&gt;</span>      </span><br><span class="line"><span class="tag">&lt;<span class="name">Manager</span> <span class="attr">className</span>=<span class="string">"com.orangefunction.tomcat.redissessions.RedisSessionManager"</span></span></span><br><span class="line"><span class="tag">//这里是<span class="attr">redis</span>服务器地址</span></span><br><span class="line"><span class="tag"><span class="attr">host</span>=<span class="string">"192.168.50.140"</span></span></span><br><span class="line"><span class="tag">//这里是<span class="attr">redis</span>端口，<span class="attr">redis</span>默认端口是<span class="attr">6379</span></span></span><br><span class="line"><span class="tag"><span class="attr">port</span>=<span class="string">"6379"</span></span></span><br><span class="line"><span class="tag">//这里是<span class="attr">redis</span>数据库中的标识，标识第<span class="attr">0</span>个，默认使用<span class="attr">0</span>即可</span></span><br><span class="line"><span class="tag"><span class="attr">database</span>=<span class="string">"0"</span>            </span></span><br><span class="line"><span class="tag">//需要注意的是这里由于<span class="attr">redis</span>过期时间默认设置为<span class="attr">60</span>，单位是秒，<span class="attr">session</span>过期时间为<span class="attr">30</span>分钟，所以需要设置为<span class="attr">1800</span>对应<span class="attr">30</span>分钟</span></span><br><span class="line"><span class="tag"><span class="attr">maxInactiveInterval</span>=<span class="string">"1800"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h1 id="keepalived高可用"><a href="#keepalived高可用" class="headerlink" title="keepalived高可用"></a>keepalived高可用</h1><p>架构图：</p><p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//gAUU29mdHdhcmU6IFNuaXBhc3Rl/9sAQwAIBgYHBgUIBwcHCQkICgwUDQwLCwwZEhMPFB0aHx4dGhwcICQuJyAiLCMcHCg3KSwwMTQ0NB8nOT04MjwuMzQy/9sAQwEJCQkMCwwYDQ0YMiEcITIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy/8AAEQgCAgQ7AwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A9/ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiss+JdBBIOt6aCOoN0n+NH/AAk2gf8AQc03/wAC4/8AGp5o9zb6vW/kf3P/ACNSisv/AISbQP8AoOab/wCBcf8AjR/wk2gf9BzTf/AuP/Gjmj3D6vW/kf3P/I1KKy/+Em0D/oOab/4Fx/40f8JNoH/Qc03/AMC4/wDGjmj3D6vW/kf3P/I1KKy/+Em0D/oOab/4Fx/40f8ACTaB/wBBzTf/AALj/wAaOaPcPq9b+R/c/wDI1KKy/wDhJtA/6Dmm/wDgXH/jR/wk2gf9BzTf/AuP/Gjmj3D6vW/kf3P/ACNSisv/AISbQP8AoOab/wCBcf8AjR/wk2gf9BzTf/AuP/Gjmj3D6vW/kf3P/I1KKy/+Em0D/oOab/4Fx/40f8JNoH/Qc03/AMC4/wDGjmj3D6vW/kf3P/I1KKy/+Em0D/oOab/4Fx/40f8ACTaB/wBBzTf/AALj/wAaOaPcPq9b+R/c/wDI1KKyx4l0FiANb00k8AC6T/GtSmmnsROnOHxJr1TX5pBRRRTICiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDh/AWh6ReeCtPuLrSrGeZ/M3SS26MxxIwGSRnoK6T/hGdA/6Aem/wDgJH/hWV8Of+RC03/tr/6NeuprKnGPItOh6OPr1ViqqU38T6vv6mX/AMIzoH/QD03/AMBI/wDCj/hGdA/6Aem/+Akf+FalFXyx7HJ9Yrfzv73/AJmX/wAIzoH/AEA9N/8AASP/AAo/4RnQP+gHpv8A4CR/4VqUUcsewfWK387+9/5mX/wjOgf9APTf/ASP/Cj/AIRnQP8AoB6b/wCAkf8AhWpRRyx7B9Yrfzv73/mZf/CM6B/0A9N/8BI/8KP+EZ0D/oB6b/4CR/4VqUUcsewfWK387+9/5mX/AMIzoH/QD03/AMBI/wDCj/hGdA/6Aem/+Akf+FalFHLHsH1it/O/vf8AmZf/AAjOgf8AQD03/wABI/8ACj/hGdA/6Aem/wDgJH/hWpRRyx7B9Yrfzv73/mZf/CM6B/0A9N/8BI/8KP8AhGdA/wCgHpv/AICR/wCFalFHLHsH1it/O/vf+Zw/j3Q9Is/BWoXFrpVjBMnl7ZIrdFYZkUHBAz0NdxXLfEb/AJELUv8Atl/6NSupqYpKbt2X6nRWnKeFg5Nv3pb69I9wooorQ4QooooAKKKKACiiigAooooAKKKKACiikcFkZQxUkY3DGR780MDFuPF2gW5izq9k4kkEeY7hG2Z7tg8DtntnnjmrsOsabcwTz21/b3McC7pTbyCTYME8hcnsfyrk/wC0JhZMNL1q+kFveR2qwRpa5aMkKCoMSgA8hTnHHWui0mGdWubi9N+GZQh+3C2BKjJ6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ztA6nqBkkfruH4V2dcFH/wAU/wDFeRPu2usw7h6eYP65B/77rKfuyUvkejhP3uHq0OtuZesd/wDyV/gamhf8j74t/wC3P/0Ua6muW0L/AJH3xb/25/8Aoo11NVT2+b/Myx38Vf4Yf+koKKKKs4wooryi+W2GqXp22lw5muPNghiHnEfa4cCQlvmyM7QQO/Ws51ORo7MHhPrLkr2ser0Vxfh9Yhq8l3b6Ulq0lk0lukFpDEGjLKRuKytljgYztHDfhitfWx1KaYamBd3EeJWvNVEKhl6bfs8pAAyfkbGc8N1qXVslc2jlzlNxT2S6X/J/j30PTqK4T7VbTeDLi3mmu5IHdQ13cXltKGfcCVUtMQAAOFY9P7x68/cwQrbMbewu/sX2jz0nmt7NYC3lhdpbPkhT2fB5OME0pVrPYullnO2nK1nbb/g7+W563RXK6WdG/wCELi+3mKTT7Qnd5rRujHJxlY2ZW5bhfXGBnFaPhq3kt9PmJt3tYJbh5ba2cbTDGcYXb/Dk5bb23YrVSu7HHUw6gpO+zttv/wAG2r7GzRRRVHMFFFFAHLa7/wAj74S/7fP/AEUK6muW13/kffCX/b5/6KFdTUQ3l6/ojsxP8Kj/AIX/AOlSEZgqlmICgZJPavP9DU+MfGk+vygnTdOPk2Snoz/3v6/ivpV7x/q062tv4f0451DU28vAP3Y+hJ9M9Ppu9K6TRdJg0TR7bT7cfJCuC2OWbux+pqH787dF+ZvT/wBlwzq/bqXS8o9X89l8y/RRRWx5gVBe2cOoWM9ncLuhmQo49iKnooGm4tNbnDeALyawmv8AwrfNm409y0JP8cRPb8wfow9K7muE8dW8ujanp3i2zQlrVxFdKv8AHGeOfzI/EeldtbXEV3axXMDh4pUDow7gjINZUtLwfT8j0MelU5cVHae/lJb/AH7/ADJaKKK1POCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACuW+I3/Ihal/2y/wDRqV1NZfiLRhr+g3Olmcweft/eBd23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QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVy3jb/AJl3/sN23/s1dTXLeNv+Zd/7Ddt/7NUVPgf9dUdmA/3mPz/9JkdTRRRVnGFI5KoxVdxAyFHf2paRgGUqc4IxwcGk9tARysPiqVdGmu52gkuw0cf2NIJElgkc4COpyzYz1AGcHA6VYttc1I2upFrKW6ktoRLA62U1sJjg/JskycgjsTkMO9Wn8N206XAvLm6upJkWPzpGVXjCksu3YqgEMc5wTnvVyHT5I7eaOTUbyaSQY852QMnptCqFHr0575AArNKfU9CdXC2fLHr5+W3lutdX6mJJ4inXSobmO8s5lacxz3aWsmy2AUn95Fu3KcgDkjGQTijWtWhspNL1GWOC58u3uJlkiY4OIwfkIOMN75rSTQ/KSVo9TvkuZpBJLcjy974UKARs2YwB0Xt9aG8Oae9vZ27I7QWsLwrGWyGV12nd3PHvQ1Nr7hqrhoyTtpreytdNf0l5atJkUd7q1pfWEeo/Y5Ir1mjxAjKYZAhcDJY7xhWGcL0HHPFO11rVmtdNv7kWf2a7nWBoY0beu4kBgxbHUD5cdCea07XQ47e5gmlvLu7NspW3WdlIiyMEjaoJOOMsSevPJy4aJbLYWdmHl8u0lSVDkZJU5GeOlO0r/wBd1+lyPa0NrJ99Lfzba6fZ/rfSooorQ4Qrlvhz/wAiFpv/AG1/9GvXU1y3w5/5ELTf+2v/AKNeofxr0f6HZD/dJ/4o/lI6miiirOMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArlvG3/ADLv/Ybtv/Zq6muW8bf8y7/2G7b/ANmqKnwP+uqOzAf7zH5/+kyOpoooqzjCiiigAooooAKKKKACiiigAooooAK5b4c/8iFpv/bX/wBGvXU1y3w5/wCRC03/ALa/+jXqH8a9H+h2Q/3Sf+KP5SOpoooqzjCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAjnmEEDylJHCjO2NSzH2AFZEfiIPoZ1E2ciSG4a2jty43M/mGNQSOBk9cZxz177dczaWCv4YuYL63uVH2ueUeUh81P37MrqMZJHDDAOfQ5wYk3fTt+p1UI03G811X3O//ANCDVbuRry1exjGoW4RvJSfKOr52tvKg44bPy5GOAeMy6dqU11d3dnd2yQXVtsZhHKZEZXB2kMVU/wsMEdqwYzfWEeqazbx313LMsMEP2qFvMbDMDIY0UEKN/3QoJCk98m/pM1vY2F5cIup3t0F864kls5I5J2A6IrKo7YCr0/UypPqb1aEFFuKvslbvpfroumvV76Mu3esfZdWsrAWkz/aZChmPyonyM3GeWPy9uB3PYvvL+4jvEs7G1S4uCnmP5kvlpGmcDLBWOSc4AHY9MVX1SOWfUdCljhkKpdM7/KfkBhcfN6ckD6ms/V9PtP7cuLrUtOlvrWe1SONUt2mxIpf+EA4JDcMcY55GaJOST9f0Ip06UuW66P5u9u66a2uti/f6xd210bS2sI5547b7TMGuNiqucbVO07iSD1AHHUVieMr+OXSfDeooreU+qWs6qwwcFWbB9DUcmmzBIF8QJqMwXTVgjNl5rsXOfNDmPkk4T73ynB96reKXuF0jwnY6pbTyXD31u1w0a5XIBDJlf4ju4A9DjpWdST5Jfh953YahTjWp8uurvbquWd7a/5W213Ow0q9vr21S6u7S3topIlkTy7hpGwRnDAouOPc1Us9fluJrFprIQ2eobvss3m5ZuCy712jbuUEjBPSqul27NqE8NgNQTSms/LYXvm4WXOF2CX5sbc5x8v3e+agsFubiDQbJ7K4il0w7rovCVUFImjARiMNuLAjaelaczuv66/5HK6NO8tF+VlZtdXrey3f46bet6t/Y2mTXYtZrkxoz7IxgcDOWY8KP19AelT3t+ljpz3bqWwo2xr952PCqPckgD61n608mp+DL54bW4WWezcrA8ZEoJX7pUd/al1DSr68u7O5gvII0tkJWCe2aQeYRjfw68gZAz0yfwcnJJ2/rcwhTp8q59Gm769ktNL210v/AMAZb+IJr2y0x7SyR7u/gM4ikmKpGgAyS4UnqygfLzmrun6xb3tnBNIy28srtF5MjjcJFJDIPUgqfwGa5rQ4b7SLbQ7y+gmeNbFraRYbVzJCTsZQyjcx+6wJAHOOBWlp9v5FlareadK093dTzIRCH+y+YXYFj/D8pwT6nFJSf9fL8zor0KUbqO19Gn5yutX0SX/BujRsNQutQk86O0jTT2z5czzHzHA6MEC42nt82cYOO1NuNTurTUII5rJRaTzeSkyzZcMQSCU24CnB5DE9Mgc45/R9MFtNosNvp80GoWmUvrlomUPGEK4MhGJATsIAJwAOmKv3gM+uW0llb34vUuQJTPG5gWLozKWygJXpsIYk8/xChSdl/XYU6FNVWltZ/rZ79bJ3/DUtXWq6raXlrBJp1mwuZ/KTy71y+OSW2mIDAAJPPt3pLvxBJbyXskdmJLGwYJdTGXawOAzbE2ndtDAnJHfGalhhluPFNzdSxOsVrAsFuWUgMX+aQj16IMj0NZOvaYtzLfWdmdSim1ABZI44/wDR3JXHmM+35cDqAwJ2gYOeRuSV1/X9aipQoynGM0tlfe2r169I/jujrQQRkdKKRV2qFHQDFLWp5wVy3w5/5ELTf+2v/o166muW+HP/ACIWm/8AbX/0a9Q/jXo/0OyH+6T/AMUfykdTRRRVnGFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVy3jb/mXf8AsN23/s1dTXLeNv8AmXf+w3bf+zVFT4H/AF1R2YD/AHmPz/8ASZHU0UUVZxhRRRQAUUUUAFFFFABRRRQAUUUUAFct8Of+RC03/tr/AOjXrqa5b4c/8iFpv/bX/wBGvUP416P9Dsh/uk/8UfykdTRRRVnGFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVy3jb/mXf+w3bf+zV1NYPirSL7V7Sx/s57ZLmzvY7tftBbYdgPB2jPUioqJuLsdWClGOIi5Oy1/KS/U3qK5b/AIr3/qW//I9H/Fe/9S3/AOR6Ofyf3FfU/wDp5D/wL/7U6miuW/4r3/qW/wDyPR/xXv8A1Lf/AJHo5/J/cH1P/p5D/wAC/wDtTqaK5b/ivf8AqW//ACPR/wAV7/1Lf/kejn8n9wfU/wDp5D/wL/7U6miuW/4r3/qW/wDyPR/xXv8A1Lf/AJHo5/J/cH1P/p5D/wAC/wDtTqaK5b/ivf8AqW//ACPR/wAV7/1Lf/kejn8n9wfU/wDp5D/wL/7U6miuW/4r3/qW/wDyPR/xXv8A1Lf/AJHo5/J/cH1P/p5D/wAC/wDtTqa5b4c/8iFpv/bX/wBGvR/xXv8A1Lf/AJHrQ8KaRPoPhqz025eN5od+5oySpy7NxkD1qU25p2LnCNLDShzxbco7O+yl5LubNFFFanAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH//Z" alt="img"></p><p>上图画的不对称好难看，将就下吧</p><p>根据上边一路走来，已经是搭好了从nginx主到服务器的这条线的，那么同理，使用nginx备机192.168.50.135上再搭建nginx，也是代理192.168.137和139两台服务器。搞了一次之后也就简单了</p><p>在192.168.50.135上安装nginx，配置nginx配置即可，不再赘述，nginx备机配置如下：</p><p>配置和上边的是一样的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">........upstream blank &#123;</span><br><span class="line">        <span class="comment">#ip_hash;</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.50.137:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.50.139:8080</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"> </span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://blank;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;........</span><br></pre></td></tr></table></figure><p>那么现在就是相当于有两套nginx了，代理的服务器是一样的，为什么要搞两套？</p><p>假设只有一台nginx的话，这个nginx服务器挂了。那怎么办？</p><p>所以需要一台备份nginx。</p><p>正常情况下，主nginx作为反向代理服务器即可，假设nginx服务器挂了的话，能够立即切换到备份机上，保证用户可以访问，然后运维人员把主nginx服务器故障修好之后，又能够自动切换到主nginx提供服务。通过keepalived来监测两台服务器，正常情况时，将nginx主服务器ip（192.168.50.133）绑定到keepalived定义的一个虚拟ip（我设置为192.168.50.88）上，通过这个虚拟IP可以访问nginx，然后备机（192.168.50.135）啥事不干，就是每隔一小段时间（设置为1秒）keepalived会告诉备机，你不用管，我还活着呢，如果突然主机死了，那么就会超过一秒备机没有收到主机或者的消息，那么备机马上接管主机，keeplived将虚拟ip绑定到备机身上，网站继续提供服务。</p><p>突然主机又复活了（运维人员排除故障了），那么备机又将收到主机的活着的消息，于是将管理权交回给主机，虚拟ip又绑到主机上，大概就是这么个过程，个人理解。</p><p><strong><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210053320116-1854584241.png" alt="img"></strong></p><p> <strong>先在两台nginx服务器（主备）上都装上keepalived：</strong></p><p> 下载：这里使用rpm安装，是区分32,64位的，不要搞错了哦</p><p>keepalived-1.2.7-3.el6.x86_64.rpm</p><p>openssl-1.0.1e-30.el6_6.4.x86_64.rpm</p><p>要求必须是openssl-1.0.1e或以上才行、如果版本已经符合（因为安装nginx时已经安装openssl，使用yum安装应该是符合的）、不用再安装openssl，使用 rpm -q openssl 查看当前openssl版本，我这已经是1.0.1e 48的，所以就不安装了</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210133227866-1513518612.png" alt="img"></p><p>将两个rpm安装包上传到两台nginx服务器，进入上传到的目录，运行以下命令安装:–nodeps是忽略依赖包，当然最好是把依赖包装上，去掉–nodeps可以看到错误，需要哪些依赖包</p><p>如果需要安装openssl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm –Uvh --nodeps ./openssl-``1.0``.1e-``30``.el6_6.``4``.x86_64.rpm</span><br></pre></td></tr></table></figure><p> 安装keepalived：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``rpm -Uvh --nodeps ./keepalived-``1.2``.``7``-``3``.el6.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>安装完毕后再/etc/keepalived/目录下有个文件 keepalived.conf即是本台服务器keepalived的核心配置文件了：</strong></p><p><strong>重点：keepalived配置，配置文件上边部分按照下面的配置就行了，配置文件后面的内容可以不用管，还没有去研究其他部分</strong></p><p>先配置主机192.168.50.133的keepalived，按下边进行配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这是全局配置</span></span><br><span class="line"><span class="section">global_defs</span> &#123;</span><br><span class="line">   <span class="comment">#指定keepalived在发生切换时需要发送email到的对象，一行一个</span></span><br><span class="line">   <span class="section">notification_email</span> &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#指定发件人</span></span><br><span class="line">   <span class="attribute">notification_email_from</span> Alexandre.Cassen<span class="variable">@firewall</span>.loc</span><br><span class="line">   <span class="comment">#指定smtp服务器地址</span></span><br><span class="line">   <span class="comment">#smtp_server 192.168.200.1</span></span><br><span class="line">   <span class="comment">#指定smtp连接超时时间</span></span><br><span class="line">   <span class="comment">#smtp_connect_timeout 30</span></span><br><span class="line">   <span class="comment">#运行keepalived机器的一个标识</span></span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#主备配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment">#标示状态为MASTER 备份机为BACKUP</span></span><br><span class="line">    <span class="attribute">state</span> MASTER</span><br><span class="line">    <span class="comment">#设置keepalived实例绑定的服务器网卡，一般为eth0，linux使用ifconfig命令可查看当前服务器网卡标识名</span></span><br><span class="line">    interface eth0</span><br><span class="line">    <span class="comment">#同一实例下（即同一组主备机下）virtual_router_id必须相同</span></span><br><span class="line">    virtual_router_id <span class="number">51</span></span><br><span class="line">    <span class="comment">#MASTER权重要高于BACKUP，MASTER为100则BACKUP最大为99</span></span><br><span class="line">    priority <span class="number">100</span></span><br><span class="line">    <span class="comment">#MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒，设置为1秒</span></span><br><span class="line">    advert_int <span class="number">1</span></span><br><span class="line">    <span class="comment">#设置认证</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        <span class="comment">#主从服务器验证方式，PASS为明文密码验证</span></span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">        <span class="comment">#密码</span></span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#设置虚拟IP，与我们的主备机在同一网段下，最后一位随便给就是拉，可以设置多个，换行即可</span></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.50.88</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备机192.168.50.135的keepalived配置：</p><p>备机配置注意的地方：<strong>需要修改state为BACKUP , priority比MASTER低，virtual_router_id和master的值一致</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这是全局配置</span></span><br><span class="line"><span class="section">global_defs</span> &#123;</span><br><span class="line">   <span class="comment">#指定keepalived在发生切换时需要发送email到的对象，一行一个</span></span><br><span class="line">   <span class="section">notification_email</span> &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#指定发件人</span></span><br><span class="line">   <span class="attribute">notification_email_from</span> Alexandre.Cassen<span class="variable">@firewall</span>.loc</span><br><span class="line">   <span class="comment">#指定smtp服务器地址</span></span><br><span class="line">   <span class="comment">#smtp_server 192.168.200.1</span></span><br><span class="line">   <span class="comment">#指定smtp连接超时时间</span></span><br><span class="line">   <span class="comment">#smtp_connect_timeout 30</span></span><br><span class="line">   <span class="comment">#运行keepalived机器的一个标识</span></span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#主备配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment">#备机为BACKUP</span></span><br><span class="line">    <span class="attribute">state</span> BACKUP</span><br><span class="line">    <span class="comment">#备机网卡标识，一般都是eth0，先查询一下</span></span><br><span class="line">    interface eth0</span><br><span class="line">    <span class="comment">#virtual_router_id必须与主机相同</span></span><br><span class="line">    virtual_router_id <span class="number">51</span></span><br><span class="line">    <span class="comment">#权重，备机必须比主机小</span></span><br><span class="line">    priority <span class="number">99</span></span><br><span class="line">    <span class="comment">#MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒，设置为1秒</span></span><br><span class="line">    advert_int <span class="number">1</span></span><br><span class="line">    <span class="comment">#认证，与主机一致</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#虚拟IP，绑定的虚拟ip与主机一致</span></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.50.135</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>酱紫，keepalived就配置完成了。</p><p>keeplived启动关闭命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start``service keepalived stop</span><br></pre></td></tr></table></figure><p>启动两台nginx，启动主机keepalived，启动备机keepalived服务。</p><p>这时，nginx主机在提供服务，备机是闲着的，虚拟ip是192.168.50.88，在主机和备机上使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p> 可以发现：</p><p><strong>主机：可以看到，192.168.50.133 带有虚拟ip192.168.50.88</strong>，在浏览器中输入192.168.50.88，即可访问到主nginx192.168.50.133.然后转发到tomcat服务器上</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210141242882-701187483.png" alt="img"></p><p> 浏览器访问虚拟ip：192.168.50.88，效果如下</p><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210141512835-1512216780.png" alt="img"></p><p> <strong>备机：ip addr命令执行：可以看到，备机nginx没有绑定虚拟ip</strong></p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210141645413-2057533357.png" alt="img"></p><p> 以上是初始状态下的情况，也是正常服务的情况。</p><p><strong>现在测试高可用，假设主机nginx服务器挂了，模拟为关闭nginx主机或者将keepalived服务停止，那么主机上keepalived死了就没办法告诉备机自己活着，而备机超过1秒没有接收到主机给自己的消息，马上接管虚拟ip，同时在配置文件中配置切换主备机时发送邮件，此时开发团队收到邮件即知道主机挂了，马上去排除主机的故障。</strong></p><p>将主机上的keepalived服务停止，service keepalived stop ,然后查看虚拟ip绑定情况，</p><p><strong>主机挂了：可以看到虚拟ip就没有绑在主机上</strong></p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210142401038-1734875767.png" alt="img"></p><p><strong>备机情况：虚拟ip已经绑定到备机，此时主机虽然挂了，但是切换到备机上了（发现故障和切换的时间差最大也就是1秒），虚拟ip也绑到备机上了，访问虚拟ip，就会请求备机nginx然后转发到web服务器实现高可用。</strong></p><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210143801194-1005494402.png" alt="img"></p><p> <strong>运维人员收到邮件后就去排除主机故障了，搞定之后（模拟为keepalived服务启动），这时主机告诉备机，我又活了，于是备机将管理权又交给主机（切换为主机nginx提供服务）：</strong></p><p><strong>主机keepalived服务启动后，即吧主机维护好之后：可以看到，虚拟ip又自动绑到了主机上</strong></p><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210144429507-2028529502.png" alt="img"></p><p> <strong>备机情况，主机活了之后，备机转交管理权，虚拟ip切换到主机上，备机不绑定虚拟ip,貌似启动keepalived服务之后并不能马上切回，应该是起服务需要点时间吧，但是不影响，这段时间还是备机绑定虚拟IP的</strong></p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210144333101-695639547.png" alt="img"></p><p> 这就是keepalived高可用的模拟。</p><p><strong>注意问题：</strong></p><p><strong>主机挂了之后，主机nginx恢复时，一定要将nginx也启动，否则即使虚拟ip切换到了主机上，但是主机nginx没起那也是没法转发的。所以要把\</strong>nginx启动要加在开机启动中。****</p><h1 id="Nginx服务开机自启动"><a href="#Nginx服务开机自启动" class="headerlink" title="Nginx服务开机自启动"></a>Nginx服务开机自启动</h1><p>在linux系统的/etc/init.d/目录下创建nginx文件，使用如下命令：（vim命令不会的自己去学吧哈哈）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/init.d/nginx</span><br></pre></td></tr></table></figure><p>将如下内容搞到该文件中:注意红色部分修改成你的路径即可，<strong>nginxd</strong>值是启动nginx的nginx路径，<strong>nginx_config</strong>值是nginx配置文件nginx.conf路径，<strong>nginx_pid</strong>值是nginx.pid所在路径，如果按照我方法安装的话，是在nginx安装目录的logs里边的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nginx Startup script <span class="keyword">for</span> the Nginx HTTP Server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it is v.0.0.2 version.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chkconfig: - 85 15</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description: Nginx is a high-performance web and proxy server.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">              It has a lot of features, but it<span class="string">'s not for everyone.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> processname: nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pidfile: /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> config: /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span></span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog="nginx"</span><br><span class="line"><span class="meta">#</span><span class="bash"> Source <span class="keyword">function</span> library.</span></span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"><span class="meta">#</span><span class="bash"> Source networking configuration.</span></span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"><span class="meta">#</span><span class="bash"> Check that networking is up.</span></span><br><span class="line">[ $&#123;NETWORKING&#125; = "no" ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> Start nginx daemons <span class="built_in">functions</span>.</span></span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo "nginx already running...."</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $"Starting $prog: "</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Stop nginx daemons <span class="built_in">functions</span>.</span></span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $"Stopping $prog: "</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> reload nginx service <span class="built_in">functions</span>.</span></span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $"Reloading $prog: "</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> See how we were called.</span></span><br><span class="line">case "$1" in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $"Usage: $prog &#123;start|stop|restart|reload|status|help&#125;"</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure><p>然后设置该文件的访问权限：执行以下命令，意为所有用户可访问</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure><p> 最后将ngix加入到rc.local文件中，这样开机的时候nginx就默认启动了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210151054194-750610516.png" alt="img"></p><p>保存并退出，下次重启就会生效，nginx的开机自启动。测试无误的。</p><h1 id="解决nginx进程和keepalived不同时存在问题"><a href="#解决nginx进程和keepalived不同时存在问题" class="headerlink" title="解决nginx进程和keepalived不同时存在问题"></a>解决nginx进程和keepalived不同时存在问题</h1><p>keepalived是通过检测keepalived进程是否存在判断服务器是否宕机，如果keepalived进程在，但是nginx进程不在了，那么keepalived是不会做主备切换。因为是nginx挂了，然后无法做代理，keepalived还在不会切换到备机。</p><p>所以一直检测nginx是否还在，如果不在，那么让keepalived也停止，同生共死。</p><p>注：只需要在主机上搞就行了，备机没必要检测nginx，因为基本是主机在服务。</p><p>解决：写个脚本来监控nginx进程是否存在，如果nginx不存在就将keepalived进程杀掉。</p><p>注：keepalived不需要开机启动，假如开机自启的话，如果keepalived比nginx 更快启动的话，脚本检测会把keepalived停掉的，所以没必要，只需要nginx开机启动，启动主机后自行手动的把keepalived服务启动即可。</p><p>在主nginx上编写nginx进程检测脚本（check_nginx_dead.sh）,在keepalived配置文件目录下创建脚本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/keepalived/check_nginx_dead.sh</span><br></pre></td></tr></table></figure><p>把下边这些内容搞到脚本文件中，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 如果进程中没有nginx则将keepalived进程kill掉</span><br><span class="line">A=`ps -C nginx --no-header |wc -l`      ## 查看是否有 nginx进程 把值赋给变量A</span><br><span class="line">if [ $A -eq 0 ];then                    ## 如果没有进程值得为 零</span><br><span class="line">       service keepalived stop          ## 则结束 keepalived 进程</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>给访问权限：不然不行哦，这里卡了我半小时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x /etc/keepalived/check_nginx_dead.sh</span><br></pre></td></tr></table></figure><p>先测试一下脚本：</p><p>把nginx停了，此时keepalived还在运行，所以不会切换，虚拟ip无法访问到web服务器</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210164416866-1695444383.png" alt="img"></p><p>然后执行脚本：</p><p>主机脚本检测nginx不在了，把keepalived停掉，从输出可以看到确实停止了，主机虚拟没有绑定虚拟ip</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210164620554-1932400026.png" alt="img"></p><p>备机：成功绑定虚拟ip</p><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210164655538-1777482179.png" alt="img"></p><p>所以，只需要让该脚本一直执行，即一直检测nginx进程是否在，如果没得了，那么直接停止主机keepalived，切换备机，保证能够访问web服务器。</p><p>按如下修改keepalived配置文件keepalived.conf，添加脚本定义检测：</p><p>只需要在正确的位置添加红色部分即可：那么脚本则是两秒执行一次，一旦发现主机nginx不在了，keepalived停止，切换备机</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"> </span><br><span class="line"><span class="comment">#这是全局配置</span></span><br><span class="line"><span class="section">global_defs</span> &#123;</span><br><span class="line">   <span class="comment">#指定keepalived在发生切换时需要发送email到的对象，一行一个</span></span><br><span class="line">   <span class="section">notification_email</span> &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#指定发件人</span></span><br><span class="line">   <span class="attribute">notification_email_from</span> Alexandre.Cassen<span class="variable">@firewall</span>.loc</span><br><span class="line">   <span class="comment">#指定smtp服务器地址</span></span><br><span class="line">   <span class="comment">#smtp_server 192.168.200.1</span></span><br><span class="line">   <span class="comment">#指定smtp连接超时时间</span></span><br><span class="line">   <span class="comment">#smtp_connect_timeout 30</span></span><br><span class="line">   <span class="comment">#运行keepalived机器的一个标识</span></span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">vrrp_script check_nginx_dead &#123;</span><br><span class="line">    <span class="comment">##监控脚本路径</span></span><br><span class="line">    <span class="attribute">script</span> <span class="string">"/etc/keepalived/check_nginx_dead.sh"</span></span><br><span class="line">    <span class="comment">##时间间隔，2秒</span></span><br><span class="line">    interval <span class="number">2</span></span><br><span class="line">    <span class="comment">##权重</span></span><br><span class="line">    weight <span class="number">2</span>                                            </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#主备配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="comment">#标示状态为MASTER 备份机为BACKUP</span></span><br><span class="line">    <span class="attribute">state</span> MASTER</span><br><span class="line">    <span class="comment">#设置keepalived实例绑定的服务器网卡，一般为eth0，linux使用ifconfig命令可查看当前服务器网卡标识名</span></span><br><span class="line">    interface eth0</span><br><span class="line">    <span class="comment">#同一实例下（即同一组主备机下）virtual_router_id必须相同</span></span><br><span class="line">    virtual_router_id <span class="number">51</span></span><br><span class="line">    <span class="comment">#MASTER权重要高于BACKUP，MASTER为100则BACKUP最大为99</span></span><br><span class="line">    priority <span class="number">100</span></span><br><span class="line">    <span class="comment">#MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒，设置为1秒</span></span><br><span class="line">    advert_int <span class="number">1</span></span><br><span class="line">    <span class="comment">#设置认证</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">    <span class="comment">#主从服务器验证方式，PASS为明文密码验证</span></span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">    <span class="comment">#密码</span></span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    track_script &#123;</span><br><span class="line">    <span class="comment">#监控脚本</span></span><br><span class="line">        <span class="attribute">check_nginx_dead</span>     </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#设置虚拟IP，与我们的主备机在同一网段下，最后一位随便给就是拉，可以设置多个，换行即可</span></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.50.88</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后，重新启动主机keepalived服务即可。</p><p><strong>测试：</strong></p><p>回到负载均衡高可用的初始状态，保证主、备上的keepalived、nginx全部启动。</p><p>停止主nginx服务：</p><p>主机查看keepalived进程，发现没有，说明已经停止了，虚拟ip也没有绑在主机上</p><p><img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210172645757-50735121.png" alt="img"></p><p> 备机：绑定虚拟ip，切换成功。</p><p> <img src="/2020/03/23/【转载】Nginx反向代理，负载均衡，redis-session共享，keepalived高可用/824587-20161210172826429-550094922.png" alt="img"></p><p>  测试通过，如果主机nginx挂了之后，keepalived也会随着挂掉，然后切换备机。</p><h1 id="nginx-conf配置文件详解"><a href="#nginx-conf配置文件详解" class="headerlink" title="nginx.conf配置文件详解"></a>nginx.conf配置文件详解</h1><p>Nginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。main 部分设置的指令影响其他所有部分的设置；server 部分的指令主要用于制定虚拟主机域名、IP 和端口号；upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。</p><p>当前 nginx 支持的几个指令上下文()：</p><h2 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h2><hr><p>下面是 nginx.conf 详细的配置文件介绍（<strong>以下配置参数很多时候并不一定用的到，只是作为配置参数说明参考，可以看下面的通用版介绍</strong>）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义Nginx运行的用户和用户组</span></span><br><span class="line"><span class="attribute">user</span> www www; </span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx进程数，通常设置成和cpu的数量相等</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程pid文件</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定进程可以打开的最大描述符：数目</span></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="comment">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span></span><br><span class="line"><span class="comment">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span></span><br><span class="line">    <span class="comment">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span></span><br><span class="line">    <span class="comment">#补充说明：</span></span><br><span class="line">    <span class="comment">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span></span><br><span class="line">    <span class="comment">#A）标准事件模型</span></span><br><span class="line">    <span class="comment">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span></span><br><span class="line">    <span class="comment">#B）高效事件模型</span></span><br><span class="line">    <span class="comment">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span></span><br><span class="line">    <span class="comment">#Epoll：使用于Linux内核2.6版本及以后的系统。</span></span><br><span class="line">    <span class="comment">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span></span><br><span class="line">    <span class="comment">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数+进程数）</span></span><br><span class="line">    <span class="comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#keepalive 超时时间</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span></span><br><span class="line">    <span class="comment">#分页大小可以用命令getconf PAGESIZE 取得。</span></span><br><span class="line">    <span class="comment">#[root@web001 ~]# getconf PAGESIZE</span></span><br><span class="line">    <span class="comment">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class="line">    <span class="attribute">open_file_cache</span> max=<span class="number">65535</span> inactive=<span class="number">60s</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span></span><br><span class="line">    <span class="attribute">open_file_cache_valid</span> <span class="number">80s</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class="line">    <span class="comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span></span><br><span class="line">    <span class="attribute">open_file_cache_min_uses</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span></span><br><span class="line">    <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class="line">http&#123;</span><br><span class="line">    <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#默认编码</span></span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#服务器名字的hash表大小</span></span><br><span class="line">    <span class="comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span></span><br><span class="line">    <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span></span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设定通过nginx上传文件的大小</span></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">8m</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class="line">    <span class="comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#长连接超时时间，单位是秒</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">120</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#gzip模块设置</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启gzip压缩输出</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;    <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;    <span class="comment">#压缩缓冲区</span></span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>; <span class="comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;     <span class="comment">#压缩等级</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;    <span class="comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开启限制IP连接数的时候需要使用</span></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#负载均衡配置</span></span><br><span class="line">    <span class="attribute">upstream</span> piao.jd.com &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.121:80</span> weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.122:80</span> weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.123:80</span> weight=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx的upstream目前支持4种方式的分配</span></span><br><span class="line">        <span class="comment">#1、轮询（默认）</span></span><br><span class="line">        <span class="comment">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span></span><br><span class="line">        <span class="comment">#2、weight</span></span><br><span class="line">        <span class="comment">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14 weight=10;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15 weight=10;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#2、ip_hash</span></span><br><span class="line">        <span class="comment">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span></span><br><span class="line">        <span class="comment">#例如：</span></span><br><span class="line">        <span class="comment">#upstream bakend &#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.14:88;</span></span><br><span class="line">        <span class="comment">#    server 192.168.0.15:80;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#3、fair（第三方）</span></span><br><span class="line">        <span class="comment">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server server1;</span></span><br><span class="line">        <span class="comment">#    server server2;</span></span><br><span class="line">        <span class="comment">#    fair;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#4、url_hash（第三方）</span></span><br><span class="line">        <span class="comment">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span></span><br><span class="line">        <span class="comment">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span></span><br><span class="line">        <span class="comment">#upstream backend &#123;</span></span><br><span class="line">        <span class="comment">#    server squid1:3128;</span></span><br><span class="line">        <span class="comment">#    server squid2:3128;</span></span><br><span class="line">        <span class="comment">#    hash $request_uri;</span></span><br><span class="line">        <span class="comment">#    hash_method crc32;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#tips:</span></span><br><span class="line">        <span class="comment">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span></span><br><span class="line">        <span class="comment">#    ip_hash;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:9090 down;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:8080 weight=2;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:6060;</span></span><br><span class="line">        <span class="comment">#    server 127.0.0.1:7070 backup;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#每个设备的状态设置为:</span></span><br><span class="line">        <span class="comment">#1.down表示单前的server暂时不参与负载</span></span><br><span class="line">        <span class="comment">#2.weight为weight越大，负载的权重就越大。</span></span><br><span class="line">        <span class="comment">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span></span><br><span class="line">        <span class="comment">#4.fail_timeout:max_fails次失败后，暂停的时间。</span></span><br><span class="line">        <span class="comment">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span></span><br><span class="line">        <span class="comment">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span></span><br><span class="line">        <span class="comment">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span></span><br><span class="line">        <span class="comment">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line">        <span class="attribute">server_name</span> www.jd.com jd.com;</span><br><span class="line">        <span class="comment">#默认入口文件名称</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">        <span class="attribute">root</span> /data/www/jd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对******进行负载均衡</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(php|php5)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">            <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#图片缓存时间设置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">10d</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#JS和CSS缓存时间设置</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*.(js|css)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#日志格式设定</span></span><br><span class="line">        <span class="comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span></span><br><span class="line">        <span class="comment">#$remote_user：用来记录客户端用户名称；</span></span><br><span class="line">        <span class="comment">#$time_local： 用来记录访问时间与时区；</span></span><br><span class="line">        <span class="comment">#$request： 用来记录请求的url与http协议；</span></span><br><span class="line">        <span class="comment">#$status： 用来记录请求状态；成功是200，</span></span><br><span class="line">        <span class="comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span></span><br><span class="line">        <span class="comment">#$http_referer：用来记录从那个页面链接访问过来的；</span></span><br><span class="line">        <span class="comment">#$http_user_agent：记录客户浏览器的相关信息；</span></span><br><span class="line">        <span class="comment">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span></span><br><span class="line">        <span class="attribute">log_format</span> access <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">        <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">        <span class="string">'"<span class="variable">$http_user_agent</span>" <span class="variable">$http_x_forwarded_for</span>'</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#定义本虚拟主机的访问日志</span></span><br><span class="line">        <span class="attribute">access_log</span>  /usr/local/nginx/logs/host.access.log  main;</span><br><span class="line">        <span class="attribute">access_log</span>  /usr/local/nginx/logs/host.access.<span class="number">404</span>.log  log404;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">#对 "/connect-controller" 启用反向代理</span></span><br><span class="line">        <span class="attribute">location</span> /connect-controller &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:88; <span class="comment">#请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span></span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置，可选。</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class="line">            <span class="comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class="line">            <span class="comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class="line">            <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class="line">            <span class="attribute">proxy_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class="line">            <span class="comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class="line">            <span class="comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class="line">            <span class="attribute">proxy_send_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class="line">            <span class="comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class="line">            <span class="attribute">proxy_buffer_size</span> <span class="number">4k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class="line">            <span class="comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class="line">            <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class="line">            <span class="comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class="line">            <span class="attribute">proxy_temp_file_write_size</span> <span class="number">64k</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#本地动静分离反向代理配置</span></span><br><span class="line">        <span class="comment">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;来自：MrLinFeng - 博客园&lt;/strong&gt; 链接：&lt;a href=&quot;http://www.cnblogs.com/mrlinfeng/p/6146866.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.cnblogs.com/mrlinfeng/p/6146866.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用的资源：&lt;/p&gt;
&lt;p&gt;nginx主服务器一台，nginx备服务器一台，使用keepalived进行宕机切换。&lt;/p&gt;
&lt;p&gt;tomcat服务器两台，由nginx进行反向代理和负载均衡，此处可搭建服务器集群。&lt;/p&gt;
&lt;p&gt;redis服务器一台，用于session的分离共享。&lt;/p&gt;
&lt;p&gt;nginx主服务器：192.168.50.133&lt;/p&gt;
&lt;p&gt;nginx备服务器：192.168.50.135&lt;/p&gt;
&lt;p&gt;tomcat项目服务器1:192.168.50.137&lt;/p&gt;
&lt;p&gt;tomcat项目服务器2:192.168.50.139&lt;/p&gt;
&lt;p&gt;redis服务器：192.168.50.140&lt;/p&gt;
&lt;p&gt;注意访问时需要配置防火墙规则，或者关闭防火墙&lt;/p&gt;
    
    </summary>
    
    
      <category term="NGINX" scheme="https://vincentruan.github.io/categories/NGINX/"/>
    
    
      <category term="NGINX" scheme="https://vincentruan.github.io/tags/NGINX/"/>
    
  </entry>
  
  <entry>
    <title>【转载】20条Linux命令面试问答</title>
    <link href="https://vincentruan.github.io/2020/03/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%9120%E6%9D%A1Linux%E5%91%BD%E4%BB%A4%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/"/>
    <id>https://vincentruan.github.io/2020/03/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%9120%E6%9D%A1Linux%E5%91%BD%E4%BB%A4%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/</id>
    <published>2020-03-23T08:27:24.000Z</published>
    <updated>2020-03-24T13:07:33.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>版权声明：</strong>本文是Linux中国翻译，已按转载要求注明信息。<br>原文：<a href="http://www.linuxtechi.com/20-linux-commands-interview-questions-answers/" target="_blank" rel="noopener">http://www.linuxtechi.com/20-linux-commands-interview-questions-answers/</a><br>作者： Pradeep Kumar<br>译文：LCTT <a href="http://linux.cn/article-4790-1.html" target="_blank" rel="noopener">http://linux.cn/article-4790-1.html</a><br>译者： ZTinoZ</p></blockquote><p><strong>问:1 如何查看当前的Linux服务器的运行级别？</strong></p><p>答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。</p><p><strong>问:2 如何查看Linux的默认网关？</strong></p><p>答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。</p> <a id="more"></a><p><strong>问:3 如何在Linux上重建初始化内存盘镜像文件？</strong></p><p>答: 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r)</span></span><br></pre></td></tr></table></figure><p>如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。</p><p>在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件，举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dracut -f</span></span><br></pre></td></tr></table></figure><p>以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64</span></span><br></pre></td></tr></table></figure><p><strong>问:4 cpio命令是什么？</strong></p><p>答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。</p><p><strong>问:5 patch命令是什么？如何使用？</strong></p><p>答: 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，然后接收者用patch命令将改动写进原始的源代码里。</p><p>创建一个diff文件给patch使用，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># diff -Naur old_file new_file &gt; diff_file</span></span><br></pre></td></tr></table></figure><p>旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。</p><p>一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># patch &lt; diff_file</span></span><br></pre></td></tr></table></figure><p><strong>问:6 aspell有什么用 ?</strong></p><p>答: 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。</p><p><strong>问:7 如何从命令行查看域SPF记录？</strong></p><p>答: 我们可以用dig命令来查看域SPF记录。举例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linuxtechi@localhost:~$ dig -t TXT google.com</span><br></pre></td></tr></table></figure><p><strong>问:8 如何识别Linux系统中指定文件(/etc/fstab)的关联包？</strong></p><p>答: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpm -qf /etc/fstab</span></span><br></pre></td></tr></table></figure><p>以上命令能列出提供”/etc/fstab”这个文件的包。</p><p><strong>问:9 哪条命令用来查看bond0的状态？</strong></p><p>答: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/bonding/bond0</span><br></pre></td></tr></table></figure><p><strong>问:10 Linux系统中的/proc文件系统有什么用？</strong></p><p>答: /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。</p><p><strong>问:11 如何在/usr目录下找出大小超过10MB的文件？</strong></p><p>答: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find /usr -size +10M</span></span><br></pre></td></tr></table></figure><p><strong>问:12 如何在/home目录下找出120天之前被修改过的文件？</strong></p><p>答: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find /home -mtime +120</span></span><br></pre></td></tr></table></figure><p><strong>问:13 如何在/var目录下找出90天之内未被访问过的文件？</strong></p><p>答: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find /var \! -atime -90</span></span><br></pre></td></tr></table></figure><p><strong>问:14 在整个目录树下查找文件”core”，如发现则无需提示直接删除它们。</strong></p><p>答:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find / -name core -exec rm &#123;&#125; \;</span></span><br></pre></td></tr></table></figure><p><strong>问:15 strings命令有什么作用？</strong></p><p>答: strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）</p><p><strong>问:16 tee 过滤器有什么作用 ?</strong></p><p>答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linuxtechi@localhost:~$ ll /etc | nl | tee /tmp/ll.out</span><br></pre></td></tr></table></figure><p>在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。</p><p><strong>问:17 export PS1 = “$LOGNAME@hostname:\$PWD:” 这条命令是在做什么？</strong></p><p>答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。</p><p><strong>问:18 ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？</strong></p><p>答: 这条ll命令会显示这些文件的文件名和它们的拥有者。</p><p><strong>问:19 :Linux中的at命令有什么用？</strong></p><p>答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。</p><p><strong>问:20 linux中lspci命令的作用是什么？</strong></p><p>答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本文是Linux中国翻译，已按转载要求注明信息。&lt;br&gt;原文：&lt;a href=&quot;http://www.linuxtechi.com/20-linux-commands-interview-questions-answers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.linuxtechi.com/20-linux-commands-interview-questions-answers/&lt;/a&gt;&lt;br&gt;作者： Pradeep Kumar&lt;br&gt;译文：LCTT &lt;a href=&quot;http://linux.cn/article-4790-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://linux.cn/article-4790-1.html&lt;/a&gt;&lt;br&gt;译者： ZTinoZ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;问:1 如何查看当前的Linux服务器的运行级别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问:2 如何查看Linux的默认网关？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LINUX" scheme="https://vincentruan.github.io/categories/LINUX/"/>
    
    
      <category term="LINUX" scheme="https://vincentruan.github.io/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>善用google guava提高编程效率</title>
    <link href="https://vincentruan.github.io/2020/03/18/%E5%96%84%E7%94%A8google-guava%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E6%95%88%E7%8E%87/"/>
    <id>https://vincentruan.github.io/2020/03/18/%E5%96%84%E7%94%A8google-guava%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E6%95%88%E7%8E%87/</id>
    <published>2020-03-18T13:07:38.000Z</published>
    <updated>2020-03-18T14:45:52.768Z</updated>
    
    <content type="html"><![CDATA[<p>工具类 就是封装平常用的方法，不需要你重复造轮子，节省开发人员时间，提高工作效率。谷歌作为大公司，当然会从日常的工作中提取中很多高效率的方法出来。所以就诞生了guava。。</p><ul><li>高效设计良好的API，被Google的开发者设计，实现和使用</li><li>遵循高效的java语法实践</li><li>使代码更刻度，简洁，简单</li><li>节约时间，资源，提高生产力</li></ul><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：</p><ol><li>集合 [collections]</li><li>缓存 [caching]</li><li>原生类型支持 [primitives support]</li><li>并发库 [concurrency libraries]</li><li>通用注解 [common annotations]</li><li>字符串处理 [string processing]</li><li>I/O 等等。</li></ol><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>引入maven依赖(就是引入jar包)</p><p>(从版本号就能看出 guava是一步步改进的，并且跟随的jdk不断的提取其中优秀的部分)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="集合的创建"><a href="#集合的创建" class="headerlink" title="集合的创建"></a>集合的创建</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通Collection的创建</span></span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">Set&lt;String&gt; set = Sets.newHashSet();</span><br><span class="line">Map&lt;String, String&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不变Collection的创建</span></span><br><span class="line">ImmutableList&lt;String&gt; iList = ImmutableList.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">ImmutableSet&lt;String&gt; iSet = ImmutableSet.of(<span class="string">"e1"</span>, <span class="string">"e2"</span>);</span><br><span class="line">ImmutableMap&lt;String, String&gt; iMap = ImmutableMap.of(<span class="string">"k1"</span>, <span class="string">"v1"</span>, <span class="string">"k2"</span>, <span class="string">"v2"</span>);</span><br></pre></td></tr></table></figure><p>创建不可变集合 先理解什么是immutable(不可变)对象</p><p>1.在多线程操作下，是线程安全的。</p><p>2.所有不可变集合会比可变集合更有效的利用资源。</p><p>3.中途不可改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.of(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>);</span><br></pre></td></tr></table></figure><p>这句话就声明了一个不可变的list集合，里面有数据1，2，3，4。方法中的==操作集合的方法都声明过期==，并且抛出异常。</p><p>没用guava之前是需要声明并且加各种包裹集合才能实现这个功能。</p><p>当我们需要一个map中包含key为String value为List类型的时候 以前我们是这样写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"aa"</span>, list);</span><br><span class="line">System.out.println(map.get(<span class="string">"aa"</span>));<span class="comment">//[1, 2]</span></span><br></pre></td></tr></table></figure><p>而现在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Multimap&lt;String,Integer&gt; map = ArrayListMultimap.create();</span><br><span class="line">map.put(<span class="string">"aa"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"aa"</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">"aa"</span>));  <span class="comment">//[1, 2]</span></span><br></pre></td></tr></table></figure><p><strong>其他的黑科技集合</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MultiSet: 无序+可重复   count()方法获取单词的次数  增强了可读性+操作简单</span><br><span class="line">创建方式:  Multiset<span class="xml"><span class="tag">&lt;<span class="name">String</span>&gt;</span></span> set = HashMultiset.create();</span><br><span class="line"></span><br><span class="line">Multimap: key-value  key可以重复  </span><br><span class="line">创建方式: Multimap<span class="xml"><span class="tag">&lt;<span class="name">String,</span> <span class="attr">String</span>&gt;</span></span> teachers = ArrayListMultimap.create();</span><br><span class="line"></span><br><span class="line">BiMap: 双向Map(Bidirectional Map) 键与值都不能重复</span><br><span class="line">创建方式:  BiMap<span class="xml"><span class="tag">&lt;<span class="name">String,</span> <span class="attr">String</span>&gt;</span></span> biMap = HashBiMap.create();</span><br><span class="line"></span><br><span class="line">Table: 双键的Map Map--&gt; Table--&gt;rowKey+columnKey+value  //和sql中的联合主键有点像</span><br><span class="line">创建方式: Table<span class="xml"><span class="tag">&lt;<span class="name">String,</span> <span class="attr">String</span>, <span class="attr">Integer</span>&gt;</span></span> tables = HashBasedTable.create();</span><br><span class="line"></span><br><span class="line">...等等(guava中还有很多java里面没有给出的集合类型)</span><br></pre></td></tr></table></figure><h2 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h2><p>JDK的集合，提供了有序且可以重复的List，无序且不可以重复的Set。那这里其实对于集合涉及到了2个概念，一个order，一个dups。那么List vs Set，and then some ?</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537790400.webp" alt="img"></p><p>Multiset是什么，我想上面的图，你应该了解它的概念了。Multiset就是无序的，但是可以重复的集合，它就是游离在List/Set之间的“灰色地带”！（至于有序的，不允许重复的集合嘛，guava还没有提供，当然在未来应该会提供UniqueList，我猜的，哈哈）</p><p>来看一个Multiset的示例：</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537822424.webp" alt="img"></p><p>Multiset自带一个有用的功能，就是可以跟踪每个对象的数量。</p><h2 id="Immutable-vs-unmodifiable"><a href="#Immutable-vs-unmodifiable" class="headerlink" title="Immutable vs unmodifiable"></a>Immutable vs unmodifiable</h2><p>来我们先看一个unmodifiable的例子：</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537847333.webp" alt="img"></p><p>你看到JDK提供的unmodifiable的缺陷了吗？</p><p>实际上，Collections.unmodifiableXxx所返回的集合和源集合是同一个对象，只不过可以对集合做出改变的API都被override，会抛出UnsupportedOperationException。</p><p>也即是说我们改变源集合，导致不可变视图（unmodifiable View）也会发生变化，oh my god!</p><p>当然，在不使用guava的情况下，我们是怎么避免上面的问题的呢？</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537877732.webp" alt="img"></p><p>上面揭示了一个概念：Defensive Copies，保护性拷贝。</p><p>OK，unmodifiable看上去没有问题呢，但是guava依然觉得可以改进，于是提出了Immutable的概念，来看：</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537893925.png" alt="img"></p><p>就一个copyOf，你不会忘记，如此cheap</p><p>用Google官方的说法是：we’re using just one class,just say exactly what we mean，很了不起吗（不仅仅是个概念，Immutable在COPY阶段还考虑了线程的并发性等，很智能的！）</p><p>guava提供了很多Immutable集合，比如ImmutableList/ImmutableSet/ImmutableSortedSet/ImmutableMap/……</p><p>看一个ImmutableMap的例子：</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537922795.png" alt="img"></p><h2 id="可不可以一对多：Multimap"><a href="#可不可以一对多：Multimap" class="headerlink" title="可不可以一对多：Multimap"></a>可不可以一对多：Multimap</h2><p>JDK提供给我们的Map是一个键，一个值，一对一的，那么在实际开发中，显然存在一个KEY多个VALUE的情况（比如一个分类下的书本），我们往往这样表达：Map&lt;k,List<v>&gt;，好像有点臃肿！臃肿也就算了，更加不爽的事，我们还得判断KEY是否存在来决定是否new 一个LIST出来，有点麻烦！更加麻烦的事情还在后头，比如遍历，比如删除，so hard……</v></p><p>来看guava如何替你解决这个大麻烦的：</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537989409.webp" alt="img"></p><p>友情提示下，guava所有的集合都有create方法，这样的好处在于简单，而且我们不必在重复泛型信息了。</p><p>get()/keys()/keySet()/values()/entries()/asMap()都是非常有用的返回view collection的方法。</p><p>Multimap的实现类有：ArrayListMultimap/HashMultimap/LinkedHashMultimap/TreeMultimap/ImmutableMultimap/……</p><h2 id="可不可以双向：BiMap"><a href="#可不可以双向：BiMap" class="headerlink" title="可不可以双向：BiMap"></a>可不可以双向：BiMap</h2><p>JDK提供的MAP让我们可以find value by key，那么能不能通过find key by value呢，能不能KEY和VALUE都是唯一的呢。这是一个双向的概念，即forward+backward。</p><p>在实际场景中有这样的需求吗？比如通过用户ID找到mail，也需要通过mail找回用户名。没有guava的时候，我们需要create forward map AND create backward map，and now just let guava do that for you.</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584538028104.webp" alt="img"></p><p>biMap / biMap.inverse() / biMap.inverse().inverse() 它们是什么关系呢？</p><p>你可以稍微看一下BiMap的源码实现，实际上，当你创建BiMap的时候，在内部维护了2个map，一个forward map，一个backward map，并且设置了它们之间的关系。</p><p>因此，biMap.inverse()  != biMap ；biMap.inverse().inverse() == biMap</p><h2 id="可不可以多个KEY：Table"><a href="#可不可以多个KEY：Table" class="headerlink" title="可不可以多个KEY：Table"></a>可不可以多个KEY：Table</h2><p>我们知道数据库除了主键外，还提供了复合索引，而且实际中这样的多级关系查找也是比较多的，当然我们可以利用嵌套的Map来实现：Map&lt;k1,Map&lt;k2,v2&gt;&gt;。为了让我们的代码看起来不那么丑陋，guava为我们提供了Table。</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584538088906.webp" alt="img"></p><p>Table涉及到3个概念：rowKey,columnKey,value，并提供了多种视图以及操作方法让你更加轻松的处理多个KEY的场景。</p><h1 id="将集合转换为特定规则的字符串"><a href="#将集合转换为特定规则的字符串" class="headerlink" title="将集合转换为特定规则的字符串"></a>将集合转换为特定规则的字符串</h1><p>以前我们将list转换为特定规则的字符串是这样写的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//use java</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String str = &quot;&quot;;</span><br><span class="line">for(int i=0; i&lt;list.size(); i++)&#123;</span><br><span class="line">str = str + &quot;-&quot; +list.get(i);</span><br><span class="line">&#125;</span><br><span class="line">//str 为-aa-bb-cc</span><br><span class="line"></span><br><span class="line">//use guava</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;aa&quot;);</span><br><span class="line">list.add(&quot;bb&quot;);</span><br><span class="line">list.add(&quot;cc&quot;);</span><br><span class="line">String result = Joiner.on(&quot;-&quot;).join(list);</span><br><span class="line">//result为  aa-bb-cc</span><br></pre></td></tr></table></figure><h2 id="把map集合转换为特定规则的字符串"><a href="#把map集合转换为特定规则的字符串" class="headerlink" title="把map集合转换为特定规则的字符串"></a>把map集合转换为特定规则的字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = Maps.newHashMap();</span><br><span class="line">map.put(<span class="string">"xiaoming"</span>, <span class="number">12</span>);</span><br><span class="line">map.put(<span class="string">"xiaohong"</span>,<span class="number">13</span>);</span><br><span class="line">String result = Joiner.on(<span class="string">","</span>).withKeyValueSeparator(<span class="string">"="</span>).join(map);</span><br><span class="line"><span class="comment">// result为 xiaoming=12,xiaohong=13</span></span><br></pre></td></tr></table></figure><h1 id="将String转换为特定的集合"><a href="#将String转换为特定的集合" class="headerlink" title="将String转换为特定的集合"></a>将String转换为特定的集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use java</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String a = <span class="string">"1-2-3-4-5-6"</span>;</span><br><span class="line">String[] strs = a.split(<span class="string">"-"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strs.length; i++)&#123;</span><br><span class="line">list.add(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//use guava</span></span><br><span class="line">String str = <span class="string">"1-2-3-4-5-6"</span>;</span><br><span class="line">List&lt;String&gt; list = Splitter.on(<span class="string">"-"</span>).splitToList(str);</span><br><span class="line"><span class="comment">//list为  [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"1-2-3-4- 5-  6  "</span>;</span><br></pre></td></tr></table></figure><p>guava还可以使用</p><blockquote><p>==使用 “-“ 切分字符串并去除空串与空格== omitEmptyStrings().trimResults() 去除空串与空格</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"1-2-3-4-  5-  6   "</span>;  </span><br><span class="line">List&lt;String&gt; list = Splitter.on(<span class="string">"-"</span>).omitEmptyStrings().trimResults().splitToList(str);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>就能忽略中间的空格</p><h2 id="将String转换为map"><a href="#将String转换为map" class="headerlink" title="将String转换为map"></a>将String转换为map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"xiaoming=11,xiaohong=23"</span>;</span><br><span class="line">Map&lt;String,String&gt; map = Splitter.on(<span class="string">","</span>).withKeyValueSeparator(<span class="string">"="</span>).split(str);</span><br></pre></td></tr></table></figure><p>比如String提供的split方法，我们得关心空字符串吧，还得考虑返回的结果中存在null元素吧，只提供了前后trim的方法（如果我想对中间元素进行trim呢）。</p><p>那么，看下面的代码示例，guava让你不必在操心这些：</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537619245.webp" alt="img"></p><p>Joiner是连接器，Splitter是分割器，通常我们会把它们定义为static final，利用on生成对象后在应用到String进行处理，这是可以复用的。要知道apache commons StringUtils提供的都是static method。更加重要的是，guava提供的Joiner/Splitter是经过充分测试，它的稳定性和效率要比apache高出不少，这个你可以自行测试下。</p><p>发现没有我们想对String做什么操作，就是生成自己定制化的Joiner/Splitter，多么直白，简单，流畅的API！</p><p>对于Joiner，常用的方法是  跳过NULL元素：skipNulls()  /  对于NULL元素使用其他替代：useForNull(String)</p><p>对于Splitter，常用的方法是：trimResults()/omitEmptyStrings()。注意拆分的方式，有字符串，还有正则，还有固定长度分割（太贴心了！）</p><p>其实除了Joiner/Splitter外，guava还提供了字符串匹配器：CharMatcher</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584537629986.webp" alt="img"></p><p>CharMatcher，将字符的匹配和处理解耦，并提供丰富的方法供你使用！</p><h1 id="guava还支持多个字符切割，或者特定的正则分隔"><a href="#guava还支持多个字符切割，或者特定的正则分隔" class="headerlink" title="guava还支持多个字符切割，或者特定的正则分隔"></a>guava还支持多个字符切割，或者特定的正则分隔</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String input = <span class="string">"aa.dd,,ff,,."</span>;</span><br><span class="line">List&lt;String&gt; result = Splitter.onPattern(<span class="string">"[.|,]"</span>).omitEmptyStrings().splitToList(input);</span><br></pre></td></tr></table></figure><p>==关于字符串的操作 都是在Splitter这个类上进行的。==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断匹配结果</span></span><br><span class="line"><span class="keyword">boolean</span> result = CharMatcher.inRange(<span class="string">'a'</span>, <span class="string">'z'</span>).or(CharMatcher.inRange(<span class="string">'A'</span>, <span class="string">'Z'</span>)).matches(<span class="string">'K'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 保留数字文本</span></span><br><span class="line">String s1 = CharMatcher.digit().retainFrom(<span class="string">"abc 123 efg"</span>); <span class="comment">//123</span></span><br><span class="line"><span class="comment">// 删除数字文本</span></span><br><span class="line">String s2 = CharMatcher.digit().removeFrom(<span class="string">"abc 123 efg"</span>);    <span class="comment">//abc  efg</span></span><br></pre></td></tr></table></figure><h1 id="集合的过滤"><a href="#集合的过滤" class="headerlink" title="集合的过滤"></a>集合的过滤</h1><p>我们对于集合的过滤，思路就是迭代，然后再具体对每一个数判断，这样的代码放在程序中，难免会显得很臃肿，虽然功能都有，但是很不好看。</p><p>guava写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照条件过滤</span></span><br><span class="line">ImmutableList&lt;String&gt; names = ImmutableList.of(<span class="string">"begin"</span>, <span class="string">"code"</span>, <span class="string">"Guava"</span>, <span class="string">"Java"</span>);</span><br><span class="line">Iterable&lt;String&gt; fitered = Iterables.filter(names, Predicates.or(Predicates.equalTo(<span class="string">"Guava"</span>), Predicates.equalTo(<span class="string">"Java"</span>)));</span><br><span class="line">System.out.println(fitered); <span class="comment">// [Guava, Java]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义过滤条件   使用自定义回调方法对Map的每个Value进行操作</span></span><br><span class="line">ImmutableMap&lt;String, Integer&gt; m = ImmutableMap.of(<span class="string">"begin"</span>, <span class="number">12</span>, <span class="string">"code"</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="comment">// Function&lt;F, T&gt; F表示apply()方法input的类型，T表示apply()方法返回类型</span></span><br><span class="line">        Map&lt;String, Integer&gt; m2 = Maps.transformValues(m, <span class="keyword">new</span> Function&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(Integer input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(input&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> input;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> input+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">System.out.println(m2);   <span class="comment">//&#123;begin=13, code=15&#125;</span></span><br></pre></td></tr></table></figure><p>set的交集, 并集, 差集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HashSet setA = newHashSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  </span><br><span class="line">HashSet setB = newHashSet(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);  </span><br><span class="line">   </span><br><span class="line">SetView union = Sets.union(setA, setB);  </span><br><span class="line">System.out.println(<span class="string">"union:"</span>);  </span><br><span class="line"><span class="keyword">for</span> (Integer integer : union)  </span><br><span class="line">    System.out.println(integer);           <span class="comment">//union:12345867</span></span><br><span class="line">   </span><br><span class="line">SetView difference = Sets.difference(setA, setB);  </span><br><span class="line">System.out.println(<span class="string">"difference:"</span>);  </span><br><span class="line"><span class="keyword">for</span> (Integer integer : difference)  </span><br><span class="line">    System.out.println(integer);        <span class="comment">//difference:123</span></span><br><span class="line">   </span><br><span class="line">SetView intersection = Sets.intersection(setA, setB);  </span><br><span class="line">System.out.println(<span class="string">"intersection:"</span>);  </span><br><span class="line"><span class="keyword">for</span> (Integer integer : intersection)  </span><br><span class="line">    System.out.println(integer);  <span class="comment">//intersection:45</span></span><br></pre></td></tr></table></figure><p>map的交集，并集，差集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapDifference differenceMap = Maps.difference(mapA, mapB);  </span><br><span class="line">differenceMap.areEqual();  </span><br><span class="line">Map entriesDiffering = differenceMap.entriesDiffering();  </span><br><span class="line">Map entriesOnlyOnLeft = differenceMap.entriesOnlyOnLeft();  </span><br><span class="line">Map entriesOnlyOnRight = differenceMap.entriesOnlyOnRight();  </span><br><span class="line">Map entriesInCommon = differenceMap.entriesInCommon();</span><br></pre></td></tr></table></figure><h1 id="检查参数"><a href="#检查参数" class="headerlink" title="检查参数"></a>检查参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use java</span></span><br><span class="line"><span class="keyword">if</span>(list!=<span class="keyword">null</span> &amp;&amp; list.size()&gt;<span class="number">0</span>)</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">if(str!=null &amp;&amp; str.length()&gt;0)</span></span><br><span class="line"><span class="string">'</span><span class="string">''</span></span><br><span class="line"><span class="keyword">if</span>(str !=<span class="keyword">null</span> &amp;&amp; !str.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">//use guava</span></span><br><span class="line"><span class="keyword">if</span>(!Strings.isNullOrEmpty(str))</span><br><span class="line"></span><br><span class="line"><span class="comment">//use java</span></span><br><span class="line"><span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;                                                                                           </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"must be positive: "</span> + count);         </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//use guava</span></span><br><span class="line">Preconditions.checkArgument(count &gt; <span class="number">0</span>, <span class="string">"must be positive: %s"</span>, count);</span><br></pre></td></tr></table></figure><p>免去了很多麻烦！并且会使你的代码看上去更好看。而不是代码里面充斥着!=null， !=””</p><p>检查是否为空,不仅仅是字符串类型，其他类型的判断 全部都封装在 Preconditions类里 里面的方法全为静态。</p><p>其中的一个方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanIgnoreReturnValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">checkNotNull</span><span class="params">(T reference)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reference == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法声明（不包括额外参数）</th><th>描述</th><th>检查失败时抛出的异常</th></tr></thead><tbody><tr><td>checkArgument(boolean)</td><td>检查boolean是否为true，用来检查传递给方法的参数。</td><td>IllegalArgumentException</td></tr><tr><td>checkNotNull(T)</td><td>检查value是否为null，该方法直接返回value，因此可以内嵌使用checkNotNull</td><td>NullPointerException</td></tr><tr><td>checkState(boolean)</td><td>用来检查对象的某些状态。</td><td>IllegalStateException</td></tr><tr><td>checkElementIndex(int index, int size)</td><td>检查index作为索引值对某个列表、字符串或数组是否有效。index&gt;=0 &amp;&amp; index&lt;size</td><td>IndexOutOfBoundsException</td></tr><tr><td>checkPositionIndexes(int start, int end, int size)</td><td>检查[start, end]表示的位置范围对某个列表、字符串或数组是否有效</td><td>IndexOutOfBoundsException</td></tr></tbody></table><h1 id="MoreObjects"><a href="#MoreObjects" class="headerlink" title="MoreObjects"></a>MoreObjects</h1><p>这个方法是在Objects过期后 官方推荐使用的替代品，该类最大的好处就是不用大量的重写toString，用一种很优雅的方式实现重写，或者在某个场景定制使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"aa"</span>,<span class="number">11</span>);</span><br><span class="line">String str = MoreObjects.toStringHelper(<span class="string">"Person"</span>).add(<span class="string">"age"</span>, person.getAge()).toString();</span><br><span class="line">System.out.println(str);  </span><br><span class="line"><span class="comment">//输出Person&#123;age=11&#125;</span></span><br></pre></td></tr></table></figure><h1 id="强大的Ordering排序器"><a href="#强大的Ordering排序器" class="headerlink" title="强大的Ordering排序器"></a>强大的Ordering排序器</h1><p>排序器[Ordering]是Guava流畅风格比较器[Comparator]的实现，它可以用来为构建复杂的比较器，以完成集合排序的功能。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">natural()对可排序类型做自然排序，如数字按大小，日期按先后排序</span><br><span class="line">usingToString()按对象的字符串形式做字典排序[lexicographical ordering]</span><br><span class="line">from(Comparator)把给定的Comparator转化为排序器</span><br><span class="line">reverse()获取语义相反的排序器</span><br><span class="line">nullsFirst()使用当前排序器，但额外把null值排到最前面。</span><br><span class="line">nullsLast()使用当前排序器，但额外把null值排到最后面。</span><br><span class="line">compound(Comparator)合成另一个比较器，以处理当前排序器中的相等情况。</span><br><span class="line">lexicographical()基于处理类型T的排序器，返回该类型的可迭代对象Iterable<span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>的排序器。</span><br><span class="line">onResultOf(Function)对集合中元素调用Function，再按返回值用当前排序器排序。</span><br><span class="line">Person person = new Person("aa",14);  //String name  ,Integer age</span><br><span class="line">Person ps = new Person("bb",13);</span><br><span class="line">Ordering<span class="xml"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span> byOrdering = Ordering.natural().nullsFirst().onResultOf(new Function<span class="xml"><span class="tag">&lt;<span class="name">Person,String</span>&gt;</span></span>()&#123;</span><br><span class="line"><span class="code">public String apply(Person person)&#123;</span></span><br><span class="line"><span class="code">return person.age.toString();</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">byOrdering.compare(person, ps);</span><br><span class="line">System.out.println(byOrdering.compare(person, ps)); //1      person的年龄比ps大 所以输出1</span><br></pre></td></tr></table></figure><h1 id="计算中间代码的运行时间"><a href="#计算中间代码的运行时间" class="headerlink" title="计算中间代码的运行时间"></a>计算中间代码的运行时间</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stopwatch stopwatch = Stopwatch.createStarted();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> nanos = stopwatch.elapsed(TimeUnit.MILLISECONDS);</span><br><span class="line">System.out.println(nanos);</span><br></pre></td></tr></table></figure><p>TimeUnit 可以指定时间输出精确到多少时间</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>以前我们写文件读取的时候要定义缓冲区，各种条件判断，各种<code>$%#$$%#$@#</code></p><p>而现在我们只需要使用好guava的api 就能使代码变得简洁，并且不用担心因为写错逻辑而背锅了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"/test.txt"</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">list = Files.readLines(file, Charsets.UTF_8);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Files.copy(from,to);  <span class="comment">//复制文件</span></span><br><span class="line">Files.deleteDirectoryContents(File directory); <span class="comment">//删除文件夹下的内容(包括文件与子文件夹)  </span></span><br><span class="line">Files.deleteRecursively(File file); <span class="comment">//删除文件或者文件夹  </span></span><br><span class="line">Files.move(File from, File to); <span class="comment">//移动文件</span></span><br><span class="line">URL url = Resources.getResource(<span class="string">"abc.xml"</span>); <span class="comment">//获取classpath根下的abc.xml文件url</span></span><br></pre></td></tr></table></figure><p>Files类中还有许多方法可以用，可以多多翻阅。</p><h1 id="guava缓存"><a href="#guava缓存" class="headerlink" title="guava缓存"></a>guava缓存</h1><p>对于大多数互联网项目而言，缓存的重要性，不言而喻！</p><p>如果我们的应用系统，并不想使用一些第三方缓存组件（如redis），我们仅仅想在本地有一个功能足够强大的缓存，很可惜JDK提供的那些SET/MAP还不行！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存的实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheLoader&lt;Long, String&gt; cacheLoader = <span class="keyword">new</span> CacheLoader&lt;Long, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(Long key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 从数据库加载数据</span></span><br><span class="line">        System.out.println(<span class="string">"从数据库加载数据"</span>);</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">":value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义缓存的策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LoadingCache&lt;Long, String&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .expireAfterAccess(<span class="number">2</span>, TimeUnit.SECONDS) <span class="comment">// 设置在2秒内未访问则过期</span></span><br><span class="line">        .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS) <span class="comment">// 设置缓存在写入2秒后失效</span></span><br><span class="line">        .refreshAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS) <span class="comment">// 设置缓存在写入3秒后，通过CacheLoader的load方法进行刷新</span></span><br><span class="line">        .maximumSize(<span class="number">100L</span>) <span class="comment">// 设置缓存数量上限为100</span></span><br><span class="line">        .build(cacheLoader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//loadingCache.put(1L, "James");</span></span><br><span class="line">    System.out.println(loadingCache.get(<span class="number">1L</span>));</span><br><span class="line">    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    System.out.println(loadingCache.get(<span class="number">1L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，这是一个本地缓存，guava提供的cache是一个简洁、高效，易于维护的。为什么这么说呢？因为并没有一个单独的线程用于刷新 OR 清理cache，对于cache的操作，都是通过访问/读写带来的，也就是说在读写中完成缓存的刷新操作！</p><p>guava的缓存设计的比较巧妙，可以很精巧的使用。guava缓存创建分为两种，一种是CacheLoader,另一种则是callback方式</p><p><code>CacheLoader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String,String&gt; cahceBuilder=CacheBuilder</span><br><span class="line">        .newBuilder()</span><br><span class="line">        .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">                String strProValue=<span class="string">"hello "</span>+key+<span class="string">"!"</span>;                </span><br><span class="line">                <span class="keyword">return</span> strProValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);        </span><br><span class="line">System.out.println(cahceBuilder.apply(<span class="string">"begincode"</span>));  <span class="comment">//hello begincode!</span></span><br><span class="line">System.out.println(cahceBuilder.get(<span class="string">"begincode"</span>)); <span class="comment">//hello begincode!</span></span><br><span class="line">System.out.println(cahceBuilder.get(<span class="string">"wen"</span>)); <span class="comment">//hello wen!</span></span><br><span class="line">System.out.println(cahceBuilder.apply(<span class="string">"wen"</span>)); <span class="comment">//hello wen!</span></span><br><span class="line">System.out.println(cahceBuilder.apply(<span class="string">"da"</span>));<span class="comment">//hello da!</span></span><br><span class="line">cahceBuilder.put(<span class="string">"begin"</span>, <span class="string">"code"</span>);</span><br><span class="line">System.out.println(cahceBuilder.get(<span class="string">"begin"</span>)); <span class="comment">//code</span></span><br></pre></td></tr></table></figure><p>api中已经把apply声明为过期，声明中推荐使用get方法获取值</p><p>callback方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder().maximumSize(<span class="number">1000</span>).build();  </span><br><span class="line">        String resultVal = cache.get(<span class="string">"code"</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                String strProValue=<span class="string">"begin "</span>+<span class="string">"code"</span>+<span class="string">"!"</span>;                </span><br><span class="line">                <span class="keyword">return</span> strProValue;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">System.out.println(<span class="string">"value : "</span> + resultVal); <span class="comment">//value : begin code!</span></span><br></pre></td></tr></table></figure><h1 id="让异步回调更加简单"><a href="#让异步回调更加简单" class="headerlink" title="让异步回调更加简单"></a>让异步回调更加简单</h1><p>JDK中提供了Future/FutureTask/Callable来对异步回调进行支持，但是还是看上去挺复杂的，能不能更加简单呢？比如注册一个监听回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">ListeningExecutorService listeningExecutorService = MoreExecutors.listeningDecorator(es);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;?&gt; listenableFuture = listeningExecutorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> Random().nextInt(<span class="number">3</span>) == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">FutureCallback&lt;Integer&gt; futureCallback = <span class="keyword">new</span> FutureCallback&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(@Nullable Integer o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------"</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"------"</span> + throwable.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Futures.addCallback(listenableFuture,futureCallback);</span><br></pre></td></tr></table></figure><p>我们可以通过guava对JDK提供的线程池进行装饰，让其具有异步回调监听功能，然后在设置监听器即可！</p><h1 id="函数式编程：Funcitons"><a href="#函数式编程：Funcitons" class="headerlink" title="函数式编程：Funcitons"></a>函数式编程：Funcitons</h1><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584538158262.webp" alt="img"></p><p>上面的代码是为了完成将List集合中的元素，先截取5个长度，然后转成大写。</p><p>函数式编程的好处在于在集合遍历操作中提供自定义Function的操作，比如transform转换。我们再也不需要一遍遍的遍历集合，显著的简化了代码！</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584538261806.webp" alt="img"></p><p>对集合的transform操作可以通过Function完成</p><h1 id="断言：Predicate"><a href="#断言：Predicate" class="headerlink" title="断言：Predicate"></a>断言：Predicate</h1><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584538385000.webp" alt="img"></p><p>Predicate最常用的功能就是运用在集合的过滤当中！</p><p><img src="/2020/03/18/善用google-guava提高编程效率/640-1584538285569.webp" alt="img"></p><p>需要注意的是Lists并没有提供filter方法，不过你可以使用Collections2.filter完成！</p><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional用于包含非空对象的不可变对象。 Optional对象，用于不存在值表示null。这个类有各种实用的方法，以方便代码来处理为可用或不可用，而不是检查null值。</p><h2 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.Optional<t>类的声明：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(serializable=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static  Optional absent()</strong>              返回没有包含的参考Optional的实例。</td></tr><tr><td>2</td><td><strong>abstract Set asSet()</strong>              返回一个不可变的单集的唯一元素所包含的实例(如果存在);否则为一个空的不可变的集合。</td></tr><tr><td>3</td><td><strong>abstract boolean equals(Object object)</strong>              返回true如果对象是一个Optional实例，无论是包含引用彼此相等或两者都不存在。</td></tr><tr><td>4</td><td><strong>static  Optional fromNullable(T nullableReference)</strong>              如果nullableReference非空，返回一个包含引用Optional实例;否则返回absent()。</td></tr><tr><td>5</td><td><strong>abstract T get()</strong>              返回所包含的实例，它必须存在。</td></tr><tr><td>6</td><td><strong>abstract int hashCode()</strong>              返回此实例的哈希码。</td></tr><tr><td>7</td><td><strong>abstract boolean isPresent()</strong>              返回true，如果这支架包含一个(非空)的实例。</td></tr><tr><td>8</td><td><strong>static  Optional of(T reference)</strong>              返回包含给定的非空引用Optional实例。</td></tr><tr><td>9</td><td><strong>abstract Optional or(Optional secondChoice)</strong>              返回此Optional，如果它有一个值存在; 否则返回secondChoice。</td></tr><tr><td>10</td><td><strong>abstract T or(Supplier supplier)</strong>              返回所包含的实例(如果存在); 否则supplier.get()。</td></tr><tr><td>11</td><td><strong>abstract T or(T defaultValue)</strong>              返回所包含的实例(如果存在);否则为默认值。</td></tr><tr><td>12</td><td><strong>abstract T orNull()</strong>              返回所包含的实例(如果存在);否则返回null。</td></tr><tr><td>13</td><td><strong>static  Iterable presentInstances(Iterable&gt; optionals)</strong>              从提供的optionals返回每个实例的存在的值，从而跳过absent()。</td></tr><tr><td>14</td><td><strong>abstract String toString()</strong>              返回此实例的字符串表示。</td></tr><tr><td>15</td><td><strong>abstract  Optional transform(Function function)</strong>              如果实例存在，则它被转换给定的功能;否则absent()被返回。</td></tr></tbody></table><h2 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类的方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Optional示例"><a href="#Optional示例" class="headerlink" title="Optional示例"></a>Optional示例</h2><p>​    使用所选择的编辑器，创建下面的java程序，比如 C:/&gt; Guava</p><p>GuavaTester.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester guavaTester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line"></span><br><span class="line">      Integer value1 =  <span class="keyword">null</span>;</span><br><span class="line">      Integer value2 =  <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">      <span class="comment">//Optional.fromNullable - allows passed parameter to be null.</span></span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.fromNullable(value1);</span><br><span class="line">      <span class="comment">//Optional.of - throws NullPointerException if passed parameter is null</span></span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line"></span><br><span class="line">      System.out.println(guavaTester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span></span>&#123;</span><br><span class="line">      <span class="comment">//Optional.isPresent - checks the value is present or not</span></span><br><span class="line">      System.out.println(<span class="string">"First parameter is present: "</span> + a.isPresent());</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Second parameter is present: "</span> + b.isPresent());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Optional.or - returns the value if present otherwise returns</span></span><br><span class="line">      <span class="comment">//the default value passed.</span></span><br><span class="line">      Integer value1 = a.or(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Optional.get - gets the value, value should be present</span></span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First parameter is present: <span class="literal">false</span></span><br><span class="line">Second parameter is present: <span class="literal">true</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure><h1 id="Preconditions"><a href="#Preconditions" class="headerlink" title="Preconditions"></a>Preconditions</h1><p>在guava中，对于null的处理手段是快速失败，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">""</span>;</span><br><span class="line">Preconditions.checkNotNull(name, <span class="string">"name is not null"</span>);</span><br><span class="line">Integer age = <span class="number">30</span>;</span><br><span class="line">Preconditions.checkArgument(age&gt;=<span class="number">18</span>, <span class="string">"your age is under 18"</span>);</span><br></pre></td></tr></table></figure><p>你可以看看guava的源码，很多方法的第一行就是：Preconditions.checkNotNull(elements);</p><p>要知道null是模糊的概念，是成功呢，还是失败呢，还是别的什么含义呢？</p><p>Preconditions提供静态方法来检查方法或构造函数，被调用是否给定适当的参数。它检查的先决条件。其方法失败抛出IllegalArgumentException。</p><h2 id="类声明-1"><a href="#类声明-1" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.Preconditions类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Preconditions</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static void checkArgument(boolean expression)</strong>              确保涉及的一个或多个参数来调用方法表达式的真相。</td></tr><tr><td>2</td><td><strong>static void checkArgument(boolean expression, Object errorMessage)</strong>              确保涉及的一个或多个参数来调用方法表达式的真相。</td></tr><tr><td>3</td><td><strong>static void checkArgument(boolean expression, String errorMessageTemplate, Object… errorMessageArgs)</strong>              确保涉及的一个或多个参数来调用方法表达式的真相。</td></tr><tr><td>4</td><td><strong>static int checkElementIndex(int index, int size)</strong>              确保索引指定一个数组，列表或尺寸大小的字符串有效的元素。</td></tr><tr><td>5</td><td><strong>static int checkElementIndex(int index, int size, String desc)</strong>              确保索引指定一个数组，列表或尺寸大小的字符串有效的元素。</td></tr><tr><td>6</td><td><strong>static  T checkNotNull(T reference)</strong>              确保对象引用作为参数传递给调用方法不为空。</td></tr><tr><td>7</td><td><strong>static  T checkNotNull(T reference, Object errorMessage)</strong>              确保对象引用作为参数传递给调用方法不为空。</td></tr><tr><td>8</td><td><strong>static  T checkNotNull(T reference, String errorMessageTemplate, Object… errorMessageArgs)</strong>              确保对象引用作为参数传递给调用方法不为空。</td></tr><tr><td>9</td><td><strong>static int checkPositionIndex(int index, int size)</strong>              确保索引指定一个数组，列表或尺寸大小的字符串的有效位置。</td></tr><tr><td>10</td><td><strong>static int checkPositionIndex(int index, int size, String desc)</strong>              确保索引指定一个数组，列表或尺寸大小的字符串的有效位置。</td></tr><tr><td>11</td><td><strong>static void checkPositionIndexes(int start, int end, int size)</strong>              确保开始和结束指定数组，列表或字符串大小有效的位置，并按照顺序。</td></tr><tr><td>12</td><td><strong>static void checkState(boolean expression)</strong>              确保涉及调用实例的状态，但不涉及任何参数来调用方法表达式的真相。</td></tr><tr><td>13</td><td><strong>static void checkState(boolean expression, Object errorMessage)</strong>              确保涉及调用实例的状态，但不涉及任何参数来调用方法表达式的真相。</td></tr><tr><td>14</td><td><strong>static void checkState(boolean expression, String errorMessageTemplate, Object… errorMessageArgs)</strong>              确保涉及调用实例的状态，但不涉及任何参数来调用方法表达式的真相。</td></tr></tbody></table><h2 id="继承的方法-1"><a href="#继承的方法-1" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Preconditions-示例"><a href="#Preconditions-示例" class="headerlink" title="Preconditions 示例"></a>Preconditions 示例</h2><p>​    使用所选择的编辑器，创建下面的java程序比如 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester guavaTester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(guavaTester.sqrt(-<span class="number">3.0</span>));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IllegalArgumentException e)&#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(guavaTester.sum(<span class="keyword">null</span>,<span class="number">3</span>));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         System.out.println(guavaTester.getValue(<span class="number">6</span>));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e)&#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> input)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">      Preconditions.checkArgument(input &gt; <span class="number">0.0</span>,</span><br><span class="line">         <span class="string">"Illegal Argument passed: Negative value %s."</span>, input);</span><br><span class="line">      <span class="keyword">return</span> Math.sqrt(input);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">      a = Preconditions.checkNotNull(a,</span><br><span class="line">         <span class="string">"Illegal Argument passed: First parameter is Null."</span>);</span><br><span class="line">      b = Preconditions.checkNotNull(b,</span><br><span class="line">         <span class="string">"Illegal Argument passed: Second parameter is Null."</span>);</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> input)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">      Preconditions.checkElementIndex(input,data.length,</span><br><span class="line">         <span class="string">"Illegal Argument passed: Invalid index."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-1"><a href="#验证结果-1" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Illegal Argument passed: Negative value -3.0.</span><br><span class="line">Illegal Argument passed: First parameter is Null.</span><br><span class="line">Illegal Argument passed: Invalid index. (6) must be less than size (5)</span><br></pre></td></tr></table></figure><h1 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h1><p>Ordering(排序)可以被看作是一个丰富的比较具有增强功能的链接，多个实用方法，多类型排序功能等。</p><h2 id="类声明-2"><a href="#类声明-2" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.collect.Ordering<t>类的声明：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ordering</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="类方法-2"><a href="#类方法-2" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static Ordering allEqual()</strong>              返回一个排序，它把所有的值相等，说明“没有顺序。”通过这个顺序以任何稳定的排序算法的结果，在改变没有顺序元素。</td></tr><tr><td>2</td><td><strong>static Ordering arbitrary()</strong>              返回一个任意顺序对所有对象，其中compare(a, b) == 0 意味着a == b（身份平等）。</td></tr><tr><td>3</td><td><strong>int binarySearch(List sortedList, T key)</strong>              搜索排序列表使用键的二进制搜索算法。</td></tr><tr><td>4</td><td><strong>abstract int compare(T left, T right)</strong>              比较两个参数的顺序。</td></tr><tr><td>5</td><td><strong>Ordering compound(Comparator secondaryComparator)</strong>              返回首先使用排序这一点，但它排序中的“tie”，然后委托给secondaryComparator事件。</td></tr><tr><td>6</td><td><strong>static  Ordering compound(Iterable&gt; comparators)</strong>              返回一个排序它尝试每个给定的比较器，以便直到一个非零结果找到，返回该结果，并返回零仅当所有比较器返回零。</td></tr><tr><td>7</td><td><strong>static  Ordering explicit(List valuesInOrder)</strong>              返回根据它们出现的定列表中的顺序比较对象进行排序。</td></tr><tr><td>8</td><td><strong>static  Ordering explicit(T leastValue, T… remainingValuesInOrder)</strong>              返回根据它们所赋予本方法的顺序进行比较的对象进行排序。</td></tr><tr><td>9</td><td><strong>static  Ordering from(Comparator comparator)</strong>              返回基于现有的比较实例进行排序。</td></tr><tr><td>10</td><td><strong>List greatestOf(Iterable iterable, int k)</strong>              返回根据这个顺序给出迭代，为了从最大到最小的k个最大的元素。</td></tr><tr><td>11</td><td><strong>List greatestOf(Iterator iterator, int k)</strong>              返回从给定的迭代器按照这个顺序，从最大到最小k个最大的元素。</td></tr><tr><td>12</td><td><strong> ImmutableList immutableSortedCopy(Iterable elements)</strong>              返回包含的元素排序这种排序的不可变列表。</td></tr><tr><td>13</td><td><strong>boolean isOrdered(Iterable iterable)</strong>               返回true如果在迭代后的第一个的每个元素是大于或等于在它之前，根据该排序的元素。</td></tr><tr><td>14</td><td><strong>boolean isStrictlyOrdered(Iterable iterable)</strong>              返回true如果在迭代后的第一个的每个元素是严格比在它之前，根据该排序的元素更大。</td></tr><tr><td>15</td><td><strong>List leastOf(Iterable iterable, int k)</strong>              返回根据这个顺序给出迭代，从而从低到最大的k个最低的元素。</td></tr><tr><td>16</td><td><strong>List leastOf(Iterator elements, int k)</strong>              返回第k从给定的迭代器，按照这个顺序从最低到最大至少元素。</td></tr><tr><td></td><td></td></tr><tr><td>17</td><td><strong>Ordering&gt; lexicographical()</strong>              返回一个新的排序它通过比较对应元素两两直到非零结果发现排序迭代;规定“字典顺序”。</td></tr><tr><td>18</td><td><strong>E max(E a, E b)</strong>              返回两个值按照这个顺序的较大值。</td></tr><tr><td>19</td><td><strong>E max(E a, E b, E c, E… rest)</strong>              返回指定的值，根据这个顺序是最大的。</td></tr><tr><td>20</td><td><strong>E max(Iterable iterable)</strong>              返回指定的值，根据这个顺序是最大的。</td></tr><tr><td>21</td><td><strong>E max(Iterator iterator)</strong>              返回指定的值，根据这个顺序是最大的。</td></tr><tr><td>22</td><td><strong>E min(E a, E b)</strong>              返回两个值按照这个顺序的较小者。</td></tr><tr><td>23</td><td><strong>E min(E a, E b, E c, E… rest)</strong>              返回最少指定的值，根据这个顺序。</td></tr><tr><td>24</td><td><strong>E min(Iterable iterable)</strong>              返回最少指定的值，根据这个顺序。</td></tr><tr><td>25</td><td><strong>E min(Iterator iterator)</strong>              返回最少指定的值，根据这个顺序。</td></tr><tr><td>26</td><td><strong>static  Ordering natural()</strong>              返回使用值的自然顺序排序序列化。</td></tr><tr><td>27</td><td><strong>Ordering nullsFirst()</strong>              返回对待null小于所有其他值，并使用此来比较非空值排序。</td></tr><tr><td>28</td><td><strong>Ordering nullsLast()</strong>              返回对待null作为大于所有其他值，并使用这个顺序来比较非空值排序。</td></tr><tr><td>29</td><td><strong>Ordering onResultOf(Function function)</strong>              返回一个新的排序在F上，首先应用功能给它们，然后比较使用此这些结果的顺序元素。</td></tr><tr><td>30</td><td><strong>Ordering reverse()</strong>              返回相反顺序; 顺序相当于Collections.reverseOrder（Comparator）。</td></tr><tr><td>31</td><td><strong>List sortedCopy(Iterable elements)</strong>              返回包含的元素排序此排序可变列表;使用这个只有在结果列表可能需要进一步修改，或可能包含null。</td></tr><tr><td>32</td><td><strong>static Ordering usingToString()</strong>              返回由它们的字符串表示的自然顺序，toString()比较对象进行排序。</td></tr></tbody></table><h2 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类从以下类继承的方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Ordering-示例"><a href="#Ordering-示例" class="headerlink" title="Ordering 示例"></a>Ordering 示例</h2><p>​    使用所选择的编辑器，创建下面的java程序比如 C:/&gt; Guava</p><p>GuavaTester.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">5</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">15</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">51</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">53</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">35</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">45</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">32</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">43</span>));</span><br><span class="line">      numbers.add(<span class="keyword">new</span> Integer(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">      Ordering ordering = Ordering.natural();</span><br><span class="line">      System.out.println(<span class="string">"Input List: "</span>);</span><br><span class="line">      System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">      Collections.sort(numbers,ordering );</span><br><span class="line">      System.out.println(<span class="string">"Sorted List: "</span>);</span><br><span class="line">      System.out.println(numbers);</span><br><span class="line">         </span><br><span class="line">      System.out.println(<span class="string">"======================"</span>);</span><br><span class="line">      System.out.println(<span class="string">"List is sorted: "</span> + ordering.isOrdered(numbers));</span><br><span class="line">      System.out.println(<span class="string">"Minimum: "</span> + ordering.min(numbers));</span><br><span class="line">      System.out.println(<span class="string">"Maximum: "</span> + ordering.max(numbers));</span><br><span class="line">         </span><br><span class="line">      Collections.sort(numbers,ordering.reverse());</span><br><span class="line">      System.out.println(<span class="string">"Reverse: "</span> + numbers);</span><br><span class="line"></span><br><span class="line">      numbers.add(<span class="keyword">null</span>);</span><br><span class="line">      System.out.println(<span class="string">"Null added to Sorted List: "</span>);</span><br><span class="line">      System.out.println(numbers);</span><br><span class="line"></span><br><span class="line">      Collections.sort(numbers,ordering.nullsFirst());</span><br><span class="line">      System.out.println(<span class="string">"Null first Sorted List: "</span>);</span><br><span class="line">      System.out.println(numbers);</span><br><span class="line">      System.out.println(<span class="string">"======================"</span>);</span><br><span class="line"></span><br><span class="line">      List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      names.add(<span class="string">"Ram"</span>);</span><br><span class="line">      names.add(<span class="string">"Shyam"</span>);</span><br><span class="line">      names.add(<span class="string">"Mohan"</span>);</span><br><span class="line">      names.add(<span class="string">"Sohan"</span>);</span><br><span class="line">      names.add(<span class="string">"Ramesh"</span>);</span><br><span class="line">      names.add(<span class="string">"Suresh"</span>);</span><br><span class="line">      names.add(<span class="string">"Naresh"</span>);</span><br><span class="line">      names.add(<span class="string">"Mahesh"</span>);</span><br><span class="line">      names.add(<span class="keyword">null</span>);</span><br><span class="line">      names.add(<span class="string">"Vikas"</span>);</span><br><span class="line">      names.add(<span class="string">"Deepak"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Another List: "</span>);</span><br><span class="line">      System.out.println(names);</span><br><span class="line"></span><br><span class="line">  Collections.sort(names,ordering.nullsFirst().reverse());</span><br><span class="line">      System.out.println(<span class="string">"Null first then reverse sorted list: "</span>);</span><br><span class="line">      System.out.println(names);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-2"><a href="#验证结果-2" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input List: </span><br><span class="line">[5, 2, 15, 51, 53, 35, 45, 32, 43, 16]</span><br><span class="line">Sorted List: </span><br><span class="line">[2, 5, 15, 16, 32, 35, 43, 45, 51, 53]</span><br><span class="line">======================</span><br><span class="line">List is sorted: <span class="literal">true</span></span><br><span class="line">Minimum: 2</span><br><span class="line">Maximum: 53</span><br><span class="line">Reverse: [53, 51, 45, 43, 35, 32, 16, 15, 5, 2]</span><br><span class="line">Null added to Sorted List: </span><br><span class="line">[53, 51, 45, 43, 35, 32, 16, 15, 5, 2, null]</span><br><span class="line">Null first Sorted List: </span><br><span class="line">[null, 2, 5, 15, 16, 32, 35, 43, 45, 51, 53]</span><br><span class="line">======================</span><br><span class="line">Another List: </span><br><span class="line">[Ram, Shyam, Mohan, Sohan, Ramesh, Suresh, Naresh, Mahesh, null, Vikas, Deepak]</span><br><span class="line">Null first <span class="keyword">then</span> reverse sorted list: </span><br><span class="line">[Vikas, Suresh, Sohan, Shyam, Ramesh, Ram, Naresh, Mohan, Mahesh, Deepak, null]</span><br></pre></td></tr></table></figure><h1 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h1><p>Objects类提供适用于所有对象，如equals, hashCode等辅助函数</p><h2 id="类声明-3"><a href="#类声明-3" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.Objects类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Objects</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法-3"><a href="#类方法-3" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th style="text-align:left">S.N.</th><th style="text-align:left">方法及说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>static boolean equal(Object a, Object b)</strong>              确定两个可能是空的对象是否相等。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>static  T firstNonNull(T first, T second)</strong>              不推荐使用。使用MoreObjects.firstNonNull（T，T）来代替。定于2016年6月去除该方法。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>static int hashCode(Object… objects)</strong>              生成多个值的哈希码。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>static Objects.ToStringHelper toStringHelper(Class clazz)</strong>              不推荐使用。使用MoreObjects.toStringHelper（Class）来代替。定于2016年6月去除该方法。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>static Objects.ToStringHelper toStringHelper(Object self)</strong>              不推荐使用。使用MoreObjects.toStringHelper（Object）来代替。定于2016年6月去除该方法。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>static Objects.ToStringHelper toStringHelper(String className)</strong>              不推荐使用。使用MoreObjects.toStringHelper（String）来代替。定于2016年6月去除该方法。</td></tr></tbody></table><h2 id="方法继承-1"><a href="#方法继承-1" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类从以下类继承的方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Objects-示例"><a href="#Objects-示例" class="headerlink" title="Objects 示例"></a>Objects 示例</h2><p>​    使用所选择的编辑器，创建下面的java程序比如 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Student s1 = <span class="keyword">new</span> Student(<span class="string">"Mahesh"</span>, <span class="string">"Parashar"</span>, <span class="number">1</span>, <span class="string">"VI"</span>);</span><br><span class="line">      Student s2 = <span class="keyword">new</span> Student(<span class="string">"Suresh"</span>, <span class="keyword">null</span>, <span class="number">3</span>, <span class="keyword">null</span>);</span><br><span class="line">  </span><br><span class="line">      System.out.println(s1.equals(s2));</span><br><span class="line">      System.out.println(s1.hashCode());</span><br><span class="line">      System.out.println(</span><br><span class="line">      Objects.toStringHelper(s1)</span><br><span class="line">         .add(<span class="string">"Name"</span>,s1.getFirstName()+<span class="string">" "</span> + s1.getLastName())</span><br><span class="line">         .add(<span class="string">"Class"</span>, s1.getClassName())</span><br><span class="line">         .add(<span class="string">"Roll No"</span>, s1.getRollNo())</span><br><span class="line">         .toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String firstName;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> rollNo;</span><br><span class="line">   <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String firstName, String lastName, <span class="keyword">int</span> rollNo, String className)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">      <span class="keyword">this</span>.rollNo = rollNo;</span><br><span class="line">      <span class="keyword">this</span>.className = className;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!(object <span class="keyword">instanceof</span> Student) || object == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Student student = (Student)object;</span><br><span class="line">      <span class="comment">// no need to handle null here</span></span><br><span class="line">      <span class="comment">// Objects.equal("test", "test") == true</span></span><br><span class="line">      <span class="comment">// Objects.equal("test", null) == false</span></span><br><span class="line">      <span class="comment">// Objects.equal(null, "test") == false</span></span><br><span class="line">      <span class="comment">// Objects.equal(null, null) == true</span></span><br><span class="line">      <span class="keyword">return</span> Objects.equal(firstName, student.firstName) <span class="comment">// first name can be null</span></span><br><span class="line">         &amp;&amp; Objects.equal(lastName, student.lastName) <span class="comment">// last name can be null</span></span><br><span class="line">         &amp;&amp; Objects.equal(rollNo, student.rollNo)</span><br><span class="line">         &amp;&amp; Objects.equal(className, student.className);<span class="comment">// class name can be null</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//no need to compute hashCode by self</span></span><br><span class="line">      <span class="keyword">return</span> Objects.hashCode(className,rollNo);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRollNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rollNo;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRollNo</span><span class="params">(<span class="keyword">int</span> rollNo)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.rollNo = rollNo;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> className;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.className = className;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-3"><a href="#验证结果-3" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line">85871</span><br><span class="line">Student&#123;Name=Mahesh Parashar, Class=VI, Roll No=1&#125;</span><br></pre></td></tr></table></figure><h1 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h1><p>Range 表示一个间隔或一个序列。它被用于获取一组数字/串在一个特定范围之内。</p><h2 id="类声明-4"><a href="#类声明-4" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.collect.Range<c>类的声明：</c></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Range</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Predicate</span>&lt;<span class="title">C</span>&gt;, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static &gt; Range all()</strong>              返回包含C型的每一个值范围</td></tr><tr><td>2</td><td><strong>boolean apply(C input)Deprecated.</strong>               只有提供满足谓词接口;使用包含(C)来代替。</td></tr><tr><td>3</td><td><strong>static &gt; Range atLeast(C endpoint)</strong>              返回包含大于或等于终点(endpoint)的所有值的范围内。</td></tr><tr><td>4</td><td><strong>static &gt; Range atMost(C endpoint)</strong>              返回包含的所有值小于或等于终点的范围内。</td></tr><tr><td>5</td><td><strong>Range canonical(DiscreteDomain domain)</strong>              返回此范围内，在给定域中的规范形式。</td></tr><tr><td>6</td><td><strong>static &gt; Range closed(C lower, C upper)</strong>              返回包含大于所有值或等于降低且小于或等于上限的范围内。</td></tr><tr><td>7</td><td><strong>static &gt; Range closedOpen(C lower, C upper)</strong>              返回包含大于或等于下限和所有值严格大于上限以下的范围内。</td></tr><tr><td>8</td><td><strong>boolean contains(C value)</strong>              返回true，如果值是这个范围的范围之内。</td></tr><tr><td>9</td><td><strong>boolean containsAll(Iterable values)</strong>              如果值每一个元素都包含在这个范围内，则返回 true。</td></tr><tr><td>10</td><td><strong>static &gt; Range downTo(C endpoint, BoundType boundType)</strong>              返回的范围内的给定的端点，它可以是包容性（闭合）或专用（开），没有上限。</td></tr><tr><td>11</td><td><strong>static &gt; Range encloseAll(Iterable values)</strong>              返回包含所有给定值的最小范围内。</td></tr><tr><td>12</td><td><strong>boolean encloses(Range other)</strong>              返回true，如果其他的边界不在该范围的边界之外延伸。</td></tr><tr><td>13</td><td><strong>boolean equals(Object object)</strong>              返回true，如果对象是具有相同端点和绑定类型，这个范围内的范围。</td></tr><tr><td>14</td><td><strong>static &gt; Range greaterThan(C endpoint)</strong>              返回一个包含所有值严格大于端点的范围内。</td></tr><tr><td>15</td><td><strong>int hashCode()</strong>              返回此范围内的哈希码。</td></tr><tr><td>16</td><td><strong>boolean hasLowerBound()</strong>              如果此范围内具有更低的终点返回true。</td></tr><tr><td>17</td><td><strong>boolean hasUpperBound()</strong>              如果此范围内有上端点返回true。</td></tr><tr><td>18</td><td><strong>Range intersection(Range connectedRange)</strong>              返回由两者范围和connectedRange封闭，如果这样的范围存在的最大范围。</td></tr><tr><td>19</td><td><strong>boolean isConnected(Range other)</strong>              如果存在这是由两者此范围和其他封闭（可能为空）的范围，则返回true。</td></tr><tr><td>20</td><td><strong>boolean isEmpty()</strong>              返回true，如果这个范围是形式 [v..v)  或 (v..v].</td></tr><tr><td>21</td><td><strong>static &gt; Range lessThan(C endpoint)</strong>              返回一个包含所有值严格小于端点的范围内。</td></tr><tr><td>22</td><td><strong>BoundType lowerBoundType()</strong>              返回类型这个范围的下限：如果范围包括它的下端点BoundType.CLOSED，如果没有BoundType.OPEN。</td></tr><tr><td>23</td><td><strong>C lowerEndpoint()</strong>              返回该范围的较低端点。</td></tr><tr><td>24</td><td><strong>static &gt; Range open(C lower, C upper)</strong>              返回一个包含所有值严格大于下限和严格比上端更小一个范围。</td></tr><tr><td>25</td><td><strong>static &gt; Range openClosed(C lower, C upper)</strong>              返回包含所有值严格低于更大且小于或等于上限的范围内。</td></tr><tr><td>26</td><td><strong>static &gt; Range range(C lower, BoundType lowerType, C upper, BoundType upperType)</strong>              返回包含任何值由下到上，每个端点可以是包容性（关闭）或专用（开）的范围。</td></tr><tr><td>27</td><td><strong>static &gt; Range singleton(C value)</strong>              返回包含只在给定范围内的值。</td></tr><tr><td>28</td><td><strong>Range span(Range other)</strong>              返回最小的范围包围两者这个范围和other等。</td></tr><tr><td>29</td><td><strong>String toString()</strong>              返回该范围内的字符串表示，如“[3..5）”（其他实例列在类文档）。</td></tr><tr><td>30</td><td><strong>BoundType upperBoundType()</strong>              返回类型此范围的上限：如果范围包括其上的端点返回BoundType.CLOSED，如果没有返回BoundType.OPEN。</td></tr><tr><td>31</td><td><strong>C upperEndpoint()</strong>              返回此范围的上限端点。</td></tr><tr><td>32</td><td><strong>static &gt; Range upTo(C endpoint, BoundType boundType)</strong>              返回一个范围，没有下限到给定的端点，它可以是包容性（闭合）或专用（开）。</td></tr></tbody></table><h2 id="方法继承-2"><a href="#方法继承-2" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类从以下类继承的方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Range-例子"><a href="#Range-例子" class="headerlink" title="Range 例子"></a>Range 例子</h2><p>​    选择使用任何编辑器创建以下java程序在 <strong>C:/&gt; Guava</strong></p><p>​    <em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.ContiguousSet;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.DiscreteDomain;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Range;</span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Ints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testRange();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testRange</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//create a range [a,b] = &#123; x | a &lt;= x &lt;= b&#125;</span></span><br><span class="line">      Range&lt;Integer&gt; range1 = Range.closed(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">      System.out.print(<span class="string">"[0,9] : "</span>);</span><br><span class="line">      printRange(range1);</span><br><span class="line">      System.out.println(<span class="string">"5 is present: "</span> + range1.contains(<span class="number">5</span>));</span><br><span class="line">      System.out.println(<span class="string">"(1,2,3) is present: "</span> + range1.containsAll(Ints.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)));</span><br><span class="line">      System.out.println(<span class="string">"Lower Bound: "</span> + range1.lowerEndpoint());</span><br><span class="line">      System.out.println(<span class="string">"Upper Bound: "</span> + range1.upperEndpoint());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//create a range (a,b) = &#123; x | a &lt; x &lt; b&#125;</span></span><br><span class="line">      Range&lt;Integer&gt; range2 = Range.open(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">      System.out.print(<span class="string">"(0,9) : "</span>);</span><br><span class="line">      printRange(range2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//create a range (a,b] = &#123; x | a &lt; x &lt;= b&#125;</span></span><br><span class="line">      Range&lt;Integer&gt; range3 = Range.openClosed(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">      System.out.print(<span class="string">"(0,9] : "</span>);</span><br><span class="line">      printRange(range3);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//create a range [a,b) = &#123; x | a &lt;= x &lt; b&#125;</span></span><br><span class="line">      Range&lt;Integer&gt; range4 = Range.closedOpen(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">      System.out.print(<span class="string">"[0,9) : "</span>);</span><br><span class="line">      printRange(range4);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//create an open ended range (9, infinity</span></span><br><span class="line">      Range&lt;Integer&gt; range5 = Range.greaterThan(<span class="number">9</span>);</span><br><span class="line">      System.out.println(<span class="string">"(9,infinity) : "</span>);</span><br><span class="line">      System.out.println(<span class="string">"Lower Bound: "</span> + range5.lowerEndpoint());</span><br><span class="line">      System.out.println(<span class="string">"Upper Bound present: "</span> + range5.hasUpperBound());</span><br><span class="line"></span><br><span class="line">      Range&lt;Integer&gt; range6 = Range.closed(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">      printRange(range6);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//check a subrange [3,5] in [0,9]</span></span><br><span class="line">      System.out.println(<span class="string">"[0,9] encloses [3,5]:"</span> + range1.encloses(range6));</span><br><span class="line"></span><br><span class="line">      Range&lt;Integer&gt; range7 = Range.closed(<span class="number">9</span>, <span class="number">20</span>);</span><br><span class="line">      printRange(range7);</span><br><span class="line">      <span class="comment">//check ranges to be connected</span></span><br><span class="line">      System.out.println(<span class="string">"[0,9] is connected [9,20]:"</span> + range1.isConnected(range7));</span><br><span class="line"></span><br><span class="line">      Range&lt;Integer&gt; range8 = Range.closed(<span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//intersection</span></span><br><span class="line">      printRange(range1.intersection(range8));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//span</span></span><br><span class="line">      printRange(range1.span(range8));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printRange</span><span class="params">(Range&lt;Integer&gt; range)</span></span>&#123;</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> grade : ContiguousSet.create(range, DiscreteDomain.integers())) &#123;</span><br><span class="line">         System.out.print(grade +<span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-4"><a href="#验证结果-4" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[0,9] : [ 0 1 2 3 4 5 6 7 8 9 ]</span><br><span class="line">5 is present: <span class="literal">true</span></span><br><span class="line">(1,2,3) is present: <span class="literal">true</span></span><br><span class="line">Lower Bound: 0</span><br><span class="line">Upper Bound: 9</span><br><span class="line">(0,9) : [ 1 2 3 4 5 6 7 8 ]</span><br><span class="line">(0,9] : [ 1 2 3 4 5 6 7 8 9 ]</span><br><span class="line">[0,9) : [ 0 1 2 3 4 5 6 7 8 ]</span><br><span class="line">(9,infinity) : </span><br><span class="line">Lower Bound: 9</span><br><span class="line">Upper Bound present: <span class="literal">false</span></span><br><span class="line">[ 3 4 5 ]</span><br><span class="line">[0,9] encloses [3,5]:<span class="literal">true</span></span><br><span class="line">[ 9 10 11 12 13 14 15 16 17 18 19 20 ]</span><br><span class="line">[0,9] is connected [9,20]:<span class="literal">true</span></span><br><span class="line">[ 5 6 7 8 9 ]</span><br><span class="line">[ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ]</span><br></pre></td></tr></table></figure><h1 id="Throwables"><a href="#Throwables" class="headerlink" title="Throwables"></a>Throwables</h1><p>Throwable类提供了相关的Throwable接口的实用方法。</p><h2 id="类声明-5"><a href="#类声明-5" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.Throwables类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwables</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法-4"><a href="#类方法-4" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List getCausalChain(Throwable throwable)</strong>              获取一个Throwable的原因链的列表。</td></tr><tr><td>2</td><td><strong>static Throwable getRootCause(Throwable throwable)</strong>              返回抛出的最里面的原因。</td></tr><tr><td>3</td><td><strong>static String getStackTraceAsString(Throwable throwable)</strong>              返回包含toString()的结果字符串，随后完整抛出，递归的堆栈跟踪。</td></tr><tr><td>4</td><td><strong>static RuntimeException propagate(Throwable throwable)</strong>              传播抛出原样如果RuntimeException或Error是一个实例，否则作为最后的报告，把它包装在一个RuntimeException，然后传播。</td></tr><tr><td>5</td><td><strong>static  void propagateIfInstanceOf(Throwable throwable, Class declaredType)</strong>              传播抛出对象完全按原样，当且仅当它是declaredType的一个实例。</td></tr><tr><td>6</td><td><strong>static void propagateIfPossible(Throwable throwable)</strong>              传播抛出对象完全按原样，当且仅当它是RuntimeException或Error的一个实例。</td></tr><tr><td>7</td><td><strong>static  void propagateIfPossible(Throwable throwable, Class declaredType)</strong>              传播抛出对象完全按原样，当且仅当它是RuntimeException，错误或的declaredType的一个实例。</td></tr><tr><td>8</td><td><strong>static void propagateIfPossible(Throwable throwable, Class declaredType1, Class declaredType2)</strong>              传播抛出对象完全按原样，当且仅当它是RuntimeException，Error，declaredType1或declaredType2的一个实例。</td></tr></tbody></table><h2 id="继承的方法-2"><a href="#继承的方法-2" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Throwables示例"><a href="#Throwables示例" class="headerlink" title="Throwables示例"></a>Throwables示例</h2><p>​    创建使用所选择的任何编辑器下面的java程序，比如 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Objects;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Throwables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tester.showcaseThrowables();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvalidInputException e) &#123;</span><br><span class="line">         <span class="comment">//get the root cause</span></span><br><span class="line">         System.out.println(Throwables.getRootCause(e));</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">//get the stack trace in string format</span></span><br><span class="line">         System.out.println(Throwables.getStackTraceAsString(e));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         tester.showcaseThrowables1();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         System.out.println(Throwables.getStackTraceAsString(e));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showcaseThrowables</span><span class="params">()</span> <span class="keyword">throws</span> InvalidInputException</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         sqrt(-<span class="number">3.0</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         <span class="comment">//check the type of exception and throw it</span></span><br><span class="line">         Throwables.propagateIfInstanceOf(e, InvalidInputException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         Throwables.propagate(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showcaseThrowables1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line">         getValue(data, <span class="number">4</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;        </span><br><span class="line">         Throwables.propagateIfInstanceOf(e, IndexOutOfBoundsException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         Throwables.propagate(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> input)</span> <span class="keyword">throws</span> InvalidInputException</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(input &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> InvalidInputException();</span><br><span class="line">      <span class="keyword">return</span> Math.sqrt(input);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span>[] list, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> list[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dummyIO</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvalidInputException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-5"><a href="#验证结果-5" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InvalidInputException</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: 4</span><br><span class="line">at GuavaTester.getValue(GuavaTester.java:52)</span><br><span class="line">at GuavaTester.showcaseThrowables1(GuavaTester.java:38)</span><br><span class="line">at GuavaTester.main(GuavaTester.java:19)</span><br></pre></td></tr></table></figure><h1 id="Multiset-1"><a href="#Multiset-1" class="headerlink" title="Multiset"></a>Multiset</h1><p>Multiset接口扩展设置有重复的元素，并提供了各种实用的方法来处理这样的元素在集合中出现。</p><h2 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h2><p>​    以下是com.google.common.collect.Multiset<e>接口的声明：</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Multiset</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>boolean add(E element)</strong>              添加一个出现的指定元素这个multiset。</td></tr><tr><td>2</td><td><strong>int add(E element, int occurrences)</strong>              增加大量的元素到这个multiset。</td></tr><tr><td>3</td><td><strong>boolean contains(Object element)</strong>              确定此多集是否包含指定的元素。</td></tr><tr><td>4</td><td><strong>boolean containsAll(Collection elements)</strong>              返回true，如果这个多集至少包含一个出现的指定集合中的所有元素。</td></tr><tr><td>5</td><td><strong>int count(Object element)</strong>              返回出现的元素的在该multiset的数目（元素的数量）。</td></tr><tr><td>6</td><td><strong>Set elementSet()</strong>              返回集包含在此多集不同的元素。</td></tr><tr><td>7</td><td><strong>Set&gt; entrySet()</strong>              返回此多集的内容的视图，分组在Multiset.Entry实例中，每一个都提供了多集的一个元素和元素的计数。</td></tr><tr><td>8</td><td><strong>boolean equals(Object object)</strong>              比较指定对象与此multiset是否相等。</td></tr><tr><td>9</td><td><strong>int hashCode()</strong>              返回此multiset的哈希码。</td></tr><tr><td>10</td><td><strong>Iterator iterator()</strong>              返回一个迭代在这个集合中的元素。</td></tr><tr><td>11</td><td><strong>boolean remove(Object element)</strong>              移除此多集multiset的单个出现的指定元素，如果存在。</td></tr><tr><td>12</td><td><strong>int remove(Object element, int occurrences)</strong>              删除了一些出现，从该多集multiset的指定元素。</td></tr><tr><td>13</td><td><strong>boolean removeAll(Collection c)</strong>              删除所有这一切都包含在指定集合（可选操作）在此集合的元素。</td></tr><tr><td>14</td><td><strong>boolean retainAll(Collection c)</strong>              保持那些包含在指定collection（可选操作）在此只集合中的元素。</td></tr><tr><td>15</td><td><strong>int setCount(E element, int count)</strong>              添加或删除，使得该元素达到所期望的计数的元件的必要出现。</td></tr><tr><td>16</td><td><strong>boolean setCount(E element, int oldCount, int newCount)</strong>              有条件设置元素的计数为一个新值，如在setCount（对象，INT）中所述，条件是该元素预期的当前计数。</td></tr><tr><td>17</td><td><strong>String toString()</strong>              返回该对象的字符串表示。</td></tr></tbody></table><h2 id="方法继承-3"><a href="#方法继承-3" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    此接口继承从以下接口方法：</p><ul><li>​            java.util.Collection</li></ul><h2 id="Multiset-示例"><a href="#Multiset-示例" class="headerlink" title="Multiset 示例"></a>Multiset 示例</h2><p>​    使用所选择的编辑器创建下面的java程序，比如说 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.HashMultiset;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Multiset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="comment">//create a multiset collection</span></span><br><span class="line">      Multiset&lt;String&gt; multiset = HashMultiset.create();</span><br><span class="line">      multiset.add(<span class="string">"a"</span>);</span><br><span class="line">      multiset.add(<span class="string">"b"</span>);</span><br><span class="line">      multiset.add(<span class="string">"c"</span>);</span><br><span class="line">      multiset.add(<span class="string">"d"</span>);</span><br><span class="line">      multiset.add(<span class="string">"a"</span>);</span><br><span class="line">      multiset.add(<span class="string">"b"</span>);</span><br><span class="line">      multiset.add(<span class="string">"c"</span>);</span><br><span class="line">      multiset.add(<span class="string">"b"</span>);</span><br><span class="line">      multiset.add(<span class="string">"b"</span>);</span><br><span class="line">      multiset.add(<span class="string">"b"</span>);</span><br><span class="line">      <span class="comment">//print the occurrence of an element</span></span><br><span class="line">      System.out.println(<span class="string">"Occurrence of 'b' : "</span>+multiset.count(<span class="string">"b"</span>));</span><br><span class="line">      <span class="comment">//print the total size of the multiset</span></span><br><span class="line">      System.out.println(<span class="string">"Total Size : "</span>+multiset.size());</span><br><span class="line">      <span class="comment">//get the distinct elements of the multiset as set</span></span><br><span class="line">      Set&lt;String&gt; set = multiset.elementSet();</span><br><span class="line">      <span class="comment">//display the elements of the set</span></span><br><span class="line">      System.out.println(<span class="string">"Set ["</span>);</span><br><span class="line">      <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">         System.out.println(s);    </span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//display all the elements of the multiset using iterator</span></span><br><span class="line">      Iterator&lt;String&gt; iterator  = multiset.iterator();</span><br><span class="line">      System.out.println(<span class="string">"MultiSet ["</span>);</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">         System.out.println(iterator.next());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//display the distinct elements of the multiset with their occurrence count</span></span><br><span class="line">      System.out.println(<span class="string">"MultiSet ["</span>);</span><br><span class="line">      <span class="keyword">for</span> (Multiset.Entry&lt;String&gt; entry : multiset.entrySet())</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">"Element: "</span>+entry.getElement() +<span class="string">", Occurrence(s): "</span> + entry.getCount());    </span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//remove extra occurrences </span></span><br><span class="line">      multiset.remove(<span class="string">"b"</span>,<span class="number">2</span>);</span><br><span class="line">      <span class="comment">//print the occurrence of an element</span></span><br><span class="line">      System.out.println(<span class="string">"Occurence of 'b' : "</span>+multiset.count(<span class="string">"b"</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-6"><a href="#验证结果-6" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Occurence of <span class="string">'b'</span> : 5</span><br><span class="line">Total Size : 10</span><br><span class="line">Set [</span><br><span class="line">d</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">]</span><br><span class="line">MultiSet [</span><br><span class="line">d</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">]</span><br><span class="line">MultiSet [</span><br><span class="line">Element: d, Occurence(s): 1</span><br><span class="line">Element: b, Occurence(s): 5</span><br><span class="line">Element: c, Occurence(s): 2</span><br><span class="line">Element: a, Occurence(s): 2</span><br><span class="line">]</span><br><span class="line">Occurence of <span class="string">'b'</span> : 3</span><br></pre></td></tr></table></figure><h1 id="Bimap"><a href="#Bimap" class="headerlink" title="Bimap"></a>Bimap</h1><p>BiMap是一种特殊的映射其保持映射，同时确保没有重复的值是存在于该映射和一个值可以安全地用于获取键背面的倒数映射。</p><h2 id="接口声明-1"><a href="#接口声明-1" class="headerlink" title="接口声明"></a>接口声明</h2><p>​    以下是com.google.common.collect.Bimap&lt;K，V&gt;接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="接口方法-1"><a href="#接口方法-1" class="headerlink" title="接口方法"></a>接口方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>V forcePut(K key, V value)</strong>              另一种put的形式是默默删除，在put(K, V)运行前的任何现有条目值值。</td></tr><tr><td>2</td><td><strong>BiMap inverse()</strong>              返回此bimap，每一个bimap的值映射到其相关联的键的逆视图。</td></tr><tr><td>3</td><td><strong>V put(K key, V value)</strong>              关联指定值与此映射中(可选操作)指定的键。</td></tr><tr><td>4</td><td><strong>void putAll(Map map)</strong>              将所有从指定映射此映射(可选操作)的映射。</td></tr><tr><td>5</td><td><strong>Set values()</strong>              返回此映射中包含Collection的值视图。</td></tr></tbody></table><h2 id="继承的方法-3"><a href="#继承的方法-3" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承自以下接口方法：</p><ul><li>​            java.util.Map</li></ul><h2 id="BiMap-示例"><a href="#BiMap-示例" class="headerlink" title="BiMap 示例"></a>BiMap 示例</h2><p>​    使用所选择的编辑器创建下面的java程序，比如说 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.BiMap;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.HashBiMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      BiMap&lt;Integer, String&gt; empIDNameMap = HashBiMap.create();</span><br><span class="line"></span><br><span class="line">      empIDNameMap.put(<span class="keyword">new</span> Integer(<span class="number">101</span>), <span class="string">"Mahesh"</span>);</span><br><span class="line">      empIDNameMap.put(<span class="keyword">new</span> Integer(<span class="number">102</span>), <span class="string">"Sohan"</span>);</span><br><span class="line">      empIDNameMap.put(<span class="keyword">new</span> Integer(<span class="number">103</span>), <span class="string">"Ramesh"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Emp Id of Employee "Mahesh"</span></span><br><span class="line">      System.out.println(empIDNameMap.inverse().get(<span class="string">"Mahesh"</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-7"><a href="#验证结果-7" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看看以下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure><h1 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h1><p>Table代表一个特殊的映射，其中两个键可以在组合的方式被指定为单个值。它类似于创建映射的映射。</p><h2 id="接口声明-2"><a href="#接口声明-2" class="headerlink" title="接口声明"></a>接口声明</h2><p>​    以下是 com.google.common.collect.Table&lt;R，C，V&gt; 接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Table</span>&lt;<span class="title">R</span>,<span class="title">C</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="接口方法-2"><a href="#接口方法-2" class="headerlink" title="接口方法"></a>接口方法</h2><table><thead><tr><th>S.N.</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>Set&gt; cellSet()</strong>              返回集合中的所有行键/列键/值三元组。</td></tr><tr><td>2</td><td><strong>void clear()</strong>              从表中删除所有映射。</td></tr><tr><td>3</td><td><strong>Map column(C columnKey)</strong>              返回在给定列键的所有映射的视图。</td></tr><tr><td>4</td><td><strong>Set columnKeySet()</strong>              返回一组具有表中的一个或多个值的列键。</td></tr><tr><td>5</td><td><strong>Map&gt; columnMap()</strong>              返回关联的每一列键与行键对应的映射值的视图。</td></tr><tr><td>6</td><td><strong>boolean contains(Object rowKey, Object columnKey)</strong>              返回true，如果表中包含与指定的行和列键的映射。</td></tr><tr><td>7</td><td><strong>boolean containsColumn(Object columnKey)</strong>              返回true，如果表中包含与指定列的映射。</td></tr><tr><td>8</td><td><strong>boolean containsRow(Object rowKey)</strong>              返回true，如果表中包含与指定的行键的映射关系。</td></tr><tr><td>9</td><td><strong>boolean containsValue(Object value)</strong>              返回true，如果表中包含具有指定值的映射。</td></tr><tr><td>10</td><td><strong>boolean equals(Object obj)</strong>              比较指定对象与此表是否相等。</td></tr><tr><td>11</td><td><strong>V get(Object rowKey, Object columnKey)</strong>              返回对应于给定的行和列键，如果没有这样的映射存在值，返回null。</td></tr><tr><td>12</td><td><strong>int hashCode()</strong>              返回此表中的哈希码。</td></tr><tr><td>13</td><td><strong>boolean isEmpty()</strong>              返回true，如果表中没有映射。</td></tr><tr><td>14</td><td><strong>V put(R rowKey, C columnKey, V value)</strong>              关联指定值与指定键。</td></tr><tr><td>15</td><td><strong>void putAll(Table table)</strong>              复制从指定的表中的所有映射到这个表。</td></tr><tr><td>16</td><td><strong>V remove(Object rowKey, Object columnKey)</strong>              如果有的话，使用给定键相关联删除的映射。</td></tr><tr><td>17</td><td><strong>Map row(R rowKey)</strong>              返回包含给定行键的所有映射的视图。</td></tr><tr><td>18</td><td><strong>Set rowKeySet()</strong>              返回一组行键具有在表中的一个或多个值。</td></tr><tr><td>19</td><td><strong>Map&gt; rowMap()</strong>              返回关联的每一行按键与键列对应的映射值的视图。</td></tr><tr><td>20</td><td><strong>int size()</strong>              返回行键/列键/表中的值映射关系的数量。</td></tr><tr><td>21</td><td><strong>Collection values()</strong>              返回所有值，其中可能包含重复的集合。</td></tr></tbody></table><h2 id="Table-例子"><a href="#Table-例子" class="headerlink" title="Table 例子"></a>Table 例子</h2><p>​    选择使用任何编辑器创建以下java程序在 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.HashBasedTable;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="comment">//Table&lt;R,C,V&gt; == Map&lt;R,Map&lt;C,V&gt;&gt;</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      *  Company: IBM, Microsoft, TCS</span></span><br><span class="line"><span class="comment">      *  IBM -&gt; &#123;101:Mahesh, 102:Ramesh, 103:Suresh&#125;</span></span><br><span class="line"><span class="comment">      *  Microsoft -&gt; &#123;101:Sohan, 102:Mohan, 103:Rohan &#125; </span></span><br><span class="line"><span class="comment">      *  TCS -&gt; &#123;101:Ram, 102: Shyam, 103: Sunil &#125; </span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">      <span class="comment">//create a table</span></span><br><span class="line">      Table&lt;String, String, String&gt; employeeTable = HashBasedTable.create();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//initialize the table with employee details</span></span><br><span class="line">      employeeTable.put(<span class="string">"IBM"</span>, <span class="string">"101"</span>,<span class="string">"Mahesh"</span>);</span><br><span class="line">      employeeTable.put(<span class="string">"IBM"</span>, <span class="string">"102"</span>,<span class="string">"Ramesh"</span>);</span><br><span class="line">      employeeTable.put(<span class="string">"IBM"</span>, <span class="string">"103"</span>,<span class="string">"Suresh"</span>);</span><br><span class="line"></span><br><span class="line">      employeeTable.put(<span class="string">"Microsoft"</span>, <span class="string">"111"</span>,<span class="string">"Sohan"</span>);</span><br><span class="line">      employeeTable.put(<span class="string">"Microsoft"</span>, <span class="string">"112"</span>,<span class="string">"Mohan"</span>);</span><br><span class="line">      employeeTable.put(<span class="string">"Microsoft"</span>, <span class="string">"113"</span>,<span class="string">"Rohan"</span>);</span><br><span class="line"></span><br><span class="line">      employeeTable.put(<span class="string">"TCS"</span>, <span class="string">"121"</span>,<span class="string">"Ram"</span>);</span><br><span class="line">      employeeTable.put(<span class="string">"TCS"</span>, <span class="string">"122"</span>,<span class="string">"Shyam"</span>);</span><br><span class="line">      employeeTable.put(<span class="string">"TCS"</span>, <span class="string">"123"</span>,<span class="string">"Sunil"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get Map corresponding to IBM</span></span><br><span class="line">      Map&lt;String,String&gt; ibmEmployees =  employeeTable.row(<span class="string">"IBM"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"List of IBM Employees"</span>);</span><br><span class="line">      <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : ibmEmployees.entrySet())&#123;</span><br><span class="line">         System.out.println(<span class="string">"Emp Id: "</span> + entry.getKey() + <span class="string">", Name: "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get all the unique keys of the table</span></span><br><span class="line">      Set&lt;String&gt; employers = employeeTable.rowKeySet();</span><br><span class="line">      System.out.print(<span class="string">"Employers: "</span>);</span><br><span class="line">      <span class="keyword">for</span>(String employer: employers)&#123;</span><br><span class="line">         System.out.print(employer + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get a Map corresponding to 102</span></span><br><span class="line">      Map&lt;String,String&gt; EmployerMap =  employeeTable.column(<span class="string">"102"</span>);</span><br><span class="line">      <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : EmployerMap.entrySet())&#123;</span><br><span class="line">         System.out.println(<span class="string">"Employer: "</span> + entry.getKey() + <span class="string">", Name: "</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-8"><a href="#验证结果-8" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List of IBM Employees</span><br><span class="line">Emp Id: 102, Name: Ramesh</span><br><span class="line">Emp Id: 101, Name: Mahesh</span><br><span class="line">Emp Id: 103, Name: Suresh</span><br><span class="line">Employers: IBM TCS Microsoft </span><br><span class="line">Employer: IBM, Name: Ramesh</span><br></pre></td></tr></table></figure><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p>Guava通过接口LoadingCache提供了一个非常强大的基于内存的LoadingCache&lt;K，V&gt;。在缓存中自动加载值，它提供了许多实用的方法，在有缓存需求时非常有用。</p><h2 id="接口声明-3"><a href="#接口声明-3" class="headerlink" title="接口声明"></a>接口声明</h2><p>​    以下是forcom.google.common.cache.LoadingCache&lt;K，V&gt;接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadingCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Function</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="接口方法-3"><a href="#接口方法-3" class="headerlink" title="接口方法"></a>接口方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>V apply(K key)</strong>              不推荐使用。提供满足功能接口;使用get(K)或getUnchecked(K)代替。</td></tr><tr><td>2</td><td><strong>ConcurrentMap asMap()</strong>              返回存储在该缓存作为一个线程安全的映射条目的视图。</td></tr><tr><td>3</td><td><strong>V get(K key)</strong>              返回一个键在这个高速缓存中，首先装载如果需要该值相关联的值。</td></tr><tr><td>4</td><td><strong>ImmutableMap getAll(Iterable keys)</strong>              返回一个键相关联的值的映射，创建或必要时检索这些值。</td></tr><tr><td>5</td><td><strong>V getUnchecked(K key)</strong>              返回一个键在这个高速缓存中，首先装载如果需要该值相关联的值。</td></tr><tr><td>6</td><td><strong>void refresh(K key)</strong>              加载键key，可能是异步的一个新值。</td></tr></tbody></table><h2 id="LoadingCache-示例"><a href="#LoadingCache-示例" class="headerlink" title="LoadingCache 示例"></a>LoadingCache 示例</h2><p>​    使用所选择的编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.MoreObjects;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheLoader;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.LoadingCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="comment">//create a cache for employees based on their employee id</span></span><br><span class="line">      LoadingCache employeeCache = </span><br><span class="line">         CacheBuilder.newBuilder()</span><br><span class="line">            .maximumSize(<span class="number">100</span>) <span class="comment">// maximum 100 records can be cached</span></span><br><span class="line">            .expireAfterAccess(<span class="number">30</span>, TimeUnit.MINUTES) <span class="comment">// cache will expire after 30 minutes of access</span></span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader()&#123; <span class="comment">// build the cacheloader</span></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Employee <span class="title">load</span><span class="params">(String empId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">//make the expensive call</span></span><br><span class="line">                  <span class="keyword">return</span> getFromDatabase(empId);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//on first invocation, cache will be populated with corresponding</span></span><br><span class="line">         <span class="comment">//employee record</span></span><br><span class="line">         System.out.println(<span class="string">"Invocation #1"</span>);</span><br><span class="line">         System.out.println(employeeCache.get(<span class="string">"100"</span>));</span><br><span class="line">         System.out.println(employeeCache.get(<span class="string">"103"</span>));</span><br><span class="line">         System.out.println(employeeCache.get(<span class="string">"110"</span>));</span><br><span class="line">         <span class="comment">//second invocation, data will be returned from cache</span></span><br><span class="line">         System.out.println(<span class="string">"Invocation #2"</span>);</span><br><span class="line">         System.out.println(employeeCache.get(<span class="string">"100"</span>));</span><br><span class="line">         System.out.println(employeeCache.get(<span class="string">"103"</span>));</span><br><span class="line">         System.out.println(employeeCache.get(<span class="string">"110"</span>));</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Employee <span class="title">getFromDatabase</span><span class="params">(String empId)</span></span>&#123;</span><br><span class="line">      Employee e1 = <span class="keyword">new</span> Employee(<span class="string">"Mahesh"</span>, <span class="string">"Finance"</span>, <span class="string">"100"</span>);</span><br><span class="line">      Employee e2 = <span class="keyword">new</span> Employee(<span class="string">"Rohan"</span>, <span class="string">"IT"</span>, <span class="string">"103"</span>);</span><br><span class="line">      Employee e3 = <span class="keyword">new</span> Employee(<span class="string">"Sohan"</span>, <span class="string">"Admin"</span>, <span class="string">"110"</span>);</span><br><span class="line"></span><br><span class="line">      Map database = <span class="keyword">new</span> HashMap();</span><br><span class="line">      database.put(<span class="string">"100"</span>, e1);</span><br><span class="line">      database.put(<span class="string">"103"</span>, e2);</span><br><span class="line">      database.put(<span class="string">"110"</span>, e3);</span><br><span class="line">      System.out.println(<span class="string">"Database hit for"</span> + empId);</span><br><span class="line">      <span class="keyword">return</span> database.get(empId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   String dept;</span><br><span class="line">   String emplD;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, String dept, String empID)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.emplD = empID;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getDept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dept;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDept</span><span class="params">(String dept)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getEmplD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> emplD;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmplD</span><span class="params">(String emplD)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.emplD = emplD;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> MoreObjects.toStringHelper(Employee<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">      .add("Name", name)</span><br><span class="line">      .add(<span class="string">"Department"</span>, dept)</span><br><span class="line">      .add(<span class="string">"Emp Id"</span>, emplD).toString();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-9"><a href="#验证结果-9" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器如下编译类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Invocation <span class="comment">#1</span></span><br><span class="line">Database hit for100</span><br><span class="line">Employee&#123;Name=Mahesh, Department=Finance, Emp Id=100&#125;</span><br><span class="line">Database hit for103</span><br><span class="line">Employee&#123;Name=Rohan, Department=IT, Emp Id=103&#125;</span><br><span class="line">Database hit for110</span><br><span class="line">Employee&#123;Name=Sohan, Department=Admin, Emp Id=110&#125;</span><br><span class="line">Invocation <span class="comment">#2</span></span><br><span class="line">Employee&#123;Name=Mahesh, Department=Finance, Emp Id=100&#125;</span><br><span class="line">Employee&#123;Name=Rohan, Department=IT, Emp Id=103&#125;</span><br><span class="line">Employee&#123;Name=Sohan, Department=Admin, Emp Id=110&#125;</span><br></pre></td></tr></table></figure><h1 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h1><p>Joiner 提供了各种方法来处理字符串加入操作，对象等。</p><h2 id="类声明-6"><a href="#类声明-6" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.Joiner类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Joiner</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法-5"><a href="#类方法-5" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>A appendTo(A appendable, Iterable parts)</strong>              每个追加部分的字符串表示，使用每个之间先前配置的分离器，可用来追加。</td></tr><tr><td>2</td><td><strong>A appendTo(A appendable, Iterator parts)</strong>              每个追加部分的字符串表示，使用每个之间先前配置的分离器，可用来追加。</td></tr><tr><td>3</td><td><strong>A appendTo(A appendable, Object[] parts)</strong>              每个追加部分的字符串表示，使用每个之间先前配置的分离器，可用来追加。</td></tr><tr><td>4</td><td><strong>A appendTo(A appendable, Object first, Object second, Object… rest)</strong>              追加到可追加的每个其余参数的字符串表示。</td></tr><tr><td>5</td><td><strong>StringBuilder appendTo(StringBuilder builder, Iterable parts)</strong>              每个追加部分的字符串表示，使用每个之间先前配置的分离器，为构建者。</td></tr><tr><td>6</td><td><strong>StringBuilder appendTo(StringBuilder builder, Iterator parts)</strong>              每个追加部分的字符串表示，使用每个之间先前配置的分离器，为构建者。</td></tr><tr><td>7</td><td><strong>StringBuilder appendTo(StringBuilder builder, Object[] parts)</strong>              每个追加部分的字符串表示，使用每个之间先前配置的分离器，为构建者。</td></tr><tr><td>8</td><td><strong>StringBuilder appendTo(StringBuilder builder, Object first, Object second, Object… rest)</strong>              追加到构建器的每个其余参数的字符串表示。</td></tr><tr><td>9</td><td><strong>String join(Iterable parts)</strong>              返回一个包含每个部分的字符串表示，使用每个之间先前配置的分隔符的字符串。</td></tr><tr><td>10</td><td><strong>String join(Iterator parts)</strong>              返回一个包含每个部分的字符串表示，使用每个之间先前配置的分隔符的字符串。</td></tr><tr><td>11</td><td><strong>String join(Object[] parts)</strong>              返回一个包含每个部分的字符串表示，使用每个之间先前配置的分隔符的字符串。</td></tr><tr><td>12</td><td><strong>String join(Object first, Object second, Object… rest)</strong>              返回一个包含每个参数的字符串表示，使用每个之间先前配置的分隔符的字符串。</td></tr><tr><td>13</td><td><strong>static Joiner on(char separator)</strong>              返回一个加入者其连续元素之间自动地分隔符。</td></tr><tr><td>14</td><td><strong>static Joiner on(String separator)</strong>              返回一个加入者其连续元素之间自动地分隔符。</td></tr><tr><td>15</td><td><strong>Joiner skipNulls()</strong>              返回一个相同的行为，因为这加入者，除了自动跳过任何提供空元素的加入者。</td></tr><tr><td>16</td><td><strong>Joiner useForNull(String nullText)</strong>              返回一个相同的行为，因为这一个加入者，除了自动替换nullText任何提供null元素。</td></tr><tr><td>17</td><td><strong>Joiner.MapJoiner withKeyValueSeparator(String keyValueSeparator)</strong>              返回使用给定键值分离器MapJoiner，和相同的结构，否则为Joiner连接符 。</td></tr></tbody></table><h2 id="继承的方法-4"><a href="#继承的方法-4" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Joiner-示例"><a href="#Joiner-示例" class="headerlink" title="Joiner 示例"></a>Joiner 示例</h2><p>​    使用所选择的编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Joiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testJoiner();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testJoiner</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(Joiner.on(<span class="string">","</span>)</span><br><span class="line">         .skipNulls()</span><br><span class="line">         .join(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="number">6</span>)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证输出结果"><a href="#验证输出结果" class="headerlink" title="验证输出结果"></a>验证输出结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看看结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5,6</span><br></pre></td></tr></table></figure><h1 id="Spiltter"><a href="#Spiltter" class="headerlink" title="Spiltter"></a>Spiltter</h1><p>Splitter 提供了各种方法来处理分割操作字符串，对象等。</p><h2 id="类声明-7"><a href="#类声明-7" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.Splitter类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Splitter</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="类方法-6"><a href="#类方法-6" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th style="text-align:left">S.N.</th><th style="text-align:left">方法及说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>static Splitter fixedLength(int length)</strong>              返回分离器的划分字符串到给定长度的片段。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>Splitter limit(int limit)</strong>              返回一个分离器，其行为等同于这个分离器，但停止分裂后达到了极限。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>Splitter omitEmptyStrings()</strong>              返回使用给定的单字符分离器分离器。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>static Splitter on(char separator)</strong>              返回使用给定的单字符分离器分离器。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>static Splitter on(CharMatcher separatorMatcher)</strong>              返回一个分离器的匹配考虑由给定CharMatcher是一个分隔任何单个字符。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>static Splitter on(Pattern separatorPattern)</strong>              返回分离器的考虑任何序列匹配模式是一个分隔符。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>static Splitter on(String separator)</strong>              返回使用给定的固定的字符串作为分隔符分离器。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>static Splitter onPattern(String separatorPattern)</strong>              返回分离器的考虑任何序列匹配一个给定模式(正则表达式)是一个分隔符。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>Iterable split(CharSequence sequence)</strong>              分割成序列串组件并使其可通过迭代器，其可以被懒惰地评估计算。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong>List splitToList(CharSequence sequence)</strong>              拆分序列化为字符串组成部分，并将其返回为不可变列表。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>Splitter trimResults()</strong>              返回分离器的行为等同于该分离器，但会自动删除开头和结尾的空白，从每个返回子;相当于trimResults(CharMatcher.WHITESPACE).</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>Splitter trimResults(CharMatcher trimmer)</strong>              返回分离器的行为等同于该分离器，但会删除所有开头或结尾的字符匹配每一个给定的CharMatcher返回字符串。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong>Splitter.MapSplitter withKeyValueSeparator(char separator)</strong>              返回MapSplitter这样会将在此基础上分离器的条目，并分割成入口键和值使用指定的分隔符。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><strong>Splitter.MapSplitter withKeyValueSeparator(Splitter keyValueSplitter)</strong>              返回MapSplitter这样会将在此基础上分离器的条目，并分割成条目使用指定的键值分离器键和值。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong>Splitter.MapSplitter withKeyValueSeparator(String separator)</strong>              返回MapSplitter这样会将在此基础上分离器的条目，并分割成入口键和值使用指定的分隔符。</td></tr></tbody></table><h2 id="继承的方法-5"><a href="#继承的方法-5" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Splitter-例子"><a href="#Splitter-例子" class="headerlink" title="Splitter 例子"></a>Splitter 例子</h2><p>​    使用所选择的编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.Splitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testSplitter();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(Splitter.on(<span class="string">','</span>)</span><br><span class="line">         .trimResults()</span><br><span class="line">         .omitEmptyStrings()</span><br><span class="line">         .split(<span class="string">"the ,quick, , brown         , fox,              jumps, over, the, lazy, little dog."</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证输出"><a href="#验证输出" class="headerlink" title="验证输出"></a>验证输出</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[the, quick, brown, fox, jumps, over, the, lazy, little dog.]</span><br></pre></td></tr></table></figure><h1 id="CharMatcher"><a href="#CharMatcher" class="headerlink" title="CharMatcher"></a>CharMatcher</h1><p>CharMatcher提供了各种方法来处理各种JAVA char类型值。</p><h2 id="类声明-8"><a href="#类声明-8" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.CharMatcher类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CharMatcher</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th>S.N.</th><th>字段及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static CharMatcher ANY</strong>              匹配任意字符。</td></tr><tr><td>2</td><td><strong>static CharMatcher ASCII</strong>              确定字符是否为ASCII码，这意味着它的代码点低于128。</td></tr><tr><td>3</td><td><strong>static CharMatcher BREAKING_WHITESPACE</strong>              确定一个字符是否是一个破空白（即，一个空格可以解释为格式目的词之间休息）。</td></tr><tr><td>4</td><td><strong>static CharMatcher DIGIT</strong>              确定一个字符是否是根据Unicode数字。</td></tr><tr><td>5</td><td><strong>static CharMatcher INVISIBLE</strong>              确定一个字符是否是看不见的;也就是说，如果它的Unicode类是任何SPACE_SEPARATOR，LINE_SEPARATOR，PARAGRAPH_SEPARATOR，控制，FORMAT，SURROGATE和PRIVATE_USE根据ICU4J。</td></tr><tr><td>6</td><td><strong>static CharMatcher JAVA_DIGIT</strong>              确定一个字符是否是按照Java的定义一个数字。</td></tr><tr><td>7</td><td><strong>static CharMatcher JAVA_ISO_CONTROL</strong>              确定一个字符是否是所指定的Character.isISOControl(char)ISO控制字符。</td></tr><tr><td>8</td><td><strong>static CharMatcher JAVA_LETTER</strong>              确定一个字符是否是按照Java的定义的字母。</td></tr><tr><td>9</td><td><strong>static CharMatcher JAVA_LETTER_OR_DIGIT</strong>              确定一个字符是否是按照Java的定义，一个字母或数字。</td></tr><tr><td>10</td><td><strong>static CharMatcher JAVA_LOWER_CASE</strong>              确定一个字符是否是按照Java定义的小写。</td></tr><tr><td>11</td><td><strong>static CharMatcher JAVA_UPPER_CASE</strong>              确定一个字符是否是按照Java定义的大写。</td></tr><tr><td>12</td><td><strong>static CharMatcher NONE</strong>              匹配任何字符。</td></tr><tr><td>13</td><td><strong>static CharMatcher SINGLE_WIDTH</strong>              确定一个字符是否是单宽度（不是双倍宽度）。</td></tr><tr><td>14</td><td><strong>static CharMatcher WHITESPACE</strong>              决定根据最新的Unicode标准是否字符是空白，如图所示这里。</td></tr></tbody></table><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><table><thead><tr><th>S.N.</th><th>构造函数 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>protected CharMatcher()</strong>              构造方法，供子类使用。</td></tr></tbody></table><h2 id="类方法-7"><a href="#类方法-7" class="headerlink" title="类方法"></a>类方法</h2><table><thead><tr><th>S.N.</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td>1</td><td><strong>CharMatcher and(CharMatcher other)</strong>              返回一个匹配器，匹配两种匹配器和其他任何字符。</td></tr><tr><td>2</td><td><strong>static CharMatcher anyOf(CharSequence sequence)</strong>              返回一个字符匹配匹配任何字符出现在给定的字符序列。</td></tr><tr><td>3</td><td><strong>boolean apply(Character character)</strong>              不推荐使用。只有提供满足谓词接口;用匹配（字符）代替。</td></tr><tr><td>4</td><td><strong>String collapseFrom(CharSequence sequence, char replacement)</strong>              返回输入字符序列的字符串拷贝，每个组连续的字符匹配此匹配由单一的替换字符替换。</td></tr><tr><td>5</td><td><strong>int countIn(CharSequence sequence)</strong>              返回一个字符序列中发现匹配的字符的数目。</td></tr><tr><td>6</td><td><strong>static CharMatcher forPredicate(Predicate predicate)</strong>              返回与相同的行为给定的基于字符的谓词匹配，但运行在原始的字符，而不是实例。</td></tr><tr><td>7</td><td><strong>int indexIn(CharSequence sequence)</strong>              返回第一个匹配字符的索引中的一个字符序列，或-1，如果没有匹配的字符存在。</td></tr><tr><td>8</td><td><strong>int indexIn(CharSequence sequence, int start)</strong>              返回第一个匹配字符的索引中的一个字符序列，从给定位置开始，或-1，如果没有字符的位置之后匹配。</td></tr><tr><td>9</td><td><strong>static CharMatcher inRange(char startInclusive, char endInclusive)</strong>              返回一个字符匹配匹配给定范围内的任何字符（两个端点也包括在内）。</td></tr><tr><td>10</td><td><strong>static CharMatcher is(char match)</strong>              返回一个字符匹配匹配只有一个指定的字符。</td></tr><tr><td>11</td><td><strong>static CharMatcher isNot(char match)</strong>              返回一个字符匹配匹配除了指定的任何字符。</td></tr><tr><td>12</td><td><strong>int lastIndexIn(CharSequence sequence)</strong>              返回最后一个匹配字符的索引中的字符序列，或-1，如果没有匹配的字符存在。</td></tr><tr><td>13</td><td><strong>abstract boolean matches(char c)</strong>              确定给定字符一个true或false值。</td></tr><tr><td>14</td><td><strong>boolean matchesAllOf(CharSequence sequence)</strong>              确定给定字符一个true或false值。</td></tr><tr><td>15</td><td><strong>boolean matchesAnyOf(CharSequence sequence)</strong>              返回true如果字符序列包含至少一个匹配的字符。</td></tr><tr><td>16</td><td><strong>boolean matchesNoneOf(CharSequence sequence)</strong>              返回true，如果一个字符序列中没有匹配的字符。</td></tr><tr><td>17</td><td><strong>CharMatcher negate()</strong>              返回一个匹配器，不受此匹配匹配任何字符。</td></tr><tr><td>18</td><td><strong>static CharMatcher noneOf(CharSequence sequence)</strong>              返回一个字符匹配器匹配不存在于给定的字符序列的任何字符。</td></tr><tr><td>19</td><td><strong>CharMatcher or(CharMatcher other)</strong>              返回一个匹配器，匹配任何匹配或其他任何字符。</td></tr><tr><td>20</td><td><strong>CharMatcher precomputed()</strong>              返回一个字符匹配功能上等同于这一个，但它可能会快于原来的查询;您的里程可能会有所不同。</td></tr><tr><td>21</td><td><strong>String removeFrom(CharSequence sequence)</strong>              返回包含的字符序列的所有非匹配的字符，为了一个字符串。</td></tr><tr><td>22</td><td><strong>String replaceFrom(CharSequence sequence, char replacement)</strong>              返回输入字符序列的字符串副本，其中每个字符匹配该匹配器由一个给定的替换字符替换。</td></tr><tr><td>23</td><td><strong>String replaceFrom(CharSequence sequence, CharSequence replacement)</strong>              返回输入字符序列的字符串副本，其中每个字符匹配该匹配器由一个给定的替换序列替换。</td></tr><tr><td>24</td><td><strong>String retainFrom(CharSequence sequence)</strong>              返回包含的字符序列的所有字符匹配，为了一个字符串。</td></tr><tr><td>25</td><td><strong>String toString()</strong>              返回此CharMatcher，如CharMatcher.or（WHITESPACE，JAVA_DIGIT）的字符串表示。</td></tr><tr><td>26</td><td><strong>String trimAndCollapseFrom(CharSequence sequence, char replacement)</strong>              折叠匹配字符完全一样collapseFrom一组如collapseFrom(java.lang.CharSequence, char) 做的一样，不同之处在于，无需更换一组被移除的匹配字符在开始或该序列的结束。</td></tr><tr><td>27</td><td><strong>String trimFrom(CharSequence sequence)</strong>              返回输入字符序列省略了所有匹配器从一开始，并从该串的末尾匹配字符的字符串。</td></tr><tr><td>28</td><td><strong>String trimLeadingFrom(CharSequence sequence)</strong>              返回输入字符序列，它省略了所有这些匹配的字符串开始处匹配字符的字符串。</td></tr><tr><td>29</td><td><strong>String trimTrailingFrom(CharSequence sequence)</strong>              返回输入字符序列，它省略了所有这些匹配的字符串的结尾匹配字符的字符串。</td></tr></tbody></table><h2 id="继承的方法-6"><a href="#继承的方法-6" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="CharMatcher-例子"><a href="#CharMatcher-例子" class="headerlink" title="CharMatcher 例子"></a>CharMatcher 例子</h2><p>​    使用所选择的编辑器创建下面的java程序 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.CharMatcher;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Splitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testCharMatcher();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testCharMatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(CharMatcher.DIGIT.retainFrom(<span class="string">"mahesh123"</span>)); <span class="comment">// only the digits</span></span><br><span class="line">      System.out.println(CharMatcher.WHITESPACE.trimAndCollapseFrom(<span class="string">"     Mahesh     Parashar "</span>, <span class="string">' '</span>));</span><br><span class="line">      <span class="comment">// trim whitespace at ends, and replace/collapse whitespace into single spaces</span></span><br><span class="line">      System.out.println(CharMatcher.JAVA_DIGIT.replaceFrom(<span class="string">"mahesh123"</span>, <span class="string">"*"</span>)); <span class="comment">// star out all digits</span></span><br><span class="line">      System.out.println(CharMatcher.JAVA_DIGIT.or(CharMatcher.JAVA_LOWER_CASE).retainFrom(<span class="string">"mahesh123"</span>));</span><br><span class="line">      <span class="comment">// eliminate all characters that aren't digits or lowercase</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-10"><a href="#验证结果-10" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看看结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">Mahesh Parashar</span><br><span class="line">mahesh***</span><br><span class="line">mahesh123</span><br></pre></td></tr></table></figure><h1 id="CaseFormat"><a href="#CaseFormat" class="headerlink" title="CaseFormat"></a>CaseFormat</h1><p>CaseFormat是一种实用工具类，以提供不同的ASCII字符格式之间的转换。</p><h2 id="类声明-9"><a href="#类声明-9" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.base.CaseFormat类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CaseFormat</span><br><span class="line">   extends Enum&lt;CaseFormat&gt;</span><br></pre></td></tr></table></figure><h2 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h2><table><thead><tr><th>S.N.</th><th>枚举常量和说明</th></tr></thead><tbody><tr><td>1</td><td><strong>LOWER_CAMEL</strong>              Java变量的命名规则，如“lowerCamel”。</td></tr><tr><td>2</td><td><strong>LOWER_HYPHEN</strong>              连字符连接变量的命名规则，如“lower-hyphen”。</td></tr><tr><td>3</td><td><strong>LOWER_UNDERSCORE</strong>              C ++变量命名规则，如“lower_underscore”。</td></tr><tr><td>4</td><td><strong>UPPER_CAMEL</strong>              Java和C++类的命名规则，如“UpperCamel”。</td></tr><tr><td>5</td><td><strong>UPPER_UNDERSCORE</strong>              Java和C++常量的命名规则，如“UPPER_UNDERSCORE”。</td></tr></tbody></table><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>Converter converterTo(CaseFormat targetFormat)</strong>              返回一个转换，从这个格式转换targetFormat字符串。</td></tr><tr><td>2</td><td><strong>String to(CaseFormat format, String str)</strong>              从这一格式指定格式的指定字符串 str 转换。</td></tr><tr><td>3</td><td><strong>static CaseFormat valueOf(String name)</strong>              返回此类型具有指定名称的枚举常量。</td></tr><tr><td>4</td><td><strong>static CaseFormat[] values()</strong>              返回一个包含该枚举类型的常量数组中的顺序被声明。</td></tr></tbody></table><h2 id="继承的方法-7"><a href="#继承的方法-7" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Enum</li><li>​            java.lang.Object</li></ul><h2 id="CaseFormat-示例"><a href="#CaseFormat-示例" class="headerlink" title="CaseFormat 示例"></a>CaseFormat 示例</h2><p>​    使用所选择的编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.base.CaseFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testCaseFormat();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testCaseFormat</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String data = <span class="string">"test_data"</span>;</span><br><span class="line">      System.out.println(CaseFormat.LOWER_HYPHEN.to(CaseFormat.LOWER_CAMEL, <span class="string">"test-data"</span>));</span><br><span class="line">      System.out.println(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, <span class="string">"test_data"</span>));</span><br><span class="line">      System.out.println(CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, <span class="string">"test_data"</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-11"><a href="#验证结果-11" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testData</span><br><span class="line">testData</span><br><span class="line">TestData</span><br></pre></td></tr></table></figure><h1 id="Bytes"><a href="#Bytes" class="headerlink" title="Bytes"></a>Bytes</h1><p>Bytes是byte的基本类型实用工具类。</p><h2 id="类声明-10"><a href="#类声明-10" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Bytes类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bytes</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(byte… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似 Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static byte[] concat(byte[]… arrays)</strong>              则返回来自每个阵列提供组合成一个单一的阵列值。</td></tr><tr><td>3</td><td><strong>static boolean contains(byte[] array, byte target)</strong>              返回true，如果目标是否存在在任何地方数组元素。</td></tr><tr><td>4</td><td><strong>static byte[] ensureCapacity(byte[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>5</td><td><strong>static int hashCode(byte value)</strong>              返回哈希码的值;等于调用的结果 ((Byte) value).hashCode().</td></tr><tr><td>6</td><td><strong>static int indexOf(byte[] array, byte target)</strong>              返回目标数组的首次出现的索引值。</td></tr><tr><td>7</td><td><strong>static int indexOf(byte[] array, byte[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1如果不存在。</td></tr><tr><td>8</td><td><strong>static int lastIndexOf(byte[] array, byte target)</strong>              返回目标在数组中最后一个出场的索引的值。</td></tr><tr><td>9</td><td><strong>static byte[] toArray(Collection collection)</strong>              返回包含集合的每个值的数组，转换为字节值中的方式Number.byteValue().</td></tr></tbody></table><h2 id="继承的方法-8"><a href="#继承的方法-8" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Bytes-示例"><a href="#Bytes-示例" class="headerlink" title="Bytes 示例"></a>Bytes 示例</h2><p>​    使用所选择的编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testBytes();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Byte&gt; objectArray = Bytes.asList(byteArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      byteArray = Bytes.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; byteArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(byteArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="keyword">byte</span> data = <span class="number">5</span>;</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"5 is in list? "</span>+ Bytes.contains(byteArray, data));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the index</span></span><br><span class="line">      System.out.println(<span class="string">"Index of 5: "</span> + Bytes.indexOf(byteArray,data));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the last index maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Last index of 5: "</span> + Bytes.lastIndexOf(byteArray,data));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-12"><a href="#验证结果-12" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 5, 7, 9, 9]</span><br><span class="line">[ 1 2 3 4 5 5 7 9 9 ]</span><br><span class="line">5 is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line">Index of 5: 4</span><br><span class="line">Last index of 5: 5</span><br></pre></td></tr></table></figure><h1 id="Shorts"><a href="#Shorts" class="headerlink" title="Shorts"></a>Shorts</h1><p>Shorts是基本类型short的实用工具类。</p><h2 id="类声明-11"><a href="#类声明-11" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Shorts类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Shorts</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><table><thead><tr><th>S.N.</th><th>字段及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static int BYTES</strong>              所需要的字节数来表示一个原始short的值。</td></tr><tr><td>2</td><td><strong>static short MAX_POWER_OF_TWO</strong>              两个最大的幂可以被表示为short。</td></tr></tbody></table><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(short… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似 Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static short checkedCast(long value)</strong>              返回 short 值，该值等于value，如果可能的话。</td></tr><tr><td>3</td><td><strong>static int compare(short a, short b)</strong>              比较两个指定的short值。</td></tr><tr><td>4</td><td><strong>static short[] concat(short[]… arrays)</strong>              每个阵列提供组合成一个单一的阵列，则返回其值。</td></tr><tr><td>5</td><td><strong>static boolean contains(short[] array, short target)</strong>              返回true，如果目标是否存在在任何地方数组元素。</td></tr><tr><td>6</td><td><strong>static short[] ensureCapacity(short[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>7</td><td><strong>static short fromByteArray(byte[] bytes)</strong>              返回短值，其大端表示被存储在最前2字节的字节;相当于 ByteBuffer.wrap(bytes).getShort().</td></tr><tr><td>8</td><td><strong>static short fromBytes(byte b1, byte b2)</strong>              返回short值的字节表示的是给定2个字节，以 big-endian 顺序; 相当于 Shorts.fromByteArray(new byte[] {b1, b2}).</td></tr><tr><td>9</td><td><strong>static int hashCode(short value)</strong>              返回值的哈希码;等于调用的结果 ((Short) value).hashCode().</td></tr><tr><td>10</td><td><strong>static int indexOf(short[] array, short target)</strong>              返回值目标数组的首次出现的索引。</td></tr><tr><td>11</td><td><strong>static int indexOf(short[] array, short[] target)</strong>              返回指定目标的第一个匹配的起始位置数组或-1，如果不存在这样的发生。</td></tr><tr><td>12</td><td><strong>static String join(String separator, short… array)</strong>              返回包含由分离器分离所提供的短值的字符串。</td></tr><tr><td>13</td><td><strong>static int lastIndexOf(short[] array, short target)</strong>              返回目标在数组中最后一个出现的索引的值。</td></tr><tr><td>14</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较，比较两个 short 阵列字典顺序。</td></tr><tr><td>15</td><td><strong>static short max(short… array)</strong>              返回出现在数组中的最大值。</td></tr><tr><td>16</td><td><strong>static short min(short… array)</strong>              返回出现在数组的最小值。</td></tr><tr><td>17</td><td><strong>static short saturatedCast(long value)</strong>              返回short最接近int的值。</td></tr><tr><td>18</td><td><strong>static Converter stringConverter()</strong>              返回使用字符串和shorts之间的一个转换器序列化对象 Short.decode(java.lang.String) and Short.toString().</td></tr><tr><td>19</td><td><strong>static short[] toArray(Collection collection)</strong>              返回包含集合的每个值的数组，转换为 short 值的方式Number.shortValue().</td></tr><tr><td>20</td><td><strong>static byte[] toByteArray(short value)</strong>              返回在2元素的字节数组值大尾数法表示;相当于 ByteBuffer.allocate(2).putShort(value).array().</td></tr></tbody></table><h2 id="继承的方法-9"><a href="#继承的方法-9" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Shorts-示例"><a href="#Shorts-示例" class="headerlink" title="Shorts 示例"></a>Shorts 示例</h2><p>​    使用所选择的编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Shorts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testShorts();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testShorts</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">short</span>[] shortArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Short&gt; objectArray = Shorts.asList(shortArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      shortArray = Shorts.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; shortArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(shortArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="keyword">short</span> data = <span class="number">5</span>;</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"5 is in list? "</span>+ Shorts.contains(shortArray, data));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the minimum</span></span><br><span class="line">      System.out.println(<span class="string">"Min: "</span> + Shorts.min(shortArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Max: "</span> + Shorts.max(shortArray));</span><br><span class="line">      data = <span class="number">2400</span>;</span><br><span class="line">      <span class="comment">//get the byte array from an integer</span></span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = Shorts.toByteArray(data);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; byteArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(byteArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-13"><a href="#验证结果-13" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[ 1 2 3 4 5 6 7 8 9 ]</span><br><span class="line">5 is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line">Min: 1</span><br><span class="line">Max: 9</span><br><span class="line">9 96</span><br></pre></td></tr></table></figure><h1 id="Ints"><a href="#Ints" class="headerlink" title="Ints"></a>Ints</h1><p>整数Ints是原始的int类型的实用工具类。</p><h2 id="类声明-12"><a href="#类声明-12" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Ints类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Ints</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字段-1"><a href="#字段-1" class="headerlink" title="字段"></a>字段</h2><table><thead><tr><th>S.N.</th><th>字段及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static int BYTES</strong>              所需要的字节数来表示一个原始int值。</td></tr><tr><td>2</td><td><strong>static int MAX_POWER_OF_TWO</strong>              两个最大的幂可以被表示为整数。</td></tr></tbody></table><h2 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(int… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static int checkedCast(long value)</strong>              返回int值等于值，如果可能的话。</td></tr><tr><td>3</td><td><strong>static int compare(int a, int b)</strong>              比较两个指定的int值。</td></tr><tr><td>4</td><td><strong>static int[] concat(int[]… arrays)</strong>              每个阵列提供组合成一个单一的阵列，则返回值。</td></tr><tr><td>5</td><td><strong>static boolean contains(int[] array, int target)</strong>              返回true，如果target是否存在在任何地方数组元素。</td></tr><tr><td>6</td><td><strong>static int[] ensureCapacity(int[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>7</td><td><strong>static int fromByteArray(byte[] bytes)</strong>              返回int值，其大端表示存储在第一个4字节的字节;相当于ByteBuffer.wrap(bytes).getInt().</td></tr><tr><td>8</td><td><strong>static int fromBytes(byte b1, byte b2, byte b3, byte b4)</strong>              返回int值的字节表示的是给定的4个字节，在big-endian的顺序;相当于 Ints.fromByteArray(new byte[] {b1, b2, b3, b4}).</td></tr><tr><td>9</td><td><strong>static int hashCode(int value)</strong>              返回值的哈希码; 等于调用 ((Integer) value).hashCode() 的结果</td></tr><tr><td>10</td><td><strong>static int indexOf(int[] array, int target)</strong>              返回值目标数组的第一次亮相的索引。</td></tr><tr><td>11</td><td><strong>static int indexOf(int[] array, int[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1，如果不存在。</td></tr><tr><td>12</td><td><strong>static String join(String separator, int… array)</strong>              返回包含由分离器分离所提供的整型值的字符串。</td></tr><tr><td>13</td><td><strong>static int lastIndexOf(int[] array, int target)</strong>              返回target 在数组中最后一个出场的索引值。</td></tr><tr><td>14</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较，比较两个int数组字典顺序。</td></tr><tr><td>15</td><td><strong>static int max(int… array)</strong>              返回出现在数组中的最大值。</td></tr><tr><td>16</td><td><strong>static int min(int… array)</strong>              返回最小值出现在数组。</td></tr><tr><td>17</td><td><strong>static int saturatedCast(long value)</strong>              返回最接近的int值。</td></tr><tr><td>18</td><td><strong>static Converter stringConverter()</strong>              返回使用字符串和整数之间的一个转换器序列化对象 Integer.decode(java.lang.String) 和 Integer.toString().</td></tr><tr><td>19</td><td><strong>static int[] toArray(Collection collection)</strong>              返回包含集合的每个值的数组，转换为int值的方式Number.intValue().</td></tr><tr><td>20</td><td><strong>static byte[] toByteArray(int value)</strong>              返回一个4元素的字节数组值大端表示;相当于 ByteBuffer.allocate(4).putInt(value).array().</td></tr><tr><td>21</td><td><strong>static Integer tryParse(String string)</strong>              解析指定的字符串作为符号十进制整数。</td></tr></tbody></table><h2 id="继承的方法-10"><a href="#继承的方法-10" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Ints-示例"><a href="#Ints-示例" class="headerlink" title="Ints 示例"></a>Ints 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Ints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testInts();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testInts</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] intArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Integer&gt; objectArray = Ints.asList(intArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      intArray = Ints.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; intArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(intArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"5 is in list? "</span>+ Ints.contains(intArray, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the minimum</span></span><br><span class="line">      System.out.println(<span class="string">"Min: "</span> + Ints.min(intArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Max: "</span> + Ints.max(intArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get the byte array from an integer</span></span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = Ints.toByteArray(<span class="number">20000</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; byteArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(byteArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-14"><a href="#验证结果-14" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[ 1 2 3 4 5 6 7 8 9 ]</span><br><span class="line">5 is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line">Min: 1</span><br><span class="line">Max: 9</span><br><span class="line">0 0 78 32</span><br></pre></td></tr></table></figure><h1 id="Longs"><a href="#Longs" class="headerlink" title="Longs"></a>Longs</h1><p>Longs是基本类型long的实用工具类。</p><h2 id="类声明-13"><a href="#类声明-13" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Longs类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Longs</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字段-2"><a href="#字段-2" class="headerlink" title="字段"></a>字段</h2><table><thead><tr><th>S.N.</th><th>字段及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static int BYTES</strong>              所需要的字节数来表示一个原始long 值。</td></tr><tr><td>2</td><td><strong>static long MAX_POWER_OF_TWO</strong>              两个最大幂可以被表示为一个long。</td></tr></tbody></table><h2 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(long… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static int compare(long a, long b)</strong>              比较两个指定数的long值。</td></tr><tr><td>3</td><td><strong>static long[] concat(long[]… arrays)</strong>              每个数组提供组合成一个单一的数组，则返回值。</td></tr><tr><td>4</td><td><strong>static boolean contains(long[] array, long target)</strong>              返回true，如果target是否存在在任何地方数组元素。</td></tr><tr><td>5</td><td><strong>static long[] ensureCapacity(long[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>6</td><td><strong>static long fromByteArray(byte[] bytes)</strong>              返回long值，其大端表示存储在头8个字节的字节;相当于ByteBuffer.wrap(bytes).getLong().</td></tr><tr><td>7</td><td><strong>static long fromBytes(byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8)</strong>              返回long值，字节表示的是给定的8个字节，在big-endian的顺序;相当于 Longs.fromByteArray(new byte[] {b1, b2, b3, b4, b5, b6, b7, b8}).</td></tr><tr><td>8</td><td><strong>static int hashCode(long value)</strong>              返回哈希码的值;等于调用 ((Long) value).hashCode() 的结果</td></tr><tr><td>9</td><td><strong>static int indexOf(long[] array, long target)</strong>              返回目标数组的首次出现的索引值。</td></tr><tr><td>10</td><td><strong>static int indexOf(long[] array, long[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1，如果不存在。</td></tr><tr><td>11</td><td><strong>static String join(String separator, long… array)</strong>              返回包含由分离器分离所提供long 的字符串值。</td></tr><tr><td>12</td><td><strong>static int lastIndexOf(long[] array, long target)</strong>              返回target 在数组中最后一个出场的索引值。</td></tr><tr><td>13</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较，比较两个long数组字典顺序。</td></tr><tr><td>14</td><td><strong>static long max(long… array)</strong>              返回出现在数组中的最大值。</td></tr><tr><td>15</td><td><strong>static long min(long… array)</strong>              返回最小值出现在数组。</td></tr><tr><td>16</td><td><strong>static Converter stringConverter()</strong>              返回使用字符串和长整型之间的转换可序列化器对象Long.decode(java.lang.String) 和 Long.toString().</td></tr><tr><td>17</td><td><strong>static long[] toArray(Collection collection)</strong>              返回包含集合的每个值的数组，转换为一个long值的方式Number.longValue().</td></tr><tr><td>18</td><td><strong>static byte[] toByteArray(long value)</strong>              返回字节数组值大端在8元素的表示;相当于 ByteBuffer.allocate(8).putLong(value).array().</td></tr><tr><td>19</td><td><strong>static Long tryParse(String string)</strong>              Parses the specified string as a signed decimal long value.</td></tr></tbody></table><h2 id="继承的方法-11"><a href="#继承的方法-11" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Longs-示例"><a href="#Longs-示例" class="headerlink" title="Longs 示例"></a>Longs 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Ints;</span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testLongs();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLongs</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">long</span>[] longArray = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Long&gt; objectArray = Longs.asList(longArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      longArray = Longs.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; longArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(longArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"5 is in list? "</span>+ Longs.contains(longArray, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the minimum</span></span><br><span class="line">      System.out.println(<span class="string">"Min: "</span> + Longs.min(longArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Max: "</span> + Longs.max(longArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//get the byte array from an integer</span></span><br><span class="line">      <span class="keyword">byte</span>[] byteArray = Longs.toByteArray(<span class="number">20000</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; byteArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(byteArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-15"><a href="#验证结果-15" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[ 1 2 3 4 5 6 7 8 9 ]</span><br><span class="line">5 is in list? true</span><br><span class="line">Min: 1</span><br><span class="line">Max: 9</span><br><span class="line">0 0 0 0 0 0 78 32</span><br></pre></td></tr></table></figure><h1 id="Floats"><a href="#Floats" class="headerlink" title="Floats"></a>Floats</h1><p>Floats是float基本类型的实用工具类。</p><h2 id="类声明-14"><a href="#类声明-14" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Floats类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Floats</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字体-1"><a href="#字体-1" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th>S.N.</th><th>字段及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static int BYTES</strong>              所需要的字节数来表示一个原始浮点值。</td></tr></tbody></table><h2 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(float… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似 Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static int compare(float a, float b)</strong>              通过比较两个指定的浮点值 Float.compare(float, float).</td></tr><tr><td>3</td><td><strong>static float[] concat(float[]… arrays)</strong>              每个数组提供组合成一个单一的数组，则返回值。</td></tr><tr><td>4</td><td><strong>static boolean contains(float[] array, float target)</strong>              返回true，如果target是否存在在任何地方数组元素。</td></tr><tr><td>5</td><td><strong>static float[] ensureCapacity(float[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>6</td><td><strong>static int hashCode(float value)</strong>              返回哈希码的值;等于调用的结果 ((Float) value).hashCode().</td></tr><tr><td>7</td><td><strong>static int indexOf(float[] array, float target)</strong>              返回目标数组的首次出现的索引值。</td></tr><tr><td>8</td><td><strong>static int indexOf(float[] array, float[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1，如果不存在。</td></tr><tr><td>9</td><td><strong>static boolean isFinite(float value)</strong>              返回true，如果值代表一个实数。</td></tr><tr><td>10</td><td><strong>static String join(String separator, float… array)</strong>              返回包含所提供的浮点值，所指定的Float.toString(float)，并通过分离器分离转换为字符串的字符串。</td></tr><tr><td>11</td><td><strong>static int lastIndexOf(float[] array, float target)</strong>              返回target 在数组中最后一个出场的索引值。</td></tr><tr><td>12</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较，比较两个浮点阵列字典顺序。</td></tr><tr><td>13</td><td><strong>static float max(float… array)</strong>              返回存在于数组的最大值，使用比较为相同的规则 Math.min(float, float).</td></tr><tr><td>14</td><td><strong>static float min(float… array)</strong>              返回存在于数组的最小值，使用比较为相同的规则 Math.min(float, float).</td></tr><tr><td>15</td><td><strong>static Converter stringConverter()</strong>              返回使用字符串和浮点数之间的一个转换器序列化对象 Float.valueOf(java.lang.String) 和 Float.toString().</td></tr><tr><td>16</td><td><strong>static float[] toArray(Collection collection)</strong>              返回一个包含集合中的每个值的数组，转换为浮点值的方式Number.floatValue().</td></tr><tr><td>17</td><td><strong>static Float tryParse(String string)</strong>              解析指定的字符串作为单精度浮点值。</td></tr></tbody></table><h2 id="继承的方法-12"><a href="#继承的方法-12" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Floats-示例"><a href="#Floats-示例" class="headerlink" title="Floats 示例"></a>Floats 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Floats;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testFloats();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testFloats</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">float</span>[] floatArray = &#123;<span class="number">1.0f</span>,<span class="number">2.0f</span>,<span class="number">3.0f</span>,<span class="number">4.0f</span>,<span class="number">5.0f</span>,<span class="number">6.0f</span>,<span class="number">7.0f</span>,<span class="number">8.0f</span>,<span class="number">9.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Float&gt; objectArray = Floats.asList(floatArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      floatArray = Floats.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; floatArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(floatArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"5.0 is in list? "</span>+ Floats.contains(floatArray, <span class="number">5.0f</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//return the index of element</span></span><br><span class="line">      System.out.println(<span class="string">"5.0 position in list "</span>+ Floats.indexOf(floatArray, <span class="number">5.0f</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the minimum</span></span><br><span class="line">      System.out.println(<span class="string">"Min: "</span> + Floats.min(floatArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Max: "</span> + Floats.max(floatArray));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-16"><a href="#验证结果-16" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]</span><br><span class="line">[ 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 ]</span><br><span class="line">5.0 is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line">5.0 position <span class="keyword">in</span> list 4</span><br><span class="line">Min: 1.0</span><br><span class="line">Max: 9.0</span><br></pre></td></tr></table></figure><h1 id="Doubles"><a href="#Doubles" class="headerlink" title="Doubles"></a>Doubles</h1><p>Doubles是double基本类型的实用工具类。</p><h2 id="类声明-15"><a href="#类声明-15" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Doubles类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Doubles</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字段-3"><a href="#字段-3" class="headerlink" title="字段"></a>字段</h2><table><thead><tr><th style="text-align:left">S.N.</th><th style="text-align:left">字段及说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>static int BYTES</strong>              所需要的字节数来表示基本的double值。</td></tr></tbody></table><h2 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(double… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似 Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static int compare(double a, double b)</strong>              比较两个指定的double值。</td></tr><tr><td>3</td><td><strong>static double[] concat(double[]… arrays)</strong>              每个数组提供组合成一个单一的数组，则返回值。</td></tr><tr><td>4</td><td><strong>static boolean contains(double[] array, double target)</strong>              返回true，如果target是否存在在任何地方数组元素。</td></tr><tr><td>5</td><td><strong>static double[] ensureCapacity(double[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>6</td><td><strong>static int hashCode(double value)</strong>              返回哈希码的值;等于调用 ((Double) value).hashCode() 的结果.</td></tr><tr><td>7</td><td><strong>static int indexOf(double[] array, double target)</strong>              返回目标数组的首次出现的索引值。</td></tr><tr><td>8</td><td><strong>static int indexOf(double[] array, double[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1，如果不存在。</td></tr><tr><td>9</td><td><strong>static boolean isFinite(double value)</strong>              返回true，如果值代表一个实数。</td></tr><tr><td>10</td><td><strong>static String join(String separator, double… array)</strong>              返回包含所提供的double 值的字符串，所指定的转换为字符串 Double.toString(double), 及相隔分离。</td></tr><tr><td>11</td><td><strong>static int lastIndexOf(double[] array, double target)</strong>              返回target 在数组中最后一个出现的索引值。</td></tr><tr><td>12</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较，比较两个double阵列字典顺序。</td></tr><tr><td>13</td><td><strong>static double max(double… array)</strong>              返回存在于数组的最大值，使用比较为相同的规则 Math.max(double, double).</td></tr><tr><td>14</td><td><strong>static double min(double… array)</strong>              返回存在于数组的最小值，使用比较为相同的规则 Math.min(double, double).</td></tr><tr><td>15</td><td><strong>static Converter stringConverter()</strong>              返回字符串转换之间和double采用序列化器对象 Double.valueOf(java.lang.String) and Double.toString().</td></tr><tr><td>16</td><td><strong>static double[] toArray(Collection collection)</strong>              返回一个包含集合中的每个值的数组，转换为double值的方式Number.doubleValue().</td></tr><tr><td>17</td><td><strong>static Double tryParse(String string)</strong>              解析指定的字符串作为一个双精度浮点值。</td></tr></tbody></table><h2 id="方法继承-4"><a href="#方法继承-4" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Doubles-示例"><a href="#Doubles-示例" class="headerlink" title="Doubles 示例"></a>Doubles 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Doubles;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testDoubles();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testDoubles</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span>[] doubleArray = &#123;<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>,<span class="number">5.0</span>,<span class="number">6.0</span>,<span class="number">7.0</span>,<span class="number">8.0</span>,<span class="number">9.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Double&gt; objectArray = Doubles.asList(doubleArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      doubleArray = Doubles.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; doubleArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(doubleArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"5.0 is in list? "</span>+ Doubles.contains(doubleArray, <span class="number">5.0f</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//return the index of element</span></span><br><span class="line">      System.out.println(<span class="string">"5.0 position in list "</span>+ Doubles.indexOf(doubleArray, <span class="number">5.0f</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the minimum</span></span><br><span class="line">      System.out.println(<span class="string">"Min: "</span> + Doubles.min(doubleArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Max: "</span> + Doubles.max(doubleArray));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-17"><a href="#验证结果-17" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]</span><br><span class="line">[ 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 ]</span><br><span class="line">5.0 is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line">5.0 position <span class="keyword">in</span> list 4</span><br><span class="line">Min: 1.0</span><br><span class="line">Max: 9.0</span><br></pre></td></tr></table></figure><h1 id="Chars"><a href="#Chars" class="headerlink" title="Chars"></a>Chars</h1><p>Chars是基本char类型的实用工具类。</p><h2 id="类声明-16"><a href="#类声明-16" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Chars类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Chars</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="字段-4"><a href="#字段-4" class="headerlink" title="字段"></a>字段</h2><table><thead><tr><th>S.N.</th><th>字段及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static int BYTES</strong>              所需要的字节数来表示一个原始char值。</td></tr></tbody></table><h2 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(char… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似 Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static char checkedCast(long value)</strong>              返回char值等于<strong>value</strong>值，如果可能的话。</td></tr><tr><td>3</td><td><strong>static int compare(char a, char b)</strong>              比较两个指定的char值。</td></tr><tr><td>4</td><td><strong>static char[] concat(char[]… arrays)</strong>              每个数组提供组合成一个单一的数组，则返回值。</td></tr><tr><td>5</td><td><strong>static boolean contains(char[] array, char target)</strong>              返回true，如果target是否存在在任何地方数组元素。</td></tr><tr><td>6</td><td><strong>static char[] ensureCapacity(char[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>7</td><td><strong>static char fromByteArray(byte[] bytes)</strong>              返回char值，其大端表示被存储在第一个2字节的字节;相当于 ByteBuffer.wrap(bytes).getChar().</td></tr><tr><td>8</td><td><strong>static char fromBytes(byte b1, byte b2)</strong>              返回char值的字节表示是给定2个字节，在big-endian的顺序;相当于 Chars.fromByteArray(new byte[] {b1, b2}).</td></tr><tr><td>9</td><td><strong>static int hashCode(char value)</strong>              返回哈希码的值;等于调用的结果 ((Character) value).hashCode().</td></tr><tr><td>10</td><td><strong>static int indexOf(char[] array, char target)</strong>              返回目标数组的首次出现的索引值。</td></tr><tr><td>11</td><td><strong>static int indexOf(char[] array, char[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1，如果不存在。</td></tr><tr><td>12</td><td><strong>static String join(String separator, char… array)</strong>              返回包含由分离器分离所提供的char值字符串。</td></tr><tr><td>13</td><td><strong>static int lastIndexOf(char[] array, char target)</strong>              返回target 在数组中最后一个出现的索引值。</td></tr><tr><td>14</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较器，它比较两个字符数组字典顺序。</td></tr><tr><td>15</td><td><strong>static char max(char… array)</strong>              返回在数组中的最大值。</td></tr><tr><td>16</td><td><strong>static char min(char… array)</strong>              返回出现在数组最小值。</td></tr><tr><td>17</td><td><strong>static char saturatedCast(long value)</strong>              返回值char最近的值。</td></tr><tr><td>18</td><td><strong>static char[] toArray(Collection collection)</strong>              复制字符实例的集合到原始char值的新数组。</td></tr><tr><td>19</td><td><strong>static byte[] toByteArray(char value)</strong>              返回在2元素的字节数组值大端表示;相当于 ByteBuffer.allocate(2).putChar(value).array().</td></tr></tbody></table><h2 id="方法继承-5"><a href="#方法继承-5" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类从以下类继承的方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Chars-例子"><a href="#Chars-例子" class="headerlink" title="Chars 例子"></a>Chars 例子</h2><p>​    选择使用任何编辑器创建以下java程序在 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Chars;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testChars();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testChars</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">char</span>[] charArray = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Character&gt; objectArray = Chars.asList(charArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      charArray = Chars.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; charArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(charArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"c is in list? "</span>+ Chars.contains(charArray, <span class="string">'c'</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//return the index of element</span></span><br><span class="line">      System.out.println(<span class="string">"c position in list "</span>+ Chars.indexOf(charArray, <span class="string">'c'</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the minimum</span></span><br><span class="line">      System.out.println(<span class="string">"Min: "</span> + Chars.min(charArray));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the maximum</span></span><br><span class="line">      System.out.println(<span class="string">"Max: "</span> + Chars.max(charArray));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-18"><a href="#验证结果-18" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, d, e, f, g, h]</span><br><span class="line">[ a b c d e f g h ]</span><br><span class="line">c is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line">c position <span class="keyword">in</span> list 2</span><br><span class="line">Min: a</span><br><span class="line">Max: h</span><br></pre></td></tr></table></figure><h1 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h1><p>Booleans是布尔型基本的实用工具类。</p><h2 id="类声明-17"><a href="#类声明-17" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.primitives.Booleans类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Booleans</span></span></span><br><span class="line"><span class="class">      <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static List asList(boolean… backingArray)</strong>              返回由指定数组支持的固定大小的列表，类似 Arrays.asList(Object[]).</td></tr><tr><td>2</td><td><strong>static int compare(boolean a, boolean b)</strong>              比较两个指定的布尔值的标准方式(假的比真的少考虑以下)。</td></tr><tr><td>3</td><td><strong>static boolean[] concat(boolean[]… arrays)</strong>              每个数组提供组合成一个单一的数组，则值返回。</td></tr><tr><td>4</td><td><strong>static boolean contains(boolean[] array, boolean target)</strong>              返回true，如果target存在在任何地方数组元素。</td></tr><tr><td>5</td><td><strong>static int countTrue(boolean… values)</strong>              返回为true值的数目。</td></tr><tr><td>6</td><td><strong>static boolean[] ensureCapacity(boolean[] array, int minLength, int padding)</strong>              返回一个包含相同的值数组的数组，但保证是一个规定的最小长度。</td></tr><tr><td>7</td><td><strong>static int hashCode(boolean value)</strong>              返回哈希码的值;等于调用的结果 ((Boolean) value).hashCode().</td></tr><tr><td>8</td><td><strong>static int indexOf(boolean[] array, boolean target)</strong>              返回目标数组的首次出现的索引值。</td></tr><tr><td>9</td><td><strong>static int indexOf(boolean[] array, boolean[] target)</strong>              返回指定目标的第一个匹配的起始位置数组内，或-1，如果不存在。</td></tr><tr><td>10</td><td><strong>static String join(String separator, boolean… array)</strong>              返回包含由分离器分离所提供的布尔值的字符串。</td></tr><tr><td>11</td><td><strong>static int lastIndexOf(boolean[] array, boolean target)</strong>              返回target 在数组中最后一个出现的索引值。</td></tr><tr><td>12</td><td><strong>static Comparator lexicographicalComparator()</strong>              返回一个比较器，它比较两个布尔数组字典顺序。</td></tr><tr><td>13</td><td><strong>static boolean[] toArray(Collection collection)</strong>              复制Boolean实例集合到原始的布尔值的新数组。</td></tr></tbody></table><h2 id="方法继承-6"><a href="#方法继承-6" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="Booleans-示例"><a href="#Booleans-示例" class="headerlink" title="Booleans 示例"></a>Booleans 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.google.common.primitives.Booleans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testBooleans();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testBooleans</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span>[] booleanArray = &#123;<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of primitives to array of objects</span></span><br><span class="line">      List&lt;Boolean&gt; objectArray = Booleans.asList(booleanArray);</span><br><span class="line">      System.out.println(objectArray.toString());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//convert array of objects to array of primitives</span></span><br><span class="line">      booleanArray = Booleans.toArray(objectArray);</span><br><span class="line">      System.out.print(<span class="string">"[ "</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; booleanArray.length ; i++)&#123;</span><br><span class="line">         System.out.print(booleanArray[i] + <span class="string">" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"]"</span>);</span><br><span class="line">      <span class="comment">//check if element is present in the list of primitives or not</span></span><br><span class="line">      System.out.println(<span class="string">"true is in list? "</span>+ Booleans.contains(booleanArray, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//return the first index of element</span></span><br><span class="line">      System.out.println(<span class="string">"true position in list "</span>+ Booleans.indexOf(booleanArray, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the count of true values</span></span><br><span class="line">      System.out.println(<span class="string">"true occured: "</span> + Booleans.countTrue());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Returns the comparisons</span></span><br><span class="line">      System.out.println(<span class="string">"false Vs true: "</span> + Booleans.compare(<span class="keyword">false</span>, <span class="keyword">true</span>));</span><br><span class="line">      System.out.println(<span class="string">"false Vs false: "</span> + Booleans.compare(<span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">      System.out.println(<span class="string">"true Vs false: "</span> + Booleans.compare(<span class="keyword">true</span>, <span class="keyword">false</span>));</span><br><span class="line">      System.out.println(<span class="string">"true Vs true: "</span> + Booleans.compare(<span class="keyword">true</span>, <span class="keyword">true</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-19"><a href="#验证结果-19" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line">[ <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span> <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span> <span class="literal">false</span> ]</span><br><span class="line"><span class="literal">true</span> is <span class="keyword">in</span> list? <span class="literal">true</span></span><br><span class="line"><span class="literal">true</span> position <span class="keyword">in</span> list 0</span><br><span class="line"><span class="literal">true</span> occured: 0</span><br><span class="line"><span class="literal">false</span> Vs <span class="literal">true</span>: -1</span><br><span class="line"><span class="literal">false</span> Vs <span class="literal">false</span>: 0</span><br><span class="line"><span class="literal">true</span> Vs <span class="literal">false</span>: 1</span><br><span class="line"><span class="literal">true</span> Vs <span class="literal">true</span>: 0</span><br></pre></td></tr></table></figure><h1 id="IntMath"><a href="#IntMath" class="headerlink" title="IntMath"></a>IntMath</h1><p>IntMath提供整型的实用方法。</p><h2 id="类声明-18"><a href="#类声明-18" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.math.IntMath类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntMath</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="方法-9"><a href="#方法-9" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th style="text-align:left">S.N.</th><th style="text-align:left">方法及说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>static int binomial(int n, int k)</strong>              返回n个选择K，也被称为n和k，或Integer.MAX_VALUE的二项式系数，如果结果在一个int不适合。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>static int checkedAdd(int a, int b)</strong>              返回a和b的总和，只要它不会溢出。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>static int checkedMultiply(int a, int b)</strong>              返回a和b的产物，只要它不会溢出。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>static int checkedPow(int b, int k)</strong>              返回b的第k幂，只要它不会溢出。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>static int checkedSubtract(int a, int b)</strong>              返回a和b的差，只要它不会溢出。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>static int divide(int p, int q, RoundingMode mode)</strong>              返回除以p由q，使用指定RoundingMode的四舍五入结果。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>static int factorial(int n)</strong>              返回n个！，也就是说，前n个正整数的乘积，如果n==0则返回1，或者是Integer.MAX_VALUE如果结果不适合在一个int值。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>static int gcd(int a, int b)</strong>              返回a, b的最大公约数。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><strong>static boolean isPowerOfTwo(int x)</strong>              返回true，如果x代表两个幂。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><strong>static int log10(int x, RoundingMode mode)</strong>              返回基数为10的对数x，根据指定的舍入模式圆形。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><strong>static int log2(int x, RoundingMode mode)</strong>              返回基数为2-对数x，根据指定的舍入模式圆形。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><strong>static int mean(int x, int y)</strong>              返回x和y的算术平均值，取整。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><strong>static int mod(int x, int m)</strong>              返回x模m，一个非负的值小于m以下。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><strong>static int pow(int b, int k)</strong>              返回b的第k幂。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><strong>static int sqrt(int x, RoundingMode mode)</strong>              返回x的平方根，大概指定的舍入模式。</td></tr></tbody></table><h2 id="方法继承-7"><a href="#方法继承-7" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类从以下类继承的方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="IntMath-例子"><a href="#IntMath-例子" class="headerlink" title="IntMath 例子"></a>IntMath 例子</h2><p>​    选择使用任何编辑器创建以下java程序在 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> com.google.common.math.IntMath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testIntMath();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testIntMath</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         System.out.println(IntMath.checkedAdd(Integer.MAX_VALUE, Integer.MAX_VALUE));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(IntMath.divide(<span class="number">100</span>, <span class="number">5</span>, RoundingMode.UNNECESSARY));</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//exception will be thrown as 100 is not completely divisible by 3 thus rounding</span></span><br><span class="line">         <span class="comment">// is required, and RoundingMode is set as UNNESSARY</span></span><br><span class="line">         System.out.println(IntMath.divide(<span class="number">100</span>, <span class="number">3</span>, RoundingMode.UNNECESSARY));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Log2(2): "</span>+IntMath.log2(<span class="number">2</span>, RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Log10(10): "</span>+IntMath.log10(<span class="number">10</span>, RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"sqrt(100): "</span>+IntMath.sqrt(IntMath.pow(<span class="number">10</span>,<span class="number">2</span>), RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"gcd(100,50): "</span>+IntMath.gcd(<span class="number">100</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"modulus(100,50): "</span>+IntMath.mod(<span class="number">100</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"factorial(5): "</span>+IntMath.factorial(<span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-20"><a href="#验证结果-20" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Error: overflow</span><br><span class="line">20</span><br><span class="line">Error: mode was UNNECESSARY, but rounding was necessary</span><br><span class="line">Log2(2): 1</span><br><span class="line">Log10(10): 1</span><br><span class="line">sqrt(100): 10</span><br><span class="line">gcd(100,50): 50</span><br><span class="line">modulus(100,50): 0</span><br><span class="line">factorial(5): 120</span><br></pre></td></tr></table></figure><h1 id="LongMath"><a href="#LongMath" class="headerlink" title="LongMath"></a>LongMath</h1><p>LongMath提供long基础类型的实用方法。</p><h2 id="类声明-19"><a href="#类声明-19" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.math.LongMath类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LongMath</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="方法-10"><a href="#方法-10" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static long binomial(int n, int k)</strong>              返回n个选择K，也称为n和k，或为Long.MAX_VALUE的二项式系数，如果long结果不相符。</td></tr><tr><td>1</td><td><strong>static long checkedAdd(long a, long b)</strong>              返回a和b的总和，只要它不会溢出。</td></tr><tr><td>2</td><td><strong>static long checkedMultiply(long a, long b)</strong>              返回a和b的产物，只要它不会溢出。</td></tr><tr><td>3</td><td><strong>static long checkedPow(long b, int k)</strong>              返回b的第k幂，只要它不会溢出。</td></tr><tr><td>4</td><td><strong>static long checkedSubtract(long a, long b)</strong>              返回a和b的差，只要它不会溢出。</td></tr><tr><td>5</td><td><strong>static long divide(long p, long q, RoundingMode mode)</strong>              返回除以p由q，使用指定的RoundingMode四舍五入的结果。</td></tr><tr><td>6</td><td><strong>static long factorial(int n)</strong>              返回n！，也就是说，前n个正整数的乘积，如果n==则返回1，或为Long.MAX_VALUE如果结果long不相符。</td></tr><tr><td>7</td><td><strong>static long gcd(long a, long b)</strong>              返回a, b的最大公约数。</td></tr><tr><td>8</td><td><strong>static boolean isPowerOfTwo(long x)</strong>              返回true，如果x代表两个幂。</td></tr><tr><td>9</td><td><strong>static int log10(long x, RoundingMode mode)</strong>              返回基数为10的对数x，根据指定的舍入模式圆形。</td></tr><tr><td>10</td><td><strong>static int log2(long x, RoundingMode mode)</strong>              返回基数为2-对数x，根据指定的舍入模式圆形。</td></tr><tr><td>11</td><td><strong>static long mean(long x, long y)</strong>              返回x和y的算术平均值，四舍五入向负无穷大。</td></tr><tr><td>12</td><td><strong>static int mod(long x, int m)</strong>              返回x模m，一个非负的值小于m以下。</td></tr><tr><td>13</td><td><strong>static long mod(long x, long m)</strong>              返回x模m，一个非负的值小于m以下。</td></tr><tr><td>14</td><td><strong>static long pow(long b, int k)</strong>              返回b为第k幂。</td></tr><tr><td>15</td><td><strong>static long sqrt(long x, RoundingMode mode)</strong>              返回x的平方根，大概指定的舍入模式。</td></tr></tbody></table><h2 id="方法继承-8"><a href="#方法继承-8" class="headerlink" title="方法继承"></a>方法继承</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="LongMath-示例"><a href="#LongMath-示例" class="headerlink" title="LongMath 示例"></a>LongMath 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> com.google.common.math.LongMath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testLongMath();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testLongMath</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         System.out.println(LongMath.checkedAdd(Long.MAX_VALUE, Long.MAX_VALUE));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(LongMath.divide(<span class="number">100</span>, <span class="number">5</span>, RoundingMode.UNNECESSARY));</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//exception will be thrown as 100 is not completely divisible by 3 thus rounding</span></span><br><span class="line">         <span class="comment">// is required, and RoundingMode is set as UNNESSARY</span></span><br><span class="line">         System.out.println(LongMath.divide(<span class="number">100</span>, <span class="number">3</span>, RoundingMode.UNNECESSARY));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Log2(2): "</span>+LongMath.log2(<span class="number">2</span>, RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Log10(10): "</span>+LongMath.log10(<span class="number">10</span>, RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"sqrt(100): "</span>+LongMath.sqrt(LongMath.pow(<span class="number">10</span>,<span class="number">2</span>), RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"gcd(100,50): "</span>+LongMath.gcd(<span class="number">100</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"modulus(100,50): "</span>+LongMath.mod(<span class="number">100</span>,<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"factorial(5): "</span>+LongMath.factorial(<span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-21"><a href="#验证结果-21" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Error: overflow</span><br><span class="line">20</span><br><span class="line">Error: mode was UNNECESSARY, but rounding was necessary</span><br><span class="line">Log2(2): 1</span><br><span class="line">Log10(10): 1</span><br><span class="line">sqrt(100): 10</span><br><span class="line">gcd(100,50): 50</span><br><span class="line">modulus(100,50): 0</span><br><span class="line">factorial(5): 120</span><br></pre></td></tr></table></figure><h1 id="BigIntegerMath"><a href="#BigIntegerMath" class="headerlink" title="BigIntegerMath"></a>BigIntegerMath</h1><p>BigIntegerMath提供BigInteger的实用方法。</p><h2 id="类声明-20"><a href="#类声明-20" class="headerlink" title="类声明"></a>类声明</h2><p>​    以下是com.google.common.math.BigIntegerMath类的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span>(emulated=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BigIntegerMath</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h2 id="方法-11"><a href="#方法-11" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>static BigInteger binomial(int n, int k)</strong>              返回n选择k，也被称为n和k的二项式系数，即n! / (k! (n - k)!)。</td></tr><tr><td>2</td><td><strong>static BigInteger divide(BigInteger p, BigInteger q, RoundingMode mode)</strong>              返回除以p由q，使用指定的RoundingMode四舍五入的结果。</td></tr><tr><td>3</td><td><strong>static BigInteger factorial(int n)</strong>              返回n个！，即，在第一n个正整数的乘积，或1如果n== 0。</td></tr><tr><td>4</td><td><strong>static boolean isPowerOfTwo(BigInteger x)</strong>              返回true，如果x代表两个幂。</td></tr><tr><td>5</td><td><strong>static int log10(BigInteger x, RoundingMode mode)</strong>              返回基数为10的对数x，根据指定的舍入模式范围。</td></tr><tr><td>6</td><td><strong>static int log2(BigInteger x, RoundingMode mode)</strong>              返回基数为2-对数x，根据指定的舍入模式圆形。</td></tr><tr><td>7</td><td><strong>static BigInteger sqrt(BigInteger x, RoundingMode mode)</strong>              返回x的平方根，大概指定的舍入模式。</td></tr></tbody></table><h2 id="继承的方法-13"><a href="#继承的方法-13" class="headerlink" title="继承的方法"></a>继承的方法</h2><p>​    这个类继承了以下类方法：</p><ul><li>​            java.lang.Object</li></ul><h2 id="BigIntegerMath-示例"><a href="#BigIntegerMath-示例" class="headerlink" title="BigIntegerMath 示例"></a>BigIntegerMath 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 C:/&gt; Guava</p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.math.BigIntegerMath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      tester.testBigIntegerMath();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testBigIntegerMath</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(BigIntegerMath.divide(BigInteger.TEN, <span class="keyword">new</span> BigInteger(<span class="string">"2"</span>), RoundingMode.UNNECESSARY));</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//exception will be thrown as 100 is not completely divisible by 3 thus rounding</span></span><br><span class="line">         <span class="comment">// is required, and RoundingMode is set as UNNESSARY</span></span><br><span class="line">         System.out.println(BigIntegerMath.divide(BigInteger.TEN, <span class="keyword">new</span> BigInteger(<span class="string">"3"</span>), RoundingMode.UNNECESSARY));</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">         System.out.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Log2(2): "</span>+BigIntegerMath.log2(<span class="keyword">new</span> BigInteger(<span class="string">"2"</span>), RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Log10(10): "</span>+BigIntegerMath.log10(BigInteger.TEN, RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"sqrt(100): "</span>+BigIntegerMath.sqrt(BigInteger.TEN.multiply(BigInteger.TEN), RoundingMode.HALF_EVEN));</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"factorial(5): "</span>+BigIntegerMath.factorial(<span class="number">5</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-22"><a href="#验证结果-22" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">Error: Rounding necessary</span><br><span class="line">Log2(2): 1</span><br><span class="line">Log10(10): 1</span><br><span class="line">sqrt(100): 10</span><br><span class="line">factorial(5): 120</span><br></pre></td></tr></table></figure><h1 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h1><p>多重映射接口扩展映射，使得其键一次可被映射到多个值。</p><h2 id="接口声明-4"><a href="#接口声明-4" class="headerlink" title="接口声明"></a>接口声明</h2><p>​    以下是com.google.common.collect.Multimap&lt;K，V&gt;接口的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Multimap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="接口方法-4"><a href="#接口方法-4" class="headerlink" title="接口方法"></a>接口方法</h2><table><thead><tr><th>S.N.</th><th>方法及说明</th></tr></thead><tbody><tr><td>1</td><td><strong>Map&gt; asMap()</strong>              返回此multimap中的视图，从每个不同的键在键的关联值的非空集合映射。</td></tr><tr><td>2</td><td><strong>void clear()</strong>              将删除所有multimap中的键值对，留下空。</td></tr><tr><td>3</td><td><strong>boolean containsEntry(Object key, Object value)</strong>              返回true如果此多重映射包含至少一个键 - 值对用键键和值value。</td></tr><tr><td>4</td><td><strong>boolean containsKey(Object key)</strong>              返回true，如果这个multimap中至少包含一个键值对的键key。</td></tr><tr><td>5</td><td><strong>boolean containsValue(Object value)</strong>              返回true，如果这个multimap至少包含一个键值对的值值。</td></tr><tr><td>6</td><td><strong>Collection&gt; entries()</strong>              返回包含在此multimap中，为Map.Entry的情况下，所有的键 - 值对的视图集合。</td></tr><tr><td>7</td><td><strong>boolean equals(Object obj)</strong>              比较指定对象与此多重映射是否相等。</td></tr><tr><td>8</td><td><strong>Collection get(K key)</strong>              返回，如果有的话，在这个multimap中键关联的值的视图集合。</td></tr><tr><td>9</td><td><strong>int hashCode()</strong>              返回此多重映射的哈希码。</td></tr><tr><td>10</td><td><strong>boolean isEmpty()</strong>              返回true，如果这个multimap中未包含键 - 值对。</td></tr><tr><td>11</td><td><strong>Multiset keys()</strong>              返回一个视图集合包含从每个键值对这个multimap中的关键，没有折叠重复。</td></tr><tr><td>12</td><td><strong>Set keySet()</strong>              Returns a view collection of all distinct keys contained in this multimap.</td></tr><tr><td>13</td><td><strong>boolean put(K key, V value)</strong>              存储键 - 值对在这个multimap中。</td></tr><tr><td>14</td><td><strong>boolean putAll(K key, Iterable values)</strong>              存储一个键 - 值对在此multimap中的每个值，都使用相同的键 key。</td></tr><tr><td>15</td><td><strong>boolean putAll(Multimap multimap)</strong>              存储了所有键 - 值对多重映射在这个multimap中，通过返回 multimap.entries() 的顺序.</td></tr><tr><td>16</td><td><strong>boolean remove(Object key, Object value)</strong>              删除一个键 - 值对用键键，并从该多重映射的值的值，如果这样的存在。</td></tr><tr><td>17</td><td><strong>Collection removeAll(Object key)</strong>              删除与键键关联的所有值。</td></tr><tr><td>18</td><td><strong>Collection replaceValues(K key, Iterable values)</strong>              存储与相同的键值，替换任何现有值的键的集合。</td></tr><tr><td>19</td><td><strong>int size()</strong>              返回此多重映射键 - 值对的数量。</td></tr><tr><td>20</td><td><strong>Collection values()</strong>              返回一个视图集合包含从包含在该multimap中的每个键 - 值对的值，而不发生重复 (so values().size() == size()).</td></tr></tbody></table><h2 id="Multimap-示例"><a href="#Multimap-示例" class="headerlink" title="Multimap 示例"></a>Multimap 示例</h2><p>​    使用所选择的任何编辑器创建下面的java程序 <strong>C:/&gt; Guava</strong></p><p><em>GuavaTester.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.ArrayListMultimap;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Multimap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaTester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      GuavaTester tester = <span class="keyword">new</span> GuavaTester();</span><br><span class="line">      Multimap&lt;String,String&gt; multimap = tester.getMultimap();</span><br><span class="line"></span><br><span class="line">      List&lt;String&gt; lowerList = (List&lt;String&gt;)multimap.get(<span class="string">"lower"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Initial lower case list"</span>);</span><br><span class="line">      System.out.println(lowerList.toString());</span><br><span class="line">      lowerList.add(<span class="string">"f"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Modified lower case list"</span>);</span><br><span class="line">      System.out.println(lowerList.toString());</span><br><span class="line"></span><br><span class="line">      List&lt;String&gt; upperList = (List&lt;String&gt;)multimap.get(<span class="string">"upper"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Initial upper case list"</span>);</span><br><span class="line">      System.out.println(upperList.toString());</span><br><span class="line">      upperList.remove(<span class="string">"D"</span>);</span><br><span class="line">      System.out.println(<span class="string">"Modified upper case list"</span>);</span><br><span class="line">      System.out.println(upperList.toString());</span><br><span class="line"></span><br><span class="line">      Map&lt;String, Collection&lt;String&gt;&gt; map = multimap.asMap();</span><br><span class="line">      System.out.println(<span class="string">"Multimap as a map"</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String,  Collection&lt;String&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">         String key = entry.getKey();</span><br><span class="line">         Collection&lt;String&gt; value =  multimap.get(<span class="string">"lower"</span>);</span><br><span class="line">         System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Keys of Multimap"</span>);</span><br><span class="line">      Set&lt;String&gt; keys =  multimap.keySet();</span><br><span class="line">      <span class="keyword">for</span>(String key:keys)&#123;</span><br><span class="line">         System.out.println(key);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"Values of Multimap"</span>);</span><br><span class="line">      Collection&lt;String&gt; values = multimap.values();</span><br><span class="line">      System.out.println(values);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Multimap&lt;String,String&gt; <span class="title">getMultimap</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//Map&lt;String, List&lt;String&gt;&gt;</span></span><br><span class="line">      <span class="comment">// lower -&gt; a, b, c, d, e </span></span><br><span class="line">      <span class="comment">// upper -&gt; A, B, C, D</span></span><br><span class="line"></span><br><span class="line">      Multimap&lt;String,String&gt; multimap = ArrayListMultimap.create();</span><br><span class="line"></span><br><span class="line">      multimap.put(<span class="string">"lower"</span>, <span class="string">"a"</span>);</span><br><span class="line">      multimap.put(<span class="string">"lower"</span>, <span class="string">"b"</span>);</span><br><span class="line">      multimap.put(<span class="string">"lower"</span>, <span class="string">"c"</span>);</span><br><span class="line">      multimap.put(<span class="string">"lower"</span>, <span class="string">"d"</span>);</span><br><span class="line">      multimap.put(<span class="string">"lower"</span>, <span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line">      multimap.put(<span class="string">"upper"</span>, <span class="string">"A"</span>);</span><br><span class="line">      multimap.put(<span class="string">"upper"</span>, <span class="string">"B"</span>);</span><br><span class="line">      multimap.put(<span class="string">"upper"</span>, <span class="string">"C"</span>);</span><br><span class="line">      multimap.put(<span class="string">"upper"</span>, <span class="string">"D"</span>);</span><br><span class="line">      <span class="keyword">return</span> multimap;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证结果-23"><a href="#验证结果-23" class="headerlink" title="验证结果"></a>验证结果</h2><p>​    使用javac编译器编译如下类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;javac GuavaTester.java</span><br></pre></td></tr></table></figure><p>​    现在运行GuavaTester看到的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Guava&gt;java GuavaTester</span><br></pre></td></tr></table></figure><p>​    看到结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Initial lower <span class="keyword">case</span> list</span><br><span class="line">[a, b, c, d, e]</span><br><span class="line">Modified lower <span class="keyword">case</span> list</span><br><span class="line">[a, b, c, d, e, f]</span><br><span class="line">Initial upper <span class="keyword">case</span> list</span><br><span class="line">[A, B, C, D]</span><br><span class="line">Modified upper <span class="keyword">case</span> list</span><br><span class="line">[A, B, C]</span><br><span class="line">Multimap as a map</span><br><span class="line">upper:[a, b, c, d, e, f]</span><br><span class="line">lower:[a, b, c, d, e, f]</span><br><span class="line">Keys of Multimap</span><br><span class="line">upper</span><br><span class="line">lower</span><br><span class="line">Values of Multimap</span><br><span class="line">[A, B, C, a, b, c, d, e, f]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工具类 就是封装平常用的方法，不需要你重复造轮子，节省开发人员时间，提高工作效率。谷歌作为大公司，当然会从日常的工作中提取中很多高效率的方法出来。所以就诞生了guava。。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效设计良好的API，被Google的开发者设计，实现和使用&lt;/li&gt;
&lt;li&gt;遵循高效的java语法实践&lt;/li&gt;
&lt;li&gt;使代码更刻度，简洁，简单&lt;/li&gt;
&lt;li&gt;节约时间，资源，提高生产力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;集合 [collections]&lt;/li&gt;
&lt;li&gt;缓存 [caching]&lt;/li&gt;
&lt;li&gt;原生类型支持 [primitives support]&lt;/li&gt;
&lt;li&gt;并发库 [concurrency libraries]&lt;/li&gt;
&lt;li&gt;通用注解 [common annotations]&lt;/li&gt;
&lt;li&gt;字符串处理 [string processing]&lt;/li&gt;
&lt;li&gt;I/O 等等。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="GUAVA" scheme="https://vincentruan.github.io/tags/GUAVA/"/>
    
  </entry>
  
  <entry>
    <title>B+树和数据库索引原理简述</title>
    <link href="https://vincentruan.github.io/2020/02/27/B-%E6%A0%91%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
    <id>https://vincentruan.github.io/2020/02/27/B-%E6%A0%91%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/</id>
    <published>2020-02-27T07:12:49.000Z</published>
    <updated>2020-02-28T08:31:39.690Z</updated>
    
    <content type="html"><![CDATA[<p>所以下面我们就从二叉树到平衡二叉树，再到 B- 树，最后到 B+ 树来一步一步了解数据库索引底层的原理！</p><h1 id="二叉树（Binary-Search-Trees）"><a href="#二叉树（Binary-Search-Trees）" class="headerlink" title="二叉树（Binary Search Trees）"></a>二叉树（Binary Search Trees）</h1><p>二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（Left Subtree）和“右子树”（Right Subtree）。二叉树常被用于实现二叉查找树和二叉堆。</p><p><strong>二叉树有如下特性</strong>：</p><ul><li>每个结点都包含一个元素以及 n 个子树，这里 0≤n≤2。 </li><li>左子树和右子树是有顺序的，次序不能任意颠倒。左子树的值要小于父结点，右子树的值要大于父结点。</li></ul><a id="more"></a><p>光看概念有点枯燥，假设我们现在有这样一组数[35 27 48 12 29 38 55]，顺序的插入到一个数的结构中，步骤如下 ：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787709189.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787733056.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787744819.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787831568.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787847118.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787860077.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787871729.webp" alt="img"></p><p>好了，这就是一棵二叉树啦！我们能看到，经过一系列的插入操作之后，原本无序的一组数已经变成一个有序的结构了，并且这个树满足了上面提到的两个二叉树的特性！</p><p>但是如果同样是上面那一组数，我们自己升序排列后再插入，也就是说按照[12 27 29 35 38 48 55]的顺序插入，会怎么样呢？</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787881659.png" alt="img"></p><center>线性退化</center><p>由于是升序插入，新插入的数据总是比已存在的结点数据都要大，所以每次都会往结点的右边插入，最终导致这棵树严重偏科！</p><p>上图就是最坏的情况，也就是一棵树退化为一个线性链表了，这样查找效率自然就低了，完全没有发挥树的优势了呢！ </p><p>为了较大发挥二叉树的查找效率，让二叉树不再偏科，保持各科平衡，所以有了平衡二叉树！</p><h1 id="平衡二叉树-AVL-Trees"><a href="#平衡二叉树-AVL-Trees" class="headerlink" title="平衡二叉树 (AVL Trees)"></a>平衡二叉树 (AVL Trees)</h1><p>平衡二叉树是一种特殊的二叉树，所以他也满足前面说到的二叉树的两个特性，同时还有一个特性：它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</p><p>大家也看到了前面[35 27 48 12 29 38 55]插入完成后的图，其实就已经是一棵平衡二叉树啦。</p><p>那如果按照[12 27 29 35 38 48 55]的顺序插入一棵平衡二叉树，会怎么样呢？</p><p>我们看看插入以及平衡的过程：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787943829.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787954773.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787967340.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787989170.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582787998161.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788020862.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788029812.jpg" alt="img"></p><p>这棵树始终满足平衡二叉树的几个特性而保持平衡！这样我们的树也不会退化为线性链表了！</p><p>我们需要查找一个数的时候就能沿着树根一直往下找，这样的查找效率和二分法查找是一样的呢！</p><p>一棵平衡二叉树能容纳多少的结点呢？这跟树的高度是有关系的，假设树的高度为 h，那每一层最多容纳的结点数量为 2^(n-1)，整棵树最多容纳节点数为 2^0+2^1+2^2+…+2^(h-1)。</p><p>这样计算，100w 数据树的高度大概在 20 左右，也就是说从有着 100w 条数据的平衡二叉树中找一个数据，最坏的情况下需要 20 次查找。</p><p>如果是内存操作，效率也是很高的！但是我们数据库中的数据基本都是放在磁盘中的，每读取一个二叉树的结点就是一次磁盘 IO，这样我们找一条数据如果要经过 20 次磁盘的 IO？</p><p>那性能就成了一个很大的问题了！那我们是不是可以把这棵树压缩一下，让每一层能够容纳更多的节点呢？虽然我矮，但是我胖啊…</p><h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>这颗矮胖的树就是 B-Tree，注意中间是杠精的杠而不是减，所以也不要读成 B 减 Tree 了~</p><p><strong>那 B-Tree 有哪些特性呢？一棵 m 阶的 B-Tree 有如下特性</strong>：</p><ul><li>每个结点最多 m 个子结点。 </li><li>除了根结点和叶子结点外，每个结点最少有 m/2（向上取整）个子结点。 </li><li>如果根结点不是叶子结点，那根结点至少包含两个子结点。 </li><li>所有的叶子结点都位于同一层。 </li><li>每个结点都包含 k 个元素（关键字），这里 m/2≤k。</li><li>每个节点中的元素（关键字）从小到大排列。 </li><li>每个元素（关键字）字左结点的值，都小于或等于该元素（关键字）。右结点的值都大于或等于该元素（关键字）。</li></ul><p>是不是感觉跟丈母娘张口问你要彩礼一样，列一堆的条件，而且每一条都让你很懵逼！</p><p>下面我们以一个[0,1,2,3,4,5,6,7]的数组插入一棵 3 阶的 B-Tree 为例，将所有的条件都串起来，你就明白了！</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788179282.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788189696.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788310198.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788325037.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788332662.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788338881.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788345347.jpg" alt="img"></p><p>那么，你是否对 B-Tree 的几点特性都清晰了呢？在二叉树中，每个结点只有一个元素。</p><p>但是在 B-Tree 中，每个结点都可能包含多个元素，并且非叶子结点在元素的左右都有指向子结点的指针。</p><p>如果需要查找一个元素，那流程是怎么样的呢？我们看下图，如果我们要在下面的 B-Tree 中找到关键字 24，那流程如下：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788382294.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788391253.png" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788400331.webp" alt="img"></p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788413177.png" alt="img"></p><p>从这个流程我们能看出，B-Tree 的查询效率好像也并不比平衡二叉树高。但是查询所经过的结点数量要少很多，也就意味着要少很多次的磁盘 IO，这对性能的提升是很大的。</p><p>从前面对 B-Tree 操作的图，我们能看出来，元素就是类似 1、2、3 这样的数值。</p><p>但是数据库的数据都是一条条的数据，如果某个数据库以 B-Tree 的数据结构存储数据，那数据怎么存放的呢？</p><p>我们看下一张图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788425169.png" alt="img"></p><p>普通的 B-Tree 的结点中，元素就是一个个的数字。但是上图中，我们把元素部分拆分成了 key-data 的形式，Key 就是数据的主键，Data 就是具体的数据。</p><p>这样我们在找一条数的时候，就沿着根结点往下找就 OK 了，效率是比较高的。</p><h1 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h1><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构。</p><p><strong>B+Tree 与 B-Tree 的结构很像，但是也有几个自己的特性</strong>：</p><ul><li>所有的非叶子节点只存储关键字信息。 </li><li>所有卫星数据（具体数据）都存在叶子结点中。 </li><li>所有的叶子结点中包含了全部元素的信息。 </li><li>所有叶子节点之间都有一个链指针。</li></ul><p>如果上面 B-Tree 的图变成 B+Tree，那应该如下： </p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788503163.png" alt="img"></p><p>大家仔细对比于 B-Tree 的图能发现什么不同？ </p><ul><li>非叶子结点上已经只有 Key 信息了，满足上面第 1 点特性！ </li><li>所有叶子结点下面都有一个 Data 区域，满足上面第 2 点特性！ </li><li>非叶子结点的数据在叶子结点上都能找到，如根结点的元素 4、8 在最底层的叶子结点上也能找到，满足上面第 3 点特性！ </li><li>注意图中叶子结点之间的箭头，满足上面第 4 点特性！</li></ul><h1 id="B-Tree-or-B-Tree？"><a href="#B-Tree-or-B-Tree？" class="headerlink" title="B-Tree or B+Tree？"></a>B-Tree or B+Tree？</h1><p>在讲这两种数据结构在数据库中的选择之前，我们还需要了解的一个知识点是操作系统从磁盘读取数据到内存是以磁盘块（Block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。</p><p>这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。 </p><p>预读的长度一般为页（Page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为 4K）。</p><p><strong>B-Tree 和 B+Tree 该如何选择呢？都有哪些优劣呢？</strong></p><p>①B-Tree 因为非叶子结点也保存具体数据，所以在查找某个关键字的时候找到即可返回。</p><p>而 B+Tree 所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的 B-Tree 和 B+Tree 中，B-Tree 查找某个关键字的效率更高。 </p><p>②由于 B+Tree 所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的数据的时候，B+Tree 只需要找到该关键字然后沿着链表遍历就可以了，而 B-Tree 还需要遍历该关键字结点的根结点去搜索。 </p><p>③由于 B-Tree 的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而 B+Tree 非叶子结点只存储关键字信息，而每个页的大小是有限的，所以同一页能存储的 B-Tree 的数据会比 B+Tree 存储的更少。</p><p>这样同样总量的数据，B-Tree 的深度会更大，增大查询时的磁盘 I/O 次数，进而影响查询效率。 </p><p>鉴于以上的比较，所以在常用的关系型数据库中，都是选择 B+Tree 的数据结构来存储数据！</p><p>下面我们以 MySQL 的 InnoDB 存储引擎为例讲解，其他类似 SQL Server、Oracle 的原理！</p><h2 id="InnoDB-引擎数据存储"><a href="#InnoDB-引擎数据存储" class="headerlink" title="InnoDB 引擎数据存储"></a>InnoDB 引擎数据存储</h2><p>在 InnoDB 存储引擎中，也有页的概念，默认每个页的大小为 16K，也就是每次读取数据时都是读取 4*4K 的大小！</p><p>假设我们现在有一个用户表，我们往里面写数据：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788570858.png" alt="img"></p><p>这里需要注意的一点是，在某个页内插入新行时，为了减少数据的移动，通常是插入到当前行的后面或者是已删除行留下来的空间，所以在某一个页内的数据并不是完全有序的（后面页结构部分有细讲）。</p><p>但是为了数据访问顺序性，在每个记录中都有一个指向下一条记录的指针，以此构成了一条单向有序链表，不过在这里为了方便演示我是按顺序排列的！</p><p>由于数据还比较少，一个页就能容下，所以只有一个根结点，主键和数据也都是保存在根结点（左边的数字代表主键，右边名字、性别代表具体的数据）。</p><p>假设我们写入 10 条数据之后，Page1 满了，再写入新的数据会怎么存放呢？</p><p>我们继续看下图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788597877.png" alt="img"></p><p>有个叫“秦寿生”的朋友来了，但是 Page1 已经放不下数据了，这时候就需要进行页分裂，产生一个新的 Page。</p><p><strong>在 InnoDB 中的流程是怎么样的呢？</strong></p><ul><li>产生新的 Page2，然后将 Page1 的内容复制到 Page2。 </li><li>产生新的 Page3，“秦寿生”的数据放入 Page3。 </li><li>原来的 Page1 依然作为根结点，但是变成了一个不存放数据只存放索引的页，并且有两个子结点 Page2、Page3。</li></ul><p><strong>这里有两个问题需要注意的是：</strong></p><p>①为什么要复制 Page1 为 Page2 而不是创建一个新的页作为根结点，这样就少了一步复制的开销了？</p><p>如果是重新创建根结点，那根结点存储的物理地址可能经常会变，不利于查找。</p><p>并且在 InnoDB 中根结点是会预读到内存中的，所以结点的物理地址固定会比较好！</p><p>②原来 Page1 有 10 条数据，在插入第 11 条数据的时候进行裂变，根据前面对 B-Tree、B+Tree 特性的了解，那这至少是一棵 11 阶的树，裂变之后每个结点的元素至少为 11/2=5 个。</p><p>那是不是应该页裂变之后主键 1-5 的数据还是在原来的页，主键 6-11 的数据会放到新的页，根结点存放主键 6？ </p><p>如果是这样的话，新的页空间利用率只有 50%，并且会导致更为频繁的页分裂。</p><p>所以 InnoDB 对这一点做了优化，新的数据放入新创建的页，不移动原有页面的任何记录。</p><p>随着数据的不断写入，这棵树也逐渐枝繁叶茂，如下图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788654590.webp" alt="img"></p><p>每次新增数据，都是将一个页写满，然后新创建一个页继续写，这里其实是有个隐含条件的，那就是主键自增！</p><p>主键自增写入时新插入的数据不会影响到原有页，插入效率高！且页的利用率高！</p><p>但是如果主键是无序的或者随机的，那每次的插入可能会导致原有页频繁的分裂，影响插入效率！降低页的利用率！这也是为什么在 InnoDB 中建议设置主键自增的原因！</p><p>这棵树的非叶子结点上存的都是主键，那如果一个表没有主键会怎么样？在 InnoDB 中，如果一个表没有主键，那默认会找建了唯一索引的列，如果也没有，则会生成一个隐形的字段作为主键！</p><p>有数据插入那就有删除，如果这个用户表频繁的插入和删除，那会导致数据页产生碎片，页的空间利用率低，还会导致树变的“虚高”，降低查询效率！这可以通过索引重建来消除碎片提高查询效率！</p><h2 id="InnoDB-引擎数据查找"><a href="#InnoDB-引擎数据查找" class="headerlink" title="InnoDB 引擎数据查找"></a>InnoDB 引擎数据查找</h2><p>数据插入了怎么查找呢？</p><ul><li><strong>找到数据所在的页。</strong>这个查找过程就跟前面说到的 B+Tree 的搜索过程是一样的，从根结点开始查找一直到叶子结点。 </li><li><strong>在页内找具体的数据。</strong>读取第 1 步找到的叶子结点数据到内存中，然后通过分块查找的方法找到具体的数据。</li></ul><p>这跟我们在新华字典中找某个汉字是一样的，先通过字典的索引定位到该汉字拼音所在的页，然后到指定的页找到具体的汉字。</p><p>InnoDB 中定位到页后用了哪种策略快速查找某个主键呢？这我们就需要从页结构开始了解。</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788721379.png" alt="img"></p><p>左边蓝色区域称为 Page Directory，这块区域由多个 Slot 组成，是一个稀疏索引结构，即一个槽中可能属于多个记录，最少属于 4 条记录，最多属于 8 条记录。</p><p>槽内的数据是有序存放的，所以当我们寻找一条数据的时候可以先在槽中通过二分法查找到一个大致的位置。</p><p>右边区域为数据区域，每一个数据页中都包含多条行数据。注意看图中最上面和最下面的两条特殊的行记录 Infimum 和 Supremum，这是两个虚拟的行记录。</p><p>在没有其他用户数据的时候 Infimum 的下一条记录的指针指向 Supremum。</p><p>当有用户数据的时候，Infimum 的下一条记录的指针指向当前页中最小的用户记录，当前页中最大的用户记录的下一条记录的指针指向 Supremum，至此整个页内的所有行记录形成一个单向链表。</p><p>行记录被 Page Directory 逻辑的分成了多个块，块与块之间是有序的，也就是说“4”这个槽指向的数据块内最大的行记录的主键都要比“8”这个槽指向的数据块内最小的行记录的主键要小。但是块内部的行记录不一定有序。</p><p>每个行记录的都有一个 n_owned 的区域（图中粉红色区域），n_owned 标识这个块有多少条数据。</p><p>伪记录 Infimum 的 n_owned 值总是 1，记录 Supremum 的 n_owned 的取值范围为[1,8]，其他用户记录 n_owned 的取值范围[4,8]。</p><p>并且只有每个块中最大的那条记录的 n_owned 才会有值，其他的用户记录的 n_owned 为 0。</p><p>所以当我们要找主键为 6 的记录时，先通过二分法在稀疏索引中找到对应的槽，也就是 Page Directory 中“8”这个槽。</p><p>“8”这个槽指向的是该数据块中最大的记录，而数据是单向链表结构，所以无法逆向查找。</p><p>所以需要找到上一个槽即“4”这个槽，然后通过“4”这个槽中最大的用户记录的指针沿着链表顺序查找到目标记录。</p><h2 id="聚集索引-amp-非聚集索引"><a href="#聚集索引-amp-非聚集索引" class="headerlink" title="聚集索引&amp;非聚集索引"></a>聚集索引&amp;非聚集索引</h2><p>前面关于数据存储的都是演示的聚集索引的实现，如果上面的用户表需要以“用户名字”建立一个非聚集索引，是怎么实现的呢？</p><p>我们看下图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788771077.webp" alt="img"></p><p>非聚集索引的存储结构与前面是一样的，不同的是在叶子结点的数据部分存的不再是具体的数据，而是数据的聚集索引的 Key。</p><p>所以通过非聚集索引查找的过程是先找到该索引 Key 对应的聚集索引的 Key，然后再拿聚集索引的 Key 到主键索引树上查找对应的数据，这个过程称为回表！</p><p><em>PS：图中的这些名字均来源于网络，希望没有误伤正在看这篇文章的你~^_^</em></p><h2 id="InnoDB-与-MyISAM-引擎对比"><a href="#InnoDB-与-MyISAM-引擎对比" class="headerlink" title="InnoDB 与 MyISAM 引擎对比"></a>InnoDB 与 MyISAM 引擎对比</h2><p>上面包括存储和搜索都是拿的 InnoDB 引擎为例，那 MyISAM 与 InnoDB 在存储上有啥不同呢？憋缩话，看图：</p><p><img src="/2020/02/27/B-树和数据库索引原理简述/640-1582788802217.webp" alt="img"></p><p>上图为 MyISAM 主键索引的存储结构，我们能看到的不同是：</p><ul><li>主键索引树的叶子结点的数据区域没有存放实际的数据，存放的是数据记录的地址。 </li><li>数据的存储不是按主键顺序存放的，是按写入的顺序存放。</li></ul><p>也就是说 InnoDB 引擎数据在物理上是按主键顺序存放，而 MyISAM 引擎数据在物理上按插入的顺序存放。</p><p>并且 MyISAM 的叶子结点不存放数据，所以非聚集索引的存储结构与聚集索引类似，在使用非聚集索引查找数据的时候通过非聚集索引树就能直接找到数据的地址了，不需要回表，这比 InnoDB 的搜索效率会更高呢！</p><h2 id="索引优化建议"><a href="#索引优化建议" class="headerlink" title="索引优化建议"></a>索引优化建议</h2><p>大家经常会在很多的文章或书中能看到一些索引的使用建议，比如说：</p><ul><li>like 的模糊查询以 % 开头，会导致索引失效。 </li><li>一个表建的索引尽量不要超过 5 个。 </li><li>尽量使用覆盖索引。 </li><li>尽量不要在重复数据多的列上建索引。 </li><li>……</li></ul><p>很多这里就不一一列举了！那看完这篇文章，我们能否带着疑问去分析一下为什么要有这些建议？</p><blockquote><p>原<em>作者：苏静</em>，转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655825290&amp;idx=1&amp;sn=455202c916d0a7bd9e3fbbef95ddde76&amp;chksm=bd74e05d8a03694b028c2276d3ddda70e9e966ac98962d503e0c8c5c30bf5f4b6042165387d0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">心里没点B树，怎能吃透数据库索引底层原理？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所以下面我们就从二叉树到平衡二叉树，再到 B- 树，最后到 B+ 树来一步一步了解数据库索引底层的原理！&lt;/p&gt;
&lt;h1 id=&quot;二叉树（Binary-Search-Trees）&quot;&gt;&lt;a href=&quot;#二叉树（Binary-Search-Trees）&quot; class=&quot;headerlink&quot; title=&quot;二叉树（Binary Search Trees）&quot;&gt;&lt;/a&gt;二叉树（Binary Search Trees）&lt;/h1&gt;&lt;p&gt;二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（Left Subtree）和“右子树”（Right Subtree）。二叉树常被用于实现二叉查找树和二叉堆。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉树有如下特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个结点都包含一个元素以及 n 个子树，这里 0≤n≤2。 &lt;/li&gt;
&lt;li&gt;左子树和右子树是有顺序的，次序不能任意颠倒。左子树的值要小于父结点，右子树的值要大于父结点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="B树" scheme="https://vincentruan.github.io/tags/B%E6%A0%91/"/>
    
      <category term="B+树" scheme="https://vincentruan.github.io/tags/B-%E6%A0%91/"/>
    
      <category term="数据库" scheme="https://vincentruan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="https://vincentruan.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>微服务-API网关</title>
    <link href="https://vincentruan.github.io/2020/02/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1-API%E7%BD%91%E5%85%B3/"/>
    <id>https://vincentruan.github.io/2020/02/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1-API%E7%BD%91%E5%85%B3/</id>
    <published>2020-02-27T06:29:12.000Z</published>
    <updated>2020-02-28T08:33:48.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h1><h2 id="什么是-API-网关"><a href="#什么是-API-网关" class="headerlink" title="什么是 API 网关"></a>什么是 API 网关</h2><p>既然需要 API 网关为我所用，首先就让我们来了解一下什么是 API 网关。</p><h3 id="什么是-API-网关-1"><a href="#什么是-API-网关-1" class="headerlink" title="什么是 API 网关"></a>什么是 API 网关</h3><p>网关一词最早出现在网络设备，比如两个相互独立的局域网之间通过路由器进行通信，中间的路由被称之为网关。</p><p>任何一个应用系统如果需要被其他系统调用，就需要暴露 API，这些 API 代表着一个一个的功能点。</p><p>如果两个系统中间通信，在系统之间加上一个中介者协助 API 的调用，这个中介者就是 API 网关。</p><a id="more"></a><p><img src="/2020/02/27/微服务-API网关/640-1582785125084.webp" alt="img"></p><center><i>对接两个系统的 API 网关</i></center><p>当然，API 网关可以放在两个系统之间，同时也可以放在客户端与服务端之间。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785171304.png" alt="img"></p><center><i>对接客户端和服务端的 API 网关</i></center><p>知道了 API 网关的基本定义，再来看看为什么我们要使用它。</p><h3 id="为何要使用-API-网关"><a href="#为何要使用-API-网关" class="headerlink" title="为何要使用 API 网关"></a>为何要使用 API 网关</h3><p>网关作为系统的唯一入口，也就是说，进入系统的所有请求都需要经过 API 网关。</p><p><strong>当系统外部的应用或者客户端访问系统的时候，都会遇到这样的情况：</strong></p><ul><li>系统要判断它们的权限</li><li>如果传输协议不一致，需要对协议进行转换</li><li>如果调用水平扩展的服务，需要做负载均衡</li><li>一旦请求流量超出系统承受的范围，需要做限流操作</li><li>针对每个请求以及回复，系统会记录响应的日志</li></ul><p>也就是说，只要是涉及到对系统的请求，并且能够从业务中抽离出来的功能，都有可能在网关上实现。</p><p>例如：协议转换，负载均衡，请求路由，流量控制等等。后面我们会一一给大家介绍这些功能。</p><p>在了解 API 网关有哪些基本功能以后，来看看它可以服务于哪些系统或者客户端。</p><h3 id="API-网关服务定位"><a href="#API-网关服务定位" class="headerlink" title="API 网关服务定位"></a>API 网关服务定位</h3><p>API 网关拥有处理请求的能力，从定位来看分为 5 类：</p><p><strong>①面向 WebApp，</strong>这部分的系统以网站和 H5 应用为主。通过前后端分离的设计，将大部分的业务功能都放在了后端，前面的 Web App 只展示页面的内容。</p><p><strong>②MobileApp，</strong>这里的 Mobile 指的是 iOS 和 Android，设计思路和 WebApp 基本相同。<br>区别是 API 网关需要做一些移动设备管理的工作（MDM）。例如：设备的注册，激活，使用，淘汰等，全生命周期的管理。<br>由于移动设备的特殊性，导致了我们在考虑移动设备请求的时候，需要考虑请求，设备，使用者之间的关系。</p><p><strong>③面向合作伙伴的 OpenAPI，</strong>通常系统会给合作伙伴提供接口。这些接口会全部开放或者部分开发，在有条件限制（时间，流量）的情况下给合作伙伴访问。因此需要更多考虑 API 网关的流量和安全以及协议转换的管理。</p><p><strong>④企业内部可扩展 API，</strong>给企业内部的其他部门或者项目使用，也可以作为中台输出的一部分，支持其他系统。这里需要更多地考虑划分功能边界，认证和授权问题。</p><p><strong>⑤面向 IOT 设备，</strong>会接收来自 IOT 设备的请求，特别是工业传感器等设备。这里需要考虑协议转换和数据过滤。</p><h3 id="API-网关架构"><a href="#API-网关架构" class="headerlink" title="API 网关架构"></a>API 网关架构</h3><p>既然谈了 API 网关的功能和定位，接下来说说它的架构：</p><p><img src="/2020/02/27/微服务-API网关/640-1582785312869.jpg" alt="img"></p><center><i>API 网关系统架构图</i></center><p>API 网关拆分成为 3 个系统：</p><ul><li><strong>Gateway-Core（核心）</strong></li><li><strong>Gateway-Admin（管理）</strong></li><li><strong>Gateway-Monitor（监控）</strong></li></ul><p>Gateway-Core 核心网关，负责接收客户端请求，调度、加载和执行组件，将请求路由到上游服务端，并处理其返回的结果。</p><p>大多数的功能都在这一层完成，例如：验证，鉴权，负载均衡，协议转换，服务路由，数据缓存。如果没有其他两个子系统，它也是可以单独运行的。</p><p>Gateway-Admin 网关管理界面，可以进行 API、组件等系统基础信息的配置；例如：限流的策略，缓存配置，告警设置。</p><p>Gateway-Monitor 监控日志、生成各种运维管理报表、自动告警等；管理和监控系统主要是为核心系统服务的，起到支撑的作用。</p><h2 id="API-网关技术原理"><a href="#API-网关技术原理" class="headerlink" title="API 网关技术原理"></a>API 网关技术原理</h2><p>上面谈到了网关的架构思路，这里谈几点技术原理。平时我们在使用网关的时候，多注重其实现的功能。例如：路由，负载均衡，限流，缓存，日志，发布等等。</p><p>实际上这些功能的背后有一些原理我们可以了解，这样在应用功能的时候会更加笃定。下面是几个原理分享给大家。</p><h3 id="协议转换"><a href="#协议转换" class="headerlink" title="协议转换"></a>协议转换</h3><p>每个系统内部服务之间的调用，可以统一使用一种协议，例如：HTTP，GRPC。</p><p>假设每个系统使用的协议不同，那么系统之间的调用或者数据传输，就存在协议转换的问题了。如果解决这个问题呢？API 网关通过泛化调用的方式实现协议之间的转化。</p><p>实际上就是将不同的协议转换成“通用协议”，然后再将通用协议转化成本地系统能够识别的协议。</p><p>这一转化工作通常在 API 网关完成。通用协议用得比较多的有 JSON，当然也有使用 XML 或者自定义 JSON 文件的。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785663976.webp" alt="img"></p><center><i>不同的协议需要转化成共同语言进行传输</i></center><h3 id="链式处理"><a href="#链式处理" class="headerlink" title="链式处理"></a>链式处理</h3><p>设计模式中有一种责任链模式，它将“处理请求”和“处理步骤”分开。每个处理步骤，只关心这个步骤上需要做的处理操作，处理步骤存在先后顺序。</p><p>消息从第一个“处理步骤”流入，从最后一个“处理步骤”流出，每个步骤对经过的消息进行处理，整个过程形成了一个链条。在 API 网关中也用到了类似的模式。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785725522.webp" alt="img"></p><center><i>Zuul 网关过滤器链式处理</i></center><p>下面以 Zuul 为例，当消息出入网关需要经历一系列的过滤器。这些过滤器之间是有先后顺序的，并且在每个过滤器需要进行的工作也是各不一样：</p><ul><li><strong>PRE：</strong>前置过滤器，用来处理通用事务，比如鉴权，限流，熔断降级，缓存。并且可以通过 Custom 过滤器进行扩展。</li><li><strong>ROUTING：</strong>路由过滤器，在这种过滤器中把用户请求发送给 Origin Server。它主要负责：协议转化和路由的工作。</li><li><strong>POST：</strong>后置过滤器，从 Origin Server 返回的响应信息会经过它，再返回给调用者。在返回的 Response 上加入 Response Header，同时可以做 Response 的统计和日志记录。</li><li><strong>ERROR：</strong>错误过滤器，当上面三个过滤器发生异常时，错误信息会进到这里，并对错误进行处理。</li></ul><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>所有的请求通过 API 网关访问应用服务，一旦吞吐量上去了，如何高效地处理这些请求？</p><p><strong>拿 Zuul 为例，Zuul1 采用：</strong>一个线程处理一个请求的方式。线程负责接受请求，然后调用应用返回结果。</p><p>如果把网络请求看成一次 IO 操作的话，处理请求的线程，从接受请求，到服务返回响应，都是阻塞状态。</p><p>同时，如果多个线程都处在这种状态，会导致系统缓慢。因为每个网关能够开启的线程数量是有限的，特别是在访问的高峰期。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785808868.webp" alt="img"></p><center><i>每个线程处理一个请求</i></center><p>为了解决这个问题，Zuul2 启动了异步请求的机制。每个请求进入网关的时候，会被包装成一个事件，CPU 内核会维持一个监听器，不断轮询“请求事件”。</p><p>一旦，发现请求事件，就会调用对应的应用。获取应用返回的信息以后，按照请求的要求把数据/文件放到指定的缓冲区，同时发送一个通知事件，告诉请求端数据已经就绪，可以从这个缓冲获取数据/文件。</p><p>这个过程是异步的，请求的线程不用一直等待数据的返回。它在请求完毕以后，就直接返回了，这时它可以做其他的事情。</p><p>当请求数据被 CPU 内核获取，并且发送到指定的数据缓冲区时，请求的线程会接到“数据返回”的通知，然后就直接使用数据，不用自己去做取数据的操作。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785841303.webp" alt="img"></p><center><i>异步请求处理，CPU 处理数据以后通知请求端</i></center><p>实现异步处理请求有两种模式，分别是：</p><ul><li><strong>Reactor</strong></li><li><strong>Proactor</strong></li></ul><p><img src="/2020/02/27/微服务-API网关/640-1582786001001.png" alt="img"></p><center><i>Reactor 工作原理流水图</i></center><p><strong>Reactor：</strong>通过 handle_events 事件循环处理请求。用户线程注册事件处理器之后，可以继续执行其他的工作（异步），而 Reactor 线程负责调用内核的 Select 函数检查 Socket 状态。</p><p>当有 Socket 被激活时（获取网络数据），则通知相应的用户线程，执行 handle_event 进行数据读取、处理的工作。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786035615.png" alt="img"></p><center><i>Proactor 工作原理流水图</i></center><p><strong>Proactor：</strong>用户线程使用 CPU 内核提供的异步 IO 发起请求，请求发起以后立即返回。CPU 内核继续执行用户请求线程代码。</p><p>此时用户线程已将 AsynchronousOperation（异步处理）和 CompletionHandler（完成获取资源）注册到内核。之后操作系统开启独立的内核线程去处理 IO 操作。</p><p>当请求的数据到达时，由内核负责读取 Socket（网络请求）中的数据，并写入用户指定的缓冲区中。</p><p>最后内核将数据和用户线程注册的 CompletionHandler 分发给内部 Proactor，Proactor 将 IO 完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步 IO。</p><h2 id="API-网关实现功能"><a href="#API-网关实现功能" class="headerlink" title="API 网关实现功能"></a>API 网关实现功能</h2><p>说起对 API 网关的使用，我们还是对具体功能更加感兴趣。让我们一起来看看它实现了哪些功能。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>当网关后面挂接同一应用的多个副本时，每次用户的请求都会通过网关的负载均衡算法，路由到对应的服务上面。例如：随机算法，权重算法，Hash 算法等等。</p><p>如果上游服务采取微服务的架构，也可以和注册中心合作实现动态的负载均衡。</p><p>当微服务动态挂载（动态扩容）的时候，可以通过服务注册中心获取微服务的注册信息，从而实现负载均衡。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786091726.png" alt="img"></p><center><i>Nginx+Lua+服务注册中心实现动态负载均衡</i></center><h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>这个不言而喻，网关可以根据请求的 URL 地址解析，知道需要访问的服务。再通过路由表把请求路由到目标服务上去。</p><p>有时候因为网络原因，服务可能会暂时的不可用，这个时候我们希望可以再次对服务进行重试。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786124168.webp" alt="img"></p><center><i>Zuul 作为 API 网关将请求路由到上游服务器</i></center><p>例如：Zuul 与 Spring Retry 合作完成路由重试。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否开启重试功能</span></span><br><span class="line"><span class="meta">zuul.retryable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#对当前服务的重试次数</span></span><br><span class="line"><span class="meta">ribbon.MaxAutoRetries</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>限流是 API 网关常用的功能之一，当上游服务超出请求承载范围，或者服务因为某种原因无法正常使用，都会导致服务处理能力下滑。</p><p>这个时候，API 网关作为“看门人”，就可以限制流入的请求，让应用服务器免受冲击。</p><p>限流实际上就是限制流入请求的数量，其算法不少，有令牌桶算法，漏桶算法，连接数限制等等。这里我们就介绍三个常用的，一般通过 Nginx+Lua 来实现。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786174509.png" alt="img"></p><center><i>令牌桶限流</i></center><h3 id="统一鉴权"><a href="#统一鉴权" class="headerlink" title="统一鉴权"></a>统一鉴权</h3><p>访问应用服务器的请求都需要拥有一定权限，如果说每访问一个服务都需要验证一次权限，这个对效率是很大的影响。可以把权限认证放到 API 网关来进行。</p><p>目前比较常见的做法是，用户通过登录服务获取 Token，把它存放到客户端，在每次请求的时候把这个 Token 放入请求头，一起发送给服务器。</p><p>API 网关要做的事情就是解析这个 Token，知道访问者是谁（鉴定），他能做什么/访问什么（权限）。</p><p>说白了就是看访问者能够访问哪些 URL，这里根据权限/角色定义一个访问列表。</p><p>如果要实现多个系统的 OSS（Single Sign On 单点登录），API 网关需要和 CAS（Central Authentication Service 中心鉴权服务）做连接，来确定请求者的身份和权限。</p><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>当应用服务出现异常，不能继续提供服务的时候，也就是说应用服务不可用了。作为 API 网关需要做出处理，把请求导入到其他服务上。</p><p>或者对服务进行降级处理，例如：用兜底的服务数据返回客户端，或者提示服务暂时不可用。</p><p>同时通过服务注册中心，监听存在问题的服务，一旦服务恢复，随即恢复路由请求到该服务。</p><p>例如：Zuul 中提供了 ZuulFallbackProvider 接口来实现熔断，它提供两个方法，一个指明熔断拦截的服务 getRoute，一个指定返回内容 ClientHttpResponse。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">ZuulFallbackProvider</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The route this fallback will be used  for.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The route the fallback will be  used for.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Provides a fallback response.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The fallback response.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">ClientHttpResponsefallbackResponse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过自定义的 Fallback 方法，并且将其指定给某个 Route 来实现该 Route 访问出问题的熔断处理。</p><p>主要继承 ZuulFallbackProvider 接口来实现，ZuulFallbackProvider 默认有两个方法，一个用来指明熔断拦截哪个服务，一个定制返回内容。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786260809.png" alt="img"></p><center><i>API 网关熔断降级</i></center><h3 id="发布测试"><a href="#发布测试" class="headerlink" title="发布测试"></a>发布测试</h3><p>在发布版本的时候会采用：金丝雀发布和蓝绿发布。作为 API 网关可以使用路由选择和流量切换来协助上述行为。这里以金丝雀发布为例，看看 API 网关如何做路由转换的。</p><p>假设将 4 个服务从 V1 更新到 V2 版本，这 4 个服务的流量请求由 1 个 API 网关管理。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786294156.webp" alt="img"></p><p>那么先将一台服务与 API 网关断开，部署 V2 版本的服务，然后 API 网关再将流量导入到 V2 版本的服务上。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786301772.webp" alt="img"></p><p>这里流量的导入可以是逐步进行的，一旦 V2 版本的服务趋于稳定。再如法炮制，将其他服务替换成 V2 版本。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786310099.jpg" alt="img"></p><p>金丝雀发布一般先发 1 台，或者一个小比例，例如 2% 的服务器，主要做流量验证用，也称为金丝雀（Canary）测试（灰度测试）。</p><p>其来历是，旷工下矿洞前，先放一只金丝雀探查是否有毒气，金丝雀发布由此得名。</p><p>金丝雀测试需要完善的监控设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回滚的依据。</p><p>如果金丝测试通过，则把剩余的 V1 版本全部升级为 V2 版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。</p><h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><p><img src="/2020/02/27/微服务-API网关/640-1582786344099.webp" alt="img"></p><p>我们可以在 API 网关缓存一些修改频率不高的数据。<em>例如：用户信息，配置信息，通过服务定期刷新这个缓存就行了</em>：</p><ul><li>用户请求先访问 API 网关，如果发现有缓存信息，直接返回给用户。</li><li>如果没有发现缓存信息，回源到应用服务器获取信息。</li><li>另外，有一个缓存更新服务，定期把应用服务器中的信息更新到网关本地缓存中。</li></ul><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>通过 API 网关上的过滤器我们可以加入日志服务，记录请求和返回信息。同时可以建立一个管理员的界面去监控这些数据。</p><p><img src="/2020/02/27/微服务-API网关/640-1582785080155.webp" alt="img"></p><center><i>日志服务简图</i></center><p>日志记录了以后，可以做很多功能扩展。我们整理了以下几点供大家参考：</p><ul><li><strong>报表分析：</strong>针对服务访问情况，提供可视化展示。</li><li><strong>实时查询：</strong>了解实时关键信息，例如：吞吐量，并发数。在秒杀活动的时候，会特别关注。</li><li><strong>异常告警：</strong>针对关键参数进行监控，对于统计结果支持阈值报警，对接阿里云通知中心、短信、钉钉进行告警。</li><li><strong>日志投递：</strong>将日志进行归档，存放到文件库或者数据仓库中，以便后期分析。</li></ul><p><img src="/2020/02/27/微服务-API网关/640-1582785080158.webp" alt="img"></p><center><i>日志记录衍生的功能</i></center><h2 id="流行-API-网关对比"><a href="#流行-API-网关对比" class="headerlink" title="流行 API 网关对比"></a>流行 API 网关对比</h2><p>在介绍了 API 网关的功能以后，再来看看目前几个流行的 API 网关项目。看看他们各自的特点，并且把他们做一个简单的比较。这些网关目前都是开源的，大家可以有选择地在项目中使用。</p><h3 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h3><p>Kong 是 Mash ape 公司的开源项目，它是一个在 Nginx 中运行的 Lua 应用程序，并且可以通过 Lua-Nginx 模块实现扩展。</p><p>所以，可以通过插件集合的方式定制功能，例如：HTTP 基本认证、密钥认证、CORS（Cross-origin Resource Sharing，跨域资源共享）、TCP、UDP、日志、API 限流、请求转发以及监控，都是目前已有的插件。</p><p>由于是基于 Nginx 的，所以可以对网关进行水平扩展，来应对大批量的网络请求。</p><p><img src="/2020/02/27/微服务-API网关/640-1582786729359.png" alt="img"></p><center><i>Kong 架构图</i></center><p>Kong 主要有三个组件：</p><ul><li><strong>KongServer ：</strong>基于 Nginx 的服务器，用来接收 API 请求。</li><li><strong>ApacheCassandra/PostgreSQL：</strong>用来存储操作数据。</li><li><strong>Kongdashboard：</strong>UI 管理工具。</li></ul><h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p><img src="/2020/02/27/微服务-API网关/640-1582786770091.webp" alt="img"></p><center><i>Traefik 架构图</i></center><p>Traefik 是 HTTP 反向代理和负载均衡器，可以轻松部署微服务，可以与现有的组件（Docker、Swarm，Kubernetes，Marathon，Consul，Etcd）做集成。</p><p>因为支持动态配置，所以它的伸缩性很好。不过它只支持 HTTP、HTTPS 和 GRPC。如果你需要 TCP 负载均衡，那么您需要选择其他方案了。</p><h3 id="Ambassador"><a href="#Ambassador" class="headerlink" title="Ambassador"></a>Ambassador</h3><p><img src="/2020/02/27/微服务-API网关/640-1582785080167.webp" alt="img"></p><center><i>Ambassador 架构图</i></center><p>Ambassador 是一个基于 Envoy Proxy 构建的，Kubernetes 原生的开源微服务网关。</p><p>它在构建之初就致力于支持多个独立的团队，这些团队需要为最终用户快速发布、监控和更新服务。</p><p>Ambassador 还具有 Kubernetes Ingress 和负载均衡的能力。它支持处理 Kubernetes Ingress Controller 和负载均衡等功能，可以与 Istio 无缝集成。</p><h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p><img src="/2020/02/27/微服务-API网关/640-1582785080168.webp" alt="img"></p><center><i>Zuul 2 结构图</i></center><p>Zuul 是 Spring Cloud 全家桶中的微服务 API 网关。所有从设备或网站来的请求都会经过 Zuul 到达后端的 Netflix 应用程序。</p><p>作为一个边界性质的应用程序，Zuul 提供了动态路由、监控、弹性负载和安全功能。包括 Zuul1 和 Zuul2 两个版本。</p><p>介绍了几个开源 API 网关的基本信息以后，我们从几个维度对他们进行比较：</p><p><img src="/2020/02/27/微服务-API网关/640-1582786854230.png" alt="img"></p><p>从开源社区活跃度来说，Kong 和 Traefik 较好；从成熟度来看，较好的是 Kong、Traefik；从架构优势的扩展性来看，Kong 有丰富的插件，Ambassador 也有插件但不多，而 Zuul 是需要自研。</p><p>但 Zuul 由于与 Spring Cloud 集成，如果使用 Spring Cloud 的小伙伴可以考虑使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>API 网关是系统内外通讯的中介者。从定位上来说它服务 WebApp，MobileApp，合作伙伴 OpenAPI，企业内部可扩展 API，以及 IOT 设备。</p><p>从架构设计角度来说，分为 Gateway-Core（核心）、Gateway-Admin（管理）、Gateway-Monitor（监控）三部分。</p><p>API 网关需要注意的技术原理有，协议转换，链式处理以及异步请求。它的应用比较广泛，例如：负载均衡，路由选择，流量控制，统一鉴权，熔断降级，发布测试，缓存数据，日志记录等。</p><p>比较流行的开源 API网关有 Kong，Traefik，Ambassador，Zuul。从使用上来说他们各有千秋，可以根据项目的情况选取。</p><blockquote><p>转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655826846&amp;idx=1&amp;sn=483ea4f2d1d34f921ef07e35a4af63c1&amp;chksm=bd74fe498a03775fc5980c568e1af13f53c64ebaaedea643dc4ec03acc338fac7a323e3656a7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655826846&amp;idx=1&amp;sn=483ea4f2d1d34f921ef07e35a4af63c1&amp;chksm=bd74fe498a03775fc5980c568e1af13f53c64ebaaedea643dc4ec03acc338fac7a323e3656a7&amp;scene=21#wechat_redirect</a> 原<em>作者：崔皓</em></p></blockquote><h1 id="各大API网关性能比较"><a href="#各大API网关性能比较" class="headerlink" title="各大API网关性能比较"></a>各大API网关性能比较</h1><p>API网关最基本的功能就是反向代理，所以在对API网关做技术选型的时候需要着重考察其性能表现，本文对Nginx、Haproxy、Netty、Spring Cloud Gateway、Zuul2做了性能测试，测试代码可以在<a href="https://github.com/chanjarster/api-gateways-comparison" target="_blank" rel="noopener">github</a>获得。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><ul><li>准备了三台2CPU 4G内存的服务器，分别运行Tomcat、API Gateway、Gatling（压测工具）</li><li>先对Tomcat做压测，取Tomcat充分预热后的压测结果作为基准。压的是Tomcat自带的example：<code>/examples/jsp/jsp2/simpletag/book.jsp</code></li><li>在对Netty、Zuul2、Spring Cloud Gateway做压测时候也是先压个几轮做预热。</li><li>被测的API网关都没有添加额外业务，只做反向代理</li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>下图是吞吐量的情况，可以看到Netty、Nginx、Haproxy均比直压Tomcat低一点点，而Spring Cloud Gateway和Zuul2则要低得多。</p><p><img src="/2020/02/27/微服务-API网关/2973533330-5caf458852f74_articlex.png" alt="clipboard.png"></p><p>下面这张图可以更明显的看到吞吐量比较，Tomcat为100%因为它是基准值，Netty、Nginx、Haproxy的只比基准值低8%，而Spring Cloud Gateway和Zuul2则只是基准值的35%和34%（难兄难弟）。</p><p><img src="/2020/02/27/微服务-API网关/3673220854-5caf459e353c7_articlex.png" alt="clipboard.png"></p><h2 id="平均响应时间"><a href="#平均响应时间" class="headerlink" title="平均响应时间"></a>平均响应时间</h2><p>下图可以看到Netty、Nginx、Haproxy的平均响应时间与Tomcat差不多。但是Spring Cloud Gateway和Zuul2则是Tomcat的3倍多，不出所料。</p><p><img src="/2020/02/27/微服务-API网关/2061935431-5caf45afea0b8_articlex.png" alt="clipboard.png"></p><p>下图同样是以Tomcat作为基准值的比较：</p><p><img src="/2020/02/27/微服务-API网关/60484509-5caf45c794cb9_articlex.png" alt="clipboard.png"></p><h2 id="响应时间分布"><a href="#响应时间分布" class="headerlink" title="响应时间分布"></a>响应时间分布</h2><p>光看平均响应时间是不够的，我们还得看P50、P90、P99、P99.9以及Max响应时间（可惜Gatling只能设置4个百分位，否则我还想看看P99.99的响应时间）。</p><blockquote><p>为何要观察P99.9的响应时间？光看P90不够吗？理由有两个：</p><p>1）观察P99、P99.9、P99.99的响应时间可以观察系统的在高压情况下的稳定性，如果这三个时间的增长比较平滑那么说明该系统在高压力情况下比较稳定，如果这个曲线非常陡峭则说明不稳定。</p><p>2）观察P99、P99.9、P99.99的响应时间能够帮助你估算用户体验。假设你有一个页面会发出5次请求，那么这5次请求均落在P90以内概率是多少？90%^5=59%，至少会经历一次 &gt; P90响应时间的概率是 100%-59%=41%，如果你的P90=10s，那么就意味着用户有41%的概率会在加载页面的时候超过10s，是不是很惊人？如果你的P99=10s，那么用户只有5%的概率会在访问页面的时候超过10s。如果P99.9=10s，则有0.4%的概率。</p><p>关于如何正确测量系统可以看 <a href="https://www.youtube.com/watch?v=lJ8ydIuPFeU" target="_blank" rel="noopener">“How NOT to Measure Latency” by Gil Tene</a></p></blockquote><p><img src="/2020/02/27/微服务-API网关/684416954-5caf45ec7efc3_articlex.png" alt="clipboard.png"></p><p>下面同样是把结果与Tomcat基准值做对比：</p><p><img src="/2020/02/27/微服务-API网关/851752044-5caf460b876aa_articlex.png" alt="clipboard.png"></p><p>可以看到几个很有趣的现象：</p><ul><li>Haproxy、Nginx的P50、P90、P99、P99.9、Max都是逐渐递增的。</li><li>Netty的P50、P90、P99、P99.9是很平坦的，Max则为基准值的207%。</li><li>Spring Cloud Gateway和Zuul2则是相反的，它们的平面呈现下降趋势。Spring Cloud Gateway的Max甚至还比基准值低了一点点（94%），我相信这只是一个随机出现的数字，不要太在意。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Nginx、Haproxy、Netty三者的表现均很不错，其对于吞吐量和响应时间的性能损耗很低，可以忽略不计。</p><p>但是目前最为火热的Spring Cloud Gateway和Zuul2则表现得比较糟糕，因我没有写额外的业务逻辑这，可以推测这和它们的内置逻辑有关，那么大致有这么几种可能：</p><ol><li>内置逻辑比较多</li><li>内置逻辑算法存在问题，占用了太多CPU时间</li><li>内置逻辑存在阻塞</li><li>内置逻辑没有用正确姿势使用Netty（两者皆基于Netty）</li></ol><p>不管是上面的哪一种都需要再后续分析。</p><p>不过话说回来考虑选用那种作为API网关（的基础技术）不光要看性能，还要看：</p><ul><li>是否易于扩展自己的业务逻辑</li><li>API使用的便利性</li><li>代码的可维护性</li><li>文档是否齐全</li><li>…</li></ul><p>性能只是我们手里的一个筹码，当我们知道这个东西性能到底几何后，才可以与上面的这些做交换（trade-off）。比如Nginx和Haproxy的可扩展性很差，那么我们可以使用Netty。如果你觉得Netty的API太底层了太难用了，那么可以考虑<code>Spring Cloud Gateway</code>或<code>Zuul2</code>。前提是你知道你会失去多少性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;API-网关&quot;&gt;&lt;a href=&quot;#API-网关&quot; class=&quot;headerlink&quot; title=&quot;API 网关&quot;&gt;&lt;/a&gt;API 网关&lt;/h1&gt;&lt;h2 id=&quot;什么是-API-网关&quot;&gt;&lt;a href=&quot;#什么是-API-网关&quot; class=&quot;headerlink&quot; title=&quot;什么是 API 网关&quot;&gt;&lt;/a&gt;什么是 API 网关&lt;/h2&gt;&lt;p&gt;既然需要 API 网关为我所用，首先就让我们来了解一下什么是 API 网关。&lt;/p&gt;
&lt;h3 id=&quot;什么是-API-网关-1&quot;&gt;&lt;a href=&quot;#什么是-API-网关-1&quot; class=&quot;headerlink&quot; title=&quot;什么是 API 网关&quot;&gt;&lt;/a&gt;什么是 API 网关&lt;/h3&gt;&lt;p&gt;网关一词最早出现在网络设备，比如两个相互独立的局域网之间通过路由器进行通信，中间的路由被称之为网关。&lt;/p&gt;
&lt;p&gt;任何一个应用系统如果需要被其他系统调用，就需要暴露 API，这些 API 代表着一个一个的功能点。&lt;/p&gt;
&lt;p&gt;如果两个系统中间通信，在系统之间加上一个中介者协助 API 的调用，这个中介者就是 API 网关。&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构设计" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="API网关" scheme="https://vincentruan.github.io/tags/API%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>数据库软件架构设计</title>
    <link href="https://vincentruan.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://vincentruan.github.io/2020/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-02-26T03:28:47.000Z</published>
    <updated>2020-02-26T09:53:39.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="概念一：单库"><a href="#概念一：单库" class="headerlink" title="概念一：单库"></a>概念一：单库</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688299341.webp" alt="img"></p><h2 id="概念二：分片"><a href="#概念二：分片" class="headerlink" title="概念二：分片"></a>概念二：分片</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688306996.webp" alt="img"></p><p>分片解决“数据量太大”这一问题，也就是通常说的“水平切分”。</p><p>一旦引入分片，势必面临“数据路由”的新问题，数据到底要访问哪个库。路由规则通常有3种方法：</p><a id="more"></a><h3 id="（1）范围：range"><a href="#（1）范围：range" class="headerlink" title="（1）范围：range"></a>（1）范围：range</h3><p>优点：简单，容易扩展。</p><p>缺点：各库压力不均（新号段更活跃）。</p><h3 id="（2）哈希：hash"><a href="#（2）哈希：hash" class="headerlink" title="（2）哈希：hash"></a>（2）哈希：hash</h3><p>优点：简单，数据均衡，负载均匀。</p><p>缺点：迁移麻烦（2库扩3库数据要迁移）。</p><h3 id="（3）统一路由服务：router-config-server"><a href="#（3）统一路由服务：router-config-server" class="headerlink" title="（3）统一路由服务：router-config-server"></a>（3）统一路由服务：router-config-server</h3><p>优点：灵活性强，业务与路由算法解耦。</p><p>缺点：每次访问数据库前多一次查询。</p><p>大部分互联网公司采用的方案二：哈希路由。</p><h2 id="概念三：分组"><a href="#概念三：分组" class="headerlink" title="概念三：分组"></a>概念三：分组</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688370033.webp" alt="img"><br>分组解决“可用性，性能提升”这一问题，分组通常通过主从复制的方式实现。</p><p>互联网公司数据库实际软件架构是“既分片，又分组”：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805463.webp" alt="img"></p><hr><p>数据库软件架构，究竟设计些什么呢，至少要考虑以下四点：</p><ul><li>如何保证数据可用性</li><li>如何提高数据库读性能（大部分应用读多写少，读会先成为瓶颈）</li><li>如何保证一致性</li><li>如何提高扩展性</li></ul><hr><h1 id="如何保证数据的可用性？"><a href="#如何保证数据的可用性？" class="headerlink" title="如何保证数据的可用性？"></a>如何保证数据的可用性？</h1><p>解决可用性问题的思路是：冗余。</p><blockquote><p>如何保证站点的可用性？冗余站点。<br>如何保证服务的可用性？冗余服务。<br>如何保证数据的可用性？冗余数据。</p></blockquote><p>数据的冗余，会带来一个副作用：一致性问题。</p><h2 id="如何保证数据库“读”高可用？"><a href="#如何保证数据库“读”高可用？" class="headerlink" title="如何保证数据库“读”高可用？"></a>如何保证数据库“读”高可用？</h2><blockquote><p>冗余读库</p></blockquote><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805472.webp" alt="img"></p><p>冗余读库带来什么副作用？</p><p>读写有延时，数据可能不一致。</p><p>上图是很多互联网公司mysql的架构，写仍然是单点，不能保证写高可用。</p><h2 id="如何保证数据库“写”高可用？"><a href="#如何保证数据库“写”高可用？" class="headerlink" title="如何保证数据库“写”高可用？"></a>如何保证数据库“写”高可用？</h2><blockquote><p>冗余写库。</p></blockquote><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805479.webp" alt="img"><br>采用双主互备的方式，可以冗余写库。</p><p>冗余写库带来什么副作用？</p><p>双写同步，数据可能冲突（例如“自增id”同步冲突）。</p><blockquote><p>如何解决同步冲突，有两种常见解决方案：<br>（1）两个写库使用不同的初始值，相同的步长来增加id：1写库的id为0,2,4,6…；2写库的id为1,3,5,7…；<br>（2）不使用数据的id，业务层自己生成唯一的id，保证数据不冲突；</p></blockquote><p>阿里云的RDS服务号称写高可用，是如何实现的呢？</p><p>他们采用的就是类似于“双主同步”的方式（不再有从库了）。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805483.webp" alt="img"><br>仍是双主，但只有一个主提供读写服务，另一个主是“shadow-master”，只用来保证高可用，平时不提供服务。</p><p>master挂了，shadow-master顶上，虚IP漂移，对业务层透明，不需要人工介入。</p><blockquote><p>这种方式的好处：<br>（1）读写没有延时，无一致性问题；<br>（2）读写高可用；</p></blockquote><blockquote><p>不足是：<br>（1）不能通过加从库的方式扩展读性能；<br>（2）资源利用率为50%，一台冗余主没有提供服务；</p></blockquote><p><em>画外音：所以，高可用RDS还挺贵的。</em></p><h1 id="如何扩展读性能？"><a href="#如何扩展读性能？" class="headerlink" title="如何扩展读性能？"></a>如何扩展读性能？</h1><p>提高读性能的方式大致有三种，</p><h2 id="第一种是增加索引。"><a href="#第一种是增加索引。" class="headerlink" title="第一种是增加索引。"></a>第一种是增加索引。</h2><p>这种方式不展开，要提到的一点是，不同的库可以建立不同的索引。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805494.webp" alt="img"><br>如上图：</p><p>（1）写库不建立索引；<br>（2）线上读库建立线上访问索引，例如uid；<br>（3）线下读库建立线下访问索引，例如time；</p><h2 id="第二种扩充读性能的方式是，增加从库。"><a href="#第二种扩充读性能的方式是，增加从库。" class="headerlink" title="第二种扩充读性能的方式是，增加从库。"></a>第二种扩充读性能的方式是，增加从库。</h2><p>这种方法大家用的比较多，存在两个缺点：</p><p>（1）从库越多，同步越慢；<br>（2）同步越慢，数据不一致窗口越大；</p><h2 id="第三种增加系统读性能的方式是，增加缓存。"><a href="#第三种增加系统读性能的方式是，增加缓存。" class="headerlink" title="第三种增加系统读性能的方式是，增加缓存。"></a>第三种增加系统读性能的方式是，增加缓存。</h2><p>常见的缓存架构如下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805496.webp" alt="img"><br>（1）上游是业务应用；<br>（2）下游是主库，从库（读写分离），缓存；</p><p>如果系统架构实施了服务化：</p><p>（1）上游是业务应用；<br>（2）中间是服务；<br>（3）下游是主库，从库，缓存；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582687805568.webp" alt="img"><br>业务层不直接面向db和cache，服务层屏蔽了底层db、cache的复杂性。</p><p>不管采用主从的方式扩展读性能，还是缓存的方式扩展读性能，数据都要复制多份（主+从，db+cache），一定会引发一致性问题。</p><h1 id="如何保证一致性？"><a href="#如何保证一致性？" class="headerlink" title="如何保证一致性？"></a>如何保证一致性？</h1><p>主从数据库的一致性，通常有两种解决方案：</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688661771.webp" alt="img"><br>如果某一个key有写操作，在不一致时间窗口内，中间件会将这个key的读操作也路由到主库上。</p><h2 id="强制读主"><a href="#强制读主" class="headerlink" title="强制读主"></a>强制读主</h2><p><img src="/2020/02/26/数据库软件架构设计/640-1582688686209.webp" alt="img"><br>“双主高可用”的架构，主从一致性的问题能够大大缓解。</p><p>第二类不一致，是db与缓存间的不一致。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582710817260.webp" alt="img"></p><p>这一类不一致，<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961368&amp;idx=1&amp;sn=82a59f41332e11a29c5759248bc1ba17&amp;chksm=bd2d0dc48a5a84d293f5999760b994cee9b7e20e240c04d0ed442e139f84ebacf608d51f4342&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">《缓存架构，一篇足够？》</a>里有非常详细的叙述，本文不再展开。</p><p>另外建议，所有允许cache miss的业务场景，缓存中的KEY都设置一个超时时间，这样即使出现不一致，有机会得到自修复。</p><h1 id="如何保障数据库的扩展性？"><a href="#如何保障数据库的扩展性？" class="headerlink" title="如何保障数据库的扩展性？"></a>如何保障数据库的扩展性？</h1><h2 id="秒级成倍数据库扩容"><a href="#秒级成倍数据库扩容" class="headerlink" title="秒级成倍数据库扩容"></a>秒级成倍数据库扩容</h2><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962231&amp;idx=1&amp;sn=1b51d042c243f0b3ce0b748ddbcff865&amp;chksm=bd2d0eab8a5a87bdcbe7dd08fb4c969ad76fa0ea00b2c78645db8561fd2a78d813d7b8bef2ac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">亿级数据DB秒级平滑扩容</a>》</p><p>一步一步，娓娓道来。</p><p><strong>一般来说，并发量大，吞吐量大的互联网分层架构是怎么样的？</strong></p><p>数据库上层都有一个微服务，服务层记录“业务库”与“数据库实例配置”的映射关系，通过数据库连接池向数据库路由sql语句。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689399761.webp" alt="img"></p><p>如上图所示，服务层配置用户库user对应的数据库实例ip。</p><p><em>画外音：其实是一个内网域名。</em></p><h3 id="该分层架构，如何应对数据库的高可用？"><a href="#该分层架构，如何应对数据库的高可用？" class="headerlink" title="该分层架构，如何应对数据库的高可用？"></a>该分层架构，如何应对数据库的高可用？</h3><p>数据库高可用，很常见的一种方式，使用双主同步+keepalived+虚ip的方式进行。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689439373.webp" alt="img"></p><p>如上图所示，两个相互同步的主库使用相同的虚ip。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689464428.webp" alt="img"></p><p>当主库挂掉的时候，虚ip自动漂移到另一个主库，整个过程对调用方透明，通过这种方式保证数据库的高可用。</p><p><em>画外音：关于高可用，《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962050&amp;idx=1&amp;sn=f60b8bb833fe3425f5227da42e3b3adf&amp;chksm=bd2d0f1e8a5a8608f81d42a16eea476d0bd4763f84f9a008ed616d1cfa050a4015780f898eb1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">互联网分层架构如何保证“高可用“？</a>》专题介绍过，本文不再展开。</em></p><hr><h3 id="该分层架构，如何应对数据量的暴增？"><a href="#该分层架构，如何应对数据量的暴增？" class="headerlink" title="该分层架构，如何应对数据量的暴增？"></a>该分层架构，如何应对数据量的暴增？</h3><p>随着数据量的增大，数据库要进行水平切分，分库后将数据分布到不同的数据库实例（甚至物理机器）上，以达到降低数据量，增强性能的扩容目的。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689545536.webp" alt="img"></p><p>如上图所示，用户库user分布在两个实例上，ip0和ip1，服务层通过用户标识uid取模的方式进行寻库路由，模2余0的访问ip0上的user库，模2余1的访问ip1上的user库。</p><p><em>画外音：此时，水平切分集群的读写实例加倍，单个实例的数据量减半，性能增长可不止一倍。</em></p><p>综上三点所述，大数据量，高可用的互联网微服务分层的架构如下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582689574601.webp" alt="img"></p><p>既有水平切分，又保证高可用。</p><p><strong>如果数据量持续增大，2个库性能扛不住了，该怎么办呢？</strong></p><p>此时，需要继续水平拆分，拆成更多的库，降低单库数据量，增加库主库实例（机器）数量，提高性能。</p><p><strong>新的问题来了，分成n个库后，随着数据量的增加，要增加到2*n个库，数据库如何扩容，数据能否平滑迁移，能够持续对外提供服务，保证服务的可用性？</strong></p><p><em>画外音：你遇到过类似的问题么？</em></p><p><strong>停服扩容，是最容易想到的方案？</strong></p><p>在讨论秒级平滑扩容方案之前，先简要说明下停服务扩容的方案的步骤：</p><p>（1）站点挂一个公告“为了为广大用户提供更好的服务，本站点/游戏将在今晚00:00-2:00之间升级，届时将不能登录，用户周知”；</p><p><em>画外音：见过这样的公告么，实际上在迁移数据。</em></p><p>（2）<strong>微服务停止服务</strong>，数据库不再有流量写入；</p><p>（3）<strong>新建2*n个新库</strong>，并做好高可用；</p><p><strong>（4）</strong>写一个小脚本进行<strong>数据迁移</strong>，把数据从n个库里select出来，insert到2*n个库里；</p><p>（5）<strong>修改微服务的数据库路由配置</strong>，模n变为模2*n；</p><p>（6）<strong>微服务重启</strong>，连接新库重新对外提供服务；</p><p>整个过程中，最耗时的是第四步数据迁移。</p><p><strong>如果出现问题，如何进行回滚？</strong></p><p>如果数据迁移失败，或者迁移后测试失败，则将<strong>配置改回旧库，恢复服务</strong>即可。</p><p><strong>停服方案有什么优劣？</strong></p><p>优点：<strong>简单</strong>。</p><p>缺点：</p><p>（1）需要停止服务，<strong>方案不高可用</strong>；</p><p>（2）技术同学压力大，所有工作要在规定时间内完成，根据经验，压力越大约容易出错；</p><p><em>画外音：这一点很致命。</em></p><p>（3）如果有问题第一时间没检查出来，启动了服务，运行一段时间后再发现有问题，则难以回滚，如果<strong>回档会丢失一部分数据</strong>；</p><h3 id="有没有秒级实施、更平滑、更帅气的方案呢？"><a href="#有没有秒级实施、更平滑、更帅气的方案呢？" class="headerlink" title="有没有秒级实施、更平滑、更帅气的方案呢？"></a>有没有秒级实施、更平滑、更帅气的方案呢？</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582689771696.webp" alt="img"></p><p>再次看一眼扩容前的架构，分两个库，假设每个库1亿数据量，<strong>如何</strong>平滑扩容，增加实例数，降低单库数据量呢？三个简单步骤搞定。</p><h4 id="步骤一：修改配置"><a href="#步骤一：修改配置" class="headerlink" title="步骤一：修改配置"></a>步骤一：修改配置</h4><p><img src="/2020/02/26/数据库软件架构设计/640-1582701009934.webp" alt="img"></p><p>主要修改两处：</p><ul><li>数据库实例所在的机器做<strong>双虚ip</strong>：</li></ul><p>（1）原%2=0的库是虚ip0，现增加一个虚ip00；</p><p>（2）原%2=1的库是虚ip1，现增加一个虚ip11；</p><ul><li>修改服务的配置，将2个库的<strong>数据库配置</strong>，改为4个库的数据库配置，修改的时候要注意旧库与新库的映射关系：</li></ul><p>（1）%2=0的库，会变为%4=0与%4=2；</p><p>（2）%2=1的部分，会变为%4=1与%4=3；</p><p><em>画外音：这样能够保证，依然路由到正确的数据。</em></p><h4 id="步骤二：reload配置，实例扩容"><a href="#步骤二：reload配置，实例扩容" class="headerlink" title="步骤二：reload配置，实例扩容"></a>步骤二：reload配置，实例扩容</h4><p><img src="/2020/02/26/数据库软件架构设计/640-1582701068464.webp" alt="img"></p><p>服务层reload配置，reload可能是这么几种方式：</p><p>（a）比较原始的，重启服务，读新的配置文件；<br>（b）高级一点的，配置中心给服务发信号，重读配置文件，重新初始化数据库连接池；</p><p>不管哪种方式，reload之后，数据库的实例扩容就完成了，原来是2个数据库实例提供服务，现在变为4个数据库实例提供服务，这个过程一般可以在秒级完成。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701102779.webp" alt="img"></p><p>整个过程可以逐步重启，对服务的正确性和可用性完全没有影响：</p><p>（a）<strong>即使%2寻库和%4寻库同时存在，也不影响数据的正确性</strong>，因为此时仍然是双主数据同步的；<br>（b）<strong>即使%4=0与%4=2的寻库落到同一个数据库实例上，也不影响数据的正确性</strong>，因为此时仍然是双主数据同步的；</p><p>完成了实例的扩展，会发现每个数据库的数据量依然没有下降，所以第三个步骤还要做一些收尾工作。</p><p><em>画外音：这一步，数据库实例个数加倍了。</em></p><h4 id="步骤三：收尾工作，数据收缩"><a href="#步骤三：收尾工作，数据收缩" class="headerlink" title="步骤三：收尾工作，数据收缩"></a>步骤三：收尾工作，数据收缩</h4><p><img src="/2020/02/26/数据库软件架构设计/640.jpg" alt="img"></p><p>有这些一些收尾工作：</p><p>（a）把双虚ip修改回单虚ip；</p><p>（b）解除旧的双主同步，让成对库的数据不再同步增加；</p><p>（c）增加新的双主同步，保证高可用；</p><p>（d）删除掉冗余数据，例如：ip0里%4=2的数据全部删除，只为%4=0的数据提供服务；</p><p><em>画外音：这一步，数据库单实例数据量减半了。</em></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582701273816.webp" alt="img"></p><p>互联网大数据量，高吞吐量，高可用微服务分层架构，数据库实现秒级平滑扩容的三个步骤为：</p><p>（1）修改配置（双虚ip，微服务数据库路由）；</p><p>（2）reload配置，<strong>实例增倍</strong>完成；</p><p>（3）删除冗余数据等收尾工作，<strong>数据量减半</strong>完成；</p><p><strong>思路</strong>比结论重要，希望大家有收获。</p><h2 id="100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？"><a href="#100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？" class="headerlink" title="100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？"></a>100亿数据，非“双倍”扩容，如何不影响服务，数据平滑迁移？</h2><p>如果不是成倍扩容：</p><p>《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962270&amp;idx=1&amp;sn=3131888f29d0d137d02703a6dc91fa56&amp;chksm=bd2d0e428a5a87547dfc6a0a292a7746ad50b74a078e29b4b8024633fa42db6ccc5f47435063&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">100亿数据平滑数据迁移,不影响服务</a>》</p><p>如果不是“双倍”扩容，能否做到平滑迁移，不影响服务呢？</p><h3 id="适用什么场景？"><a href="#适用什么场景？" class="headerlink" title="适用什么场景？"></a>适用什么场景？</h3><p>互联网有很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，其典型系统分层架构如下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584150.webp" alt="img"></p><p>（1）上游是<strong>业务层biz</strong>，实现个性化的业务逻辑；<br>（2）中游是<strong>服务层service</strong>，封装数据访问；<br>（3）下游是<strong>数据层db</strong>，存储固化的业务数据；</p><p>服务化分层架构的好处是，服务层屏蔽下游数据层的复杂性，例如缓存、分库分表、存储引擎等存储细节不需要向调用方暴露，而只向上游提供方便的RPC访问接口，当有一些数据层变化的时候，所有的调用方也不需要升级，只需要服务层升级即可。</p><p>互联网架构，很多时候面临着这样一些需求：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701647190.png" alt="img"></p><p><strong>（1）底层表结构变更</strong>：数据量非常大的情况下，数据表增加了一些属性，删除了一些属性，修改了一些属性。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584125.webp" alt="img"></p><p><strong>（2）分库个数变化</strong>：由于数据量的持续增加，底层分库个数非成倍增加。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701690543.png" alt="img"></p><p><strong>（3）底层存储介质变化</strong>：底层存储引擎由一个数据库换为另一个数据库。</p><p>种种需求，都需要进行数据迁移，如何平滑迁移数据，迁移过程不停机，保证系统持续服务，是文本将要讨论的问题。</p><h4 id="方案一：停机方案"><a href="#方案一：停机方案" class="headerlink" title="方案一：停机方案"></a>方案一：停机方案</h4><p>在讨论平滑迁移数据方案之前，先看下不平滑的停机数据迁移方案，主要分三个步骤。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584135.webp" alt="img"></p><p><strong>步骤一</strong>：<strong>挂</strong>一个类似“为了给广大用户提供更好的服务，服务器会在凌晨0:00-0:400进行停机维护”的<strong>公告</strong>，并在对应时段进行<strong>停机</strong>，这个时段系统没有流量进入。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701774823.png" alt="img"></p><p><strong>步骤二</strong>：停机后，研发一个<strong>离线</strong>的数据迁移工具，进行<strong>数据迁移</strong>。针对第一节的三类需求，会分别开发不同的数据迁移工具。</p><p>（1）底层表结构变更需求：开发旧表导新表的工具；</p><p>（2）分库个数变换需求：开发2库导3库的工具；</p><p>（3）底层存储介质变换需求：开发Mongo导Mysql工具；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584173.webp" alt="img"></p><p><strong>步骤三</strong>：<strong>恢复服务</strong>，并将流量切到新库，不同的需求，可能会涉及不同服务升级。</p><p>（1）底层表结构变更需求：服务要升级到访问新表；<br>（2）分库个数变换需求：服务不需要升级，只需要改寻库路由配置；<br>（3）底层存储介质变换需求：服务升级到访问新的存储介质；</p><p>总的来说，停机方案是<strong>相对直观和简单</strong>的，但对<strong>服务的可用性有影响</strong>，许多游戏公司的服务器升级，游戏分区与合区，可能会采用类似的方案。</p><p>除了影响服务的可用性，这个方案还有一个缺点，就是必须在指定时间完成升级，这个对研发、测试、运维同学来说，<strong>压力会非常大</strong>，一旦出现问题例如数据不一致，必须在规定时间内解决，否则只能回滚。根据经验，<strong>人压力越大越容易出错</strong>，这个缺点一定程度上是致命的。</p><p>无论如何，停机方案并不是今天要讨论的重点，接下来看一下常见的平滑数据迁移方案。</p><h4 id="方案二：追日志方案"><a href="#方案二：追日志方案" class="headerlink" title="方案二：追日志方案"></a>方案二：追日志方案</h4><p>追日志方案，是一个高可用的平滑迁移方案，这个方案主要分为五个步骤。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584118.webp" alt="img"></p><p>数据迁移前，上游业务应用通过旧的服务访问旧的数据。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701865724.png" alt="img"></p><p><strong>步骤一</strong>：服务进行升级，<strong>记录“对旧库上的数据修改”的日志</strong>（这里的修改，为数据的insert, delete, update），这个日志不需要记录详细数据，主要记录：</p><p>（1）被修改的<strong>库</strong>；<br>（2）被修改的<strong>表</strong>；<br>（3）被修改的<strong>唯一主键</strong>；</p><p>具体新增了什么行，修改后的数据格式是什么，不需要详细记录。这样的好处是，不管业务细节如何变化，日志的格式是固定的，这样能保证方案的通用性。</p><p>这个服务升级风险较小：</p><p>（1）写接口是少数接口，改动点较少；<br>（2）升级只是增加了一些日志，对业务功能没有任何影响；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584104.webp" alt="img"></p><p><strong>步骤二</strong>：<em>研发一个数据迁移工具，进行数据迁移</em>。这个数据迁移工具和离线迁移工具一样，把旧库中的数据转移到新库中来。</p><p>这个小工具的风险较小：</p><p>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，都可以把新库中的数据干掉重来；<br>（4）可以限速慢慢迁移，技术同学没有时间压力；</p><p><strong>数据迁移完成之后，就能够切到新库提供服务了么？</strong></p><p><strong>答案是否定的</strong>，在数据迁移的过程中，旧库依然对线上提供着服务，库中的数据随时可能变化，这个变化并没有反映到新库中来，于是旧库和新库的数据并不一致，所以不能直接切库，需要将数据追平。</p><p><strong>哪些数据发生了变化呢？</strong></p><p>步骤一中日志里记录的，正是变化的数据。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701996028.png" alt="img"></p><p><strong>步骤三</strong>：<strong>研发一个读取日志并迁移数据的小工具，要把步骤二迁移数据过程中产生的差异数据追平</strong>。这个小工具需要做的是：<br>（1）读取日志，得到哪个库、哪个表、哪个主键发生了变化；<br>（2）把旧库中对应主键的记录读取出来；<br>（3）把新库中对应主键的记录替换掉；</p><p>无论如何，<strong>原则是数据以旧库为准</strong>。</p><p>这个小工具的风险也很小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，大不了从步骤二开始重来；<br>（4）可以限速慢慢重放日志，技术同学没有时间压力；</p><p><strong>日志重放之后，就能够切到新库提供服务了么？</strong></p><p><strong>答案依然是否定的</strong>，在日志重放的过程中，旧库中又可能有数据发生了变化，导致数据不一致，所以还是不能切库，需要进一步读取日志，追平记录。可以看到，重放日志追平数据的程序是一个while(1)的程序，新库与旧库中的<strong>数据追平也会是一个“无限逼近”的过程</strong>。</p><p><strong>什么时候数据会完全一致呢？</strong></p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584177.webp" alt="img"></p><p><strong>步骤四</strong>：在持续重放日志，<strong>追平数据的过程中，研发一个数据校验的小工具，将旧库和新库中的数据进行比对，直到数据完全一致</strong>。</p><p>这个小工具的风险依旧很小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，大不了从步骤二开始重来；<br>（4）可以限速慢慢比对数据，技术同学没有时间压力；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584187.webp" alt="img"></p><p><strong>步骤五</strong>：在数据比对完全一致之后，将<strong>流量迁移到新库</strong>，新库提供服务，完成迁移。</p><p>如果步骤四数据一直是99.9%的一致，不能完全一致，也是正常的，可以做一个秒级的旧库readonly，等日志重放程序完全追上数据后，再进行切库切流量。</p><p>至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</p><h4 id="方案三：双写方案"><a href="#方案三：双写方案" class="headerlink" title="方案三：双写方案"></a>方案三：双写方案</h4><p>双写方案，也是一个高可用的平滑迁移方案，这个方案主要分为四个步骤。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584167.webp" alt="img"></p><p>数据迁移前，上游业务应用通过旧的服务访问旧的数据。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582702242950.png" alt="img"></p><p><strong>步骤一</strong>：<strong>服务进行升级</strong>，对“对旧库上的数据修改”（这里的修改，为数据的insert, delete, update），在新库上进行相同的修改操作，这就是所谓的“<strong>双写</strong>”，主要修改操作包括：<br>（1）旧库与新库的同时insert；<br>（2）旧库与新库的同时delete；<br>（3）旧库与新库的同时update；</p><p>由于新库中此时是没有数据的，所以双写旧库与新库中的affect rows可能不一样，不过这完全不影响业务功能，只要不切库，依然是旧库提供业务服务。</p><p>这个服务升级风险较小：<br>（1）写接口是少数接口，改动点较少；<br>（2）新库的写操作执行成功与否，对业务功能没有任何影响；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582702288458.png" alt="img"></p><p><strong>步骤二</strong>：研发一个数据迁移工具，进行<strong>数据迁移</strong>。这个数据迁移工具在本文中已经出现第三次了，把旧库中的数据转移到新库中来。</p><p>这个小工具的风险较小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，都可以把新库中的数据干掉重来；<br>（4）可以限速慢慢迁移，技术同学没有时间压力；</p><p><strong>数据迁移完成之后，就能够切到新库提供服务了么？</strong></p><p><strong>答案是肯定的</strong>，因为前置步骤进行了双写，所以理论上数据迁移完之后，新库与旧库的数据应该完全一致。</p><p>由于迁移数据的过程中，旧库新库双写操作在同时进行，<strong>怎么证明数据迁移完成之后数据就完全一致了呢？</strong></p><p><img src="/2020/02/26/数据库软件架构设计/640.png" alt="img"></p><p>如上图所示：</p><p>（1）左侧是旧库中的数据，右侧是新库中的数据；</p><p>（2）按照primary key从min到max的顺序，分段，限速进行数据的迁移，假设已经迁移到now这个数据段，数据迁移过程中的修改操作分别讨论：</p><ul><li>假设迁移过程中进行了一个<strong>双insert操作</strong>，旧库新库都插入了数据，数据一致性没有被破坏</li><li>假设迁移过程中进行了一个<strong>双delete操作</strong>，这又分为两种情况</li></ul><p><strong>情况一</strong>：假设这delete的数据属于[min,now]范围，即已经完成迁移，则旧库新库都删除了数据，<code>数据一致性</code>没有被破坏；<br><strong>情况二</strong>：假设这delete的数据属于[now,max]范围，即未完成迁移，则旧库中删除操作的affect rows为1，新库中删除操作的affect rows为0，但是数据迁移工具在后续数据迁移中，并不会将这条旧库中被删除的数据迁移到新库中，所以数据一致性仍没有被破坏；</p><ul><li>假设迁移过程中进行了一个<strong>双update操作</strong>，可以认为update操作是一个delete加一个insert操作的复合操作，所以数据仍然是<code>一致</code>的</li></ul><p>除非，在一种非常极限的情况下：<br>（1）date-migrate-tool<strong>刚好</strong>从旧库中将某一条数据X取出；<br>（2）在X插入到新库中之前，旧库与新库中<strong>刚好</strong>对X进行了双delete操作；<br>（3）date-migrate-tool再将X插入到新库中；</p><p>这样，会出现新库比旧库多出一条数据X。</p><p>但无论如何，为了保证数据的一致性，切库之前，还是需要进行数据校验的。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582702403207.png" alt="img"></p><p><strong>步骤三</strong>：在数据迁移完成之后，需要<strong>使用数据校验的小工具</strong>，将旧库和新库中的数据进行比对，完全一致则符合预期，如果出现步骤二中的极限不一致情况，则以旧库中的数据为准。</p><p>这个小工具的风险依旧很小：<br>（1）整个过程依然是旧库对线上提供服务；<br>（2）小工具的复杂度较低；<br>（3）任何时间发现问题，大不了从步骤二开始重来；<br>（4）可以限速慢慢比对数据，技术同学没有时间压力；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582701584204.webp" alt="img"></p><p><strong>步骤四</strong>：数据完全一致之后，将<strong>流量切到新库</strong>，完成平滑数据迁移。</p><p>至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>针对互联网很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，在：<br>（1）底层表结构变更；<br>（2）分库个数变化；<br>（3）底层存储介质变化；</p><p>的众多需求下，需要进行数据迁移，完成<strong>“平滑迁移数据，迁移过程不停机，保证系统持续服务”</strong>有两种常见的解决方案。</p><p><strong>追日志方案</strong>，五个步骤：<br>（1）<strong>服务进行升级</strong>，<code>记录</code>“对旧库上的数据修改”的<code>日志</code>；<br>（2）研发一个数据迁移<strong>小工具</strong>，进行<code>数据迁移</code>；<br>（3）研发一个读取日志<strong>小工具</strong>，<code>追平数据差异</code>；<br>（4）研发一个数据比对<strong>小工具</strong>，<code>校验数据</code>一致性；<br>（5）<code>流量切到新库</code>，完成平滑迁移；</p><p><strong>双写方案</strong>，四个步骤：<br>（1）<strong>服务进行升级</strong>，记录“对旧库上的数据修改”进行新库的<code>双写</code>；<br>（2）研发一个数据迁移<strong>小工具</strong>，进行<code>数据迁移</code>；<br>（3）研发一个数据比对<strong>小工具</strong>，<code>校验数据</code>一致性；<br>（4）<code>流量切到新库</code>，完成平滑迁移；</p><p><strong>思路</strong>比结论重要。</p><h2 id="1万属性，100亿数据，每秒10万吞吐，架构如何设计？"><a href="#1万属性，100亿数据，每秒10万吞吐，架构如何设计？" class="headerlink" title="1万属性，100亿数据，每秒10万吞吐，架构如何设计？"></a>1万属性，100亿数据，每秒10万吞吐，架构如何设计？</h2><p>也可能，是要对字段进行扩展：《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962219&amp;idx=1&amp;sn=30545c7a9f46fa74a61cc09323a6a8c9&amp;chksm=bd2d0eb78a5a87a1c16b1d10fbb688adb2848345b70fa2fbc161b3a566c7c3e02adaccd5981e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">1万属性，100亿数据，架构设计？</a>》，如下：</p><p>有一类业务场景，没有固定的schema存储，却有着海量的数据行数，架构上如何来实现这类业务的存储与检索呢？58最核心的数据“帖子”的架构实现技术细节，今天和大家聊一聊。</p><h3 id="背景描述及业务介绍"><a href="#背景描述及业务介绍" class="headerlink" title="背景描述及业务介绍"></a>背景描述及业务介绍</h3><p><strong>什么是58最核心的数据？</strong></p><p>58是一个信息平台，有很多垂直品类：招聘、房产、二手物品、二手车、黄页等等，每个品类又有很多子品类，不管哪个品类，最核心的数据都是“帖子信息”。</p><p><em>画外音：像不像一个大论坛？</em></p><p><strong>各分类帖子的信息有什么特点？</strong></p><p>逛过58的朋友很容易了解到，这里的帖子信息：<br>（1）<strong>各品类的属性千差万别</strong>，招聘帖子和二手帖子属性完全不同，二手手机和二手家电的属性又完全不同，目前恐怕有<code>近万个属性</code>；<br>（2）<strong>数据量巨大</strong>，<code>100亿</code>级别；<br>（3）<strong>每个属性上都有查询需求</strong>，各组合属性上都可能有组合查询需求，招聘要查职位/经验/薪酬范围，二手手机要查颜色/价格/型号，二手要查冰箱/洗衣机/空调；<br>（4）<strong>吞吐量很大</strong>，<code>每秒几十万吞吐</code>；</p><p>如何解决100亿数据量，1万属性，多属性组合查询，10万并发查询的技术难题呢？一步步来。</p><h3 id="最容易想到的方案"><a href="#最容易想到的方案" class="headerlink" title="最容易想到的方案"></a>最容易想到的方案</h3><p>每个公司的发展都是一个从小到大的过程，撇开并发量和数据量不谈，先看看<br>（1）如何实现属性扩展性需求；<br>（2）多属性组合查询需求；<br><em>画外音：公司初期并发量和数据量都不大，必须先解决业务问题。</em></p><p><strong>如何满足业务的存储需求呢？</strong></p><p>最开始，业务只有一个招聘品类，那帖子表可能是这么设计的：<br>tiezi(tid, uid, c1, c2, c3);</p><p><strong>那如何满足各属性之间的组合查询需求呢？</strong></p><p>最容易想到的是通过组合索引满足查询需求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index_1(c1, c2)</span><br><span class="line">index_2(c2, c3)</span><br><span class="line">index_3(c1, c3)</span><br></pre></td></tr></table></figure></p><p><strong>随着业务的发展，又新增了一个房产类别，存储问题又该如何解决呢？</strong></p><p>可以新增若干属性满足存储需求，于是帖子表变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tiezi(tid, uid, c1, c2, c3, c10, c11, c12, c13);</span><br></pre></td></tr></table></figure></p><p>其中：</p><ul><li>c1,c2,c3是招聘类别属性</li><li>c10,c11,c12,c13是房产类别属性</li></ul><p>通过扩展属性，可以解决存储的问题。</p><p><strong>查询需求，又该如何满足呢？</strong></p><p>首先，跨业务属性一般没有组合查询需求。只能建立了若干组合索引，满足房产类别的查询需求。</p><p><em>画外音：不敢想有多少个索引能覆盖所有两属性查询，三属性查询。</em></p><p><strong>当业务越来越多时，是不是发现玩不下去了？</strong></p><h3 id="垂直拆分是一个思路"><a href="#垂直拆分是一个思路" class="headerlink" title="垂直拆分是一个思路"></a>垂直拆分是一个思路</h3><p>新增属性是一种扩展方式，新增表也是一种方式，垂直拆分也是常见的存储扩展方案。</p><p><strong>如何按照业务进行垂直拆分？</strong></p><p>可以这么玩：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tiezi_zhaopin(tid, uid, c1, c2, c3);</span><br><span class="line"></span><br><span class="line">tiezi_fangchan(tid, uid, c10, c11, c12, c13);</span><br></pre></td></tr></table></figure></p><p><strong>在业务各异，数据量和吞吐量都巨大的情况下，垂直拆分会遇到什么问题呢？</strong></p><p>这些表，以及对应的服务维护在不同的部门，看上去各业务灵活性强，研发闭环，这恰恰是悲剧的开始：<br>（1）tid如何规范？<br>（2）属性如何规范？<br>（3）按照uid来查询怎么办（查询自己发布的所有帖子）？<br>（4）按照时间来查询怎么办（最新发布的帖子）？<br>（5）跨品类查询怎么办（例如首页搜索框）？<br>（6）技术范围的扩散，有的用mongo存储，有的用mysql存储，有的自研存储；<br>（7）重复开发了不少组件；<br>（8）维护成本过高；<br>（9）…</p><p><em>画外音：想想看，电商的商品表，不可能一个类目一个表的。</em></p><h3 id="58的玩法：三大中心服务"><a href="#58的玩法：三大中心服务" class="headerlink" title="58的玩法：三大中心服务"></a>58的玩法：三大中心服务</h3><h4 id="第一：统一帖子中心服务"><a href="#第一：统一帖子中心服务" class="headerlink" title="第一：统一帖子中心服务"></a>第一：统一帖子中心服务</h4><p><code>平台型</code>创业型公司，可能有多个品类，各品类有很多异构数据的存储需求，到底是分还是合，无需纠结：<strong>基础数据基础服务的统一</strong>，是一个很好的实践。</p><p><em>画外音：这里说的是平台型业务。</em></p><p><strong>如何将不同品类，异构的数据统一存储起来呢？</strong></p><p>（1）全品类通用属性统一存储；<br>（2）单品类特有属性，品类类型与通用属性json来进行存储；</p><p>更具体的：</p><p>tiezi(tid, uid, time, title, cate, subcate, xxid, ext);</p><p>（1）一些通用的字段抽取出来单独存储；<br>（2）通过cate, subcate, xxid等来定义ext是何种含义；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582704023957.webp" alt="img"></p><p>（3）通过ext来存储不同业务线的个性化需求</p><p>例如：</p><p>招聘的帖子，ext为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“job”:”driver”,”salary”:8000,”location”:”bj”&#125;</span><br></pre></td></tr></table></figure></p><p>而二手的帖子，ext为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;”type”:”iphone”,”money”:3500&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382769.png" alt="img"></p><p>帖子数据，100亿的数据量，分256库，通过ext存储异构业务数据，使用mysql存储，上层架了一个帖子中心服务，使用memcache做缓存，就是这样一个并不复杂的架构，解决了业务的大问题。这是58最核心的帖子中心服务IMC（Info Management Center）。</p><p><em>画外音：该服务的底层存储在16年全面切换为了自研存储引擎，替换了mysql，但架构理念仍未变。</em></p><p>解决了海量异构数据的存储问题，遇到的<strong>新问题</strong>是：</p><p>（1）每条记录ext内key都需要重复存储，占据了大量的空间，能否压缩存储；<br>（2）cateid已经不足以描述ext内的内容，品类有层级，深度不确定，ext能否具备自描述性；<br>（3）随时可以增加属性，保证扩展性；</p><p>解决完海量异构数据的存储问题，接下来，要解决的是类目的扩展性问题。</p><h4 id="第二：统一类目属性服务"><a href="#第二：统一类目属性服务" class="headerlink" title="第二：统一类目属性服务"></a>第二：统一类目属性服务</h4><p><strong>每个业务有多少属性，这些属性是什么含义，值的约束等，**</strong>耦合到帖子服务里<strong>**显然是不合理的，那怎么办呢？</strong></p><p>抽象出一个统一的类目、属性服务，单独来管理这些信息，而帖子库ext字段里json的key，统一由数字来表示，减少存储空间。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382664.webp" alt="img"></p><p><em>画外音：帖子表只存元信息，不管业务含义。</em></p><p>如上图所示，json里的key不再是”salary” ”location” ”money” 这样的长字符串了，取而代之的是数字1,2,3,4，这些数字是什么含义，属于哪个子分类，值的校验约束，统一都存储在类目、属性服务里。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382674.webp" alt="img"></p><p><em>画外音：类目表存业务信息，以及约束信息，与帖子表解耦。</em></p><p>这个表里对帖子中心服务里ext字段里的数字key进行了解释：<br>（1）1代表job，属于招聘品类下100子品类，其value必须是一个小于32的[a-z]字符；<br>（2）4代表type，属于二手品类下200子品类，其value必须是一个short；</p><p>这样就对原来帖子表ext扩展属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;“1”:”driver”,”2”:8000,”3”:”bj”&#125;</span><br><span class="line"></span><br><span class="line">&#123;”4”:”iphone”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p><code>key和value都做了统一约束。</code></p><p>除此之外，如果ext里某个key的value不是正则校验的值，而是枚举值时，需要有一个对值进行限定的枚举表来进行校验：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382708.webp" alt="img"></p><p>这个枚举校验，说明key=4的属性（对应属性表里二手，手机类型字段），其值不只是要进行“short类型”校验，而是value必须是固定的枚举值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;”4”:”iphone”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>这个ext就是不合法的，key=4的value=iphone不合法，而应该是枚举属性，合法的应该为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;”4”:”5”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>此外，<em>类目属性服务还能记录类目之间的层级关系</em>：<br>（1）一级类目是招聘、房产、二手…<br>（2）二手下有二级类目二手家具、二手手机…<br>（3）二手手机下有三级类目二手iphone，二手小米，二手三星…<br>（4）…</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582704209305.webp" alt="img"></p><p>类目服务<code>解释了帖子数据，描述品类层级关系，保证各类目属性扩展性，保证各属性值合理性校验</code>，就是58另一个统一的核心服务CMC（Category Management Center）。</p><blockquote><p><em>画外音：类目、属性服务像不像电商系统里的SKU扩展服务？</em><br><em>（1）品类层级关系，对应电商里的类别层级体系；</em><br><em>（2）属性扩展，对应电商里各类别商品SKU的属性；</em><br><em>（3）枚举值校验，对应属性的枚举值，例如颜色：红，黄，蓝；</em></p></blockquote><p>通过品类服务，解决了key压缩，key描述，key扩展，value校验，品类层级的问题，还有这样的一个问题没有解决：每个品类下帖子的属性各不相同，查询需求各不相同，<strong>如何解决100亿数据量，1万属性的检索与联合检索需求呢？</strong></p><h4 id="第三：统一检索服务"><a href="#第三：统一检索服务" class="headerlink" title="第三：统一检索服务"></a>第三：统一检索服务</h4><p>数据量很大的时候，不同属性上的查询需求，不可能通过组合索引来满足所有查询需求，“外置索引，统一检索服务”是一个很常用的实践：</p><p>（1）数据库提供“帖子id”的正排查询需求；<br>（2）所有非“帖子id”的个性化检索需求，统一走外置索引；</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382712.webp" alt="img"></p><p>元数据与索引数据的操作遵循：<br>（1）对帖子进行tid正排查询，直接访问帖子服务；<br>（2）对帖子进行修改，帖子服务通知检索服务，同时对索引进行修改；<br>（3）对帖子进行复杂查询，通过检索服务满足需求；</p><blockquote><p><em>画外音：这个检索服务，扛起了58同城80%的请求（不管来自PC还是APP，不管是主页、城市页、分类页、列表页、详情页，最终都会转化为一个检索请求），它就是58另一个统一的核心服务E-search，这个搜索引擎，是完全自研的。</em></p></blockquote><p>对于这个内核自研服务的搜索引擎架构，简单说明一下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382739.webp" alt="img"></p><p>为应对100亿级别数据量、几十万级别的吞吐量，业务线各种复杂的复杂检索查询，<code>扩展性是设计重点</code>：<br>（1）统一的<strong>代理层</strong>，作为入口，其无状态性能够保证增加机器就能扩充系统性能；<br>（2）统一的<strong>结果聚合层</strong>，其无状态性也能够保证增加机器就能扩充系统性能；<br>（3）搜索内核<strong>检索层</strong>，服务和索引数据部署在同一台机器上，服务启动时可以加载索引数据到内存，请求访问时从内存中load数据，访问速度很快：</p><ul><li>为了满足<code>数据容量的扩展性</code>，索引数据进行了水平切分，增加切分份数，就能够无限扩展性能</li><li>为了满足一份<code>数据的性能扩展性</code>，同一份数据进行了冗余，理论上做到增加机器就无限扩展性能</li></ul><p>系统时延，100亿级别帖子检索，包含请求分合，拉链求交集，从聚合层均可以做到10ms返回。</p><p><em>画外音：入口层是Java研发的，聚合层与检索层都是C语言研发的。</em></p><p>帖子业务，一致性不是主要矛盾，E-search会定期全量重建索引，以保证即使数据不一致，也不会持续很长的时间。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582703382663.webp" alt="img"></p><p>文章写了很长，最后做一个简单总结，面对100亿数据量，1万列属性，10万吞吐量的业务需求，可以采用了<strong>元数据服务、属性服务、搜索服务来</strong>解决：</p><ul><li>一个解决存储问题</li><li>一个解决品类解耦问题</li><li>一个解决检索问题</li></ul><p>任何复杂问题的解决，都是<code>循序渐进</code>的。</p><p><strong>思路</strong>比结论重要，希望大家有收获。</p><h2 id="100亿数据1万属性数据架构设计"><a href="#100亿数据1万属性数据架构设计" class="headerlink" title="100亿数据1万属性数据架构设计"></a>100亿数据1万属性数据架构设计</h2><p>《<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959855&amp;idx=1&amp;sn=f33abe8ec598c273f29cebb9365ece59&amp;chksm=bd2d07f38a5a8ee58a944507a134e1da1efc3ac9c4d1c4cff261137cd986e51f5fe7cee9de15&amp;scene=25#wechat_redirect" target="_blank" rel="noopener">100亿数据1万属性数据架构设计</a>》</p><p>对于version + ext方案，还是有很多朋友质疑“线上不可能这么用”。本篇将讲述一下58同城最核心的数据“帖子”的架构实现技术细节，说明不仅不是“不可能这么用”，而是大数据，可变属性，高吞吐场景下的“常用手段”。</p><h3 id="背景描述及业务介绍-1"><a href="#背景描述及业务介绍-1" class="headerlink" title="背景描述及业务介绍"></a>背景描述及业务介绍</h3><p><strong>问：什么是数据库扩展的version + ext方案？</strong></p><p>使用ext来承载不同业务需求的个性化属性，使用version来标识ext里各个字段的含义。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010881.webp" alt="img"></p><p>例如上述user表：<br>verion=0表示ext里是passwd/nick<br>version=1表示ext里是passwd/nick/age/sex</p><p><strong>优点？</strong></p><p>（1）可以随时动态扩展属性，扩展性好<br>（2）新旧两种数据可以同时存在，兼容性好</p><p><strong>不足？</strong></p><p>（1）ext里的字段无法建立索引<br>（2）ext里的key值有大量冗余，建议key短一些</p><p><strong><em>问：</em>什么是58同城最核心的数据？</strong></p><p>58同城是一个信息平台，有很多垂直品类：招聘、房产、二手物品、二手车、黄页等等，每个品类又有很多子品类，不管哪个品类，最核心的数据都是“帖子信息”（业务像一个大论坛？）。</p><p><strong><em>问：</em>帖子信息有什么特点？</strong><br>大家去58同城的首页上看看就知道了：</p><p>（1）<code>每个品类的属性千差万别</code>，招聘帖子和二手帖子属性完全不同，二手手机和二手家电的属性又完全不同，目前恐怕有近万个属性<br>（2）<code>帖子量很大，100亿级别</code><br>（3）<code>每个属性上都有查询需求</code>（各组合属性上都可能有组合查询需求），招聘要查职位/经验/薪酬范围，二手手机要查颜色/价格/型号，二手要查冰箱/洗衣机/空调<br>（4）<code>查询量很大，每秒几十万级别</code></p><p>如何解决<strong>100亿数据量，1万属性，多属性组合查询，10万并发查询</strong>的技术难题，是今天要讨论的内容。</p><h3 id="最容易想到的方案-1"><a href="#最容易想到的方案-1" class="headerlink" title="最容易想到的方案"></a>最容易想到的方案</h3><p>每个公司的发展都是一个从小到大的过程，撇开并发量和数据量不谈，先看看</p><p>（1）如何实现属性扩展性需求<br>（2）多属性组合查询需求</p><p>最开始，可能只有一个<strong>招聘品类</strong>，那帖子表可能是这么设计的：</p><p>tiezi(tid,uid, c1, c2, c3)</p><p>那如何满足各属性之间的组合查询需求呢？</p><p>最容易想到的是通过组合索引：</p><p>index_1(c1,c2) index_2(c2, c3) index_3(c1, c3)</p><p>随着业务的发展，又新增了一个<strong>房产类别</strong>，新增了若干属性，新增了若干组合查询，于是帖子表变成了：</p><p>tiezi(tid,uid, c1, c2, c3, c10, c11, c12, c13)</p><p>其中c1,c2,c3是招聘类别属性，c10,c11,c12,c13是房产类别属性，这两块属性一般没有组合查询需求</p><p>但为了满足房产类别的查询需求，又要建立了若干组合索引（不敢想有多少个索引能覆盖所有两属性查询，三属性查询）</p><p>是不是发现玩不下去了？</p><h3 id="友商的玩法"><a href="#友商的玩法" class="headerlink" title="友商的玩法"></a>友商的玩法</h3><p>新增属性是一种扩展方式，新增表也是一种方式，有友商是这么玩的，按照业务进行垂直拆分：</p><blockquote><p>tiezi_zhaopin(tid,uid, c1, c2, c3)<br>tiezi_fangchan(tid,uid, c10, c11, c12, c13)</p></blockquote><p>这些表，这些服务维护在不同的部门，不同的研发同学手里，看上去各业务线灵活性强，这恰恰是悲剧的开始：</p><p>（1）tid如何规范？<br>（2）属性如何规范？<br>（3）按照uid来查询怎么办（查询自己发布的所有帖子）？<br>（4）按照时间来查询怎么办（最新发布的帖子）？<br>（5）跨品类查询怎么办（例如首页搜索框）？<br>（6）技术范围的扩散，有的用mongo存储，有的用mysql存储，有的自研存储<br>（7）重复开发了不少组件<br>（8）维护成本过高<br>（9）…</p><p>想想看，电商的商品表，不可能一个类目一个表的。</p><h3 id="58同城的玩法"><a href="#58同城的玩法" class="headerlink" title="58同城的玩法"></a>58同城的玩法</h3><h4 id="【统一帖子中心服务】"><a href="#【统一帖子中心服务】" class="headerlink" title="【统一帖子中心服务】"></a>【统一帖子中心服务】</h4><p>平台型创业型公司，可能有多个品类，例如58同城的招聘房产二手，很多异构数据的存储需求，到底是分还是合，无需纠结：<strong>基础数据基础服务的统一</strong>，无疑是58同城技术路线发展roadmap上最正确的决策之一，把这个方针坚持下来，@老崔 @晓飞 这些高瞻远瞩的先贤功不可没，业务线会有“扩展性”“灵活性”上的微词，后文看看先贤们如何通过一些巧妙的技术方案来解决的。</p><p>如何将不同品类，异构的数据统一存储起来，采用的就是类似<code>version+ext</code>的方式：</p><p>tiezi(tid,uid, time, title, cate, subcate, xxid, ext)</p><p>（1）<code>一些通用的字段抽取出来单独存储</code><br>（2）<code>通过cate, subcate, xxid等来定义ext是何种含义</code>（和version有点像？）</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010848.webp" alt="img"></p><p>（3）通过ext来存储不同业务线的个性化需求</p><p>例如招聘的帖子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;“job”:”driver”,”salary”:8000,”location”:”bj”&#125;</span><br></pre></td></tr></table></figure></p><p>而二手的帖子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;”type”:”iphone”,”money”:3500&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010843.png" alt="img"></p><p>58同城最核心的帖子数据，100亿的数据量，分256库，异构数据mysql存储，上层架了一个服务，使用memcache做缓存，就是这样一个简单的架构，一直坚持这这么多年。上层的这个服务，就是<strong>58同城最核心的统一服务IMC（Imformation Management Center）</strong>，注意这个最核心，是没有之一。</p><p>解决了海量异构数据的存储问题，遇到的<strong>新问题</strong>是：</p><p>（1）每条记录ext内key都需要重复存储，占据了大量的空间，能否压缩存储<br>（2）cateid已经不足以描述ext内的内容，品类有层级，深度不确定，ext能否具备自描述性<br>（3）随时可以增加属性，保证扩展性</p><h4 id="【统一类目属性服务】"><a href="#【统一类目属性服务】" class="headerlink" title="【统一类目属性服务】"></a>【统一类目属性服务】</h4><p>每个业务有多少属性，这些属性是什么含义，值的约束等揉不到帖子服务里，怎么办呢？</p><p>58同城的先贤们抽象出一个统一的类目、属性服务，单独来管理这些信息，而帖子库ext字段里json的key，统一由数字来表示，减少存储空间。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010912.webp" alt="img"></p><p>如上图所示，json里的key不再是”salary” ”location” ”money” 这样的长字符串了，取而代之的是数字1,2,3,4，这些数字是什么含义，属于哪个子分类，值的校验约束，统一都存储在类目、属性服务里。</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010931.webp" alt="img"></p><p>这个表里对帖子中心服务里ext字段里的数字key进行了解释：</p><p>1代表job，属于招聘品类下100子品类，其value必须是一个小于32的[a-z]字符</p><p>4代表type，属于二手品类下200子品类，其value必须是一个short</p><p>这样就对原来帖子表ext里的<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;“1”:”driver”,”2”:8000,”3”:”bj”&#125;</span><br><span class="line"></span><br><span class="line">ext : &#123;”4”:”iphone”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>key和value都做了统一约束。</p><p>除此之外，如果ext里某个key的value不是正则校验的值，而是枚举值时，需要有一个对值进行限定的枚举表来进行校验：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010936.webp" alt="img"></p><p>这个枚举校验，说明key=4的属性（对应属性表里二手，手机类型字段），其值不只是要进行“short类型”校验，而是value必须是固定的枚举值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ext : &#123;”4”:”iphone”,”5”:3500&#125; 这个ext就是不合法的（key=4的value=iphone不合法），合法的应该为</span><br><span class="line"></span><br><span class="line">ext : &#123;”4”:”5”,”5”:3500&#125;</span><br></pre></td></tr></table></figure></p><p>此外，类目属性服务还能记录类目之间的层级关系：</p><p>（1）一级类目是招聘、房产、二手…<br>（2）二手下有二级类目二手家具、二手手机…<br>（3）二手手机下有三级类目二手iphone，二手小米，二手三星…<br>（4）…</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010961.webp" alt="img"></p><p>协助解释58同城最核心的帖子数据，描述品类层级关系，保证各类目属性扩展性，保证各属性值合理性校验，就是<strong>58同城另一个统一的核心服务CMC（Category Management Center）</strong>。</p><p>多提一句，类目、属性服务像不像电商系统里的SKU扩展服务？</p><p>（1）品类层级关系，对应电商里的类别层级体系<br>（2）属性扩展，对应电商里各类别商品SKU的属性<br>（3）枚举值校验，对应属性的枚举值，例如颜色：红，黄，蓝</p><p>解决了key压缩，key描述，key扩展，value校验，品类层级的问题，<strong>还有这样的一个问题</strong>没有解决：每个品类下帖子的属性各不相同，查询需求各不相同，如何解决100亿数据量，1万属性的查询需求，是58同城面临的新问题。</p><p>####【统一检索服务】</p><p>数据量很大的时候，不同属性上的查询需求，不可能通过组合索引来满足所有查询需求，怎么办呢？</p><p>58同城的先贤们，从一早就确定了“外置索引，统一检索服务”的技术路线：</p><p>（1）数据库提供“帖子id”的正排查询需求<br>（2）所有非“帖子id”的个性化检索需求，统一走外置索引</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010966.webp" alt="img"></p><p>元数据与索引数据的操作遵循：</p><p>（1）对帖子进行tid正排查询，直接访问帖子服务<br>（2）对帖子进行修改，帖子服务通知检索服务，同时对索引进行修改<br>（3）对帖子进行复杂查询，通过检索服务满足需求</p><p>这个扛起58同城80%终端请求（不管来自PC还是APP，不管是主页、城市页、分类页、列表页、详情页，很可能这个请求最终会是一个检索请求）的服务，就是<strong>58同城另一个统一的核心服务E-search</strong>，这个搜索引擎的每一行代码都来自58同城@老崔 @老龚 等先贤们，目前系统维护者，就是“架构师之路”里屡次提到的@龙神 。</p><p>对于这个服务的架构，简单展开说明一下：</p><p><img src="/2020/02/26/数据库软件架构设计/640-1582709010962.webp" alt="img"></p><p>为应对100亿级别数据量、几十万级别的吞吐量，业务线各种复杂的复杂检索查询，扩展性是设计重点：</p><p>（1）<strong>统一的Java代理层集群</strong>，其无状态性能够保证增加机器就能扩充系统性能<br>（2）<strong>统一的合并层C服务集群</strong>，其无状态性也能够保证增加机器就能扩充系统性能<br>（3）<strong>搜索内核检索层C服务集群</strong>，服务和索引数据部署在同一台机器上，服务启动时可以加载索引数据到内存，请求访问时从内存中load数据，访问速度很快<br>（3.1）为了满足数据容量的扩展性，索引数据进行了水平切分，增加切分份数，就能够无限扩展性能<br>（3.2）为了满足一份数据的性能扩展性，同一份数据进行了冗余，理论上做到增加机器就无限扩展性能</p><p>系统时延，100亿级别帖子检索，包含请求分合，拉链求交集，从merger层均可以做到10ms返回。</p><p>58同城的帖子业务，一致性不是主要矛盾，E-search会定期全量重建索引，以保证即使数据不一致，也不会持续很长的时间。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/02/26/数据库软件架构设计/640-1582709011000.webp" alt="img"></p><p>文章写了很长，最后做一个简单总结，面对<strong>100亿数据量，1万列属性，10万吞吐量的业务需求</strong>，58同城的经验，是采用了<code>元数据服务、属性服务、搜索服务</code>来解决的。</p><h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><p>数据库软件架构，到底要设计些什么？</p><ul><li>可用性</li><li>读性能</li><li>一致性</li><li>扩展性</li></ul><blockquote><p>转载自<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651962610&amp;idx=1&amp;sn=e5ddf9d321139b143186f2ee596c1f06&amp;chksm=bd2d092e8a5a8038ac72b243f7114d41a754dddfff4177eeb9d897443a3ec01922bbc4ae02cd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">数据库软件架构，到底要设计些什么？</a>，在原文基础上有修改</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;概念一：单库&quot;&gt;&lt;a href=&quot;#概念一：单库&quot; class=&quot;headerlink&quot; title=&quot;概念一：单库&quot;&gt;&lt;/a&gt;概念一：单库&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/26/数据库软件架构设计/640-1582688299341.webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念二：分片&quot;&gt;&lt;a href=&quot;#概念二：分片&quot; class=&quot;headerlink&quot; title=&quot;概念二：分片&quot;&gt;&lt;/a&gt;概念二：分片&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020/02/26/数据库软件架构设计/640-1582688306996.webp&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;分片解决“数据量太大”这一问题，也就是通常说的“水平切分”。&lt;/p&gt;
&lt;p&gt;一旦引入分片，势必面临“数据路由”的新问题，数据到底要访问哪个库。路由规则通常有3种方法：&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://vincentruan.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="架构设计" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】多次尝试学习，终于搞懂了微服务架构</title>
    <link href="https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E5%A4%9A%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%BB%88%E4%BA%8E%E6%90%9E%E6%87%82%E4%BA%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E5%A4%9A%E6%AC%A1%E5%B0%9D%E8%AF%95%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%BB%88%E4%BA%8E%E6%90%9E%E6%87%82%E4%BA%86%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2020-02-25T07:40:45.000Z</published>
    <updated>2020-02-25T15:09:15.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务?"></a>什么是微服务?</h1><p>微服务 Microservices 之父，马丁.福勒，对微服务大概的概述如下：</p><blockquote><p>就目前而言，对于微服务业界并没有一个统一的、标准的定义(While there is no precise definition of this architectural style ) 。</p></blockquote><blockquote><p>但通常在其而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。</p></blockquote><blockquote><p>服务之间采用轻量级的通信机制互相沟通(通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。</p></blockquote><blockquote><p>另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p></blockquote><a id="more"></a><p>根据马丁.福勒的描述，我总结了以下几点：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/e242f34d8c87c66437d98b728f4a171d.jpg" alt="img"></p><h2 id="小服务"><a href="#小服务" class="headerlink" title="小服务"></a>小服务</h2><p>小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。</p><h2 id="进程独立"><a href="#进程独立" class="headerlink" title="进程独立"></a>进程独立</h2><p>每一组服务都是独立运行的，可能我这个服务运行在 Tomcat 容器，而另一个服务运行在 Jetty 上。可以通过进程方式，不断的横向扩展整个服务。</p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>过去的协议都是很重的，就像 ESB，就像 SOAP，轻通信，这意味着相比过去更智能更轻量的服务相互调用，就所谓 smart endpoints and dumb pipes。</p><p>这些 Endpoint 都是解耦的，完成一个业务通信调用串起这些 Micro Service 就像是 Linux 系统中通过管道串起一系列命令业务。</p><p>过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维职责。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>传统的企业级 SOA 服务往往很大，不易于管理，耦合性高，团队开发成本比较大。</p><p>微服务，可以让团队各思其政的选择技术实现，不同的 Service 可以根据各自的需要选择不同的技术栈来实现其业务逻辑。</p><h1 id="微服务的利与弊"><a href="#微服务的利与弊" class="headerlink" title="微服务的利与弊"></a>微服务的利与弊</h1><p>为什么用微服务呢?因为好玩?不是的。下面是我从网络上找到说的比较全的优点：</p><ul><li>优点是每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求。</li><li>开发简单、开发效率提高，一个服务可能就是专一的只干一件事。</li><li>微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。</li><li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。</li><li>微服务能使用不同的语言开发。</li><li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如 Jenkins，Hudson，bamboo。</li><li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。微服务允许你利用融合最新技术。</li><li>微服务只是业务逻辑的代码，不会和 HTML，CSS 或其他界面组件混合。</li><li>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库。</li></ul><p>总的来说，微服务的优势，就是在于，面对大的系统，可以有效的减少复杂程度，使服务架构的逻辑更清晰明了。</p><p>但是这样也会带来很多问题，就譬如分布式环境下的数据一致性，测试的复杂性，运维的复杂性。</p><h1 id="什么组织适合使用微服务"><a href="#什么组织适合使用微服务" class="headerlink" title="什么组织适合使用微服务?"></a>什么组织适合使用微服务?</h1><p>微服务带了种种优点，种种弊端，那么什么组织适合使用微服务?</p><h2 id="墨菲定律-设计系统-和康威定律-系统划分"><a href="#墨菲定律-设计系统-和康威定律-系统划分" class="headerlink" title="墨菲定律(设计系统)和康威定律(系统划分)"></a>墨菲定律(设计系统)和康威定律(系统划分)</h2><p>康威定律，是一个五十多年前就被提出来的微服务概念。在康威的这篇文章中，最有名的一句话就是：</p><blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</p><p>-Melvin Conway(1967)</p></blockquote><p>中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。</p><p>看看下面的图片，再想想 Apple 的产品、微软的产品设计，就能形象生动的理解这句话。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/da1466451bb6c8b1c86be88beeeb20ec.jpg" alt="img"><br>感兴趣的各位可以研究一下!</p><h2 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a>架构演化</h2><p>架构是不断演化出来的，微服务也是这样，当从各大科技公司，规模大到一定程度，完全需要演化成更进一步管理的技术架构体系。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/27b5dcef62fffede437262192a8d5049.jpg" alt="img"></p><p>传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。</p><p>我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/8e89430be81287e37febfb9daaa7c266.jpg-wh_600x-s_3329617205.jpg" alt="img"></p><p>使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用 API 方式发布他们的功能，而平台使用他们的功能发布产品。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/2f8f923667a1cf85e4ea0a36142dd463.jpg-wh_600x-s_3077522574.jpg" alt="img"></p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/3fd3fa788ba4f3ded5c42e9812112632.jpg-wh_600x-s_3676732613.jpg" alt="img"></p><h1 id="微服务技术架构体系"><a href="#微服务技术架构体系" class="headerlink" title="微服务技术架构体系"></a>微服务技术架构体系</h1><p>下面我分享一下大部分公司都使用的微服务技术架构体系：</p><p><a href="https://s4.51cto.com/oss/201911/20/bdce530e4c713c192e33aacf560cf36b.jpg" target="_blank" rel="noopener"><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/bdce530e4c713c192e33aacf560cf36b.jpg" alt="img"></a></p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>主流的服务发现，分为三种：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/a7482fcd1ab956afac3925367032d166.jpg-wh_600x-s_699873961.jpg" alt="img"></p><p>第一种，开发人员开发了程序以后，会找运维配一个域名，服务的话通过 DNS 就能找到我们对应的服务。</p><p>缺点是，由于服务没有负载均衡功能，对负载均衡服务，可能会有相当大的性能问题。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/648fcd0296d3e6e5ddb45a5d97bfc0b5.jpg-wh_600x-s_746651471.jpg" alt="img"></p><p>第二种，是目前普遍的做法。可以参考 Zuul 网关，每一个服务都通过服务端内置的功能注册到注册中心，服务消费者不断轮询注册中心发现对应的服务，使用内置负载均衡调用服务。</p><p>缺点是，对多语言环境不是很好，你需要单独给消费者的客户端开发服务发现和负载均衡功能。当然了，这个方法通常都是用在 Spring Cloud 上的。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/65e07e662e2d302a734e43ab65ccb9ca.jpg-wh_600x-s_947263207.jpg" alt="img"></p><p>第三种，是将客户端和负载均衡放在同一个主机，而不是同一个进程内。</p><p>这种方法相对第一种第二种方法来说，改善了他们的缺点，但是会极大增加运维成本。</p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>微服务的网关是什么?我们可以联系生活实际想一下。每一个大的公司，都会有一偏属于自己的建筑区，而这建筑区内，都有不少的门卫。如果有外来人员进入公司，会先和门卫打好招呼，才能进去。</p><p>将生活实际联系到微服务上，就不难理解网关的意思了：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/768eea8c5a33305f0fddc39f61153229.jpg-wh_600x-s_1831175765.jpg" alt="img"></p><p>网关的作用如下：</p><ul><li>反向路由：很多时候，公司不想让外部人员看到我们公司的内部，就需要网关来进行反向路由。即将外部请求转换成内部具体服务调用。</li><li>安全认证：网络中会有很多恶意访问，譬如爬虫，譬如黑客攻击，网关维护安全功能。</li><li>限流熔断：当请求很多服务不堪重负，会让我们的服务自动关闭，导致不能用服务。限流熔断可以有效的避免这类问题。</li><li>日志监控：所有的外面的请求都会经过网关，这样我们就可以使用网关来记录日志信息。</li><li>灰度发布，蓝绿部署。是指能够平滑过渡的一种发布方式。在其上可以进行 A/B testing。</li></ul><p>即让一部分用户继续用产品特性 A，一部分用户开始用产品特性 B，如果用户对 B 没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到 B 上面来。</p><p>开源网关 Zuul 架构：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/226237b2fb8ff757a643e67ec682df71.jpg" alt="img"></p><p>Zuul 网关核心其实是一个 Servlet，所有请求都会经过 Zuul Servlet 传到 ZuulFilter Runner，然后分发到三种过滤器。</p><p>先说说架构图左半部分，分别是使用 Groovy 实现的前置路由过滤器，路由过滤器，后置路由过滤器。</p><p>一般请求都会先经过前置路由过滤器处理，一般的自定义 Java 封装逻辑也会在这里实现。</p><p>路由过滤器，实现的是找到对应的微服务进行调用。调用完了，响应回来，会经过后置路由过滤器，通过后置路由过滤器我们可以封装日志审计的处理。</p><p>可以说 Zuul 网关最大的特色就是它的三层过滤器。架构图右半部分，是 Zuul 网关设计的自定义过滤器加载机制。</p><p>网关内部会有生产者消费者模型，自动的将过滤器脚本发布到 Zuul 网关读取加载运行。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>以前，开发人员把配置文件放在开发文件里面，这样会有很多隐患。譬如，配置规范不同，无法追溯配置人员。</p><p>一旦需要大规模改动配置，改动时间会很长，无法追溯配置人员，从而影响整个产品，后果是我们承担不起的。</p><p>因此就有配置中心这个喽!现在的开源中心有百度配置中心 Disconf，Spring Cloud Config，Apollo。</p><p>今天重点说说现在应用质量不错的配置中心，携程开源的阿波罗(Apollo)：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/cd598d47c727b134a2ca198e41c50462.jpg-wh_600x-s_1032512502.jpg" alt="img"></p><p>Apollo 的配置中心规模比较大，本地应用会有响应的配置中心客户端，可以定时同步配置中心里的配置。如果配置中心怠机，会使用缓存来进行配置。</p><h2 id="通讯方式"><a href="#通讯方式" class="headerlink" title="通讯方式"></a>通讯方式</h2><p>关于通讯方式，一般市面也就是两种远程调用方式，我整理了一个表格：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/b2119c2e7c9bce882b42c644c1fdeca8.jpg-wh_600x-s_1516237122.jpg" alt="img"></p><h2 id="监控预警"><a href="#监控预警" class="headerlink" title="监控预警"></a>监控预警</h2><p>监控预警对于微服务很重要，一个可靠的监控预警体系对微服务运行至关重要。</p><p>一般监控分为如下层次：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/002cbe53dc2f67ae16350acbcb8f7dd7.jpg" alt="img"></p><p>从基础设施到用户端，层层有监控，全方位，多角度，每一个层面都很重要。</p><p>总体来说，微服务可分为 5 个监控点：</p><ul><li>日志监控</li><li>Metrics 监控</li><li>健康检查</li><li>调用链检查</li><li>告警系统</li></ul><h3 id="监控架构"><a href="#监控架构" class="headerlink" title="监控架构"></a>监控架构</h3><p>下面的图是大部分公司的一种监控架构图。每一个服务都有一个 Agent，Agent 收集到关键信息，会传到一些 MQ 中，为了解耦。</p><p>同时将日志传入 ELK，将 Metrics 传入 InfluxDB 时间序列库。而像 Nagios，可以定期向 Agent 发起信息检查微服务。</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/9b8b3cb7cf0e2ac69578caefc5f1d9a3.jpg" alt="img"></p><h3 id="调用链监控-APM"><a href="#调用链监控-APM" class="headerlink" title="调用链监控 APM"></a>调用链监控 APM</h3><p>很多公司都有调用链监控，就譬如阿里有鹰眼监控，点评的 Cat，大部分调用链监控(没错，我指的 Zipkin)架构是这样的：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/286dfb2abc5d0b52436469a52e543232.jpg" alt="img"></p><p>当请求进入 Web 容器的时候，会经过创建 Tracer，连接 Spans(模拟潜在的分布式工作的延迟，该模块还包含在系统网络间传递跟踪上下文信息的工具包，如通过 HTTP Headers)。</p><p>Spans 有一个上下文，其中包含 Tracer 标识符，将其放在表示分布式操作的树的正确位置。</p><p>当我们把图中的各种 Span 放到后端的时候，我们的服务调用链会动态的生成调用链。</p><p>下面是一些市场上用的比较多的调用链监控对比：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/d8e4aaf560ea57e869d4aebd08f1fe8b.jpg-wh_600x-s_3497886967.jpg" alt="img"></p><h3 id="熔断、隔离、限流、降级"><a href="#熔断、隔离、限流、降级" class="headerlink" title="熔断、隔离、限流、降级"></a>熔断、隔离、限流、降级</h3><p>面对巨大的突发流量下，大型公司一般会采用一系列的熔断(系统自动将服务关闭防止让出现的问题最大化)、隔离(将服务和服务隔离，防止一个服务挂了其他服务不能访问)、限流(单位时间内之允许一定数量用户访问)、降级(当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些不重要或不紧急的服务或任务进行服务的延迟使用或暂停使用)措施。</p><p>下面介绍一下 Hystrix 的运行流程：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/5b7f9f765608935b6ab292657d7acaa6.jpg-wh_600x-s_499345865.jpg" alt="img"></p><p>每一个微服务调用时，都会使用 Hystrix 的 Command 方式(上图的左上角那个)，然后使用 Command 同步的，或者是响应式的，或者是异步的，判断电路是否熔断(顺着图从左往右看)，如果断路则走降级 Fallback。</p><p>如果这个线闭合着，但是线程资源没了，队列满了，则走限流措施(看图的第 5 步)。</p><p>如果走完了，执行成功了，则走 run() 方法，获取 Response，但是这个过程如果出错了，则继续走降级 Fallback。</p><p>同时，看图最上面有一个后缀是 Health 的，这是一个计算整个链路是否健康的组件，每一步操作都被它记录着。</p><h1 id="容器与服务编排引擎"><a href="#容器与服务编排引擎" class="headerlink" title="容器与服务编排引擎"></a>容器与服务编排引擎</h1><p>从物理机到虚拟机，从虚拟机到容器;从物理集群到 OpenStack，OpenStack 到 Kubernetes;科技不断的变化，我们的认知也没刷新。</p><p>我们从容器开始说起，它首先是一个相对独立的运行环境，在这一点有点类似于虚拟机，但是不像虚拟机那样彻底。</p><p>虚拟机会将虚拟硬件、内核(即操作系统)以及用户空间打包在新虚拟机当中，虚拟机能够利用“虚拟机管理程序”运行在物理设备之上。</p><p>虚拟机依赖于 Hypervisor，其通常被安装在“裸金属”系统硬件之上，这导致 Hypervisor 在某些方面被认为是一种操作系统。</p><p>一旦 Hypervisor 安装完成， 就可以从系统可用计算资源当中分配虚拟机实例了，每台虚拟机都能够获得唯一的操作系统和负载(应用程序)。</p><p>简言之，虚拟机先需要虚拟一个物理环境，然后构建一个完整的操作系统，再搭建一层 Runtime，然后供应用程序运行。</p><p>对于容器环境来说，不需要安装主机操作系统，直接将容器层(比如 LXC 或 Libcontainer)安装在主机操作系统(通常是 Linux 变种)之上。</p><p>在安装完容器层之后，就可以从系统可用计算资源当中分配容器实例了，并且企业应用可以被部署在容器当中。</p><p>但是，每个容器化应用都会共享相同的操作系统(单个主机操作系统)。容器可以看成一个装好了一组特定应用的虚拟机，它直接利用了宿主机的内核，抽象层比虚拟机更少，更加轻量化，启动速度极快。</p><p>相比于虚拟机，容器拥有更高的资源使用效率，因为它并不需要为每个应用分配单独的操作系统——实例规模更小、创建和迁移速度也更快。这意味着相比于虚拟机，单个操作系统能够承载更多的容器。</p><p>云提供商十分热衷于容器技术，因为在相同的硬件设备当中，可以部署数量更多的容器实例。</p><p>此外，容器易于迁移，但是只能被迁移到具有兼容操作系统内核的其他服务器当中，这样就会给迁移选择带来限制。</p><p>因为容器不像虚拟机那样同样对内核或者虚拟硬件进行打包，所以每套容器都拥有自己的隔离化用户空间，从而使得多套容器能够运行在同一主机系统之上。</p><p>我们可以看到全部操作系统层级的架构都可实现跨容器共享，惟一需要独立构建的就是二进制文件与库。</p><p>正因为如此，容器才拥有极为出色的轻量化特性。我们最常用的容器是 Docker。</p><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>过去虚拟机可以通过云平台 OpenStack 管理虚拟化，容器时代如何管理容器呢?这就要看看容器编排引擎了。</p><p>Apache Mesos：Mesos 是基于 Master，Slave 架构，框架决定如何利用资源，Master 负责管理机器，Slave 会定期的将机器情况报告给 Master，Master 再将信息给框架。Master 是高可用的，因为 ZK，也有 Leader 的存在。</p><p>下面是架构图：</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/f42d01026d05b86c3218871af63ac4a8.jpg" alt="img"></p><p>Kubernetes：Kubernetes 是最近十分火热的开源容器编排引擎，具体可以参考前几天分享的一篇文章《我花了10个小时，写出了这篇K8S架构解析》</p><p><img src="/2020/02/25/【转载】多次尝试学习，终于搞懂了微服务架构/3e364b0e4be082fb50b51b793db18863.jpg-wh_600x-s_3201520885.jpg" alt="img"></p><p>Kubernetes 设计理念和功能其实就是一个类似 Linux 的分层架构，先说说每一个 Kubernetes 节点内部，kubelet 管理全局全局 pod，而每一个 pod 承载着一个或多个容器，kube-proxy 负责网络代理和负载均衡。</p><p>Kubernetes 节点外部，则是对应的控制管理服务器，负责统一管理各个节点调度分配与运行。</p><h2 id="服务网格化"><a href="#服务网格化" class="headerlink" title="服务网格化"></a>服务网格化</h2><p>关于服务网络化，后面会更加深入的为大家进行讲解。</p><h1 id="资料与文献"><a href="#资料与文献" class="headerlink" title="资料与文献"></a>资料与文献</h1><ul><li>马丁.福勒对微服务的描述</li><li>微服务架构的理论基础 - 康威定律</li><li>调用链选型之Zipkin，Pinpoint，SkyWalking，CAT</li></ul><hr><blockquote><p>原文转载自<a href="https://mp.weixin.qq.com/s/Pfs57ee6KpW342cKmJTGrw" target="_blank" rel="noopener">多次尝试学习，终于搞懂了微服务架构</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是微服务&quot;&gt;&lt;a href=&quot;#什么是微服务&quot; class=&quot;headerlink&quot; title=&quot;什么是微服务?&quot;&gt;&lt;/a&gt;什么是微服务?&lt;/h1&gt;&lt;p&gt;微服务 Microservices 之父，马丁.福勒，对微服务大概的概述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就目前而言，对于微服务业界并没有一个统一的、标准的定义(While there is no precise definition of this architectural style ) 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;但通常在其而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;服务之间采用轻量级的通信机制互相沟通(通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="微服务" scheme="https://vincentruan.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>【转载】我花了10个小时，写出了这篇K8S架构解析</title>
    <link href="https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%88%91%E8%8A%B1%E4%BA%8610%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E5%86%99%E5%87%BA%E4%BA%86%E8%BF%99%E7%AF%87K8S%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <id>https://vincentruan.github.io/2020/02/25/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%88%91%E8%8A%B1%E4%BA%8610%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E5%86%99%E5%87%BA%E4%BA%86%E8%BF%99%E7%AF%87K8S%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/</id>
    <published>2020-02-25T07:40:31.000Z</published>
    <updated>2020-02-25T15:09:15.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>互联网技术飞速发展的今天，为了承载请求的高并发和业务的多样性，微服务的架构成了各个公司的标配。</p></blockquote><p>每个微服务通过 Docker 进行发布，随着业务的发展，系统中遍布着各种各样的容器。于是，容器的资源调度，部署运行，扩容缩容就是我们要面临的问题。</p><p>基于 Kubernetes 作为容器集群的管理平台被广泛应用，今天我们一起来看看 Kubernetes 的架构中有那些常用的组件以及运行原理。</p><a id="more"></a><h1 id="Kubernetes-架构概述"><a href="#Kubernetes-架构概述" class="headerlink" title="Kubernetes 架构概述"></a>Kubernetes 架构概述</h1><p>Kubernetes 是用来管理容器集群的平台。既然是管理集群，那么就存在被管理节点，针对每个 Kubernetes 集群都由一个 Master 负责管理和控制集群节点。</p><p>我们通过 Master 对每个节点 Node 发送命令。简单来说，Master 就是管理者，Node 就是被管理者。</p><p>Node 可以是一台机器或者一台虚拟机。在 Node 上面可以运行多个 Pod，Pod 是 Kubernetes 管理的最小单位，同时每个 Pod 可以包含多个容器（Docker）。</p><p>通过下面的 Kubernetes 架构简图可以看到 Master 和 Node 之间的关系：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612508509.webp" alt="img"></p><p><center><i>Kubernetes 架构简图</i></center><br>通常我们都是通过 kubectl 对 Kubernetes 下命令的，它通过 APIServer 去调用各个进程来完成对 Node 的部署和控制。</p><p>APIServer 的核心功能是对核心对象（例如：Pod，Service，RC）的增删改查操作，同时也是集群内模块之间数据交换的枢纽。</p><p>它包括了常用的 API，访问（权限）控制，注册，信息存储（etcd）等功能。在它的下面我们可以看到 Scheduler，它将待调度的 Pod 绑定到 Node 上，并将绑定信息写入 etcd 中。</p><p>etcd 包含在 APIServer 中，用来存储资源信息。接下来就是 Controller Manager 了，如果说 Kubernetes 是一个自动化运行的系统，那么就需要有一套管理规则来控制这套系统。</p><p>Controller Manager 就是这个管理者，或者说是控制者。它包括 8 个 Controller，分别对应着副本，节点，资源，命名空间，服务等等。</p><p>紧接着，Scheduler 会把 Pod 调度到 Node 上，调度完以后就由 kubelet 来管理 Node 了。</p><p>kubelet 用于处理 Master 下发到 Node 的任务（即 Scheduler 的调度任务），同时管理 Pod 及 Pod 中的容器。</p><p>在完成资源调度以后，kubelet 进程也会在 APIServer 上注册 Node 信息，定期向 Master 汇报 Node 信息，并通过 cAdvisor 监控容器和节点资源。</p><p>由于，微服务的部署都是分布式的，所以对应的 Pod 以及容器的部署也是。为了能够方便地找到这些 Pod 或者容器，引入了 Service（kube-proxy）进程，它来负责反向代理和负载均衡的实施。</p><p>上面就是 Kubernetes 架构的简易说明，涉及到了一些核心概念以及简单的信息流动。</p><p>将一些功能收录到了 APIServer 中，这个简图比官网的图显得简单一些，主要是方便大家记忆。</p><p>后面我们会用一个简单的例子，带大家把 Kubernetes 的概念的由来做深入的了解。</p><h1 id="从一个例子开始"><a href="#从一个例子开始" class="headerlink" title="从一个例子开始"></a>从一个例子开始</h1><p>假设使用 Kubernetes 部署 Tomcat 和 MySQL 服务到两个 Node 上面。其中 Tomcat 服务生成两个实例也就是生成两个 Pod，用来对其做水平扩展。</p><p>MySQL 只部署一个实例，也就是一个 Pod。可以通过外网访问 Tomcat，而 Tomcat 可以在内网访问 MySQL。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612580738.webp" alt="img"></p><p><center><i>例子示意图</i></center><br>这里我们假设 Kubernetes 和 Docker 的安装都已经完成，并且镜像文件都已经准备好了。重点看 Kubernetes 如何部署和管理容器。</p><h1 id="kubectl-和-APIServer"><a href="#kubectl-和-APIServer" class="headerlink" title="kubectl 和 APIServer"></a>kubectl 和 APIServer</h1><p>既然我们要完成上面的例子，接下来就要部署两个应用。</p><p>首先，根据要部署的应用建立 Replication Controller（RC）。RC 是用来声明应用副本的个数，也就是 Pod 的个数。</p><p>按照上面的例子，Tomcat 的 RC 就是 2，MySQL 的 RC 就是 1。</p><p>由于 kubectl 作为用户接口向 Kubernetes 下发指令，那么指令是通过“.yaml”的配置文件编写的。</p><p>定义 ysql-rc.yaml 的配置文件来描述 MySQL 的 RC：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">V1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">mysql#RC的名称，全局唯一</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="string">replicas:1</span> <span class="comment">#Pod 副本的期待数量</span></span><br><span class="line"><span class="attr">selector :</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">mysql</span></span><br><span class="line"> <span class="attr">template:</span> <span class="comment">#Pod模版，用这个模版来创建Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line"><span class="string">app:mysql#Pod副本的标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="string">containers:#容器定义部分</span></span><br><span class="line">     <span class="string">-name:mysql</span></span><br><span class="line"><span class="string">Image:mysql#容器对应的DockerImage</span></span><br><span class="line">      <span class="attr">Ports:</span></span><br><span class="line">      <span class="string">-containerPort:3306#容器应用监听的端口号</span></span><br><span class="line">      <span class="string">Env:#注入容器的环境变量</span></span><br><span class="line">      <span class="string">-name:MYSQL_ROOT_PASSWORD</span></span><br><span class="line">      <span class="string">Value:”123456”</span></span><br></pre></td></tr></table></figure><p>从上面的配置文件可以看出，需要对这个 RC 定义一个名字，以及期望的副本数，以及容器中的镜像文件。然后通过 kubectl 作为客户端的 cli 工具，执行这个配置文件。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612852256.webp" alt="img"></p><p><center><i>通过 kubectl 执行 RC 配置文件</i></center><br>执行了上面的命令以后，Kubernetes 会帮助我们部署副本 MySQL 的 Pod 到 Node。</p><p>此时先不着急看结果，回到最开始的架构图，可以看到 kubectl 会向 Master 中的 APIServer 发起命令，看看 APIServer 的结构和信息的传递吧。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612887167.png" alt="img"></p><p>Kubernetes API Server 通过一个名为 kube-apiserver 的进程提供服务，该进程运行在 Master 上。</p><p>可以通过 Master 的 8080 端口访问 kube-apiserver 进程，它提供 REST 服务。</p><p>因此可以通过命令行工具 kubectl 来与 Kubernetes APIServer 交互，它们之间的接口是 RESTful API。</p><p><strong>APIServer 的架构从上到下分为四层</strong>：</p><ul><li><strong>API 层：</strong>主要以 REST 方式提供各种 API 接口，针对 Kubernetes 资源对象的 CRUD 和 Watch 等主要 API，还有健康检查、UI、日志、性能指标等运维监控相关的 API。</li><li><strong>访问控制层：</strong>负责身份鉴权，核准用户对资源的访问权限，设置访问逻辑（Admission Control）。</li><li><strong>注册表层：</strong>选择要访问的资源对象。PS：Kubernetes 把所有资源对象都保存在注册表（Registry）中，例如：Pod，Service，Deployment 等等。</li><li><strong>etcd 数据库：</strong>保存创建副本的信息。用来持久化 Kubernetes 资源对象的 Key-Value 数据库。</li></ul><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449162.webp" alt="img"></p><p><center><i>APIServer 分层架构图</i></center><br>当 kubectl 用 Create 命令建立 Pod 时，是通过 APIServer 中的 API 层调用对应的 RESTAPI 方法。</p><p>之后会进入权限控制层，通过 Authentication 获取调用者身份，Authorization 获取权限信息。</p><p>AdmissionControl 中可配置权限认证插件，通过插件来检查请求约束。例如：启动容器之前需要下载镜像，或者检查具备某命名空间的资源。</p><p>还记得 mysql-rc.yaml 中配置需要生成的 Pod 的个数为 1。到了 Registry 层会从 CoreRegistry 资源中取出 1 个 Pod 作为要创建的 Kubernetes 资源对象。</p><p>然后将 Node，Pod 和 Container 信息保存在 etcd 中去。这里的 etcd 可以是一个集群，由于里面保存集群中各个 Node/Pod/Container 的信息，所以必要时需要备份，或者保证其可靠性。</p><h1 id="Controller-Manager，Scheduler-和-kubelet"><a href="#Controller-Manager，Scheduler-和-kubelet" class="headerlink" title="Controller Manager，Scheduler 和 kubelet"></a>Controller Manager，Scheduler 和 kubelet</h1><p>前面通过 kubectl 根据配置文件，向 APIServer 发送命令，在 Node 上面建立 Pod 和 Container。</p><p>在 APIServer，经过 API 调用，权限控制，调用资源和存储资源的过程。实际上还没有真正开始部署应用。</p><p>这里需要 Controller Manager，Scheduler 和 kubelet 的协助才能完成整个部署过程。</p><p>在介绍他们协同工作之前，要介绍一下在 Kubernetes 中的监听接口。从上面的操作知道，所有部署的信息都会写到 etcd 中保存。</p><p>实际上 etcd 在存储部署信息的时候，会发送 Create 事件给 APIServer，而 APIServer 会通过监听（Watch）etcd 发过来的事件。其他组件也会监听（Watch）APIServer 发出来的事件。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612994188.webp" alt="img"></p><p><strong>Kubernetes 就是用这种 List-Watch 的机制保持数据同步的，如上图</strong>：</p><ul><li><p>这里有三个 List-Watch，分别是 kube-controller-manager（运行在Master），kube-scheduler（运行在 Master），kublete（运行在 Node）。他们在进程已启动就会监听（Watch）APIServer 发出来的事件。</p></li><li><p>kubectl 通过命令行，在 APIServer 上建立一个 Pod 副本。</p></li><li><p>这个部署请求被记录到 etcd 中，存储起来。</p></li><li><p>当 etcd 接受创建 Pod 信息以后，会发送一个 Create 事件给 APIServer。</p></li><li><p>由于 Kubecontrollermanager 一直在监听 APIServer 中的事件。此时 APIServer 接受到了 Create 事件，又会发送给 Kubecontrollermanager。</p></li><li><p>Kubecontrollermanager 在接到 Create 事件以后，调用其中的 Replication Controller 来保证 Node 上面需要创建的副本数量。</p><p>上面的例子 MySQL 应用是 1 个副本，Tomcat 应用是两个副本。一旦副本数量少于 RC 中定义的数量，Replication Controller 会自动创建副本。总之它是保证副本数量的 Controller。PS：扩容缩容的担当。</p></li><li><p>在 Controller Manager 创建 Pod 副本以后，APIServer 会在 etcd 中记录这个 Pod 的详细信息。例如在 Pod 的副本数，Container 的内容是什么。</p></li><li><p>同样的 etcd 会将创建 Pod 的信息通过事件发送给 APIServer。</p></li><li><p>由于 Scheduler 在监听（Watch）APIServer，并且它在系统中起到了“承上启下”的作用，“承上”是指它负责接收创建的 Pod 事件，为其安排 Node；“启下”是指安置工作完成后，Node 上的 kubelet 服务进程接管后继工作，负责 Pod 生命周期中的“下半生”。</p><p>换句话说，Scheduler 的作用是将待调度的 Pod 按照调度算法和策略绑定到集群中 Node 上，并将绑定信息写入 etcd 中。</p></li><li><p>Scheduler 调度完毕以后会更新 Pod 的信息，此时的信息更加丰富了。除了知道 Pod 的副本数量，副本内容。还知道部署到哪个 Node 上面了。</p></li><li><p>同样，将上面的 Pod 信息更新到 etcd 中，保存起来。</p></li><li><p>etcd 将更新成功的事件发送给 APIServer。</p></li><li><p>注意这里的 kubelet 是在 Node 上面运行的进程，它也通过 List-Watch 的方式监听（Watch）APIServer 发送的 Pod 更新的事件。实际上，在第 9 步的时候创建 Pod 的工作就已经完成了。</p><p>为什么 kubelete 还要一直监听呢？原因很简单，假设这个时候 kubectl 发命令，需要把原来的 MySQL 的 1 个 RC 副本扩充成 2 个。那么这个流程又会触发一遍。</p><p>作为 Node 的管理者 kubelet 也会根据最新的 Pod 的部署情况调整 Node 端的资源。</p><p>又或者 MySQL 应用的 RC 个数没有发生变化，但是其中的镜像文件升级了，kubelet 也会自动获取最新的镜像文件并且加载。</p></li></ul><p>通过上面 List-Watch 的介绍大家发现了，除了之前引入的 kubectl 和 APIServer 以外又引入了 Controller Manager，Scheduler 和 kubelet。</p><p>这里给大家介绍一下他们的作用和原理：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613048027.png" alt="img"></p><p><center><i>聚焦 Scheduler，Controller Manager，kubelet</i></center></p><h1 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h1><p>Kubernetes 需要管理集群中的不同资源，所以针对不同的资源要建立不同的 Controller。</p><p>每个 Controller 通过监听机制获取 APIServer 中的事件（消息），它们通过 API Server 提供的（List-Watch）接口监控集群中的资源，并且调整资源的状态。</p><p>可以把它想象成一个尽职的管理者，随时管理和调整资源。比如 MySQL 所在的 Node 意外宕机了，Controller Manager 中的 Node Controller 会及时发现故障，并执行修复流程。</p><p>在部署了成百上千微服务的系统中，这个功能极大地协助了运维人员。从此可以看出，Controller Manager 是 Kubernetes 资源的管理者，是运维自动化的核心。</p><p>它分为 8 个 Controller，上面我们介绍了 Replication Controller，这里我们把其他几个都列出来，就不展开描述了。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640.jpg" alt="img"></p><p><center><i>Controller Manager 中不同的 Controller 负责对不同资源的监控和管理</i></center></p><h1 id="Scheduler-与-kubelet"><a href="#Scheduler-与-kubelet" class="headerlink" title="Scheduler 与 kubelet"></a>Scheduler 与 kubelet</h1><p>Scheduler 的作用是，将待调度的 Pod 按照算法和策略绑定到 Node 上，同时将信息保存在 etcd 中。</p><p>如果把 Scheduler 比作调度室，那么这三件事就是它需要关注的，待调度的 Pod、可用的 Node，调度算法和策略。</p><p>简单地说，就是通过调度算法/策略把 Pod 放到合适的 Node 中去。此时 Node 上的 kubelet 通过 APIServer 监听到 Scheduler 产生的 Pod 绑定事件，然后通过 Pod 的描述装载镜像文件，并且启动容器。</p><p>也就是说 Scheduler 负责思考，Pod 放在哪个 Node，然后将决策告诉 kubelet，kubelet 完成 Pod 在 Node 的加载工作。</p><p>说白了，Scheduler 是 boss，kubelet 是干活的工人，他们都通过 APIServer 进行信息交换。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613129697.webp" alt="img"></p><p><center><i>Scheduler 与 kubelet 协同工作图</i></center></p><h1 id="Service-和-kubelet"><a href="#Service-和-kubelet" class="headerlink" title="Service 和 kubelet"></a>Service 和 kubelet</h1><p>经历上面一系列的过程，终于将 Pod 和容器部署到 Node 上了。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449201.webp" alt="img"></p><p><center><i>MySQL 部署成功</i></center><br>作为部署在 Kubernetes 中，Pod 如何访问其他的 Pod 呢？答案是通过 Kubernetes 的 Service 机制。</p><p>在 Kubernetes 中的 Service 定义了一个服务的访问入口地址（IP+Port）。Pod 中的应用通过这个地址访问一个或者一组 Pod 副本。</p><p>Service 与后端 Pod 副本集群之间是通过 Label Selector 来实现连接的。Service 所访问的这一组 Pod 都会有同样的 Label，通过这样的方法知道这些 Pod 属于同一个组。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449202.webp" alt="img"></p><p><center><i>Pod 通过 Service 访问其他 Pod</i></center><br>写 MySQL 服务的配置文件（mysql-svc.yaml）如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion :</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment">#说明创建资源对象的类型是Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">mysql#Service全局唯一名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">prots:</span></span><br><span class="line"><span class="string">-port:</span> <span class="number">3306</span><span class="comment">#Service的服务端口号</span></span><br><span class="line"> <span class="string">selector:#Service对应的Pod标签，用来给Pod分类</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p>按照惯例运行 kubectl，创建 Service：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449203.webp" alt="img"></p><p>再用 getsvc 命令检查 Service 信息：</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613228838.webp" alt="img"></p><p>这里的 Cluster-IP 169.169.253.143 是由 Kubernetes 自动分配的。当一个 Pod 需要访问其他的 Pod 的时候就需要通过 Service 的 Cluster-IP 和 Port。</p><p>也就是说 Cluster-IP 和 Port 是 Kubernetes 集群的内部地址，是提供给集群内的 Pod 之间访问使用的，外部系统是无法通过这个 Cluster-IP 来访问 Kubernetes 中的应用的。</p><p>上面提到的 Service 只是一个概念，而真正将 Service 落实的是 kube-proxy。</p><p>只有理解了 kube-proxy 的原理和机制，我们才能真正理解 Service 背后的实现逻辑。</p><p>在 Kubernetes 集群的每个 Node 上都会运行一个 kube-proxy 服务进程，我们可以把这个进程看作 Service 的负载均衡器，其核心功能是将到 Service 的请求转发到后端的多个 Pod 上。</p><p>此外，Service 的 Cluster-IP 与 NodePort 是 kube-proxy 服务通过 iptables 的 NAT 转换实现的。kube-proxy 在运行过程中动态创建与 Service 相关的 iptables 规则。</p><p>由于 iptables 机制针对的是本地的 kube-proxy 端口，所以在每个 Node 上都要运行 kube-proxy 组件。</p><p>因此在 Kubernetes 集群内部，可以在任意 Node 上发起对 Service 的访问请求。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613246411.webp" alt="img"></p><p><center><i>集群内部通过 kube-proxy（Service）访问其他 Pod</i></center><br>正如 MySQL 服务，可以被 Kubernetes 内部的 Tomcat 调用，那么 Tomcat 如何被 Kubernetes 外部调用？</p><p>先生成配置文件，myweb-rc.yaml 看看：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">V1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">myweb#RC的名称，全局唯一</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="string">replicas:2#Pod</span> <span class="string">副本的期待数量，这里的数量是2，需要建立两个Tomcat的副本</span></span><br><span class="line"><span class="attr">selector :</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line"> <span class="attr">template:</span> <span class="comment">#Pod模版，用这个模版来创建Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line"><span class="string">app:myweb#Pod副本的标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">containers:</span> <span class="comment">#容器定义部分</span></span><br><span class="line">     <span class="string">-name:mysql</span></span><br><span class="line"><span class="string">Image:kubeguide/tomcat-app:v1#容器对应的DockerImage</span></span><br><span class="line">      <span class="attr">Ports:</span></span><br><span class="line">      <span class="string">-containerPort:8080#容器应用监听的端口号</span></span><br></pre></td></tr></table></figure><p>在 kubectl 中使用 Create 建立 myweb 副本。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613310553.webp" alt="img"></p><p>副本创建完毕以后，创建对应的服务配置文件 myweb-svc.yaml。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion :</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment">#说明创建资源对象的类型是Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">myweb#Service全局唯一名称</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">prots:</span></span><br><span class="line"><span class="string">-port:</span> <span class="number">8080</span><span class="comment">#Service的服务端口号</span></span><br><span class="line"><span class="attr">nodePort:</span> <span class="number">30001</span><span class="comment">#这个就是外网访问Kubernetes内部应用的端口。</span></span><br><span class="line"> <span class="attr">selector:</span> <span class="comment">#Service对应的Pod标签，用来给Pod分类</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">myweb</span></span><br></pre></td></tr></table></figure><p>同样在 kubectl 中运行 Create 命令，建立 Service 资源。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613324973.webp" alt="img"></p><p>从上面的配置文件可以看出，Tomcat 的 Service 中多了一个 nodePort 的配置，值为 30001。</p><p>也就是说外网通过 30001 这个端口加上 NodeIP 就可以访问 Tomcat 了。</p><p>运行命令之后，得到一个提示，大致意思是“如果你要将服务暴露给外网使用，你需要设置防火墙规则让 30001 端口能够通行。”</p><p>由于 Cluster-IP 是一个虚拟的 IP，仅供 Kubernetes 内部的 Pod 之间的通信。</p><p>Node 作为一个物理节点，因此需要使用 Node-IP 和 nodePort 的组合来从 Kubernetes 外面访问内部的应用。</p><p>如果按照上面的配置，部署了两个 Tomcat 应用，当外网访问时选择那个 Pod 呢？这里需要通过 Kubernetes 之外的负载均衡器来实现的。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582613344698.webp" alt="img"></p><p><center><i>Kubernetes 之外的负载均衡器</i></center><br>可以通过 Kubernetes 的 LoadBlancerService 组件来协助实现。通过云平台申请创建负载均衡器，向外暴露服务。</p><p>目前 LoadBlancerService 组件支持的云平台比较完善，比如国外的 GCE、DigitalOcean，国内的阿里云，私有云 OpenStack 等等。</p><p>从用法上只要把 Service 的 type=NodePort 改为 type=LoadBalancer，Kubernetes 就会自动创建一个对应的 Load Balancer 实例并返回它的 IP 地址供外部客户端使用。</p><p>至此，MySQL（RC 1）和 Tomcat（RC 2）已经在 Kubernetes 部署了。并在 Kubernetes 内部 Pod 之间是可以互相访问的，在外网也可以访问到 Kubernetes 内部的 Pod。</p><p><img src="/2020/02/25/【转载】我花了10个小时，写出了这篇K8S架构解析/640-1582612449248.webp" alt="img"></p><p><center><i>Pod 在 Kubernetes 内互相访问，外网访问 Pod</i></center><br>另外，作为资源监控 Kubernetes 在每个 Node 和容器上都运行了 cAdvisor。它是用来分析资源使用率和性能的工具，支持 Docker 容器。</p><p>kubelet 通过 cAdvisor 获取其所在 Node 及容器（Docker）的数据。cAdvisor 自动采集 CPU、内存、文件系统和网络使用的统计信息。</p><p>kubelet 作为 Node 的管理者，把 cAdvisor 采集上来的数据通过 RESTAPI 的形式暴露给 Kubernetes 的其他资源，让他们知道 Node/Pod 中的资源使用情况。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于微服务的迅猛发展，Kubernetes 作为微服务治理平台被广泛应用。由于其发展时间长，包含服务功能多我们无法一一列出。</p><p>因此，从一个简单的创建应用副本的例子入手，介绍了各个重要组件的概念和基本原理。</p><p>Kubernetes 是用来管理容器集群的，Master 作为管理者，包括 APIServer，Scheduler，Controller Manager。</p><p>Node作为副本部署的载体，包含多个 Pod，每个 Pod 又包含多个容器（container）。用户通过 kubectl 给 Master 中的 APIServer 下部署命令。</p><p>命令主体是以“.yaml”结尾的配置文件，包含副本的类型，副本个数，名称，端口，模版等信息。</p><p>APIServer 接受到请求以后，会分别进行以下操作：权限验证（包括特殊控制），取出需要创建的资源，保存副本信息到etcd。</p><p>APIServer 和 Controller Manager，Scheduler 以及 kubelete 之间通过 List-Watch 方式通信（事件发送与监听）。</p><p>Controller Manager 通过 etcd 获取需要创建资源的副本数，交由 Scheduler 进行策略分析。</p><p>最后 kubelet 负责最终的 Pod 创建和容器加载。部署好容器以后，通过 Service 进行访问，通过 cAdvisor 监控资源。</p><blockquote><p>原文转载自51CTO技术栈，崔皓，<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODI5Njc2MA==&amp;mid=2655827885&amp;idx=1&amp;sn=47feb253e0aa012023d6f421572a04b3&amp;chksm=bd74fa7a8a03736c08e43b4e7082c3763c0e64491e7b7ef3ddd9f3756cfa5e536730f8f022e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">我花了10个小时，写出了这篇K8S架构解析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;互联网技术飞速发展的今天，为了承载请求的高并发和业务的多样性，微服务的架构成了各个公司的标配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个微服务通过 Docker 进行发布，随着业务的发展，系统中遍布着各种各样的容器。于是，容器的资源调度，部署运行，扩容缩容就是我们要面临的问题。&lt;/p&gt;
&lt;p&gt;基于 Kubernetes 作为容器集群的管理平台被广泛应用，今天我们一起来看看 Kubernetes 的架构中有那些常用的组件以及运行原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="微服务" scheme="https://vincentruan.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="k8s" scheme="https://vincentruan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>【转载】神一样的CAP理论被应用在何方</title>
    <link href="https://vincentruan.github.io/2020/02/24/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84CAP%E7%90%86%E8%AE%BA%E8%A2%AB%E5%BA%94%E7%94%A8%E5%9C%A8%E4%BD%95%E6%96%B9/"/>
    <id>https://vincentruan.github.io/2020/02/24/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84CAP%E7%90%86%E8%AE%BA%E8%A2%AB%E5%BA%94%E7%94%A8%E5%9C%A8%E4%BD%95%E6%96%B9/</id>
    <published>2020-02-24T13:39:19.000Z</published>
    <updated>2020-02-25T15:09:15.058Z</updated>
    
    <content type="html"><![CDATA[<p>对于开发或设计分布式系统的架构师工程师来说，CAP是必须要掌握的理论。</p><blockquote><p>（but：这个文章的重点并不是讨论CAP理论和细节，重点是说说CAP在微服务中的开发怎么起到一个指引作用，会通过几个微服务开发的例子说说明，尽量的去贴近开发）</p></blockquote><p>CAP定理又被成为布鲁尔定理，是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。不过布鲁尔在出来CAP的时候并没有对CAP三者（Consistency，Availability，Partition tolerance）进行详细的定义，所以在网上也出现了不少对CAP不同解读的声音。</p><a id="more"></a><h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>CAP定理在发展中存在过两个版本，我们以第二个版本为准</p><blockquote><p>在一个分布式系统中（指互相连接并共享数据的节点集合）中，当涉及到读写操作时，只能保证一致性（Consistence）、可用性(Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。</p></blockquote><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f809b3bc" alt="image"></p><p>这个版本的CAP理论在探讨分布式系统，更加强调两点是互联和共享数据，其实也是理清楚了第一个版本中三选二的一些缺陷，分布式系统不一定都存在互联和共享数据，例如memcached集群相互间就没有存在连接和共享数据，所以memcached集群这类的分布式系统并不在CAP理论讨论的范围，而想Mysql集群就是互联和数据共享复制，因此mysql集群式属于CAP理论讨论的对象。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值</p><h4 id="可用性-Availability）"><a href="#可用性-Availability）" class="headerlink" title="可用性(Availability）"></a>可用性(Availability）</h4><p>非故障的节点在合理的时间内返回合理的响应</p><h4 id="分区容错性-Partition-Tolerance"><a href="#分区容错性-Partition-Tolerance" class="headerlink" title="分区容错性(Partition Tolerance)"></a>分区容错性(Partition Tolerance)</h4><p>当网络出现分区后，系统依然能够继续旅行社职责</p><p>在分布式的环境下，网络无法做到100%可靠，有可能出现故障，因此分区是一个必须的选项，如果选择了CA而放弃了P，若发生分区现象，为了保证C，系统需要禁止写入，此时就与A发生冲突，如果是为了保证A，则会出现正常的分区可以写入数据，有故障的分区不能写入数据，则与C就冲突了。因此分布式系统理论上不可能选择CA架构，而必须选择CP或AP架构。</p><h4 id="分布式事务BASE理论"><a href="#分布式事务BASE理论" class="headerlink" title="分布式事务BASE理论"></a>分布式事务BASE理论</h4><p>BASE理论是对CAP的延伸和补充，是对CAP中的AP方案的一个补充，即使在选择AP方案的情况下，如何更好的最终达到C。</p><p>BASE是基本可用，柔性状态，最终一致性三个短语的缩写，核心的思想是即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性。</p><h3 id="CAP在服务中实际的应用例子"><a href="#CAP在服务中实际的应用例子" class="headerlink" title="CAP在服务中实际的应用例子"></a>CAP在服务中实际的应用例子</h3><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f63920ec" alt="image"></p><p>理解貌似讲多了，项目的CAP可以参考下李运华的《从零开始学架构》的书，里面的21，22章比较详细的描绘了CAP的理论细节和CAP的版本演化过程。</p><p>这里着重的讲解的是神一样的CAP在我们的微服务中怎么去指导和应用起来，大概会举几个平时常见的例子</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f5068452" alt="image"></p><h3 id="服务注册中心，是选择AP还是选择CP-？"><a href="#服务注册中心，是选择AP还是选择CP-？" class="headerlink" title="服务注册中心，是选择AP还是选择CP ？"></a>服务注册中心，是选择AP还是选择CP ？</h3><h4 id="服务注册中心解决的问题"><a href="#服务注册中心解决的问题" class="headerlink" title="服务注册中心解决的问题"></a>服务注册中心解决的问题</h4><p>在讨论CAP之前先明确下服务注册中心主要是解决什么问题：一个是服务注册，一个是服务发现。</p><ul><li>服务注册：实例将自身服务信息注册到注册中心，这部分信息包括服务的主机IP和服务的Port，以及暴露服务自身状态和访问协议信息等。</li><li>服务发现：实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</li></ul><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888feb8431b" alt="image"></p><p>目前作为注册中心的一些组件大致有：dubbo的zookeeper，springcloud的eureka，consul，rocketMq的nameServer，hdfs的nameNode。目前微服务主流是dubbo和springcloud，使用最多是zookeeper和eureka，我们就来看看应该根据CAP理论应该怎么去选择注册中心。（springcloud也可以用zk，不过不是主流不讨论）。</p><h4 id="zookeeper选择CP"><a href="#zookeeper选择CP" class="headerlink" title="zookeeper选择CP"></a>zookeeper选择CP</h4><p>zookeep保证CP，即任何时刻对zookeeper的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性。从实际情况来分析，在使用zookeeper获取服务列表时，如果zk正在选举或者zk集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk不能保证服务可用性。</p><h4 id="eureka选择AP"><a href="#eureka选择AP" class="headerlink" title="eureka选择AP"></a>eureka选择AP</h4><p>eureka保证AP，eureka在设计时优先保证可用性，每一个节点都是平等的，一部分节点挂掉不会影响到正常节点的工作，不会出现类似zk的选举leader的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点，只要有一台eureka存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信息。</p><h4 id="zookeeper和eureka的数据一致性问题"><a href="#zookeeper和eureka的数据一致性问题" class="headerlink" title="zookeeper和eureka的数据一致性问题"></a>zookeeper和eureka的数据一致性问题</h4><p>先要明确一点，eureka的创建初心就是为一个注册中心，但是zk更多是作为分布式协调服务的存在，只不过因为它的特性被dubbo赋予了注册中心，它的职责更多是保证数据（配置数据，状态数据）在管辖下的所有服务之间保持一致，所有这个就不难理解为何zk被设计成CP而不是AP，zk最核心的算法ZAB，就是为了解决分布式系统下数据在多个服务之间一致同步的问题。</p><p>更深层的原因，zookeeper是按照CP原则构建，也就是说它必须保持每一个节点的数据都保持一致，如果zookeeper下节点断开或者集群中出现网络分割（例如交换机的子网间不能互访），那么zk会将它们从自己的管理范围中剔除，外界不能访问这些节点，即使这些节点是健康的可以提供正常的服务，所以导致这些节点请求都会丢失。</p><p>而eureka则完全没有这方面的顾虑，它的节点都是相对独立，不需要考虑数据一致性的问题，这个应该是eureka的诞生就是为了注册中心而设计，相对zk来说剔除了leader节点选取和事务日志极致，这样更有利于维护和保证eureka在运行的健壮性。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888fc2f78b3" alt="image"></p><p>再来看看，数据不一致性在注册服务中中会给eureka带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些ip节点被调用数少，某些ip节点调用数少的问题。也有可能存在一些本应该被删除而没被删除的脏数据。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05888f75401e9" alt="image"></p><h4 id="小结：服务注册应该选择AP还是CP"><a href="#小结：服务注册应该选择AP还是CP" class="headerlink" title="小结：服务注册应该选择AP还是CP"></a>小结：服务注册应该选择AP还是CP</h4><p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果，对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p><p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择AP。</p><h3 id="分布式锁，是选择AP还是选择CP-？"><a href="#分布式锁，是选择AP还是选择CP-？" class="headerlink" title="分布式锁，是选择AP还是选择CP ？"></a>分布式锁，是选择AP还是选择CP ？</h3><p>这里实现分布式锁的方式选取了三种：</p><ul><li>基于数据库实现分布式锁</li><li>基于redis实现分布式锁</li><li>基于zookeeper实现分布式锁</li></ul><h4 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h4><p>构建表结构</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a12368882" alt="image"></p><p>利用表的 UNIQUE KEY <code>idx_lock</code> (<code>method_lock</code>) 作为唯一主键，当进行上锁时进行insert动作，数据库成功录入则以为上锁成功，当数据库报出 Duplicate entry 则表示无法获取该锁。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a11076d99" alt="image"></p><p>不过这种方式对于单主却无法自动切换主从的mysql来说，基本就无法现实P分区容错性，（Mysql自动主从切换在目前并没有十分完美的解决方案）。可以说这种方式强依赖于数据库的可用性，数据库写操作是一个单点，一旦数据库挂掉，就导致锁的不可用。这种方式基本不在CAP的一个讨论范围。</p><h4 id="基于redis实现分布式锁"><a href="#基于redis实现分布式锁" class="headerlink" title="基于redis实现分布式锁"></a>基于redis实现分布式锁</h4><p>redis单线程串行处理天然就是解决串行化问题，用来解决分布式锁是再适合不过。</p><p>实现方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setnx key value Expire_time</span><br><span class="line">获取到锁 返回 1 ， 获取失败 返回 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>为了解决数据库锁的无主从切换的问题，可以选择redis集群，或者是 sentinel 哨兵模式，实现主从故障转移，当master节点出现故障，哨兵会从slave中选取节点，重新变成新的master节点。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05889f092fb7f" alt="image"></p><p>哨兵模式故障转移是由sentinel集群进行监控判断，当maser出现异常即复制中止，重新推选新slave成为master，sentinel在重新进行选举并不在意主从数据是否复制完毕具备一致性。</p><p>所以redis的复制模式是属于AP的模式。保证可用性，在主从复制中“主”有数据，但是可能“从”还没有数据，这个时候，一旦主挂掉或者网络抖动等各种原因，可能会切换到“从”节点，这个时候可能会导致两个业务县城同时获取得两把锁</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05889f24be477" alt="image"></p><p>这个过程如下：</p><ol><li>业务线程-1 向主节点请求锁</li><li>业务线程-1 获取锁</li><li>业务线程-1 获取到锁并开始执行业务</li><li>这个时候redis刚生成的锁在主从之间还未进行同步</li><li>redis这时候主节点挂掉了</li><li>redis的从节点升级为主节点</li><li>业务线程-2 想新的主节点请求锁</li><li>业务线程-2 获取到新的主节点返回的锁</li><li>业务线程-2 获取到锁开始执行业务</li><li>这个时候 业务线程-1 和 业务线程-2 同时在执行任务</li></ol><p>上述的问题其实并不是redis的缺陷，只是redis采用了AP模型，它本身无法确保我们对一致性的要求。redis官方推荐redlock算法来保证，问题是redlock至少需要三个redis主从实例来实现，维护成本比较高，相当于redlock使用三个redis集群实现了自己的另一套一致性算法，比较繁琐，在业界也使用得比较少。</p><h5 id="能否使用redis作为分布式锁？"><a href="#能否使用redis作为分布式锁？" class="headerlink" title="能否使用redis作为分布式锁？"></a>能否使用redis作为分布式锁？</h5><p>能不能使用redis作为分布式锁，这个本身就不是redis的问题，还是取决于业务场景，我们先要自己确认我们的场景是适合 AP 还是 CP ， 如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，redis提供给我们高性能的AP模型是非常适合的，但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻在一种更加适合的 CP 模型</p><h4 id="基于zookeeper实现分布式锁"><a href="#基于zookeeper实现分布式锁" class="headerlink" title="基于zookeeper实现分布式锁"></a>基于zookeeper实现分布式锁</h4><p>刚刚也分析过，redis其实无法确保数据的一致性，先来看zookeeper是否合适作为我们需要的分布式锁，首先zk的模式是CP模型，也就是说，当zk锁提供给我们进行访问的时候，在zk集群中能确保这把锁在zk的每一个节点都存在。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d05889f6a5ce1c" alt="image"></p><p>（这个实际上是zk的leader通过二阶段提交写请求来保证的，这个也是zk的集群规模大了的一个瓶颈点）</p><h5 id="zk锁实现的原理"><a href="#zk锁实现的原理" class="headerlink" title="zk锁实现的原理"></a>zk锁实现的原理</h5><p>说zk的锁问题之前先看看zookeeper中几个特性，这几个特性构建了zk的一把分布式锁</p><p><strong>特性：</strong></p><ul><li>有序节点</li></ul><blockquote><p>当在一个父目录下如 /lock 下创建 有序节点，节点会按照严格的先后顺序创建出自节点 lock000001,lock000002,lock0000003,以此类推，有序节点能严格保证各个自节点按照排序命名生成。</p></blockquote><ul><li>临时节点</li></ul><blockquote><p>客户端建立了一个临时节点，在客户端的会话结束或会话超时，zookepper会自动删除该解ID那。</p></blockquote><ul><li>事件监听</li></ul><blockquote><p>在读取数据时，我们可以对节点设置监听，当节点的数据发生变化（1 节点创建 2 节点删除 3 节点数据变成 4 自节点变成）时，zookeeper会通知客户端。</p></blockquote><p>结合这几个特点，来看下zk是怎么组合分布式锁。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a51620561" alt="image"></p><ol><li>业务线程-1 业务线程-2 分别向zk的/lock目录下，申请创建有序的临时节点</li><li>业务线程-1 抢到/lock0001 的文件，也就是在整个目录下最小序的节点，也就是线程-1获取到了锁</li><li>业务线程-2 只能抢到/lock0002的文件，并不是最小序的节点，线程2未能获取锁</li><li>业务线程-1 与 lock0001 建立了连接，并维持了心跳，维持的心跳也就是这把锁的租期</li><li>当业务线程-1 完成了业务，将释放掉与zk的连接，也就是释放了这把锁</li></ol><h5 id="zk分布式锁的代码实现"><a href="#zk分布式锁的代码实现" class="headerlink" title="zk分布式锁的代码实现"></a>zk分布式锁的代码实现</h5><p>zk官方提供的客户端并不支持分布式锁的直接实现，我们需要自己写代码去利用zk的这几个特性去进行实现。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a68844a5a" alt="image"></p><h4 id="小结：究竟该用CP还是AP的分布式锁"><a href="#小结：究竟该用CP还是AP的分布式锁" class="headerlink" title="小结：究竟该用CP还是AP的分布式锁"></a>小结：究竟该用CP还是AP的分布式锁</h4><p>首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型。</p><p>无论是redis，zk，例如redis的AP模型会限制很多使用场景，但它却拥有了几者中最高的性能，zookeeper的分布式锁要比redis可靠很多，但他繁琐的实现机制导致了它的性能不如redis，而且zk会随着集群的扩大而性能更加下降。</p><p>简单来说，先了解业务场景，后进行技术选型。</p><h3 id="分布式事务，是怎么从ACID解脱，投身CAP-BASE"><a href="#分布式事务，是怎么从ACID解脱，投身CAP-BASE" class="headerlink" title="分布式事务，是怎么从ACID解脱，投身CAP/BASE"></a>分布式事务，是怎么从ACID解脱，投身CAP/BASE</h3><p>如果说到事务，ACID是传统数据库常用的设计理念，追求强一致性模型，关系数据库的ACID模型拥有高一致性+可用性，所以很难进行分区，所以在微服务中ACID已经是无法支持，我们还是回到CAP去寻求解决方案，不过根据上面的讨论，CAP定理中，要么只能CP，要么只能AP，如果我们追求数据的一致性而忽略可用性这个在微服务中肯定是行不通的，如果我们追求可用性而忽略一致性，那么在一些重要的数据（例如支付，金额）肯定出现漏洞百出，这个也是无法接受。所以我们既要一致性，也要可用性。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a859246f5" alt="image"></p><p>都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入BASE理论，在分布式事务中，BASE最重要是为CAP提出了最终一致性的解决方案，BASE强调牺牲高一致性，从而获取肯用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p><h4 id="实现最终一致性"><a href="#实现最终一致性" class="headerlink" title="实现最终一致性"></a>实现最终一致性</h4><p><strong>弱一致性</strong>：系统不能保证后续访问返回更新的值。需要在一些条件满足之后，更新的值才能返回。从更新操作开始，到系统保证任何观察者总是看到更新的值的这期间被称为不一致窗口。</p><p><strong>最终一致性</strong>：这是弱一致性的特殊形式；存储系统保证如果没有对某个对象的新更新操作，最终所有的访问将返回这个对象的最后更新的值。</p><h4 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h4><p>BASE模型是传统ACID模型的反面，不同与ACID，BASE强调牺牲高一致性，从而获得可用性，数据允许在一段时间内的不一致，只要保证最终一致就可以了。</p><p>BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库) Soft state软状态 状态可以有一段时间不同步，异步。 Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时一致。</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>在分布式系统中，要实现分布式事务，无外乎几种解决方案。方案各有不同，不过其实都是遵循BASE理论，是最终一致性模型。</p><ul><li>两阶段提交（2PC）</li><li>补偿事务（TCC）</li><li>本地消息表</li><li>MQ事务消息</li></ul><h4 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h4><p>其实还有一个数据库的XA事务，不过目前在真正的互联网中实际的应用基本很少，两阶段提交就是使用XA原理。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588a87ee0c96" alt="image"></p><p>在 XA 协议中分为两阶段：</p><ol><li>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li><li>事务协调器要求每个数据库提交数据，或者回滚数据。</li></ol><p>说一下，为何在互联网的系统中没被改造过的两阶段提交基本很少被业界应用，最最大的缺点就是同步阻塞问题，在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。这个在互联网高并发大数据的今天，两阶段的提交是不能满足现在互联网的发展。</p><p>还有就是两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，例如：</p><p>比如在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p><h4 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h4><p>TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588aa354cd70" alt="image"></p><p>相比两阶段提交，TCC解决了几个问题</p><p>同步阻塞，引入了超时机制，超时后进行补偿，并不会像两阶段提交锁定了整个资源，将资源转换为业务逻辑形式，粒度变小。 因为有了补偿机制，可以由业务活动管理器进行控制，保证数据一致性。</p><p>1). try阶段</p><p>try只是一个初步的操作，进行初步的确认，它的主要职责是完成所有业务的检查，预留业务资源</p><p>2). confirm阶段</p><p>confirm是在try阶段检查执行完毕后，继续执行的确认操作，必须满足幂等性操作，如果confirm中执行失败，会有事务协调器触发不断的执行，直到满足为止</p><p>3). cancel是取消执行，在try没通过并释放掉try阶段预留的资源，也必须满足幂等性，跟confirm一样有可能被不断执行</p><p>一个下订单，生成订单扣库存的例子：</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588aa9cf1fed" alt="image"></p><p>接下来看看，我们的下单扣减库存的流程怎么加入TCC</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588ab8cd2a20" alt="image"></p><p>在try的时候，会让库存服务预留n个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源， 在confirm的时候，会使用在try预留的资源，在TCC事务机制中认为，如果在try阶段能正常预留的资源，那么在confirm一定能完整的提交</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588ab8c51652" alt="image"></p><p>在try的时候，有任务一方为执行失败，则会执行cancel的接口操作，将在try阶段预留的资源进行释放。</p><p>这个并不是重点要论tcc事务是怎么实现，重点还是讨论分布式事务在CAP+BASE理论的应用。实现可以参考：<a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">github.com/changmingxi…</a></p><h4 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h4><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案 <a href="https://queue.acm.org/detail.cfm?id=1394128。" target="_blank" rel="noopener">queue.acm.org/detail.cfm?…</a></p><p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588acde414a6" alt="image"></p><p>对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明</p><ol><li>当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）</li><li>配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。</li><li>库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。</li></ol><p>这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。</p><p>本地消息队列是BASE理论，是最终一致性模型，适用对一致性要求不高的情况。</p><h4 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h4><p>RocketMq在4.3版本已经正式宣布支持分布式事务，在选择Rokcetmq做分布式事务请务必选择4.3以上的版本。</p><p>RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588ae2844970" alt="image"></p><p>事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588aeba679cf" alt="image"></p><p>MQ事务是对本地消息表的一层封装，将本地消息表移动到了MQ内部，所以也是基于BASE理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时MQ事务将整个流程异步化了，也非常适合在高并发情况下使用。</p><h3 id="RocketMQ选择异步-同步刷盘，异步-同步复制，背后的CP和AP思考"><a href="#RocketMQ选择异步-同步刷盘，异步-同步复制，背后的CP和AP思考" class="headerlink" title="RocketMQ选择异步/同步刷盘，异步/同步复制，背后的CP和AP思考"></a>RocketMQ选择异步/同步刷盘，异步/同步复制，背后的CP和AP思考</h3><p>虽然同步刷盘/异步刷盘，同步/异步复制，并没有对cAP直接的应用，但在配置的过程中也一样涉及到可用性和一致性的考虑</p><h4 id="同步刷盘-异步刷盘"><a href="#同步刷盘-异步刷盘" class="headerlink" title="同步刷盘/异步刷盘"></a>同步刷盘/异步刷盘</h4><p>RocketMQ的消息是可以做到持久化的，数据会持久化到磁盘，RocketMQ为了提高性能，尽可能保证磁盘的顺序写入，消息在Producer写入RocketMq的时候，有两种写入磁盘方式：</p><ol><li>异步刷盘： 消息快速写入到内存的pagecache，就立马返回写成功状态，当内存的消息累计到一定程度的时候，会触发统一的写磁盘操作。这种方式可以保证大吞吐量，但也存在着消息可能未存入磁盘丢失的风险。</li><li>同步刷盘： 消息快速写入内存的pagecahe，立刻通知刷盘线程进行刷盘，等待刷盘完成之后，唤醒等待的线程，返回消息写成功的状态。</li></ol><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588b056e080a" alt="image"></p><h4 id="同步复制-异步复制"><a href="#同步复制-异步复制" class="headerlink" title="同步复制/异步复制"></a>同步复制/异步复制</h4><p>一个broker组有Master和Slave，消息需要从Master复制到Slave上，所以有同步和异步两种复制方式。</p><ol><li>同步复制： 是等Master和Slave均写成功后才反馈给客户端写成功状态。</li><li>异步复制： 是只要Master写成功即可反馈给客户端写成功状态。</li></ol><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588af130c763" alt="image"></p><p>异步复制的优点是可以提高响应速度，但牺牲了一致性 ，一般实现该类协议的算法需要增加额外的补偿机制。同步复制的优点是可以保证一致性(一般通过两阶段提交协议)，但是开销较大，可用性不好(参见CAP定理)，带来了更多的冲突和死锁等问题。值得一提的是Lazy+Primary/Copy的复制协议在实际生产环境中是非常实用的。</p><p><img src="/2020/02/24/【转载】神一样的CAP理论被应用在何方/16d0588b16477dcb" alt="image"></p><p>RocketMQ的设置要结合业务场景，合理设置刷盘方式和主从复制方式，尤其是SYNC_FLUSH方式，由于频繁的触发写磁盘动作，会明显降低性能。通常情况下，应该把Master和Slave设置成ASYNC_FLUSH的刷盘方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台机器出故障，仍然可以保证数据不丢。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在微服务的构建中，永远都逃离不了CAP理论，因为网络永远不稳定，硬件总会老化，软件会可能出现bug，所以分区容错性在微服务中是躲不过的命题，可以这么说，只要是分布式，只要是集群都面临着AP或者CP的选择，但你很贪心的时候，既要一致性又要可用性，那只能对一致性作出一点妥协，也就是引入了BASE理论，在业务允许的情况下实现最终一致性。</p><p>究竟是选AP还是选CP，真的在于对业务的了解，例如金钱，库存相关会优先考虑CP模型，例如社区发帖相关可以优先选择AP模型，这个说白了其实基于对业务的了解是一个选择和妥协的过程。</p><hr><blockquote><p>转载自陈于喆 - 神一样的CAP理论被应用在何方，原文地址<br><a href="https://juejin.im/post/5d720e86f265da03cc08de74" target="_blank" rel="noopener">https://juejin.im/post/5d720e86f265da03cc08de74</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于开发或设计分布式系统的架构师工程师来说，CAP是必须要掌握的理论。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（but：这个文章的重点并不是讨论CAP理论和细节，重点是说说CAP在微服务中的开发怎么起到一个指引作用，会通过几个微服务开发的例子说说明，尽量的去贴近开发）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CAP定理又被成为布鲁尔定理，是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。不过布鲁尔在出来CAP的时候并没有对CAP三者（Consistency，Availability，Partition tolerance）进行详细的定义，所以在网上也出现了不少对CAP不同解读的声音。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构" scheme="https://vincentruan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="CAP" scheme="https://vincentruan.github.io/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>【转载】30张图带你彻底理解红黑树</title>
    <link href="https://vincentruan.github.io/2020/02/24/30%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://vincentruan.github.io/2020/02/24/30%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2020-02-24T12:44:16.000Z</published>
    <updated>2020-02-25T15:09:15.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ &gt;                                                                                - 学红黑树有感。</p></blockquote><p>终于，在学习了几天的红黑树相关的知识后，我想把我所学所想和所感分享给大家。红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等一连串的问题在学习前困扰着我。如果你在学习过程中也会存在我的疑问，那么本文对你会有帮助，本文帮助你全面、彻底地理解红黑树！</p><a id="more"></a><p>本文将通过图文的方式讲解红黑树的知识点，并且不会涉及到任何代码，相信我，在懂得红黑树实现原理前，看代码会一头雾水的，当原理懂了，代码也就按部就班写而已，没任何难度。</p><p>阅读本文你需具备知识点：</p><ul><li>二叉查找树</li><li>完美平衡二叉树</li></ul><p>事不宜迟，让我们进入正题吧。</p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。现在在脑海想下怎么实现？是不是太多情景需要考虑了？啧啧，先别急，通过本文的学习后，你会觉得，其实也不过如此而已。好吧，我们先来看下红黑树的定义和一些基本性质。</p><h4 id="红黑树定义和性质"><a href="#红黑树定义和性质" class="headerlink" title="红黑树定义和性质"></a>红黑树定义和性质</h4><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5又可以推出：</p><ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点</li></ul><p>图1就是一颗简单的红黑树。其中Nil为叶子结点，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-4996bbfb4017a3b2.webp" alt="img"></p><p><center>图1 一颗简单的红黑树</center><br>红黑树并不是一个<em>完美</em>平衡二叉查找树，从图1可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如图2所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-abedf3ecc733ccd5.webp" alt="img"></p><p><center>图2 结点叫法约定</center><br>我们把正在处理(遍历)的结点叫做当前结点，如图2中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。</p><p>前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。</p><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。</li><li><strong>右旋</strong>：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。</li><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-a95db442f1b47f8a.webp" alt="img"></p><p><center>图3 左旋</center><br><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-0676a8e2a12e2a0b.webp" alt="img"></p><p><center>图4 右旋</center><br>上面所说的旋转结点也即旋转的支点，图4和图5中的P结点。<br>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。<br><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><p>所以旋转操作是<strong>局部</strong>的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。</p><p>但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住<strong>红黑树总是通过旋转和变色达到自平衡</strong>。</p><p>balabala了这么多，相信你对红黑树有一定印象了，那么现在来考考你：</p><p><strong><em>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？</em></strong> (答案见文末)</p><p>接下来先讲解红黑树的查找热热身。</p><hr><h4 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h4><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li>从根结点开始查找，把根结点设置为当前结点；</li><li>若当前结点为空，返回null；</li><li>若当前结点不为空，用当前结点的key跟查找key作比较；</li><li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li></ol><p>如图5所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-07b47eb3722981e6.webp" alt="img"></p><p><center>图5 二叉树查找流程图</center><br>非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～</p><hr><h4 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h4><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>如图6所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-7521866b50683a24.webp" alt="img"></p><p><center>图6 红黑树插入位置查找</center><br>ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>所有插入情景如图7所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-fa2b78271263d2c8.webp" alt="img"></p><p><center>图7 红黑树插入情景</center><br>嗯，插入情景很多呢，8种插入情景！但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。</p><p>另外，根据二叉树的性质，<strong>除了情景2，所有插入操作都是在叶子结点进行的</strong>。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。</p><p>在开始每个情景的讲解前，我们还是先来约定下，如图8所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-9ac3d6b69ef7ead3.webp" alt="img"></p><p><center>图8 插入操作结点的叫法约定</center><br>图8的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。</p><p>好了，下面让我们一个一个来分析每个插入的情景以其处理。</p><h5 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h5><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质2：根节点是黑色。还需要把插入结点设为黑色。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h5 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h5><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h5 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h5><p>由于插入的结点是红色的，当插入结点的黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h5 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h5><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><p><strong>插入情景4.1：叔叔结点存在并且为红结点</strong><br> 从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。如图9和图10所示。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-9f2c746bf0769f49.webp" alt="img"></p><p><center>图9 插入情景4.1_1</center><br><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-5374ea3c2956b441.webp" alt="img"></p><p><center>图10 插入情景4.1_2</center><br>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><p><strong>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</strong><br> 单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><p><strong>插入情景4.2.1：插入结点是其父结点的左子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-ab4097b750826870.webp" alt="img"></p><p><center>图11 插入情景4.2.1</center><br>由图11可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把P设为红色，I和PP设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把P设为红色，I和PP设为黑色。但把P设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><p><strong>插入情景4.2.2：插入结点是其父结点的右子结点</strong><br> 这种情景显然可以转换为情景4.2.1，如图12所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-fbfc4f299941cb8b.webp" alt="img"></p><p><center>图12 插入情景4.2.2</center><br><strong>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</strong><br> 该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><p><strong>插入情景4.3.1：插入结点是其父结点的右子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-2bc24a78b68dae51.webp" alt="img"></p><p><center>图13 插入情景4.3.1</center><br><strong>插入情景4.3.2：插入结点是其父结点的右子结点</strong><br> <strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-ee1a9027ddcc210a.webp" alt="img"></p><p><center>图14 插入情景4.3.2</center><br>好了，讲完插入的所有情景了。可能又同学会想：上面的情景举例的都是第一次插入而不包含自底向上处理的情况，那么上面所说的情景都适合自底向上的情况吗？答案是肯定的。理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的。好吧，在出个习题，请大家拿出笔和纸画下试试（请务必动手画下，加深印象）：</p><p><strong>习题1：请画出图15的插入自平衡处理过程。</strong>（答案见文末）</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-28186be7e43be254.webp" alt="img"></p><h2 id="图15-习题1"><a href="#图15-习题1" class="headerlink" title="图15 习题1"></a><center>图15 习题1</center></h2><h4 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h4><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，情景3的后继结点是大于删除结点的最小结点，也是删除结点的右子树种最左结点。那么可以拿前继结点（删除结点的左子树最左结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。如图16所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-dc4f0ab5d111ff96.webp" alt="img"></p><p><center>图16 二叉树投射x轴后有序</center><br>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong>话很苍白，我们看图17。在不看键值对的情况下，图17的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-f45799daa674d0ad.webp" alt="img"></p><p><center>图17 删除结点换位思路</center><br>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图18所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-a48550e315b3b132.webp" alt="img"></p><p><center>图18 二叉树删除情景转换</center><br>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如图19所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-edaf96e55f08c198.webp" alt="img"></p><p><center>图19 红黑树删除情景</center><br>哈哈，是的，即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。同样的，我们还是来约定下，如图20所示。</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-db3468a5977ad998-1582549732988.webp" alt="img"></p><p><center>图20 删除操作结点的叫法约定</center><br>图20的字母并不代表结点Key的大小。R<em>表示替代结点</em>，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h5 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h5><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h5 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h5><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><p><strong>删除情景2.1：替换结点是其父结点的左子结点</strong><br> <strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br> 若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-1e4c3388491b588f.webp" alt="img"></p><p><center>图21 删除情景2.1.1</center><br><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong><br> 当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br> 即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如图22所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-7eea721cbb855876.webp" alt="img"></p><p><center>图22 删除情景2.1.2.1</center><br>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外图2.1.2.1是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br> 兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。图如23所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对S进行右旋，得到情景2.1.2.1</strong></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-dc29605ce9889973.webp" alt="img"></p><p><center>图23 删除情景2.1.2.2</center><br><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br> 好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-75293515d8d87024.webp" alt="img"></p><p><center>图24 情景2.1.2.3</center><br><strong>删除情景2.2：替换结点是其父结点的右子结点</strong><br> 好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br> 处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-387664c771b21f1b.webp" alt="img"></p><p><center>图25 删除情景2.2.1</center><br><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br> <strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br> <strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-b1ea52c823ce0b0b.webp" alt="img"></p><p><center>图26 删除情景2.2.2.1</center><br><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-edcb4ea6ac87e342.webp" alt="img"></p><p><center>图27 删除情景2.2.2.2</center><br><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br> <strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-6559c4cccf3df81c.webp" alt="img"></p><p><center>图28 删除情景2.2.2.3</center><br>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><p>哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～</p><p>最后再做个习题加深理解（请不熟悉的同学务必动手画下）：</p><p><strong>习题2：请画出图29的删除自平衡处理过程。 </strong></p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-d3231b6890ab76a3.webp" alt="img"></p><h2 id="习题2"><a href="#习题2" class="headerlink" title="习题2"></a><center>习题2</center></h2><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>耗时良久，终于写完了～自己加深了红黑树的理解的同时，也希望能帮助大家。如果你之前没学习过红黑树，看完这篇文章后可能还存在很多疑问，如果有疑问可以在评论区写出来，我会尽自己所能解答。另外给大家推荐一个支持红黑树在线生成的网站，来做各种情景梳理很有帮助：<a href="https://sandbox.runjs.cn/show/2nngvn8w" target="_blank" rel="noopener">在线生成红黑树</a>。（删除操作那个把替代结点看作删除结点思路就是我自己在用这个网站时自己顿悟的，我觉得这样讲解更容易理解。）</p><p>少了代码是不是觉得有点空虚？哈哈，后续我会写关于Java和HashMap和TreeMap的文章，里面都有红黑树相关的知识。相信看了这篇文章后，再去看Java和HashMap和TreeMap的源码绝对没难度！</p><p>最后来看下思考题和习题的答案吧。</p><hr><h4 id="思考题和习题答案"><a href="#思考题和习题答案" class="headerlink" title="思考题和习题答案"></a>思考题和习题答案</h4><p><strong><em>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？</em></strong><br> 答：可以。如下图的F结点：</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-3e64f9f3481b209d.webp" alt="img"></p><p><strong><em>习题1：请画出图15的插入自平衡处理过程。</em></strong><br> 答：</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-f4c0891c264a2243.webp" alt="img"></p><p><strong><em>习题2：请画出图29的删除自平衡处理过程。</em></strong><br> 答：</p><p><img src="/2020/02/24/30张图带你彻底理解红黑树/2392382-b037e4c29cbffc4d.webp" alt="img"></p><hr><p>转载自<a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">30张图带你彻底理解红黑树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ &amp;gt;                                                                                - 学红黑树有感。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;终于，在学习了几天的红黑树相关的知识后，我想把我所学所想和所感分享给大家。红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等一连串的问题在学习前困扰着我。如果你在学习过程中也会存在我的疑问，那么本文对你会有帮助，本文帮助你全面、彻底地理解红黑树！&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://vincentruan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://vincentruan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="红黑树" scheme="https://vincentruan.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>[译]StackOverflow: 你没见过的七个最好的Java答案</title>
    <link href="https://vincentruan.github.io/2020/02/24/%E8%AF%91-StackOverflow-%E4%BD%A0%E6%B2%A1%E8%A7%81%E8%BF%87%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84Java%E7%AD%94%E6%A1%88/"/>
    <id>https://vincentruan.github.io/2020/02/24/%E8%AF%91-StackOverflow-%E4%BD%A0%E6%B2%A1%E8%A7%81%E8%BF%87%E7%9A%84%E4%B8%83%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84Java%E7%AD%94%E6%A1%88/</id>
    <published>2020-02-24T07:25:22.000Z</published>
    <updated>2020-02-25T15:09:15.071Z</updated>
    
    <content type="html"><![CDATA[<p>StackOverflow(后边简称so)发展到目前，已经成为了全球开发者的金矿。它能够帮助我们找到在各个领域遇到的问题的最有用的解决方案，同时我们也会从中学习到很多新的东西。这篇文章是在我们审阅了so上最流行的Java问题以及答案后从中挑出来的。即使你是一个有丰富经验的开发者，也能从中学到不少东西。</p><a id="more"></a><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>SO上最多投票的一个Java问题是：<a href="http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array" target="_blank" rel="noopener">为什么处理一个排序数组要比非排序数组快的多</a>。为了回答这个问题，你需要使用分支预测(branch prediction)。分支预测是一种架构，旨在通过在真实的路径发生前猜测某一分支的下一步来提升处理过程。</p><p>分支在这里即一个if语句。这样的话，如果是一个排序数组，那么分支预测将会进行，否则不会进行。<a href="http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902" target="_blank" rel="noopener">Mysticial</a>(so上的一个回答者)试图使用铁路和火车来简单介绍这个概念。假设你在铁轨连接处要决定火车要走哪条路，你会选择左边还是右边？你可以拦住火车，然后问司机该往那里，但是这样会让整个过程变慢。因此你只能去猜正确的方向，那么如何去猜呢？最好的办法就是通过观察目前这个火车每次经过时的路线，推测出正确的方向。</p><p>这就是分支预测：识别模式并使用它。</p><p>不幸的是，这个问题的提问者是分支预测失败的受害者。因为他的分支没有任何可以识别出的模式，所以预测出的行为是随机的。</p><h2 id="Java中的安全"><a href="#Java中的安全" class="headerlink" title="Java中的安全"></a>Java中的安全</h2><p>另一个流行的Java问题是：<a href="http://stackoverflow.com/questions/8881291/why-is-char-preferred-over-string-for-passwords-in-java" target="_blank" rel="noopener">为什么在Java中有关密码的地方更加喜欢使用char[]而不是String</a>？其实原始的问题更加具体一些，就是问的在Swing中，password控件有一个getPassword方法(返回char[]而不是getText()返回的String)。</p><p>其实这里不用惊讶-这是一个安全问题。String是不可变的，意味着一旦它被创建了，那么你就不可能去修改它。这也意味着在GC之前，你对这些数据不能做任何处理。因此，只要有人能够访问你的内存，那么String就有可能被他获取到。</p><p>这也就是为什么要使用char数组。你可以显示地清除数据或者覆盖它。这样密码这种敏感数据即使GC还没有进行也不会再在系统留下痕迹。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>即使很多开发者倾向于忽略对受检异常的处理，SO上仍然有很多关于异常的问题。其中一个最流行的问题是：什么是NullPointerException，我该怎么处理它？对此，我们并没有感到惊讶，因为这个问题也是<a href="http://blog.takipi.com/the-top-10-exceptions-types-in-production-java-applications-based-on-1b-events/" target="_blank" rel="noopener">在生产环境的Java应用中排名第一的异常</a>。</p><p>实际上，当NullPointerException(或者其他exception)在系统出现的时候，我们可以发出一个告警。因为这种异常一般情况下都是业务代码逻辑有问题造成(笔者注)。</p><h2 id="为什么这段代码使用随机字符串打印出了”hello-world”"><a href="#为什么这段代码使用随机字符串打印出了”hello-world”" class="headerlink" title="为什么这段代码使用随机字符串打印出了”hello world”"></a>为什么这段代码使用随机字符串打印出了”hello world”</h2><p>问题链接：<a href="http://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world" target="_blank" rel="noopener">http://stackoverflow.com/questions/15182496/why-does-this-code-using-random-strings-print-hello-world</a></p><p>这个问题给出了下面的代码，并打印出了”hello world”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(randomString(-<span class="number">229985452</span>) + <span class="string">" "</span> + randomString(-<span class="number">147909649</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomString</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    Random ran = <span class="keyword">new</span> Random(i);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = ran.nextInt(<span class="number">27</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        sb.append((<span class="keyword">char</span>)(<span class="string">'`'</span> + k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，选择一组随机的整数并不是随机的。给定一个seed参数(在这个例子中是-229985452和-147909649), 那么每次随机，同样的seed则会产生同样的输出。</p><p>Random(-229985452).nextInt(27)产生的前六个数字：8, 5, 12, 12, 15, 0</p><p>Random(-147909649).nextInt(27)产生的前六个数字：23, 15, 18, 12, 4, 0</p><p>这样，最终输出的就是”hello world”。</p><h2 id="为什么两个时间戳相减-in-1927-得出一个奇怪的结果？"><a href="#为什么两个时间戳相减-in-1927-得出一个奇怪的结果？" class="headerlink" title="为什么两个时间戳相减(in 1927)得出一个奇怪的结果？"></a>为什么两个时间戳相减(in 1927)得出一个奇怪的结果？</h2><p>问题链接：<a href="http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result" target="_blank" rel="noopener">http://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);  </span><br><span class="line">    String str3 = <span class="string">"1927-12-31 23:54:07"</span>;  </span><br><span class="line">    String str4 = <span class="string">"1927-12-31 23:54:08"</span>;  </span><br><span class="line">    Date sDt3 = sf.parse(str3);  </span><br><span class="line">    Date sDt4 = sf.parse(str4);  </span><br><span class="line">    <span class="keyword">long</span> ld3 = sDt3.getTime() /<span class="number">1000</span>;  </span><br><span class="line">    <span class="keyword">long</span> ld4 = sDt4.getTime() /<span class="number">1000</span>;</span><br><span class="line">    System.out.println(ld4-ld3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按说上面的代码最后的结果应该是1，但实际的输出却是353。其实，这是一个时区的问题。1927年12月31号24:00，上海时间往回调整了5分钟52秒，因此”1927-12-31 23:54:08”发生了两次，Java将后面一次实例化成了本地的这个时间。因此和前一秒的差距成了353。</p><p>我们需要指出，如果你试着来运行这段代码，结果并不一定是353。<a href="http://stackoverflow.com/a/6841479/5982245" target="_blank" rel="noopener">Jon Skeet指出了这一点</a>，在时区数据库项目2014版中，这个改变的时间点改到了1900-12-31，因此成了344秒的差距。</p><h2 id="无法被捕获的ChuckNorrisException"><a href="#无法被捕获的ChuckNorrisException" class="headerlink" title="无法被捕获的ChuckNorrisException"></a>无法被捕获的ChuckNorrisException</h2><p>问题链接：<a href="http://stackoverflow.com/questions/13883166/uncatchable-chucknorrisexception" target="_blank" rel="noopener">http://stackoverflow.com/questions/13883166/uncatchable-chucknorrisexception</a></p><p>这里有一个很明显的问题：如果有exception被抛出，但是没有任何办法去catch，那么应用会崩溃吗？或者如这个问题所问：是否可以写一段Java代码让一个假设的java.lang.ChuckNorrisException无法被捕获。</p><p>答案是可以，但是这里有一个”但是”。你可以编译一段代码抛出一个ChuckNorrisException，但是在Runtime时动态生成一个并不继承于Throwable接口的ChuckNorrisException类。当然，为了让这个过程可以进行，你需要关闭掉字节码验证。<a href="http://stackoverflow.com/a/13883510/5982245" target="_blank" rel="noopener">jtahlborn</a>给出了完整的解决办法。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是另外一个在SO上流行的问题系列。许多用户都想要知道所有集合类之间的区别，什么时候该使用哪种集合。</p><p>迭代顺序是主要考虑的因素。使用HashMap则忽略了所有的顺序信息，也就是获取元素的顺序和你插入元素的顺序是没有任何关系的；使用TreeMap则会得到一个排序好的迭代集合；使用LinkedHashMap则是一个FIFO的顺序。</p><p>如果你还是对这些感到困惑，这里有一个相关说明的图表可以<a href="http://zeroturnaround.com/wp-content/uploads/2016/04/Java-Collections-cheat-sheet.png" target="_blank" rel="noopener">参考</a>(Rebel Labs制作)。</p><p><img src="/2020/02/24/译-StackOverflow-你没见过的七个最好的Java答案/Java-Collections-cheat-sheet.png" alt="Java-Collections-cheat-sheet"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于Java，其实关键的不在于你懂多少，而是在于你可以一直学到更多的东西。StackOverflow不仅在code上的一些问题可以帮助我们，也有助于我们回过头来去深入地学习一些我们已经知道的知识。</p><blockquote><p>转载文章<br>原文：<a href="https://dzone.com/articles/stackoverflow-7-of-the-best-java-answers-that-you" target="_blank" rel="noopener">https://dzone.com/articles/stackoverflow-7-of-the-best-java-answers-that-you</a><br>译文: <a href="https://www.rowkey.me/blog/2016/08/03/so-java-7-answers/" target="_blank" rel="noopener">https://www.rowkey.me/blog/2016/08/03/so-java-7-answers/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;StackOverflow(后边简称so)发展到目前，已经成为了全球开发者的金矿。它能够帮助我们找到在各个领域遇到的问题的最有用的解决方案，同时我们也会从中学习到很多新的东西。这篇文章是在我们审阅了so上最流行的Java问题以及答案后从中挑出来的。即使你是一个有丰富经验的开发者，也能从中学到不少东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/tags/Java/"/>
    
      <category term="StackOverflow" scheme="https://vincentruan.github.io/tags/StackOverflow/"/>
    
  </entry>
  
  <entry>
    <title>Java性能优化和JVM GC（垃圾回收机制）详解</title>
    <link href="https://vincentruan.github.io/2020/02/24/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CJVM-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
    <id>https://vincentruan.github.io/2020/02/24/Java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8CJVM-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-24T06:42:01.000Z</published>
    <updated>2020-02-25T15:09:15.043Z</updated>
    
    <content type="html"><![CDATA[<p>Java的性能优化，JVM GC（垃圾回收机制）在学习Java GC 之前，我们需要记住一个单词：stop-the-world 。它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。</p><a id="more"></a><h1 id="JVM-GC回收哪个区域内的垃圾？"><a href="#JVM-GC回收哪个区域内的垃圾？" class="headerlink" title="JVM GC回收哪个区域内的垃圾？"></a><strong>JVM GC回收哪个区域内的垃圾？</strong></h1><p>需要注意的是，JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。</p><h1 id="JVM-GC怎么判断对象可以被回收了？"><a href="#JVM-GC怎么判断对象可以被回收了？" class="headerlink" title="JVM GC怎么判断对象可以被回收了？"></a><strong>JVM GC怎么判断对象可以被回收了？</strong></h1><ul><li><p>对象没有引用</p></li><li><p>作用域发生未捕获异常</p></li><li><p>程序在作用域正常执行完毕</p></li><li><p>程序执行了System.exit()</p></li><li><p>程序发生意外终止（被杀线程等）</p></li></ul><p>在Java程序中不能显式的分配和注销缓存，因为这些事情JVM都帮我们做了，那就是GC。</p><p>有些时候我们可以将相关的对象设置成null 来试图显示的清除缓存，但是并不是设置为null 就会一定被标记为可回收，有可能会发生逃逸。</p><p>将对象设置成null 至少没有什么坏处，但是使用System.gc() 便不可取了，使用System.gc() 时候并不是马上执行GC操作，而是会等待一段时间，甚至不执行，而且System.gc() 如果被执行，会触发Full GC ，这非常影响性能。</p><h1 id="JVM-GC什么时候执行？"><a href="#JVM-GC什么时候执行？" class="headerlink" title="JVM GC什么时候执行？"></a><strong>JVM GC什么时候执行？</strong></h1><p>eden区空间不够存放新对象的时候，执行Minro GC。升到老年代的对象大于老年代剩余空间的时候执行Full GC，或者小于的时候被HandlePromotionFailure 参数强制Full GC 。调优主要是减少 Full GC 的触发次数，可以通过 NewRatio 控制新生代转老年代的比例，通过MaxTenuringThreshold 设置对象进入老年代的年龄阀值（后面会介绍到）。</p><h1 id="按代的垃圾回收机制"><a href="#按代的垃圾回收机制" class="headerlink" title="按代的垃圾回收机制"></a><strong>按代的垃圾回收机制</strong></h1><p>新生代（Young generation）：绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：Minor GC 。</p><p>老年代（Old generation）：对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC 或者 Full GC。</p><p>持久代（Permanent generation）也称之为 方法区（Method area）：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Major GC 。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收：</p><ol><li>所有实例被回收</li><li>加载该类的ClassLoader 被回收</li><li>Class 对象无法通过任何途径访问（包括反射）</li></ol><p>可能我们会有疑问：</p><p>如果老年代的对象需要引用新生代的对象，会发生什么呢？</p><p>为了解决这个问题，老年代中存在一个 card table ，它是一个512byte大小的块。所有老年代的对象指向新生代对象的引用都会被记录在这个表中。当针对新生代执行GC的时候，只需要查询 card table 来决定是否可以被回收，而不用查询整个老年代。这个 card table 由一个write barrier 来管理。write barrier给GC带来了很大的性能提升，虽然由此可能带来一些开销，但完全是值得的。</p><blockquote><p>默认的新生代（Young generation）、老年代（Old generation）所占空间比例为 1 : 2 。</p></blockquote><h1 id="新生代空间的构成与逻辑"><a href="#新生代空间的构成与逻辑" class="headerlink" title="新生代空间的构成与逻辑"></a><strong>新生代空间的构成与逻辑</strong></h1><p>为了更好的理解GC，我们来学习新生代的构成，它用来保存那些第一次被创建的对象，它被分成三个空间：</p><ul><li><p>一个伊甸园空间（Eden）</p></li><li><p>两个幸存者空间（Fron Survivor、To Survivor）</p></li></ul><p>默认新生代空间的分配：<code>Eden : Fron : To = 8 : 1 : 1</code></p><p>每个空间的执行顺序如下：</p><ol><li>绝大多数刚刚被创建的对象会存放在伊甸园空间（Eden）。</li><li>在伊甸园空间执行第一次GC（Minor GC）之后，存活的对象被移动到其中一个幸存者空间（Survivor）。</li><li>此后，每次伊甸园空间执行GC后，存活的对象会被堆积在同一个幸存者空间。</li><li>当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。然后会清空已经饱和的哪个幸存者空间。</li><li>在以上步骤中重复N次（N = MaxTenuringThreshold（年龄阀值设定，默认15））依然存活的对象，就会被移动到老年代。</li></ol><p>从上面的步骤可以发现，两个幸存者空间，必须有一个是保持空的。如果两个两个幸存者空间都有数据，或两个空间都是空的，那一定是你的系统出现了某种错误。</p><p>我们需要重点记住的是，对象在刚刚被创建之后，是保存在伊甸园空间的（Eden）。那些长期存活的对象会经由幸存者空间（Survivor）转存到老年代空间（Old generation）。</p><p>也有例外出现，对于一些比较大的对象（需要分配一块比较大的连续内存空间）则直接进入到老年代。一般在Survivor 空间不足的情况下发生。</p><h1 id="老年代空间的构成与逻辑"><a href="#老年代空间的构成与逻辑" class="headerlink" title="老年代空间的构成与逻辑"></a>老年代空间的构成与逻辑</h1><p>老年代空间的构成其实很简单，它不像新生代空间那样划分为几个区域，它只有一个区域，里面存储的对象并不像新生代空间绝大部分都是朝闻道，夕死矣。这里的对象几乎都是从Survivor 空间中熬过来的，它们绝不会轻易的狗带。因此，Full GC（Major GC）发生的次数不会有Minor GC 那么频繁，并且做一次Major GC 的时间比Minor GC 要更长（约10倍）。</p><h1 id="JVM-GC-算法讲解"><a href="#JVM-GC-算法讲解" class="headerlink" title="JVM GC 算法讲解"></a>JVM GC 算法讲解</h1><h2 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h2><p>根搜索算法是从离散数学中的图论引入的，程序把所有引用关系看作一张图，从一个节点GC ROOT 开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145513084.png" alt="image-20200224145513084"></p><p>上图红色为无用的节点，可以被回收。</p><p>目前Java中可以作为GC ROOT的对象有：</p><ol><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ol><p>基本所有GC算法都引用根搜索算法这种概念。</p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><p>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象进行直接回收，如上图。</p><p>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活的对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，并没有对还存活的对象进行整理，因此会导致内存碎片。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145555734.png" alt="image-20200224145555734">复制算法将内存划分为两个区间，使用此算法时，所有动态分配的对象都只能分配在其中一个区间（活动区间），而另外一个区间（空间区间）则是空闲的。</p><p>复制算法采用从根集合扫描，将存活的对象复制到空闲区间，当扫描完毕活动区间后，会的将活动区间一次性全部回收。此时原本的空闲区间变成了活动区间。下次GC时候又会重复刚才的操作，以此循环。</p><p>复制算法在存活对象比较少的时候，极为高效，但是带来的成本是牺牲一半的内存空间用于进行对象的移动。所以复制算法的使用场景，必须是对象的存活率非常低才行，而且最重要的是，我们需要克服50%内存的浪费。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h2><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145614350.png" alt="image-20200224145614350">标记-整理算法采用 <code>标记-清除</code> 算法一样的方式进行对象的标记、清除，但在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。标记-整理 算法是在标记-清除 算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><p>JVM为了优化内存的回收，使用了分代回收的方式，对于新生代内存的回收（Minor GC）主要采用复制算法。而对于老年代的回收（Major GC），大多采用标记-整理算法。</p><h1 id="垃圾回收器简介"><a href="#垃圾回收器简介" class="headerlink" title="垃圾回收器简介"></a>垃圾回收器简介</h1><p>需要注意的是，每一个回收器都存在Stop The World 的问题，只不过各个回收器在Stop The World 时间优化程度、算法的不同，可根据自身需求选择适合的回收器。</p><h2 id="Serial（-XX-UseSerialGC）"><a href="#Serial（-XX-UseSerialGC）" class="headerlink" title="Serial（-XX:+UseSerialGC）"></a>Serial（-XX:+UseSerialGC）</h2><p>从名字我们可以看出，这是一个串行收集器。</p><p>Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需暂停所有的用户线程，直到回收结束。</p><p>使用算法：复制算法</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145650521.png" alt="image-20200224145650521">JVM中文名称为Java虚拟机，因此它像一台虚拟的电脑在工作，而其中的每一个线程都被认为是JVM的一个处理器，因此图中的CPU0、CPU1实际上为用户的线程，而不是真正的机器CPU，不要误解哦。</p><p>Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。</p><h2 id="SerialOld（-XX-UseSerialGC）"><a href="#SerialOld（-XX-UseSerialGC）" class="headerlink" title="SerialOld（-XX:+UseSerialGC）"></a>SerialOld（-XX:+UseSerialGC）</h2><p>SerialOld是Serial收集器的老年代收集器版本，它同样是一个单线程收集器，这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。</p><p>使用算法：标记 - 整理算法</p><p>运行示意图与上图一致。</p><h2 id="ParNew（-XX-UseParNewGC）"><a href="#ParNew（-XX-UseParNewGC）" class="headerlink" title="ParNew（-XX:+UseParNewGC）"></a>ParNew（-XX:+UseParNewGC）</h2><p>ParNew其实就是Serial收集器的多线程版本。除了Serial收集器外，只有它能与CMS收集器配合工作。</p><p>使用算法：复制算法</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145719526.png" alt="image-20200224145719526"></p><p>ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。</p><h2 id="ParallelScavenge（-XX-UseParallelGC）"><a href="#ParallelScavenge（-XX-UseParallelGC）" class="headerlink" title="ParallelScavenge（-XX:+UseParallelGC）"></a><strong>ParallelScavenge（-XX:+UseParallelGC）</strong></h2><p>ParallelScavenge又被称为吞吐量优先收集器，和ParNew 收集器类似，是一个新生代收集器。</p><p>使用算法：复制算法</p><p>ParallelScavenge收集器的目标是达到一个可控件的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。如果虚拟机总共运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99% 。</p><h2 id="ParallelOld（-XX-UseParallelOldGC）"><a href="#ParallelOld（-XX-UseParallelOldGC）" class="headerlink" title="ParallelOld（-XX:+UseParallelOldGC）"></a><strong>ParallelOld（-XX:+UseParallelOldGC）</strong></h2><p>ParallelOld是并行收集器，和SerialOld一样，ParallelOld是一个老年代收集器，是老年代吞吐量优先的一个收集器。这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，“吞吐量优先”收集器才名副其实！</p><p>使用算法：标记 - 整理算法</p><p><img src="/2020/02/24/Java性能优化和JVM-GC（垃圾回收机制）详解/image-20200224145812172.png" alt="image-20200224145812172"></p><p>在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。</p><h2 id="CMS-（-XX-UseConcMarkSweepGC）"><a href="#CMS-（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS （-XX:+UseConcMarkSweepGC）"></a><strong>CMS （-XX:+UseConcMarkSweepGC）</strong></h2><p>CMS是一个老年代收集器，全称 Concurrent Low Pause Collector，是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于响应时间的重要性需求大于吞吐量要求的收集器。对于要求服务器响应速度高的情况下，使用CMS非常合适。</p><p>CMS的一大特点，就是用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停。</p><p>使用算法：<code>标记 - 清理</code></p><p>CMS的执行过程如下：</p><p><strong>· 初始标记（STW initial mark）</strong></p><p>在这个阶段，需要虚拟机停顿正在执行的应用线程，官方的叫法STW（Stop Tow World）。这个过程从根对象扫描直接关联的对象，并作标记。这个过程会很快的完成。</p><p><strong>· 并发标记（Concurrent marking）</strong></p><p>这个阶段紧随初始标记阶段，在“初始标记”的基础上继续向下追溯标记。注意这里是并发标记，表示用户线程可以和GC线程一起并发执行，这个阶段不会暂停用户的线程哦。</p><p>· 并发预清理（Concurrent precleaning）</p><p>这个阶段任然是并发的，JVM查找正在执行“并发标记”阶段时候进入老年代的对象（可能这时会有对象从新生代晋升到老年代，或被分配到老年代）。通过重新扫描，减少在一个阶段“重新标记”的工作，因为下一阶段会STW。</p><p><strong>· 重新标记（STW remark）</strong></p><p>这个阶段会再次暂停正在执行的应用线程，重新重根对象开始查找并标记并发阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致），并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记。</p><p><strong>· 并发清理（Concurrent sweeping）</strong></p><p>这个阶段是并发的，应用线程和GC清除线程可以一起并发执行。</p><p><strong>· 并发重置（Concurrent reset）</strong></p><p>这个阶段任然是并发的，重置CMS收集器的数据结构，等待下一次垃圾回收。</p><p><strong>CMS的缺点：</strong></p><p>1、内存碎片。由于使用了 标记-清理 算法，导致内存空间中会产生内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。但是内存碎片的问题依然存在，如果一个对象需要3块连续的空间来存储，因为内存碎片的原因，寻找不到这样的空间，就会导致Full GC。</p><p>2、需要更多的CPU资源。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，这样就需要占用更多的CPU资源，也是牺牲了一定吞吐量的原因。</p><p>3、需要更大的堆空间。因为CMS标记阶段应用程序的线程还是执行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，必须预留一部分空间。CMS默认在老年代空间使用68%时候启动垃圾回收。可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。</p><h2 id="GarbageFirst（G1）"><a href="#GarbageFirst（G1）" class="headerlink" title="GarbageFirst（G1）"></a><strong>GarbageFirst（G1）</strong></h2><p>这是一个新的垃圾回收器，既可以回收新生代也可以回收老年代，SunHotSpot1.6u14以上EarlyAccess版本加入了这个回收器，Sun公司预期SunHotSpot1.7发布正式版本。通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。杯具的是Oracle收购这个收集器之后将其用于商用收费版收集器。因此目前暂时没有发现哪个公司使用它，这个放在之后再去研究吧。</p><p>整理一下新生代和老年代的收集器。</p><p><strong>新生代收集器：</strong></p><ul><li><p>Serial （-XX:+UseSerialGC）</p></li><li><p>ParNew（-XX:+UseParNewGC）</p></li><li><p>ParallelScavenge（-XX:+UseParallelGC）</p></li><li><p>G1 收集器</p></li></ul><p><strong>老年代收集器：</strong></p><ul><li><p>SerialOld（-XX:+UseSerialOldGC）</p></li><li><p>ParallelOld（-XX:+UseParallelOldGC）</p></li><li><p>CMS（-XX:+UseConcMarkSweepGC）</p></li><li><p>G1 收集器</p></li></ul><h2 id="调优jvm参数介绍"><a href="#调优jvm参数介绍" class="headerlink" title="调优jvm参数介绍"></a><strong>调优jvm参数介绍</strong></h2><p>堆设置</p><ul><li><p>-Xmx3550m：设置JVM最大堆内存 为3550M。</p></li><li><p>-Xms3550m：设置JVM初始堆内存 为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p></li><li><p>-Xss128k：设置每个线程的栈 大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能 生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></li><li><p>-Xmn2g：设置堆内存年轻代 大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p></li><li><p>-XX:PermSize=256M：设置堆内存持久代 初始值为256M。(貌似是Eclipse等IDE的初始化参数)</p></li><li><p>-XX:MaxNewSize=size：新生成的对象能占用内存的最大值。</p></li><li><p>-XX:MaxPermSize=512M：设置持久代最大值为512M。</p></li><li><p>-XX:NewRatio=4：设置堆内存年轻代（包括Eden和两个Survivor区）与堆内存年老代的比值（除去持久代） 。设置为4，则年轻代所占与年老代所占的比值为1:4。</p></li><li><p>-XX:SurvivorRatio=4：设置堆内存年轻代中Eden区与Survivor区大小的比值 。设置为4，则两个Survivor区（JVM堆内存年轻代中默认有2个Survivor区）与一个Eden区的比值为2:4，一个Survivor区占 整个年轻代的1/6。</p></li><li><p>-XX:MaxTenuringThreshold=7：表示一个对象如果在救助空间（Survivor区）移动7次还没有被回收就放入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于年老代比较多的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代即被回收的概率。</p></li></ul><p>回收器选择JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。</p><p>默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p><h2 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a><strong>串行收集器</strong></h2><ul><li>-XX:+UseSerialGC：设置串行收集器</li></ul><h2 id="并行收集器-吞吐量优先"><a href="#并行收集器-吞吐量优先" class="headerlink" title="并行收集器(吞吐量优先)"></a>并行收集器(吞吐量优先)</h2><ul><li><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</p></li><li><p>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p></li><li><p>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p></li><li><p>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒），如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p></li><li><p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等。</p></li></ul><p>此参数建议使用并行收集器时，一直打开。</p><h2 id="并发收集器-响应时间优先"><a href="#并发收集器-响应时间优先" class="headerlink" title="并发收集器(响应时间优先)"></a>并发收集器(响应时间优先)</h2><ul><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li></ul><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>全称Concurrent Low Pause Collector，是jdk1.4后期版本开始引入的新gc算法，在jdk5和jdk6中得到了进一步改进，它的主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用。CMS是用于对tenured generation的回收，也就是年老代的回收，目标是尽量减少应用的暂停时间，减少FullGC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代。</p><ul><li><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction=：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此参数设置运行次FullGC以后对内存空间进行压缩、整理。</p></li><li><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除内存碎片。</p></li><li><p>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</p></li><li><p>-XX:CMSInitiatingOccupancyFraction=70：表示年老代空间到70%时就开始执行CMS，确保年老代有足够的空间接纳来自年轻代的对象。</p></li></ul><p>注：如果使用 throughput collector 和 concurrent low pause collector 这两种垃圾收集器，需要适当的挺高内存大小，为多线程做准备。</p><p>其它</p><ul><li><p>-XX:+ScavengeBeforeFullGC：新生代GC优先于Full GC执行。</p></li><li><p>-XX:-DisableExplicitGC：禁止调用System.gc()，但JVM的gc仍然有效。</p></li><li><p>-XX:+MaxFDLimit：最大化文件描述符的数量限制。</p></li><li><p>-XX:+UseThreadPriorities：启用本地线程优先级API，即使 java.lang.Thread.setPriority() 生效，反之无效。</p></li><li><p>-XX:SoftRefLRUPolicyMSPerMB=0：“软引用”的对象在最后一次被访问后能存活0毫秒（默认为1秒）。</p></li><li><p>-XX:TargetSurvivorRatio=90：允许90%的Survivor空间被占用（默认为50%）。提高对于Survivor的使用率——超过就会尝试垃圾回收。</p></li></ul><p><strong>辅助信息</strong></p><ul><li><p>-XX:-CITime：打印消耗在JIT编译的时间</p></li><li><p>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或者数据到指定文件中</p></li><li><p>-XX:-ExtendedDTraceProbes：开启solaris特有的dtrace探针</p></li><li><p>-XX:HeapDumpPath=./java_pid.hprof：指定导出堆信息时的路径或文件名</p></li><li><p>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时导出此时堆中相关信息</p></li><li><p>-XX:OnError=”;”：出现致命ERROR之后运行自定义命令</p></li><li><p>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令</p></li><li><p>-XX:-PrintClassHistogram：遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同</p></li><li><p>-XX:-PrintConcurrentLocks：遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同</p></li><li><p>-XX:-PrintCommandLineFlags：打印在命令行中出现过的标记</p></li><li><p>-XX:-PrintCompilation：当一个方法被编译时打印相关信息</p></li><li><p>-XX:-PrintGC：每次GC时打印相关信息</p></li><li><p>-XX:-PrintGC Details：每次GC时打印详细信息</p></li><li><p>-XX:-PrintGCTimeStamps：打印每次GC的时间戳</p></li><li><p>-XX:-TraceClassLoading：跟踪类的加载信息</p></li><li><p>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息</p></li><li><p>-XX:-TraceClassResolution：跟踪常量池</p></li><li><p>-XX:-TraceClassUnloading：跟踪类的卸载信息</p></li><li><p>-XX:-TraceLoaderConstraints：跟踪类加载器约束的相关信息</p></li></ul><h1 id="JVM服务调优实战"><a href="#JVM服务调优实战" class="headerlink" title="JVM服务调优实战"></a><strong>JVM服务调优实战</strong></h1><p>服务器：8 cup, 8G mem</p><p>e.g.</p><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><h2 id="调优方案："><a href="#调优方案：" class="headerlink" title="调优方案："></a><strong>调优方案：</strong></h2><p>-Xmx5g：设置JVM最大可用内存为5G。</p><p>-Xms5g：设置JVM初始内存为5G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>-Xmn2g：设置年轻代大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-XX:+UseParNewGC：设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p><p>-XX:ParallelGCThreads=8：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p><p>-XX:SurvivorRatio=6：设置年轻代中Eden区与Survivor区的大小比值。根据经验设置为6，则两个Survivor区与一个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。</p><p>-XX:MaxTenuringThreshold=30：设置垃圾最大年龄（次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值 设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。设置为30表示 一个对象如果在Survivor空间移动30次还没有被回收就放入年老代。</p><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试配置这个参数以后，参数-XX:NewRatio=4就失效了，所以，此时年轻代大小最好用-Xmn设置，因此这个参数不建议使用。</p><h1 id="参考资料-JVM堆内存的分代"><a href="#参考资料-JVM堆内存的分代" class="headerlink" title="参考资料 - JVM堆内存的分代"></a><strong>参考资料 - JVM堆内存的分代</strong></h1><p>虚拟机的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集器要收集的Java对象关系不大。所以，年轻代和年老代的划分才是对垃圾 收集影响比较大的。</p><h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a><strong>年轻代</strong></h2><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。</p><p>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满 时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存 活的对象，将被复制“年老区(Tenured)”。</p><p>需要注意，两个Survivor区是对称的，没先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个 Survivor区复制过来的对象；而复制到年老区的只有从前一个Survivor区（相对的）过来的对象。而且，Survivor区总有一个是空的。特 殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><h2 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a><strong>年老代</strong></h2><p>在年轻代中经历了N（可配置）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><h2 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a><strong>持久代</strong></h2><p>用于存放静态数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些Class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。持久代大小通过 -XX:MaxPermSize= 进行设置。1.8已经移除改为metaspace。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java的性能优化，JVM GC（垃圾回收机制）在学习Java GC 之前，我们需要记住一个单词：stop-the-world 。它会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而停止了应用程序的执行。当stop-the-world 发生时，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://vincentruan.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://vincentruan.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper入门摘要</title>
    <link href="https://vincentruan.github.io/2020/02/14/zookeeper%E5%85%A5%E9%97%A8%E6%91%98%E8%A6%81/"/>
    <id>https://vincentruan.github.io/2020/02/14/zookeeper%E5%85%A5%E9%97%A8%E6%91%98%E8%A6%81/</id>
    <published>2020-02-14T10:01:16.000Z</published>
    <updated>2020-02-25T15:09:15.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ZooKeeper是什么？"><a href="#1-ZooKeeper是什么？" class="headerlink" title="1.ZooKeeper是什么？"></a>1.ZooKeeper是什么？</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p><p>有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。</p><a id="more"></a><h2 id="2-ZooKeeper提供了什么？"><a href="#2-ZooKeeper提供了什么？" class="headerlink" title="2.ZooKeeper提供了什么？"></a>2.ZooKeeper提供了什么？</h2><p>1、文件系统</p><p>2、通知机制</p><h2 id="3-Zookeeper文件系统"><a href="#3-Zookeeper文件系统" class="headerlink" title="3.Zookeeper文件系统"></a>3.Zookeeper文件系统</h2><p>Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。</p><h2 id="4-四种类型的znode"><a href="#4-四种类型的znode" class="headerlink" title="4.四种类型的znode"></a>4.四种类型的znode</h2><h3 id="1、PERSISTENT-持久化目录节点"><a href="#1、PERSISTENT-持久化目录节点" class="headerlink" title="1、PERSISTENT-持久化目录节点"></a>1、PERSISTENT-持久化目录节点</h3><p>客户端与zookeeper断开连接后，该节点依旧存在</p><h3 id="2、PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点"><a href="#2、PERSISTENT-SEQUENTIAL-持久化顺序编号目录节点" class="headerlink" title="2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点"></a>2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</h3><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><h3 id="3、EPHEMERAL-临时目录节点"><a href="#3、EPHEMERAL-临时目录节点" class="headerlink" title="3、EPHEMERAL-临时目录节点"></a>3、EPHEMERAL-临时目录节点</h3><p>客户端与zookeeper断开连接后，该节点被删除</p><h3 id="4、EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点"><a href="#4、EPHEMERAL-SEQUENTIAL-临时顺序编号目录节点" class="headerlink" title="4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点"></a>4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</h3><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><p><img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zk_dir_tree.png" alt></p><h2 id="5-Zookeeper通知机制"><a href="#5-Zookeeper通知机制" class="headerlink" title="5.Zookeeper通知机制"></a>5.Zookeeper通知机制</h2><p>client端会对某个znode建立一个watcher事件，当该znode发生变化时，这些client会收到zk的通知，然后client可以根据znode变化来做出业务上的改变等。</p><h2 id="6-Zookeeper做了什么？"><a href="#6-Zookeeper做了什么？" class="headerlink" title="6.Zookeeper做了什么？"></a>6.Zookeeper做了什么？</h2><p>1、命名服务</p><p>2、配置管理</p><p>3、集群管理</p><p>4、分布式锁</p><p>5、队列管理</p><h2 id="7-zk的命名服务（文件系统）"><a href="#7-zk的命名服务（文件系统）" class="headerlink" title="7.zk的命名服务（文件系统）"></a>7.zk的命名服务（文件系统）</h2><p>命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><h2 id="8-zk的配置管理（文件系统、通知机制）"><a href="#8-zk的配置管理（文件系统、通知机制）" class="headerlink" title="8.zk的配置管理（文件系统、通知机制）"></a>8.zk的配置管理（文件系统、通知机制）</h2><p>程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p><h2 id="9-Zookeeper集群管理（文件系统、通知机制）"><a href="#9-Zookeeper集群管理（文件系统、通知机制）" class="headerlink" title="9.Zookeeper集群管理（文件系统、通知机制）"></a>9.Zookeeper集群管理（文件系统、通知机制）</h2><p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。</p><p>对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。</p><p>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p><h2 id="10-Zookeeper分布式锁（文件系统、通知机制）"><a href="#10-Zookeeper分布式锁（文件系统、通知机制）" class="headerlink" title="10.Zookeeper分布式锁（文件系统、通知机制）"></a>10.Zookeeper分布式锁（文件系统、通知机制）</h2><p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。</p><p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。</p><p>对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p><h2 id="11-获取分布式锁的流程"><a href="#11-获取分布式锁的流程" class="headerlink" title="11.获取分布式锁的流程"></a>11.获取分布式锁的流程</h2><p> <img src="/2020/02/14/zookeeper入门摘要/zookeeper_locker_directory.png" alt="获取分布式锁的流程"></p><p>在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。</p><p> <img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zookeeper_get_lock_flow.png" alt="获取分布式锁的流程"></p><p>代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper实现分布式锁的细节。</p><h2 id="12-Zookeeper队列管理（文件系统、通知机制）"><a href="#12-Zookeeper队列管理（文件系统、通知机制）" class="headerlink" title="12.Zookeeper队列管理（文件系统、通知机制）"></a>12.Zookeeper队列管理（文件系统、通知机制）</h2><p>两种类型的队列：</p><p>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。</p><p>2、队列按照 FIFO 方式进行入队和出队操作。</p><p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。</p><p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p><h2 id="13-Zookeeper数据复制"><a href="#13-Zookeeper数据复制" class="headerlink" title="13.Zookeeper数据复制"></a>13.Zookeeper数据复制</h2><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：</p><p>1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；</p><p>2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；</p><p>3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。</p><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种：</p><p>1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；</p><p>2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。</p><p>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p><h2 id="14-Zookeeper工作原理"><a href="#14-Zookeeper工作原理" class="headerlink" title="14.Zookeeper工作原理"></a>14.Zookeeper工作原理</h2><p>Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</p><h2 id="15-zookeeper是如何保证事务的顺序一致性的？"><a href="#15-zookeeper是如何保证事务的顺序一致性的？" class="headerlink" title="15.zookeeper是如何保证事务的顺序一致性的？"></a>15.zookeeper是如何保证事务的顺序一致性的？</h2><p>zookeeper采用了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h2 id="16-Zookeeper-下-Server工作状态"><a href="#16-Zookeeper-下-Server工作状态" class="headerlink" title="16.Zookeeper 下 Server工作状态"></a>16.Zookeeper 下 Server工作状态</h2><p>每个Server在工作过程中有三种状态：</p><p>LOOKING：当前Server不知道leader是谁，正在搜寻</p><p>LEADING：当前Server即为选举出来的leader</p><p>FOLLOWING：leader已经选举出来，当前Server与之同步</p><h2 id="17-zookeeper是如何选取主leader的？"><a href="#17-zookeeper是如何选取主leader的？" class="headerlink" title="17.zookeeper是如何选取主leader的？"></a>17.zookeeper是如何选取主leader的？</h2><p>当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。</p><p>1、Zookeeper选主流程(basic paxos)</p><p>（1）选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</p><p>（2）选举线程首先向所有Server发起一次询问(包括自己)；</p><p>（3）选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中；</p><p>（4）收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</p><p>（5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。</p><p><img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zk_epoch.png" alt></p><p>2、Zookeeper选主流程(basic paxos) fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。</p><p><img src="/2020/02/14/zookeeper入门摘要/zookeeper入门摘要-zookeeper_elect_master.png" alt="img"></p><h2 id="18-Zookeeper同步流程"><a href="#18-Zookeeper同步流程" class="headerlink" title="18.Zookeeper同步流程"></a>18.Zookeeper同步流程</h2><p>选完Leader以后，zk就进入状态同步过程。</p><p>1、Leader等待server连接；</p><p>2、Follower连接leader，将最大的zxid发送给leader；</p><p>3、Leader根据follower的zxid确定同步点；</p><p>4、完成同步后通知follower 已经成为uptodate状态；</p><p>5、Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</p><pre class="mermaid">sequenceDiagram    participant L as Leader    participant F as Follower    F->>L: 1.Fllower连接Leader，发送最大zxid    L->>F: 2.Leader确定同步点，发送同步消息    F->>L: 3.完成同步，通知Leader，并修改自身状态</pre><h2 id="19-分布式通知和协调"><a href="#19-分布式通知和协调" class="headerlink" title="19.分布式通知和协调"></a>19.分布式通知和协调</h2><p>对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。</p><p>对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</p><h2 id="20-机器中为什么会有leader？"><a href="#20-机器中为什么会有leader？" class="headerlink" title="20.机器中为什么会有leader？"></a>20.机器中为什么会有leader？</h2><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行leader选举。</p><h2 id="21-zk节点宕机如何处理？"><a href="#21-zk节点宕机如何处理？" class="headerlink" title="21.zk节点宕机如何处理？"></a>21.zk节点宕机如何处理？</h2><p>Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。</p><p>如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；</p><p>如果是一个Leader宕机，Zookeeper会选举出新的Leader。</p><p>ZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p><p>所以</p><p>3个节点的cluster可以挂掉1个节点(leader可以得到2票&gt;1.5)</p><p>2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票&lt;=1)</p><h2 id="22-zookeeper负载均衡和nginx负载均衡区别"><a href="#22-zookeeper负载均衡和nginx负载均衡区别" class="headerlink" title="22.zookeeper负载均衡和nginx负载均衡区别"></a>22.zookeeper负载均衡和nginx负载均衡区别</h2><p>zk的负载均衡是可以调控，nginx只是能调权重，其他需要可控的都需要自己写插件；但是nginx的吞吐量比zk大很多，应该说按业务选择用哪种方式。</p><h2 id="23-zookeeper-watch机制"><a href="#23-zookeeper-watch机制" class="headerlink" title="23.zookeeper watch机制"></a>23.zookeeper watch机制</h2><p>Watch机制官方声明：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。</p><p>Zookeeper机制的特点：</p><p>1、一次性触发数据发生改变时，一个watcher event会被发送到client，但是client只会收到一次这样的信息。</p><p>2、watcher event异步发送watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用Zookeeper不能期望能够监控到节点每次的变化。Zookeeper只能保证最终的一致性，而无法保证强一致性。</p><p>3、数据监视Zookeeper有数据监视和子数据监视getdata() and exists()设置数据监视，getchildren()设置了子节点监视。</p><p>4、注册watcher getData、exists、getChildren</p><p>5、触发watcher create、delete、setData</p><p>6、setData()会触发znode上设置的data watch（如果set成功的话）。一个成功的create() 操作会触发被创建的znode上的数据watch，以及其父节点上的child watch。而一个成功的delete()操作将会同时触发一个znode的data watch和child watch（因为这样就没有子节点了），同时也会触发其父节点的child watch。</p><p>7、当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</p><p>8、Watch是轻量级的，其实就是本地JVM的Callback，服务器端只是存了是否有设置了Watcher的布尔类型</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-ZooKeeper是什么？&quot;&gt;&lt;a href=&quot;#1-ZooKeeper是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.ZooKeeper是什么？&quot;&gt;&lt;/a&gt;1.ZooKeeper是什么？&lt;/h2&gt;&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。&lt;/p&gt;
&lt;p&gt;客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。&lt;/p&gt;
&lt;p&gt;有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构设计" scheme="https://vincentruan.github.io/categories/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="zookeeper" scheme="https://vincentruan.github.io/tags/zookeeper/"/>
    
      <category term="分布式" scheme="https://vincentruan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis中的九种设计模式</title>
    <link href="https://vincentruan.github.io/2020/02/12/MyBatis%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://vincentruan.github.io/2020/02/12/MyBatis%E4%B8%AD%E7%9A%84%E4%B9%9D%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-12T08:54:07.000Z</published>
    <updated>2020-02-25T15:09:15.047Z</updated>
    
    <content type="html"><![CDATA[<p>虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。</p><a id="more"></a><p>Mybatis至少遇到了以下的设计模式的使用：</p><ol><li>Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；</li><li>工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；</li><li>单例模式，例如ErrorContext和LogFactory；</li><li>代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；</li><li>组合模式，例如SqlNode和各个子类ChooseSqlNode等；</li><li>模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；</li><li>适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；</li><li>装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；</li><li>迭代器模式，例如迭代器模式PropertyTokenizer；</li></ol><h3 id="1、Builder模式"><a href="#1、Builder模式" class="headerlink" title="1、Builder模式"></a>1、Builder模式</h3><p>Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5cThHeThva0Rvc3dNQ3FnQkw3Q21tN2ljSkFlSmR6ZGgyWm1EV3k5RkNSMndjMHZxaWIxOGVKNFEvNjQw.jpg" alt="img"></p><p>在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。</p><p>其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取<code>*Mapper</code>文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。</p><p>在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。</p><p>对于builder的具体类，方法都大都用<code>build*</code>开头，比如SqlSessionFactoryBuilder为例，它包含以下方法：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5NmducW1ZZXUwTWFObWV3a1h6NkhqQVFjY2ZOUmliOFVBSWRJTmdmdWx2OWljM1BPa0cwQkNVb2cvNjQw.jpg" alt="img"></p><p>即根据不同的输入参数来构建SqlSessionFactory这个工厂对象。</p><h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5a1RtU2ljdmU3a05OVlpISVV1N1BMU0puNlNRVzdpYmliWHY1dDRRZlJTV2liVDBlSVFVZXZyY0tYUS82NDA.jpg" alt="img"></p><p>SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5ZUNpYmttQzdTc3VlUDc1cmliWmNvY1ZyaWFkckVXU3RnaWJOd1lnYWZsOUlUem96OUZpYURlSHhKSEEvNjQw.jpg" alt="img"></p><p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p><p>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。</p><p>在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。</p><p>而对于LogFactory，它的实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error creating logger for logger "</span> + logger + <span class="string">".  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个特别的地方，是Log变量的的类型是Constructor，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。</p><h3 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h3><p>单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5NzBGSkxLMVB0WmZqQlFpY2lhdUpQTE1IaWFXOE5pYk94UXF1ZUtWczZvUXNQY3g3SGljTW5PTXppYXZRLzY0MA.jpg" alt="img"></p><p>在Mybatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息，而LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。</p><p>ErrorContext的单例实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ErrorContext&gt; LOCAL = <span class="keyword">new</span> ThreadLocal&lt;ErrorContext&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ErrorContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ErrorContext <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ErrorContext context = LOCAL.get();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">      context = <span class="keyword">new</span> ErrorContext();</span><br><span class="line">      LOCAL.set(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。</p><p>只是这里有个有趣的地方是，LOCAL的静态实例变量使用了ThreadLocal修饰，也就是说它属于每个线程各自的数据，而在instance()方法中，先获取本线程的该实例，如果没有就创建该线程独有的ErrorContext。</p><h3 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h3><p>代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。</p><p>代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。</p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5Zm9NeDFjbG50bGJzMnpGekpaRmhFZTd6RmcyZjc2ekFRc2VFWVJDaWNsdE9ENVN3aWJYUkxDTVEvNjQw.jpg" alt="img"><br><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5U01VcTNyaDJxaHhUdUdINmhHNG0xa0Fsemt1eWZLNkZ4MEN0Z0hWWmM2VUloakhGNVNNaWJiZy82NDA.jpg" alt="img"></p><p>这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；</p><p>当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Method, MapperMethod&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxy mapperProxy)生成代理对象然后返回。</p><p>而查看MapperProxy的代码，可以看到如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常典型的，该MapperProxy类实现了InvocationHandler接口，并且实现了该接口的invoke方法。</p><p>通过这种方式，我们只需要编写Mapper.java接口类，当真正执行一个Mapper接口的时候，就会转发给MapperProxy.invoke方法，而该方法则会调用后续的sqlSession.cud&gt;executor.execute&gt;prepareStatement等一系列方法，完成SQL的执行和返回。</p><h3 id="5、组合模式"><a href="#5、组合模式" class="headerlink" title="5、组合模式"></a>5、组合模式</h3><p><strong>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。</strong></p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p>在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5WGlhUXZMMXRnTUE2ejJwNDQ4VjJaTkNYVkZvVlVqckNOakxCalNidnJPdzJDaHY2N1Y3dmVyQS82NDA.jpg" alt="img"></p><p>Mybatis支持动态SQL的强大功能，比如下面的这个SQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"org.format.dynamicproxy.mybatis.bean.User"</span>&gt;</span></span><br><span class="line">    UPDATE users</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">prefixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null and name != ''"</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"age != null and age != ''"</span>&gt;</span></span><br><span class="line">            , age = #&#123;age&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"birthday != null and birthday != ''"</span>&gt;</span></span><br><span class="line">            , birthday = #&#123;birthday&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    where id = $&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里面使用到了trim、if等动态元素，可以根据条件来生成不同情况下的SQL；</p><p>在DynamicSqlSource.getBoundSql方法里，调用了rootSqlNode.apply(context)方法，apply方法是所有的动态节点都实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlNode</span></span>&#123;</span><br><span class="line">    booleanapply(DynamicContext context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实现该SqlSource接口的所有节点，就是整个组合模式树的各个节点：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5MUJKQ01DN295MlFVOU1ubXVFUlZTeTIwbkp0SmdpYzhtV1N1WXZPclhLWTlYMnVaMDZkT080US82NDA.jpg" alt="img"></p><p>组合模式的简单之处在于，所有的子节点都是同一类节点，可以递归的向下执行，比如对于TextSqlNode，因为它是最底层的叶子节点，所以直接将对应的内容append到SQL语句中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">    context.appendSql(parser.parse(text));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于IfSqlNode，就需要先做判断，如果判断通过，仍然会调用子元素的SqlNode，即contents.apply方法，实现递归的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、模板方法模式"><a href="#6、模板方法模式" class="headerlink" title="6、模板方法模式"></a>6、模板方法模式</h3><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p><p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p><p>模板类定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5aWNuMjZoZEYzMnhxMkV6bkJ4Ylc4WXdKUmFobGJzS0VpYzhCSVF5WWJPbmlhdUY1Q0Fsb1RuUFBBLzY0MA.jpg" alt="img"></p><p>在Mybatis中，sqlSession的SQL执行，都是委托给Executor实现的，Executor包含以下结构：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5TWVnQk8zaWJmQnQwb1VPVnV6cWxGQ0JXNDU2cEJxaWMycGhWbFZLVWNVZE1Lb0N1WGxRM2trWGcvNjQw.jpg" alt="img"></p><p>其中的BaseExecutor就采用了模板方法模式，它实现了大部分的SQL执行逻辑，然后把以下几个方法交给子类定制化完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>该模板方法类有几个子类的具体实现，使用了不同的策略：</p><ul><li>简单SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。（可以是Statement或PrepareStatement对象）</li><li>重用ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。（可以是Statement或PrepareStatement对象）</li><li>批量BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</li></ul><p>比如在SimpleExecutor中这样实现update方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration configuration = ms.getConfiguration();</span><br><span class="line">        StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, RowBounds.DEFAULT, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        <span class="keyword">return</span> handler.update(stmt);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、适配器模式"><a href="#7、适配器模式" class="headerlink" title="7、适配器模式"></a>7、适配器模式</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5SHBKYld0QlMxV3JLVEswVkRTWVlEYnlNdVFOdm8xZjU3Z1hCS282YnJTd3JDVXIwRTVodndBLzY0MA.jpg" alt="img"></p><p>在Mybatsi的logging包中，有一个Log接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口定义了Mybatis直接使用的日志方法，而Log接口具体由谁来实现呢？Mybatis提供了多种日志框架的实现，这些实现都匹配这个Log接口所定义的接口方法，最终实现了所有外部日志框架到Mybatis日志包的适配：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5MGljdWVqRTZ2STlteExJWXNYbXdlY3hXN2ljdEFQVzB0R0hIcXl2V29oeUFacG81NFBNTlJsVEEvNjQw.jpg" alt="img"></p><p>比如对于Log4jImpl的实现来说，该实现持有了org.apache.log4j.Logger的实例，然后所有的日志方法，均委托该实例来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FQCN = Log4jImpl<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Log4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    log = Logger.getLogger(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.ERROR, s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.ERROR, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.DEBUG, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.TRACE, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.log(FQCN, Level.WARN, s, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、装饰者模式"><a href="#8、装饰者模式" class="headerlink" title="8、装饰者模式"></a>8、装饰者模式</h3><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5blNSVHlwQWdhZnZPWDhUb0t4blhzRlFaNDBXTWoxNXRjMERvZm1IcEhvQUxpYVRpYXlWVVJGWHcvNjQw.jpg" alt="img"></p><p>在mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。整个体系采用装饰器设计模式，数据存储和缓存的基本功能由PerpetualCache（org.apache.ibatis.cache.impl.PerpetualCache）永久缓存实现，然后通过一系列的装饰器来对PerpetualCache永久缓存进行缓存策略等方便的控制。如下图：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5MEswRTVCVzRsY3ZXOVIzYzRwVXpRNWliRGYxaWFMdXZ2U3g1SDlWWnFhaWFaMzlEeXBGVGtuVDRRLzY0MA.jpg" alt="img"></p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在org.apache.ibatis.cache.decorators包中）：</p><ol><li>FifoCache：先进先出算法，缓存回收策略</li><li>LoggingCache：输出缓存命中的日志信息</li><li>LruCache：最近最少使用算法，缓存回收策略</li><li>ScheduledCache：调度缓存，负责定时清空缓存</li><li>SerializedCache：缓存序列化和反序列化存储</li><li>SoftCache：基于软引用实现的缓存管理策略</li><li>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</li><li>WeakCache：基于弱引用实现的缓存管理策略</li></ol><p>另外，还有一个特殊的装饰器TransactionalCache：事务性的缓存</p><p>正如大多数持久层框架一样，mybatis缓存同样分为一级缓存和二级缓存</p><ul><li>一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中（BaseExecutor），而执行器又在SqlSession（DefaultSqlSession）中，所以一级缓存的生命周期与SqlSession是相同的。</li><li>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保存在Configuration核心配置对象中。</li></ul><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis会根据配置自动追加一系列装饰器。</p><p>Cache对象之间的引用顺序为：</p><blockquote><p>SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p></blockquote><h3 id="9、迭代器模式"><a href="#9、迭代器模式" class="headerlink" title="9、迭代器模式"></a>9、迭代器模式</h3><p>迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义为：提供一种方法访问一个容器（container）对象中各个元素，而又不需暴露该对象的内部细节。</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5ZWljckRhM05lbUQ3SkoydmxydkF1MnJmZGFjaFJlNjFPZ0hnd2EzSFRVV1RnM3RqR0RBMWxSZy82NDA.jpg" alt="img"></p><p>Java的Iterator就是迭代器模式的接口，只要实现了该接口，就相当于应用了迭代器模式：</p><p><img src="/2020/02/12/MyBatis中的九种设计模式/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L0JhcTVsWXBJdzdYamp6RzRiVmNyTkJBUFB0Qks5SnM5UWJNR1pGWmRpYm9DSmpCWWpZZEVmR2lhM2dKS21RaWJ6RUlES0s3MEFxbTR3dGRRQlZsNUxsWXZBLzY0MA.jpg" alt="img"></p><p>比如Mybatis的PropertyTokenizer是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterator接口，在使用时经常被用到的是Iterator接口中的hasNext这个函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String indexedName;</span><br><span class="line">    <span class="keyword">private</span> String index;</span><br><span class="line">    <span class="keyword">private</span> String children;</span><br><span class="line"></span><br><span class="line">    publicPropertyTokenizer(String fullname) &#123;</span><br><span class="line">        <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">            children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            name = fullname;</span><br><span class="line">            children = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexedName = name;</span><br><span class="line">        delim = name.indexOf(<span class="string">'['</span>);</span><br><span class="line">        <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">            name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexedName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicbooleanhasNext() &#123;</span><br><span class="line">        <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    publicvoidremove() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">"Remove is not supported, as it has no meaning in the context of properties."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个类传入一个字符串到构造函数，然后提供了iterator方法对解析后的子串进行遍历，是一个很常用的方法类。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li>图说设计模式</li><li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/index.html</a></li><li>深入浅出Mybatis系列（十）—SQL执行流程分析（源码篇）</li><li><a href="http://www.cnblogs.com/dongying/p/4142476.html" target="_blank" rel="noopener">http://www.cnblogs.com/dongying/p/4142476.html</a></li><li>设计模式读书笔记—–组合模式</li><li><a href="http://www.cnblogs.com/chenssy/p/3299719.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3299719.html</a></li><li>Mybatis3.3.x技术内幕（四）：五鼠闹东京之执行器Executor设计原本</li><li><a href="http://blog.csdn.net/wagcy/article/details/32963235" target="_blank" rel="noopener">http://blog.csdn.net/wagcy/article/details/32963235</a></li><li>mybatis缓存机制详解（一）——Cache</li><li><a href="https://my.oschina.net/lixin91/blog/620068" target="_blank" rel="noopener">https://my.oschina.net/lixin91/blog/620068</a></li></ul><blockquote><p>转载自<a href="http://www.crazyant.net/2022.html" target="_blank" rel="noopener">http://www.crazyant.net/2022.html</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然我们都知道有26个设计模式，但是大多停留在概念层面，真实开发中很少遇到，Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="Mybatis" scheme="https://vincentruan.github.io/tags/Mybatis/"/>
    
      <category term="设计模式" scheme="https://vincentruan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>不可不说的Java锁事</title>
    <link href="https://vincentruan.github.io/2020/02/12/%E4%B8%8D%E5%8F%AF%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E9%94%81%E4%BA%8B/"/>
    <id>https://vincentruan.github.io/2020/02/12/%E4%B8%8D%E5%8F%AF%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E9%94%81%E4%BA%8B/</id>
    <published>2020-02-12T08:39:06.000Z</published>
    <updated>2020-02-25T15:09:15.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p><a id="more"></a><h1 id="JAVA主流锁"><a href="#JAVA主流锁" class="headerlink" title="JAVA主流锁"></a>JAVA主流锁</h1><p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：</p><p><img src="/2020/02/12/不可不说的Java锁事/7f749fc8.png" alt="img"></p><h2 id="1-乐观锁-VS-悲观锁"><a href="#1-乐观锁-VS-悲观锁" class="headerlink" title="1. 乐观锁 VS 悲观锁"></a>1. 乐观锁 VS 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><p><img src="/2020/02/12/不可不说的Java锁事/c8703cd9.png" alt="img"></p><p>根据从上面的概念描述我们可以发现：</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储value在AtomicInteger中的偏移量。</li><li>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</li></ul><p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- JDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// AtomicInteger 自增方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var5;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">  &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">  <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- OpenJDK 8 -------------------------</span></span><br><span class="line"><span class="comment">// Unsafe.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       v = getIntVolatile(o, offset);</span><br><span class="line">   &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">   <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p><p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p><p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p><ol><li><p>ABA问题</p><p>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p><ul><li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li></ul></li><li><p><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作</p><p>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p><ul><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li></ul></li></ol><h2 id="2-自旋锁-VS-适应性自旋锁"><a href="#2-自旋锁-VS-适应性自旋锁" class="headerlink" title="2. 自旋锁 VS 适应性自旋锁"></a>2. 自旋锁 VS 适应性自旋锁</h2><p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/452a3363.png" alt="img"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.misc.Unsafe#getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p><h2 id="3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3-无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2><p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p><p>首先为什么Synchronized能实现线程同步？</p><p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p><p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p><p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p><p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p><p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：</p><table><thead><tr><th style="text-align:left">锁状态</th><th style="text-align:left">存储内容</th><th style="text-align:left">存储内容</th></tr></thead><tbody><tr><td style="text-align:left">无锁</td><td style="text-align:left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">偏向锁</td><td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td><td style="text-align:left">01</td></tr><tr><td style="text-align:left">轻量级锁</td><td style="text-align:left">指向栈中锁记录的指针</td><td style="text-align:left">00</td></tr><tr><td style="text-align:left">重量级锁</td><td style="text-align:left">指向互斥量（重量级锁）的指针</td><td style="text-align:left">10</td></tr></tbody></table><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p><p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p><p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p><p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>整体的锁状态升级流程如下：</p><p><img src="/2020/02/12/不可不说的Java锁事/8afdf6f2.png" alt="img"></p><p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p><h2 id="4-公平锁-VS-非公平锁"><a href="#4-公平锁-VS-非公平锁" class="headerlink" title="4. 公平锁 VS 非公平锁"></a>4. 公平锁 VS 非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/a23d746a.png" alt="img"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="/2020/02/12/不可不说的Java锁事/4499559e.png" alt="img"></p><p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/6edea205.png" alt="img"></p><p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:</p><p><img src="/2020/02/12/不可不说的Java锁事/bc6fe583.png" alt="img"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。</p><p><img src="/2020/02/12/不可不说的Java锁事/bd0036bb.png" alt="img"></p><p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h2 id="5-可重入锁-VS-非可重入锁"><a href="#5-可重入锁-VS-非可重入锁" class="headerlink" title="5. 可重入锁 VS 非可重入锁"></a>5. 可重入锁 VS 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="/2020/02/12/不可不说的Java锁事/58fc5bc9.png" alt="img"></p><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="/2020/02/12/不可不说的Java锁事/ea597a0c.png" alt="img"></p><p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p><p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p><p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p><p><img src="/2020/02/12/不可不说的Java锁事/32536e7a.png" alt="img"></p><h2 id="6-独享锁-VS-共享锁"><a href="#6-独享锁-VS-共享锁" class="headerlink" title="6. 独享锁 VS 共享锁"></a>6. 独享锁 VS 共享锁</h2><p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>下图为ReentrantReadWriteLock的部分源码：</p><p><img src="/2020/02/12/不可不说的Java锁事/762a042b.png" alt="img"></p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p><p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p><p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p><p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：</p><p><img src="/2020/02/12/不可不说的Java锁事/8793e00a.png" alt="img"></p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">Thread current = Thread.currentThread();</span><br><span class="line"><span class="keyword">int</span> c = getState(); <span class="comment">// 取到当前锁的个数</span></span><br><span class="line"><span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 取写锁的个数w</span></span><br><span class="line"><span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)    <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"><span class="comment">// Reentrant acquire</span></span><br><span class="line">    setState(c + acquires);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">setExclusiveOwnerThread(current); <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</li><li>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</li></ul><p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p><p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接着是读锁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                   <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：</p><p><img src="/2020/02/12/不可不说的Java锁事/8b7878ec.png" alt="img"></p><p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p><h1 id="其他锁细节"><a href="#其他锁细节" class="headerlink" title="其他锁细节"></a>其他锁细节</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized 关键字是一把经典的锁，也是我们平时用得最多的。在 JDK1.6 之前， syncronized 是一把重量级的锁，不过随着 JDK 的升级，也在对它进行不断的优化，如今它变得不那么重了，甚至在某些场景下，它的性能反而优于轻量级锁。在加了 syncronized 关键字的方法、代码块中，一次只允许一个线程进入特定代码段，从而避免多线程同时修改同一数据。</p><p>synchronized 锁有如下几个特点：</p><p><strong>有锁升级过程</strong></p><p>在 JDK1.5 (含)之前， synchronized 的底层实现是重量级的，所以之前一致称呼它为”重量级锁”，在 JDK1.5 之后，对 synchronized 进行了各种优化，它变得不那么重了，实现原理就是锁升级的过程。我们先聊聊 1.5 之后的 synchronized 实现原理是怎样的。说到 synchronized 加锁原理，就不得不先说 Java 对象在内存中的布局， Java 对象内存布局如下:</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213202817218.png" alt="image-20200213202817218"></p><p>如上图所示，在创建一个对象后，在 JVM 虚拟机( HotSpot )中，对象在 Java 内存中的存储布局 可分为三块:</p><p><strong>对象头区域此处存储的信息包括两部分：</strong></p><p>1、对象自身的运行时数据( MarkWord )</p><p>存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID 、 CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。</p><p>2、对象类型指针( Class Pointer )</p><p>对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。</p><p><strong>实例数据区域</strong> </p><p> 此处存储的是对象真正有效的信息，比如对象中所有字段的内容</p><p><strong>对齐填充区域</strong></p><p> JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了”对齐”，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就”补位”到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。</p><p>当线程进入到 synchronized 处尝试获取该锁时， synchronized 锁升级流程如下：</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213203159163.png" alt="image-20200213203159163"></p><p>如上图所示， synchronized 锁升级的顺序为：偏向锁-&gt;轻量级锁-&gt;重量级锁，每一步触发锁升级的情况如下：</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在 JDK1.8 中，其实默认是轻量级锁，但如果设定了 -XX:BiasedLockingStartupDelay = 0 ，那在对一个 Object 做 syncronized 的时候，会立即上一把偏向锁。当处于偏向锁状态时， markwork 会记录当前线程 ID 。</p><h3 id="升级到轻量级锁"><a href="#升级到轻量级锁" class="headerlink" title="升级到轻量级锁"></a><strong>升级到轻量级锁</strong></h3><p>当下一个线程参与到偏向锁竞争时，会先判断 markword 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁。每个线程在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS (自旋)的操作将锁对象头中的 markwork 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着获得锁。关于 synchronized 中此时执行的 CAS 操作是通过 native 的调用 HotSpot 中 bytecodeInterpreter.cpp 文件 C++ 代码实现的，有兴趣的可以继续深挖。</p><h3 id="升级到重量级锁"><a href="#升级到重量级锁" class="headerlink" title="升级到重量级锁"></a><strong>升级到重量级锁</strong></h3><p>如果锁竞争加剧(如线程自旋次数或者自旋的线程数超过某阈值， JDK1.6 之后，由 JVM 自己控制该规则)，就会升级为重量级锁。此时就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。在重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是”重”的原因之一。</p><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a><strong>可重入</strong></h3><p>synchronized 拥有强制原子性的内部锁机制，是一把可重入锁。因此，在一个线程使用 synchronized 方法时调用该对象另一个 synchronized 方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的。在 Java 中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。 synchronized 锁的对象头的 markwork 中会记录该锁的线程持有者和计数器，当一个线程请求成功后， JVM 会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized 方法/块时，计数器会递减，如果计数器为 0 则释放该锁锁。</p><h3 id="悲观锁-互斥锁、排他锁"><a href="#悲观锁-互斥锁、排他锁" class="headerlink" title="悲观锁(互斥锁、排他锁)"></a><strong>悲观锁(互斥锁、排他锁)</strong></h3><p> synchronized 是一把悲观锁(独占锁)，当前线程如果获取到锁，会导致其它所有需要锁该的线程等待，一直等待持有锁的线程释放锁才继续进行锁的争抢。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 从字面可以看出是一把可重入锁，这点和 synchronized 一样，但实现原理也与 syncronized 有很大差别，它是基于经典的 AQS(AbstractQueueSyncronized) 实现的, AQS 是基于 volitale 和 CAS 实现的，其中 AQS 中维护一个 valitale 类型的变量 state 来做一个可重入锁的重入次数，加锁和释放锁也是围绕这个变量来进行的。 ReentrantLock 也提供了一些 synchronized 没有的特点，因此比 synchronized 好用。</p><p><strong>AQS模型如下图：</strong></p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213203315752.png" alt="image-20200213203315752"></p><p>ReentrantLock 有如下特点：</p><h3 id="可重入-1"><a href="#可重入-1" class="headerlink" title="可重入"></a>可重入</h3><p> ReentrantLock 和 syncronized 关键字一样，都是可重入锁，不过两者实现原理稍有差别， RetrantLock 利用 AQS 的的 state 状态来判断资源是否已锁，同一线程重入加锁， state 的状态 +1 ; 同一线程重入解锁, state 状态 -1 (解锁必须为当前独占线程，否则异常); 当 state 为 0 时解锁成功。</p><h3 id="需要手动加锁、解锁"><a href="#需要手动加锁、解锁" class="headerlink" title="需要手动加锁、解锁"></a>需要手动加锁、解锁</h3><p>synchronized 关键字是自动进行加锁、解锁的，而 ReentrantLock 需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成，来手动加锁、解锁。</p><h3 id="支持设置锁的超时时间"><a href="#支持设置锁的超时时间" class="headerlink" title="支持设置锁的超时时间"></a>支持设置锁的超时时间</h3><p> synchronized 关键字无法设置锁的超时时间，如果一个获得锁的线程内部发生死锁，那么其他线程就会一直进入阻塞状态，而 ReentrantLock 提供 tryLock 方法，允许设置线程获取锁的超时时间，如果超时，则跳过，不进行任何操作，避免死锁的发生。</p><h3 id="支持公平-非公平锁"><a href="#支持公平-非公平锁" class="headerlink" title="支持公平/非公平锁"></a>支持公平/非公平锁</h3><p>synchronized 关键字是一种非公平锁，先抢到锁的线程先执行。而 ReentrantLock 的构造方法中允许设置 true/false 来实现公平、非公平锁，如果设置为 true ，则线程获取锁要遵循”先来后到”的规则，每次都会构造一个线程 Node ，然后到双向链表的”尾巴”后面排队，等待前面的 Node 释放锁资源。</p><h3 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h3><p> ReentrantLock 中的 lockInterruptibly() 方法使得线程可以在被阻塞时响应中断，比如一个线程 t1 通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过 interrupt() 方法就可以立刻打断 t1 线程的执行，来获取t1持有的那个可重入锁。而通过 ReentrantLock 的 lock() 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt() 方法的，直到该方法主动释放锁之后才会响应 interrupt() 方法。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock (读写锁)其实是两把锁，一把是 WriteLock (写锁)，一把是读锁， ReadLock 。读写锁的规则是：读读不互斥、读写互斥、写写互斥。在一些实际的场景中，读操作的频率远远高于写操作，如果直接用一般的锁进行并发控制的话，就会读读互斥、读写互斥、写写互斥，效率低下，读写锁的产生就是为了优化这种场景的操作效率。一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高，因此需要根据实际情况选择使用。 </p><p>ReentrantReadWriteLock 的原理也是基于 AQS 进行实现的，与 ReentrantLock 的差别在于 ReentrantReadWriteLock 锁拥有共享锁、排他锁属性。读写锁中的加锁、释放锁也是基于 Sync (继承于 AQS )，并且主要使用 AQS 中的 state 和 node 中的 waitState 变量进行实现的。实现读写锁与实现普通互斥锁的主要区别在于需要分别记录读锁状态及写锁状态，并且等待队列中需要区别处理两种加锁操作。 ReentrantReadWriteLock 中将 AQS 中的 int 类型的 state 分为高 16 位与第 16 位分别记录读锁和写锁的状态，如下图所示：</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213203511263.png" alt="image-20200213203511263"></p><p><strong>WriteLock(写锁)是悲观锁(排他锁、互斥锁)</strong></p><p>通过计算 state&amp;((1&lt;&lt;16)-1) ，将 state 的高 16 位全部抹去，因此 state 的低位记录着写锁的重入计数。</p><p>获取写锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁</span></span><br><span class="line"><span class="comment">           Acquires the write lock.</span></span><br><span class="line"><span class="comment">         *  如果此时没有任何线程持有写锁或者读锁，那么当前线程执行CAS操作更新status，</span></span><br><span class="line"><span class="comment">         *  若更新成功，则设置读锁重入次数为1，并立即返回</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the write lock if neither the read nor write lock</span></span><br><span class="line"><span class="comment">         * are held by another thread</span></span><br><span class="line"><span class="comment">         * and returns immediately, setting the write lock hold count to</span></span><br><span class="line"><span class="comment">         * one.</span></span><br><span class="line"><span class="comment">         *  如果当前线程已经持有该写锁，那么将写锁持有次数设置为1，并立即返回</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the current thread already holds the write lock then the</span></span><br><span class="line"><span class="comment">         * hold count is incremented by one and the method returns</span></span><br><span class="line"><span class="comment">         * immediately.</span></span><br><span class="line"><span class="comment">         *  如果该锁已经被另外一个线程持有，那么停止该线程的CPU调度并进入休眠状态，</span></span><br><span class="line"><span class="comment">         *  直到该写锁被释放，且成功将写锁持有次数设置为1才表示获取写锁成功</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the lock is held by another thread then the current</span></span><br><span class="line"><span class="comment">         * thread becomes disabled for thread scheduling purposes and</span></span><br><span class="line"><span class="comment">         * lies dormant until the write lock has been acquired, at which</span></span><br><span class="line"><span class="comment">         * time the write lock hold count is set to one.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法为以独占模式获取锁，忽略中断</span></span><br><span class="line"><span class="comment">     * 如果调用一次该“tryAcquire”方法更新status成功，则直接返回，代表抢锁成功</span></span><br><span class="line"><span class="comment">     * 否则，将会进入同步队列等待，不断执行“tryAcquire”方法尝试CAS更新status状态，直到成功抢到锁</span></span><br><span class="line"><span class="comment">     * 其中“tryAcquire”方法在NonfairSync(公平锁)中和FairSync(非公平锁)中都有各自的实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1、如果读写锁的计数不为0，且持有锁的线程不是当前线程，则返回false</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2、如果持有锁的计数不为0且计数总数超过限定的最大值，也返回false</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3、如果该锁是可重入或该线程在队列中的策略是允许它尝试抢锁，那么该线程就能获取锁</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取读写锁的状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//获取该写锁重入的次数</span></span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="comment">//如果读写锁状态不为0，说明已经有其他线程获取了读锁或写锁</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果写锁重入次数为0，说明有线程获取到读锁，根据“读写锁互斥”原则，返回false</span></span><br><span class="line">                <span class="comment">//或者如果写锁重入次数不为0，且获取写锁的线程不是当前线程，根据"写锁独占"原则，返回false</span></span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">//如果写锁可重入次数超过最大次数（65535），则抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">//到这里说明该线程是重入写锁，更新重入写锁的计数(+1)，返回true</span></span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果读写锁状态为0,说明读锁和写锁都没有被获取，会走下面两个分支：</span></span><br><span class="line">            <span class="comment">//如果要阻塞或者执行CAS操作更新读写锁的状态失败，则返回false</span></span><br><span class="line">            <span class="comment">//如果不需要阻塞且CAS操作成功，则当前线程成功拿到锁，设置锁的owner为当前线程，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>释放写锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">  * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">  * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">  * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//若锁的持有者不是当前线程，抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">     <span class="comment">//写锁的可重入计数减掉releases个</span></span><br><span class="line">     <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">     <span class="comment">//如果写锁重入计数为0了，则说明写锁被释放了</span></span><br><span class="line">     <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">//若写锁被释放，则将锁的持有者设置为null，进行GC</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//更新写锁的重入计数</span></span><br><span class="line">     setState(nextc);</span><br><span class="line">     <span class="keyword">return</span> free;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>ReadLock(读锁)是共享锁(乐观锁)</strong></p><p>通过计算 state&gt;&gt;&gt;16 进行无符号补 0 ，右移 16 位，因此 state 的高位记录着写锁的重入计数.</p><p>读锁获取锁的过程比写锁稍微复杂些，首先判断写锁是否为 0 并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程 firstReader 和 firstReaderHoldCount ；若当前线程线程为第一个读线程，则增加 firstReaderHoldCount ；否则，将设置当前线程对应的 HoldCounter 对象的值，更新成功后会在 firstReaderHoldCount 中 readHolds ( ThreadLocal 类型的)的本线程副本中记录当前线程重入数，这是为了实现 JDK1.6 中加入的 getReadHoldCount ()方法的，这个方法能获取当前线程重入共享锁的次数( state 中记录的是多个线程的总重入次数)，加入了这个方法让代码复杂了不少，但是其原理还是很简单的：如果当前只有一个线程的话，还不需要动用 ThreadLocal ，直接往 firstReaderHoldCount 这个成员变量里存重入数，当有第二个线程来的时候，就要动用 ThreadLocal 变量 readHolds 了，每个线程拥有自己的副本，用来保存自己的重入数。</p><p>获取读锁源码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取读锁</span></span><br><span class="line"><span class="comment">         * Acquires the read lock.</span></span><br><span class="line"><span class="comment">         * 如果写锁未被其他线程持有，执行CAS操作更新status值，获取读锁后立即返回</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">         * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果写锁被其他线程持有，那么停止该线程的CPU调度并进入休眠状态，直到该读锁被释放</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">         * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">         * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法为以共享模式获取读锁，忽略中断</span></span><br><span class="line"><span class="comment">     * 如果调用一次该“tryAcquireShared”方法更新status成功，则直接返回，代表抢锁成功</span></span><br><span class="line"><span class="comment">     * 否则，将会进入同步队列等待，不断执行“tryAcquireShared”方法尝试CAS更新status状态，直到成功抢到锁</span></span><br><span class="line"><span class="comment">     * 其中“tryAcquireShared”方法在NonfairSync(公平锁)中和FairSync(非公平锁)中都有各自的实现</span></span><br><span class="line"><span class="comment">     * (看这注释是不是和写锁很对称)</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1、如果已经有其他线程获取到了写锁，根据“读写互斥”原则，抢锁失败，返回-1</span></span><br><span class="line"><span class="comment">             * 1.If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2、如果该线程本身持有写锁，那么看一下是否要readerShouldBlock，如果不需要阻塞，</span></span><br><span class="line"><span class="comment">             *    则执行CAS操作更新state和重入计数。</span></span><br><span class="line"><span class="comment">             *    这里要注意的是，上面的步骤不检查是否可重入(因为读锁属于共享锁，天生支持可重入)</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3、如果因为CAS更新status失败或者重入计数超过最大值导致步骤2执行失败</span></span><br><span class="line"><span class="comment">             *    那就进入到fullTryAcquireShared方法进行死循环，直到抢锁成功</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前尝试获取读锁的线程</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取该读写锁状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//如果有线程获取到了写锁 ，且获取写锁的不是当前线程则返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//获取读锁的重入计数</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="comment">//如果读线程不应该被阻塞，且重入计数小于最大值，且CAS执行读锁重入计数+1成功，则执行线程重入的计数加1操作，返回成功</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//如果还未有线程获取到读锁，则将firstReader设置为当前线程，firstReaderHoldCount设置为1</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">//如果firstReader是当前线程，则将firstReader的重入计数变量firstReaderHoldCount加1</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则说明有至少两个线程共享读锁，获取共享锁重入计数器HoldCounter</span></span><br><span class="line">                    <span class="comment">//从HoldCounter中拿到当前线程的线程变量cachedHoldCounter，将此线程的重入计数count加1</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果上面的if条件有一个都不满足，则进入到这个方法里进行死循环重新获取</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用于处理CAS操作state失败和tryAcquireShared中未执行获取可重入锁动作的full方法(补偿方法？)</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 此代码与tryAcquireShared中的代码有部分相似的地方，</span></span><br><span class="line"><span class="comment">             * 但总体上更简单，因为不会使tryAcquireShared与重试和延迟读取保持计数之间的复杂判断</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取读写锁状态</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="comment">//如果有线程获取到了写锁</span></span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果获取写锁的线程不是当前线程，返回失败</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;<span class="comment">//如果没有线程获取到写锁，且读线程要阻塞</span></span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="comment">//如果当前线程为第一个获取到读锁的线程</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果当前线程不是第一个获取到读锁的线程(也就是说至少有有一个线程获取到了读锁)</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *下面是既没有线程获取写锁，当前线程又不需要阻塞的情况</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//重入次数等于最大重入次数，抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">//如果执行CAS操作成功将读写锁的重入计数加1，则对当前持有这个共享读锁的线程的重入计数加1，然后返回成功</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>释放读锁源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">  * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">  *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">  *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放一次共享锁计数</span></span><br><span class="line">        doReleaseShared();<span class="comment">//真正释放锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *此方法表示读锁线程释放锁。</span></span><br><span class="line"><span class="comment"> *首先判断当前线程是否为第一个读线程firstReader，</span></span><br><span class="line"><span class="comment"> *若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，</span></span><br><span class="line"><span class="comment">  若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；</span></span><br><span class="line"><span class="comment">  若当前线程不是第一个读线程，</span></span><br><span class="line"><span class="comment">  那么首先会获取缓存计数器（上一个读锁线程对应的计数器 ），</span></span><br><span class="line"><span class="comment">  若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，</span></span><br><span class="line"><span class="comment">  如果计数器的计数count小于等于1，则移除当前线程对应的计数器，</span></span><br><span class="line"><span class="comment">  如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。</span></span><br><span class="line"><span class="comment">  无论何种情况，都会进入死循环，该循环可以确保成功设置状态state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取当前线程</span></span><br><span class="line">      Thread current = Thread.currentThread();</span><br><span class="line">      <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程</span></span><br><span class="line">          <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">         <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line">              firstReader = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">// 减少占用的资源</span></span><br><span class="line">              firstReaderHoldCount--;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不为第一个读线程</span></span><br><span class="line">         <span class="comment">// 获取缓存的计数器</span></span><br><span class="line">         HoldCounter rh = cachedHoldCounter;</span><br><span class="line">         <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line">             <span class="comment">// 获取当前线程对应的计数器</span></span><br><span class="line">             rh = readHolds.get();</span><br><span class="line">         <span class="comment">// 获取计数</span></span><br><span class="line">         <span class="keyword">int</span> count = rh.count;</span><br><span class="line">         <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123; <span class="comment">// 计数小于等于1</span></span><br><span class="line">             <span class="comment">// 移除</span></span><br><span class="line">             readHolds.remove();</span><br><span class="line">             <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="comment">// 计数小于等于0，抛出异常</span></span><br><span class="line">                 <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 减少计数</span></span><br><span class="line">         --rh.count;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">         <span class="comment">// 获取状态</span></span><br><span class="line">         <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="comment">// 获取状态</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">         <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并进行设置</span></span><br><span class="line">             <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">             <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">             <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">             <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**真正释放锁</span></span><br><span class="line"><span class="comment">  * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">  * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">  * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过分析可以看出：</p><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p><p>在线程持有写锁的况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p><h2 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h2><p>在高并发的情况下，我们对一个 Integer 类型的整数直接进行 i++ 的时候，无法保证操作的原子性，会出现线程安全的问题。为此我们会用 juc 下的 AtomicInteger ，它是一个提供原子操作的 Interger 类，内部也是通过 CAS 实现线程安全的。但当大量线程同时去访问时，就会因为大量线程执行 CAS 操作失败而进行空旋转，导致 CPU 资源消耗过多，而且执行效率也不高。 Doug Lea 大神应该也不满意，于是在 JDK1.8 中对 CAS 进行了优化，提供了 LongAdder ，它是基于了 CAS 分段锁的思想实现的。</p><p>线程去读写一个 LongAdder 类型的变量时，流程如下：</p><p><img src="/2020/02/12/不可不说的Java锁事/image-20200213204318608.png" alt="image-20200213204318608"></p><p> LongAdder 也是基于 Unsafe 提供的 CAS 操作 +valitale 去实现的。在 LongAdder 的父类 Striped64 中维护着一个 base 变量和一个 cell 数组，当多个线程操作一个变量的时候，先会在这个 base 变量上进行 cas 操作，当它发现线程增多的时候，就会使用 cell 数组。比如当 base 将要更新的时候发现线程增多（也就是调用 casBase 方法更新 base 值失败），那么它会自动使用 cell 数组，每一个线程对应于一个 cell ，在每一个线程中对该 cell 进行 cas 操作，这样就可以将单一 value 的更新压力分担到多个 value 中去，降低单个 value 的 “热度”，同时也减少了大量线程的空转，提高并发效率，分散并发压力。这种分段锁需要额外维护一个内存空间 cells ，不过在高并发场景下，这点成本几乎可以忽略。分段锁是一种优秀的优化思想， juc 中提供的的 ConcurrentHashMap 也是基于分段锁保证读写操作的线程安全。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。</p><p>其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java并发编程艺术》</li><li><a href="https://blog.csdn.net/u013256816/article/details/51204385" target="_blank" rel="noopener">Java中的锁</a></li><li><a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">Java CAS 原理剖析</a></li><li><a href="https://juejin.im/post/5b42c2546fb9a04f8751eabc" target="_blank" rel="noopener">Java并发——关键字synchronized解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/29866981" target="_blank" rel="noopener">Java synchronized原理总结</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）——Java SE1.6中的Synchronized</a></li><li><a href="https://blog.csdn.net/qq_19431333/article/details/70568478" target="_blank" rel="noopener">深入理解读写锁—ReadWriteLock源码分析</a></li><li><a href="https://www.cnblogs.com/twoheads/p/9635309.html" target="_blank" rel="noopener">【JUC】JDK1.8源码分析之ReentrantReadWriteLock</a></li><li><a href="https://my.oschina.net/adan1/blog/158107" target="_blank" rel="noopener">Java多线程（十）之ReentrantReadWriteLock深入分析</a></li><li><a href="https://mrdear.cn/2018/06/23/java/java--readwritelock" target="_blank" rel="noopener">Java–读写锁的实现原理</a></li></ol><blockquote><p>转载自美团技术团队，<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">原文地址</a>，在原文基础上有修改.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://vincentruan.github.io/tags/JAVA/"/>
    
      <category term="并发" scheme="https://vincentruan.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
