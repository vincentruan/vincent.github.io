<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[转载]从零开始：史上最详尽V2Ray搭建图文教程</title>
    <url>/2019/12/22/%E8%BD%AC%E8%BD%BD-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E5%8F%B2%E4%B8%8A%E6%9C%80%E8%AF%A6%E5%B0%BDV2Ray%E6%90%AD%E5%BB%BA%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>本文转载自从零开始：<a href="https://www.4spaces.org/digitalocean-build-v2ray-0-1/" target="_blank" rel="noopener">史上最详尽V2Ray搭建图文教程</a>，根据实际服务器配置做部分修改。</p>
<h2 id="一、服务端安装"><a href="#一、服务端安装" class="headerlink" title="一、服务端安装"></a>一、服务端安装</h2><p>以下所有操作都是使用root用户（普通用户自行sudo）进行操作的，服务器centos7。</p>
<p><strong>1.安装wget</strong></p>
<p>如提示没有安装wget，在登录完成的窗口输入下面命令并回车进行wget安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure>
<p><strong>2.下载脚本</strong></p>
<p>安装完wget之后就可以进行下载安装v2ray的脚本了，输入如下命令并回车：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br></pre></td></tr></table></figure>
<p><strong>3.安装unzip</strong></p>
<p>因为centos不支持apt-get，我们需要安装unzip，详见<a href="https://www.v2ray.com/chapter_00/install.html" target="_blank" rel="noopener">官方说明</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y zip unzip</span><br></pre></td></tr></table></figure>
<p><strong>4.执行安装</strong></p>
<p>输入下面的命令并回车执行安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[michael@centos74 v2ray]$ bash go.sh </span><br><span class="line">Installing V2Ray v3.14 on x86_64</span><br><span class="line">Downloading V2Ray.</span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   608    0   608    0     0   2229      0 --:--:-- --:--:-- --:--:--  2235</span><br><span class="line">100 8482k  100 8482k    0     0  2501k      0  0:00:03  0:00:03 --:--:-- 2813k</span><br><span class="line">Extracting V2Ray package to /tmp/v2ray.</span><br><span class="line">Archive:  /tmp/v2ray/v2ray.zip</span><br><span class="line">   creating: /tmp/v2ray/v2ray-v3.14-linux-64/</span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/geoip.dat  </span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/geosite.dat  </span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/readme.md  </span><br><span class="line">   creating: /tmp/v2ray/v2ray-v3.14-linux-64/systemd/</span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/systemd/v2ray.service  </span><br><span class="line">   creating: /tmp/v2ray/v2ray-v3.14-linux-64/systemv/</span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/systemv/v2ray  </span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/v2ctl  </span><br><span class="line"> extracting: /tmp/v2ray/v2ray-v3.14-linux-64/v2ctl.sig  </span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/v2ray  </span><br><span class="line"> extracting: /tmp/v2ray/v2ray-v3.14-linux-64/v2ray.sig  </span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/vpoint_socks_vmess.json  </span><br><span class="line">  inflating: /tmp/v2ray/v2ray-v3.14-linux-64/vpoint_vmess_freedom.json  </span><br><span class="line">PORT:13437</span><br><span class="line">UUID:f500ecf5-e135-49c6-9ce2-78eb490d0aa9</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/v2ray.service to /etc/systemd/system/v2ray.service.</span><br><span class="line">V2Ray v3.14 is installed.</span><br></pre></td></tr></table></figure>
<p><strong>5.相关命令</strong></p>
<p>在首次安装完成之后，V2Ray不会自动启动，需要手动运行上述启动命令。而在已经运行V2Ray的VPS上再次执行安装脚本，安装脚本会自动停止V2Ray 进程，升级V2Ray程序，然后自动运行V2Ray。在升级过程中，配置文件不会被修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 启动</span></span></span><br><span class="line">systemctl start v2ray</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 停止</span></span></span><br><span class="line">systemctl stop v2ray</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启</span></span></span><br><span class="line">systemctl restart v2ray</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 开机自启</span></span></span><br><span class="line">systemctl enable v2ray</span><br></pre></td></tr></table></figure>
<p>关于软件更新：<strong>更新 V2Ray 的方法是再次执行安装脚本！再次执行安装脚本！再次执行安装脚本！</strong></p>
<p><strong>6.配置</strong></p>
<p>如果你按照上面的命令执行安装完成之后，服务端其实是不需要再进行任何配置的，配置文件位于<code>/etc/v2ray/config.json</code>，使用<code>cat /etc/v2ray/config.json</code>查看配置信息。接下来进行客户端配置就行了。</p>
<p><strong>说明：</strong></p>
<ul>
<li><em>配置文件中的id、端口、alterId需要和客户端的配置保持一致</em>；</li>
<li><em>服务端使用脚本安装成功之后默认就是vmess协议</em>；</li>
</ul>
<p>配置完成之后重启v2ray。</p>
<p><strong>9.防火墙开放端口</strong></p>
<p>有的vps端口默认不开放，可能导致连接不成功，如果有这种情况，详细配置，见<a href="https://www.4spaces.org/centos-open-porter/" target="_blank" rel="noopener">CentOs开放端口的方法—二、firewalld</a>。部分服务器的防火墙配置只能在服务提供商的控制台操作，请注意。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 查看已开放端口</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">## 添加开放端口</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<h2 id="二、Windows-客户端"><a href="#二、Windows-客户端" class="headerlink" title="二、Windows 客户端"></a>二、Windows 客户端</h2><p><strong>1.下载</strong></p>
<p>目前不支持水果系列，水果机只能自行走野路子解决。</p>
<p>1)下载【<a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">v2ray-windows-64.zip Github Release</a>】;<br>2)下载【<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">v2rayN-v2rayN.exe-Github Release</a>】；</p>
<p>对<code>v2ray-windows-64.zip</code>进行解压，然后将下载的<code>V2RayN.exe</code>复制到解压后的目录，即两个下载好的文件需要在同一目录。</p>
<p><img src="/2019/12/22/转载-从零开始：史上最详尽V2Ray搭建图文教程/vmess-windows-client-dir.jpg" alt="img"></p>
<p><strong>2.配置</strong></p>
<p>运行V2RayN.exe，然后进行配置，下图中的配置信息，需要和你VPS搭建的时候的配置信息对应，VPS的v2ray配置信息位于<code>/etc/v2ray/config.json</code>文件里。</p>
<p>如果采用上面的默认方式安装，服务端配置是协议vmess，则配置如下：</p>
<p><img src="/2019/12/22/转载-从零开始：史上最详尽V2Ray搭建图文教程/new-vmess-config.jpg" alt="img"></p>
<p><img src="/2019/12/22/转载-从零开始：史上最详尽V2Ray搭建图文教程/vmess-windows-client.jpg" alt="img"></p>
<p><img src="/2019/12/22/转载-从零开始：史上最详尽V2Ray搭建图文教程/1577006106052.png" alt="1577006106052"></p>
<h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>打开浏览器，访问<code>www.google.com</code></p>
<h2 id="四、进阶"><a href="#四、进阶" class="headerlink" title="四、进阶"></a>四、进阶</h2><p>现在你已经学会使用v2ray了，为了更好的上网效果，建议继续了解一下下面文章：</p>
<ul>
<li><a href="https://www.4spaces.org/v2ray-nginx-tls-websocket/" target="_blank" rel="noopener">centos7基于nginx搭建v2ray服务端配置vmess+tls+websocket完全手册</a>；【推荐】</li>
<li><a href="https://www.4spaces.org/speed-up-your-vps-with-bbr-plus/" target="_blank" rel="noopener">使用Google BBR PLUS加速你的VPS网络</a>；</li>
<li><a href="https://www.4spaces.org/digitalocean-build-v2ray-mkcp/" target="_blank" rel="noopener">如何以mkcp方式部署v2ray</a>；</li>
</ul>
<h2 id="五、相关问题"><a href="#五、相关问题" class="headerlink" title="五、相关问题"></a>五、相关问题</h2><ul>
<li><a href="https://www.4spaces.org/v2ray-google-check/" target="_blank" rel="noopener">使用v2ray访问谷歌提示异常流量</a>；</li>
<li><a href="https://www.4spaces.org/v2ray-cloudflare-cdn-403/" target="_blank" rel="noopener">启用cloudflare cdn之后v2ray报403错误</a>；</li>
</ul>
]]></content>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>详解分布式协调服务 ZooKeeper</title>
    <url>/2018/10/07/%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1-ZooKeeper/</url>
    <content><![CDATA[<p><code>作者 | Draveness</code></p>
<p><code>本文作者 Draveness，文章转载自 https://draveness.me/zookeeper-chubby， 对其内容进行过编辑。</code></p>
<p><code>这篇文章主要会介绍 Zookeeper 的实现原理以及常见的应用</code></p>
<p>在 2006 年，Google 发表了一篇名为 The Chubby lock service for loosely-coupled distributed systems 的论文，其中描述了一个分布式锁服务 Chubby 的设计理念和实现原理；作为 Google 内部的一个基础服务，虽然 Chubby 与 GFS、Bigtable 和 MapReduce 相比并没有那么大的名气，不过它在 Google 内部也是非常重要的基础设施。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTg30dtZEX41yMutAaHrOdtng3gZrnXVS6ib5nUAGWphPdibZibF0xASOWWQ.png" alt="img"></p>
<p>相比于名不见经传的 Chubby，作者相信 Zookeeper 更被广大开发者所熟知，作为非常出名的分布式协调服务，Zookeeper 有非常多的应用，包括发布订阅、命名服务、分数是协调和分布式锁，这篇文章主要会介绍 Zookeeper 的实现原理以及常见的应用，但是在具体介绍 Zookeeper 的功能和原理之前，我们会简单介绍一下分布式锁服务 Chubby 以及它与 Zookeeper 之间的异同。</p>
<h1 id="Chubby"><a href="#Chubby" class="headerlink" title="Chubby"></a>Chubby</h1><p>作为分布式锁服务，Chubby 的目的就是允许多个客户端对它们的行为进行同步，同时也能够解决客户端的环境相关信息的分发和粗粒度的同步问题，GFS 和 Bigtable 都使用了 Chubby 以解决主节点的选举等问题。在网络上你很难找到关于 Chubby 的相关资料，我们只能从 The Chubby lock service for loosely-coupled distributed systems 一文中窥见它的一些设计思路、技术架构等信息。</p>
<p>虽然 Chubby 和 Zookeeper 有着比较相似的功能，但是它们的设计理念却非常不同，Chubby 在论文的摘要中写道：</p>
<blockquote>
<p>We describe our experiences with the Chubby lock service, which is intended to provide coarse-grained locking as well as reliable (though low-volume) storage for a loosely-coupled distributed system.</p>
</blockquote>
<p>从论文的摘要中我们可以看出 Chubby 首先被定义成一个 <strong>分布式的锁服务</strong>，它能够为分布式系统提供 <strong>松耦合、粗粒度</strong> 的分布式锁功能，然而我们并不能依赖于它来做一些重量的数据存储。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgsCvAvp0ZAfSaibY0AYOrm0lnwgTVc1kibuLHZkZImojibaia0r4Vfw7Fcg.png" alt="img"></p>
<p>Chubby 在设计时做了两个重要的设计决定，一是提供完整、独立的分布式锁服务而非一个用于共识的库或者服务，另一个是选择提供小文件的的读写功能，使得主节点能够方便地发布自己的状态信息。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>Chubby 总共由两部分组成，一部分是用于提供数据的读写接口并管理相关的配置数据的服务端，另一部分就是客户端使用的 SDK，为了提高系统的稳定性，每一个 Chubby 单元都由一组服务器组成，它会使用 共识算法 从集群中选举出主节点。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgCrLF3icVq2AXHKypeTWYbdyAg48hlAmrz6SQLicCG1EI0lic1u0icTuiaQw.png" alt="img"></p>
<p>在一个 Chubby Cell 中，<strong>只有</strong> 主节点会对外提供读写服务，其他的节点其实都是当前节点的副本（Replica），它们只是维护一个数据的拷贝并会在主节点更新时对它们持有的数据库进行更新；客户端通过向副本发送请求获取主节点的位置，一旦它获取到了主节点的位置，就会向所有的读写请求发送给主节点，直到其不再响应为止。写请求都会通过一致性协议传播到所有的副本中，当集群中的多数节点都同步了请求时就会认为当前的写入已经被确认。</p>
<p>当主节点宕机时，副本会在其租约到期时重新进行选举，副本节点如果在宕机几小时还没有回复，那么系统就会从资源池中选择一个新的节点并在该节点上启动 Chubby 服务并更新 DNS 表。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgJD5ICuJ3PWapYFJouDRg4yWhtKnvtEVIntAgDLDX9QW6psWY7lwETw.png" alt="img"></p>
<p>主节点会不停地轮训 DNS 表获取集群中最新的配置，每次 DNS 表更新时，主节点都会将新的配置下发给 Chubby 集群中其他的副本节点。</p>
<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><p>很多人都会说 Zookeeper 是 Chubby 的一个开源实现，这其实是有问题的，它们两者只不过都提供了具有层级结构的命名空间：</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgeS4Sicic9Zkwb6na4tyvZNZIvfPiaaDwzd2pUXpUIj5tOZqRUYkWqOEKQ.png" alt="img"></p>
<p>Chubby 和 Zookeeper 从最根本的设计理念上就有着非常明显的不同，在上文中我们已经提到了 Chubby 被设计成一个分布式的锁服务，它能够为分布式系统提供松耦合、粗粒度的分布式锁功能，然而我们并不能依赖于它来做一些重量的数据存储，而 Zookeeper 的论文在摘要中介绍到，它是一个能够为分布式系统提供协调功能的服务：</p>
<blockquote>
<p>In this paper, we describe ZooKeeper, a service for co- ordinating processes of distributed applications.</p>
</blockquote>
<p>Zookeeper 的目的是为客户端构建复杂的协调功能提供简单、高效的核心 API，相比于 Chubby 对外提供已经封装好的更上层的功能，Zookeeper 提供了更抽象的接口以便于客户端自行实现想要完成的功能。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgUYD5VIJiaYolwILeGH8wLoRsic727mvH1JeG0dk4cXt0A2HsofrINLPg.png" alt="img"></p>
<p>Chubby 直接为用户提供封装好的锁和解锁的功能，内部完成了锁的实现，只是将 API 直接暴露给用户，而 Zookeeper 却需要用户自己实现分布式锁；总的来说，使用 Zookeeper 往往需要客户端做更多的事情，但是也享有更多的自由。</p>
<h1 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h1><p>与 Chubby 集群中，多个节点只有一个能够对外提供服务不同，Zookeeper 集群中所有的节点都可以对外提供服务，但是集群中的节点也分为主从两种节点，所有的节点都能处理来自客户端的读请求，但是只有主节点才能处理写入操作：</p>
<blockquote>
<p>这里所说的 Zookeeper 集群主从节点实际上分别是 Leader 和 Follower 节点。</p>
</blockquote>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgCQ1kr6OiarIQLJ946WZlOq2gx64l0iaCVVcEW3z14DpMu2ibX0Ud8uniaA.png" alt="img"></p>
<p>客户端使用 Zookeeper 时会连接到集群中的任意节点，所有的节点都能够直接对外提供读操作，但是写操作都会被从节点路由到主节点，由主节点进行处理。</p>
<p>Zookeeper 在设计上提供了以下的两个基本的顺序保证，线性写和先进先出的客户端顺序：</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgV3dXOUmNaEzLib3EWJIqGGibLnSE24muXv6wPSvScaeumGGBqQibyTASw.png" alt="img"></p>
<p>其中线性写是指所有更新 Zookeeper 状态的请求都应该按照既定的顺序串行执行；而先进先出的客户端顺序是指，所有客户端发出的请求会按照发出的顺序执行。</p>
<h1 id="Zab-协议"><a href="#Zab-协议" class="headerlink" title="Zab 协议"></a>Zab 协议</h1><p>在我们简单介绍 Zookeeper 的技术架构之后，这一节将谈及 Zookeeper 中的 Zab 协议，Zookeeper 的 Zab 协议是为了解决分布式一致性而设计出的一种协议，它的全称是 Zookeeper 原子广播协议，它能够在发生崩溃时快速恢复服务，达到高可用性。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgT9kzpzicC2QY5iaONychlyTeaVcVqRloDy2Wk5Hsia20sVWPcj7z2Xplw.png" alt="img"></p>
<p>如上一节提到的，客户端在使用 Zookeeper 服务时会随机连接到集群中的一个节点，所有的读请求都会由当前节点处理，而写请求会被路由给主节点并由主节点向其他节点广播事务，与 2PC 非常相似，如果在所有的节点中超过一半都返回成功，那么当前写请求就会被提交。</p>
<p>当主节点崩溃时，其他的 Replica 节点会进入崩溃恢复模式并重新进行选举，Zab 协议必须确保提交已经被 Leader 提交的事务提案，同时舍弃被跳过的提案，这也就是说当前集群中最新 ZXID 最大的服务器会被选举成为 Leader 节点；但是在正式对外提供服务之前，新的 Leader 也需要先与 Follower 中的数据进行同步，确保所有节点拥有完全相同的提案列表。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgeHVia4rKjgtvujiarNR7HeicOvgEfzffY403N0vhx1EpHrAZ7WvXks86w.png" alt="img"></p>
<p>在上面提到 ZXID 其实就是 Zab 协议中设计的事务编号，它是一个 64 位的整数，其中最低的 32 位是一个计数器，每当客户端修改 Zookeeper 集群状态时，Leader 都会以当前 ZXID 值作为提案的编号创建一个新的事务，在这之后会将当前计数器加一；ZXID 中高的 32 位表示当前 Leader 的任期，每当发生崩溃进入恢复模式，集群的 Leader 重新选举之后都会将 epoch 加一。</p>
<h1 id="Zab-和-Paxos"><a href="#Zab-和-Paxos" class="headerlink" title="Zab 和 Paxos"></a>Zab 和 Paxos</h1><p>Zab 和 Paxos 协议在实现上其实有非常多的相似点，例如：</p>
<ul>
<li>主节点会向所有的从节点发出提案；</li>
<li>主节点在接收到一组从节点中 50% 以上节点的确认后，才会认为当前提案被提交了；</li>
<li>Zab 协议中的每一个提案都包含一个 epoch 值，与 Paxos 中的 Ballot 非常相似；</li>
</ul>
<p>因为它们有一些相同的特点，所以有的观点会认为 Zab 是 Paxos 的一个简化版本，但是 Zab 和 Paxos 在设计理念上就有着比较大的不同，两者的主要区别就在于 Zab 主要是为构建高可用的主备系统设计的，而 Paxos 能够帮助工程师搭建具有一致性的状态机系统。</p>
<p>作为一个一致性状态机系统，它能够保证集群中任意一个状态机副本都按照客户端的请求执行了相同顺序的请求，即使来自客户端请求是异步的并且不同客户端的接收同一个请求的顺序不同，集群中的这些副本就是会使用 Paxos 或者它的变种对提案达成一致；在集群运行的过程中，如果主节点出现了错误导致宕机，其他的节点会重新开始进行选举并处理未提交的请求。</p>
<p>但是在类似 Zookeeper 的高可用主备系统中，所有的副本都需要对增量的状态更新顺序达成一致，这些状态更新的变量都是由主节点创建并发送给其他的从节点的，每一个从节点都会严格按照顺序逐一的执行主节点生成的状态更新请求，如果 Zookeeper 集群中的主节点发生了宕机，新的主节点也必须严格按照顺序对请求进行恢复。</p>
<p>总的来说，使用状态更新节点数据的主备系统相比根据客户端请求改变状态的状态机系统对于请求的执行顺序有着更严格的要求。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>这一节会简单介绍 Zookeeper 的一些实现原理，重点会介绍以下几个部分的内容：文件系统、临时 / 持久节点和通知的实现原理。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>了解或者使用 Zookeeper 或者其他分布式协调服务的读者对于使用类似文件系统的方式比较熟悉，与 Unix 中的文件系统份上相似的是，Zookeeper 中也使用文件系统组织系统中存储的资源。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgLk65iczeaxzRHMdIbfb1ayLT8r6UFdPgibRhRQtb95FLMszicc0gWv2DA.png" alt="img"></p>
<p>Zookeeper 中其实并没有文件和文件夹的概念，它只有一个 Znode 的概念，它既能作为容器存储数据，也可以持有其他的 Znode 形成父子关系。</p>
<p>Znode 其实有 <code>PERSISTENT</code>、<code>PERSISTENT_SEQUENTIAL</code>、<code>EPHEMERAL</code> 和 <code>EPHEMERAL_SEQUENTIAL</code> 四种类型，它们是临时与持久、顺序与非顺序两个不同的方向组合成的四种类型。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgibl0xqo7lereZkzibrQHO3sGI0tRrDQ9oqNUlqwq0HdyTXicIdtLd2cOg.png" alt="img"></p>
<p>临时节点是客户端在连接 Zookeeper 时才会保持存在的节点，一旦客户端和服务端之间的连接中断，当前连接持有的所有节点都会被删除，而持久的节点不会随着会话连接的中断而删除，它们需要被客户端主动删除；Zookeeper 中另一种节点的特性就是顺序和非顺序，如果我们使用 Zookeeper 创建了顺序的节点，那么所有节点就会在名字的末尾附加一个序列号，序列号是一个由父节点维护的单调递增计数器。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>常见的通知机制往往都有两种，一种是客户端使用『拉』的方式从服务端获取最新的状态，这种方式获取的状态很有可能都是过期的，需要客户端不断地通过轮训的方式获取服务端最新的状态，另一种方式就是在客户端订阅对应节点后由服务端向所有订阅者推送该节点的变化，相比于客户端主动获取数据的方式，服务端主动推送更能够保证客户端数据的实时性。</p>
<p>作为分布式协调工具的 Zookeeper 就实现了这种服务端主动推送请求的机制，也就是 <code>Watch</code>，当客户端使用 <code>getData</code> 等接口获取 Znode 状态时传入了一个用于处理节点变更的回调，那么服务端就会主动向客户端推送节点的变更：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getData(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span><br></pre></td></tr></table></figure>
<p>从这个方法中传入的 <code>Watcher</code> 对象实现了相应的 <code>process</code> 方法，每次对应节点出现了状态的改变，<code>WatchManager</code> 都会通过以下的方式调用传入 <code>Watcher</code> 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Set&lt;Watcher&gt; <span class="title">triggerWatch</span><span class="params">(String path, EventType type, Set&lt;Watcher&gt; supress)</span> </span>&#123;</span><br><span class="line">    WatchedEvent e = <span class="keyword">new</span> WatchedEvent(type, KeeperState.SyncConnected, path);</span><br><span class="line">    Set&lt;Watcher&gt; watchers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        watchers = watchTable.remove(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Watcher w : watchers) &#123;</span><br><span class="line">        w.process(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watchers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Zookeeper 中的所有数据其实都是由一个名为 DataTree 的数据结构管理的，所有的读写数据的请求最终都会改变这颗树的内容，在发出读请求时可能会传入 Watcher 注册一个回调函数，而写请求就可能会触发相应的回调，由 WatchManager 通知客户端数据的变化。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgxm5Yy8RVU1JiaQpcUNs68ibbPOAoPhjicAFfsI3gytutlicibianBXaibGJFQ.png" alt="img"></p>
<p>通知机制的实现其实还是比较简单的，通过读请求设置 Watcher 监听事件，写请求在触发事件时就能将通知发送给指定的客户端。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>在 Zookeeper 中一个非常重要的概念就是会话，客户端与服务器之间的任何操作都与 Zookeeper 中会话的概念有关，比如我们再上一节中提到的临时节点生命周期以及通知的机制等等，它们都是基于会话来实现的。</p>
<p>每当客户端与服务端建立连接时，其实创建了一个新的会话，在每一个会话的生命周期中，Zookeeper 会在不同的会话状态之间进行切换，比如说：CONNECTING、CONNECTED、RECONNECTING、RECONNECTED 和 CLOSE 等。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgBknuNvicqze0Wk9Fl0qVrA69M7lzjnDL6mB9B1vGAHWfu5lvxmNiagSw.png" alt="img"></p>
<p>作为 Zookeeper 中最重要的概念之一，每一个 Session 都包含四个基本属性，会话的唯一 ID、会话超时时间、下次会话的超时时间点和表示会话是否被关闭的标记。</p>
<p>SessionTracker 是 Zookeeper 中的会话管理器，它负责所有会话的创建、管理以及清理工作，但是它本身只是一个 Java 的接口，定义了一系列用于管理会话的相关接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">getSessionId</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isClosing</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionExpirer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">expire</span><span class="params">(Session session)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">getServerId</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">createSession</span><span class="params">(<span class="keyword">int</span> sessionTimeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trackSession</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">int</span> to)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">commitSession</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">int</span> to)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">touchSession</span><span class="params">(<span class="keyword">long</span> sessionId, <span class="keyword">int</span> sessionTimeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSessionClosing</span><span class="params">(<span class="keyword">long</span> sessionId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeSession</span><span class="params">(<span class="keyword">long</span> sessionId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与其他的长连接一样，Zookeeper 中的会话也需要客户端与服务端之间进行心跳检测，客户端会在超时时间内向服务端发送心跳请求来保证会话不会被服务端关闭，一旦服务端检测到某一个会话长时间没有收到心跳包就会中断当前会话释放服务器上的资源。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>作为分布式协调服务，Zookeeper 能够为集群提供分布式一致性的保证，我们可以通过 Zookeeper 提供的最基本的 API 组合成更高级的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zookeeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">create</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], List&lt;ACL&gt; acl, CreateMode createMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">int</span> version)</span> <span class="keyword">throws</span> InterruptedException, KeeperException</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> Stat <span class="title">exists</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher)</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getData</span><span class="params">(<span class="keyword">final</span> String path, Watcher watcher, Stat stat)</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> Stat <span class="title">setData</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">byte</span> data[], <span class="keyword">int</span> version)</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">final</span> String path, VoidCallback cb, Object ctx)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在这一节中，我们将介绍如何在生产环境中使用 Zookeeper 实现发布订阅、命名服务、分布式协调以及分布式锁等功能。</p>
<h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>通过 Zookeeper 进行数据的发布与订阅其实可以说是它提供的最基本功能，它能够允许多个客户端同时订阅某一个节点的变更并在变更发生时执行我们预先设置好的回调函数，在运行时改变服务的配置和行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost"</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line">zk.getData(<span class="string">"/config"</span>, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(watchedEvent.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">null</span>);</span><br><span class="line">zk.setData(<span class="string">"/config"</span>, <span class="string">"draven"</span>.getBytes(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WatchedEvent state:SyncConnected type:NodeDataChanged path:/config</span></span><br></pre></td></tr></table></figure>
<p>发布与订阅是 Zookeeper 提供的一个最基本的功能，它的使用非常的简单，我们可以在 getData 中传入实现 process 方法的 Watcher 对象，在每次改变节点的状态时，process 方法都会被调用，在这个方法中就可以对变更进行响应动态修改一些行为。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgSxTEVkXYajOZVRbEoze94QtA3VJWVDJeZR0bZOTNEut2phSlTeia1PQ.png" alt="img"></p>
<p>通过 Zookeeper 这个中枢，每一个客户端对节点状态的改变都能够推送给节点的订阅者，在发布订阅模型中，Zookeeper 的每一个节点都可以被理解成一个主题，每一个客户端都可以向这个主题推送详细，同时也可以订阅这个主题中的消息；只是 Zookeeper 引入了文件系统的父子层级的概念将发布订阅功能实现得更加复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> EventType &#123;</span><br><span class="line">    None(-<span class="number">1</span>),</span><br><span class="line">    NodeCreated(<span class="number">1</span>),</span><br><span class="line">    NodeDeleted(<span class="number">2</span>),</span><br><span class="line">    NodeDataChanged(<span class="number">3</span>),</span><br><span class="line">    NodeChildrenChanged(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们订阅了一个节点的变更信息，那么该节点的子节点出现数量变更时就会调用 process 方法通知观察者，这也意味着更复杂的实现，同时和专门做发布订阅的中间件相比也没有性能优势，在海量推送的应用场景下，消息队列更能胜任，而 Zookeeper 更适合做一些类似服务配置的动态下发的工作。</p>
<h3 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h3><p>除了实现服务配置数据的发布与订阅功能，Zookeeper 还能帮助分布式系统实现命名服务，在每一个分布式系统中，客户端应用都有根据指定名字获取资源、服务器地址的需求，在这时就要求整个集群中的全部服务有着唯一的名字。</p>
<p>在大型分布式系统中，有两件事情非常常见，一是不同服务之间的可能拥有相同的名字，另一个是同一个服务可能会在集群中部署很多的节点，Zookeeper 就可以通过文件系统和顺序节点解决这两个问题。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgf97vCKocKsSdxkFHv6dSkVVBib7FBptgKSk3iaZw2GnPB9JILiarMttsg.png" alt="img"></p>
<p>在上图中，我们创建了两个命名空间，/infrastructure 和 /business 分别代表架构和业务部门，两个部门中都拥有名为 metrics 的服务，而业务部门的 metrics 服务也部署了两个节点，在这里使用了命名空间和顺序节点解决唯一标志符的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost"</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line">zk.create(<span class="string">"/metrics"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">zk.create(<span class="string">"/metrics"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line">List children = zk.getChildren(<span class="string">"/"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(children);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [metrics0000000001, metrics0000000002]</span></span><br></pre></td></tr></table></figure>
<p>使用上面的代码就能在 Zookeeper 中创建两个带序号的 metrics 节点，分别是 metrics0000000001 和 metrics0000000002，也就是说 Zookeeper 帮助我们保证了节点的唯一性，让我们能通过唯一的 ID 查找到对应服务的地址等信息。</p>
<h3 id="协调分布式事务"><a href="#协调分布式事务" class="headerlink" title="协调分布式事务"></a>协调分布式事务</h3><p>Zookeeper 的另一个作用就是担任分布式事务中的协调者角色，在之前介绍 分布式事务 的文章中我们曾经介绍过分布式事务本质上都是通过 2PC 来实现的，在两阶段提交中就需要一个协调者负责协调分布式事务的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost"</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line">String path = zk.create(<span class="string">"/transfer/tx"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">List ops = Arrays.asList(</span><br><span class="line">        Op.create(path + <span class="string">"/cohort"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL),</span><br><span class="line">        Op.create(path + <span class="string">"/cohort"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL),</span><br><span class="line">        Op.create(path + <span class="string">"/cohort"</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL)</span><br><span class="line">);</span><br><span class="line">zk.multi(ops);</span><br></pre></td></tr></table></figure>
<p>当前节点作为协调者在每次发起分布式事务时都会创建一个 /transfer/tx 的持久顺序节点，然后为几个事务的参与者创建几个空白的节点，事务的参与者在收到事务时会向这些空白的节点中写入信息并监听这些节点中的内容。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgZTwRH2NybwfgpMTD8gOUAT2k6NAG2MAE3UEpJTLic29Zu6HO1iac7dsA.png" alt="img"></p>
<p>所有的事务参与者会向当前节点中写入提交或者终止，一旦当前的节点改变了事务的状态，其他节点就会得到通知，如果出现一个写入终止的节点，所有的节点就会回滚对分布式事务进行回滚。</p>
<p>使用 Zookeeper 实现强一致性的分布式事务其实还是一件比较困难的事情，一方面是因为强一致性的分布式事务本身就有一定的复杂性，另一方面就是 Zookeeper 为了给客户端提供更多的自由，对外暴露的都是比较基础的 API，对它们进行组装实现复杂的分布式事务还是比较麻烦的，对于如何使用 Zookeeper 实现分布式事务，我们可以在 ZooKeeper Recipes and Solutions 一文中找到更为详细的内容。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>在数据库中，锁的概念其实是非常重要的，常见的关系型数据库就会对排他锁和共享锁进行支持，而 Zookeeper 提供的 API 也可以让我们非常简单的实现分布式锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost"</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> String resource = <span class="string">"/resource"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String lockNumber = zk</span><br><span class="line">        .create(<span class="string">"/resource/lock-"</span>, <span class="keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; locks = zk.getChildren(resource, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">Collections.sort(locks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (locks.get(<span class="number">0</span>).equals(lockNumber.replace(<span class="string">"/resource/"</span>, <span class="string">""</span>))) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Acquire Lock"</span>);</span><br><span class="line">    zk.delete(lockNumber, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    zk.getChildren(resource, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost"</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line">                List locks = zk.getChildren(resource, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (locks.get(<span class="number">0</span>).equals(lockNumber.replace(<span class="string">"/resource/"</span>, <span class="string">""</span>))) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Acquire Lock"</span>);</span><br><span class="line">                    zk.delete(lockNumber, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果多个服务同时要对某个资源进行修改，就可以使用上述的代码来实现分布式锁，假设集群中存在一个资源 /resource，几个服务需要通过分布式锁保证资源只能同时被一个节点使用，我们可以用创建临时顺序节点的方式实现分布式锁；当我们创建临时节点后，通过 getChildren 获取当前等待锁的全部节点，如果当前节点是所有节点中序号最小的就得到了当前资源的使用权限，在对资源进行处理后，就可以通过删除 /resource/lock-00000000x 来释放锁，如果当前节点不是最小值，就会注册一个 Watcher 等待 /resource 子节点的变化直到当前节点的序列号成为最小值。</p>
<p>上述代码在集群中争夺同一资源的服务器特别多的情况下会出现羊群效应，每次子节点改变时都会通知当前节点，造成资源的浪费，我们其实可以将 getChildren 换成 getData，让当前节点只监听前一个节点的删除事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer number = Integer.parseInt(lockNumber.replace(<span class="string">"/resource/lock-"</span>, <span class="string">""</span>)) + <span class="number">1</span>;</span><br><span class="line">String previousLock = <span class="string">"/resource/lock-"</span> + String.format(<span class="string">"%010d"</span>, number);</span><br><span class="line"></span><br><span class="line">zk.getData(previousLock, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Acquire Lock"</span>);</span><br><span class="line">                ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"localhost"</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line">                zk.delete(lockNumber, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>在新的分布式锁实现中，我们减少了每一个服务需要关注的事情，只让它们监听需要关心的数据变更，减少 Zookeeper 发送不必要的通知影响效率。</p>
<p><img src="/2018/10/07/详解分布式协调服务-ZooKeeper/FE4VibF0SjfNC55Nwr7XreFBdYW0Q4icTgicZX3XWkhCibYLhs7bo1XoibRfNoS05Rrhk76Yowaw8RMlv3X0MXA5BfA.png" alt="img"></p>
<p>分布式锁作为分布式系统中比较重要的一个工具，确实有着比较多的应用，同时也有非常多的实现方式，除了 Zookeeper 之外，其他服务例如 Redis 和 etcd 也能够实现分布式锁，为分布式系统的构建提供支持，不过在这篇文章中就不展开介绍了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在这篇文章中简单介绍了 Google 的分布式锁服务 Chubby 以及同样能够提供分布式锁服务功能的 Zookeeper。</p>
<p>作为分布式协调服务，Zookeeper 的应用场景非常广泛，不仅能够用于服务配置的下发、命名服务、协调分布式事务以及分布式锁，还能够用来实现微服务治理中的服务注册以及发现等功能，这些其实都源于 Zookeeper 能够提供高可用的分布式协调服务，能够为客户端提供分布式一致性的支持，在后面的文章中作者也会介绍其他用于分布式协调的服务。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zookeeper.apache.org/doc/r3.4.4/recipes.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.4/recipes.html</a></p>
<p><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf" target="_blank" rel="noopener">https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf</a></p>
]]></content>
  </entry>
  <entry>
    <title>Shadowsocks服务器代理</title>
    <url>/2018/07/13/Shadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲述如何安装配置Shadowsocks Server，并支持通过代理方式（http/sock v4/5)连接因特网.</p>
<p><img src="/2018/07/13/Shadowsocks服务器代理/1531388960253.png" alt="1531388960253"></p>
<p>这里主要阐述服务端通过proxy连接的解决方案，shadowsocks server直连网络的方式比较简单，网上这块资料也比较齐全，不做过多描述，</p>
<h2 id="ssserver代理安装配置"><a href="#ssserver代理安装配置" class="headerlink" title="ssserver代理安装配置"></a>ssserver代理安装配置</h2><h3 id="安装Shadowsocks-Server"><a href="#安装Shadowsocks-Server" class="headerlink" title="安装Shadowsocks Server"></a>安装Shadowsocks Server</h3><p>参考<a href="https://github.com/shadowsocks/shadowsocks/wiki/Install-Shadowsocks-Server-on-Windows" target="_blank" rel="noopener">Install Shadowsocks Server on Windows</a>，</p>
<p>客户端的安装方式参考<a href="https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#windows" target="_blank" rel="noopener">Shadowsocks Client安装</a>, 这里主要解决服务端通过代理解决shadowsocks server无法直连网络的问题，客户端这块不做过多描述。</p>
<h3 id="更新代理脚本"><a href="#更新代理脚本" class="headerlink" title="更新代理脚本"></a>更新代理脚本</h3><p>​    这个问题的解决方案来自github的一个issue <a href="https://github.com/shadowsocks/shadowsocks/issues/771" target="_blank" rel="noopener">通过猴子补丁的方式给ss添加了一个前置代理的功能</a></p>
<p>有兴趣深入了解的推荐star一下该作者的项目<a href="https://github.com/falseen/PySocket" target="_blank" rel="noopener">PySocket</a></p>
<p>​    在上述步骤安装了python版的Shadowsocks Server之后，通过猴子补丁的方式给给 shadowsocks 服务端添加前置代理的功能（原则上也适用于客户端），支持 http、socks4、socks5 代理。并且通过 hook 的方式去掉了ss的dns查询，ss在接收到数据之后会直接把域名和请求一起发给代理。</p>
<p><strong>使用的时候修改 socket.py 文件中 PROXY_TYPE、PROXY_ADDR、PROXY_PORT 等字段为你的代理地址，然后把 socket.py 文件放到 shadowsocks 根目录即可生效，不用修改任何源码</strong>。</p>
<p>通过pip安装的话要放到ssserver所在的目录，一般都在 <code>Python27\Scripts</code> （python27上验证OK）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install win_inet_pton --proxy=http://your-proxy-host:your-proxy-port</span><br><span class="line">pip install shadowsocks --proxy=http://your-proxy-host:your-proxy-port</span><br></pre></td></tr></table></figure>
<p>配置部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the proxy type. SOCKS5 SOCKS4 HTTP</span></span><br><span class="line">PROXY_TYPE = SOCKS5</span><br><span class="line">PROXY_ADDR = <span class="string">"127.0.0.1"</span></span><br><span class="line">PROXY_PORT = <span class="number">1080</span></span><br></pre></td></tr></table></figure>
<p><strong>socket.py</strong> 文末部分，因为我选择 hook shadowsocks的代码，实际使用时在del module会报异常，因此将文末修改为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hook shadowsocks's code remove the dns req</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_resolve</span><span class="params">(self,  hostname, callback)</span>:</span></span><br><span class="line">    callback((hostname, hostname), <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">modules_list = [<span class="string">"shadowsocks.common"</span>, <span class="string">"shadowsocks.shell"</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> modules_list:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">del</span> sys.modules[x]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"Error: key"</span>, x, <span class="string">"not found"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shadowsocks.asyncdns</span><br><span class="line">shadowsocks.asyncdns.DNSResolver.resolve = new_resolve</span><br></pre></td></tr></table></figure>
<p>如果不想 hook shadowsocks的代码的话，把文件中末尾的代码删除即可，原文件代码末尾如下: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hook shadowsocks's code remove the dns req</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_resolve</span><span class="params">(self,  hostname, callback)</span>:</span></span><br><span class="line">    callback((hostname, hostname), <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">modules_list = [<span class="string">"shadowsocks.common"</span>, <span class="string">"shadowsocks.shell"</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> modules_list:</span><br><span class="line">    <span class="keyword">del</span> sys.modules[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shadowsocks.asyncdns</span><br><span class="line">shadowsocks.asyncdns.DNSResolver.resolve = new_resolve</span><br></pre></td></tr></table></figure>
<h3 id="ssserver配置"><a href="#ssserver配置" class="headerlink" title="ssserver配置"></a>ssserver配置</h3><p>参考<a href="https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File" target="_blank" rel="noopener">Configuration via Config File</a></p>
<p>创建一个配置文件 <code>/etc/shadowsocks.json</code>. 示例如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"my_server_ip"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"mypassword"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件字段详解:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>server</td>
<td>ssserver监听地址，0.0.0.0监听本地所有网卡地址</td>
</tr>
<tr>
<td>server_port</td>
<td>ssserver服务端口</td>
</tr>
<tr>
<td>local_address</td>
<td>本地监听地址</td>
</tr>
<tr>
<td>local_port</td>
<td>本地端口</td>
</tr>
<tr>
<td>password</td>
<td>用于加密的密码</td>
</tr>
<tr>
<td>timeout</td>
<td>超时设置，单位秒，不建议太长</td>
</tr>
<tr>
<td>method</td>
<td>默认: “aes-256-cfb”, 详见 <a href="https://github.com/shadowsocks/shadowsocks/wiki/Encryption" target="_blank" rel="noopener">Encryption</a></td>
</tr>
<tr>
<td>fast_open</td>
<td>是否使用 <a href="https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open" target="_blank" rel="noopener">TCP_FASTOPEN</a>, true / false</td>
</tr>
<tr>
<td>workers</td>
<td>worker数量, 仅在Unix/Linux生效</td>
</tr>
</tbody>
</table>
<p>在控制台中执行，日志直接显示在控制台，首次测试使用建议该方式，可通过ctrl+C退出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>后台静默执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line"># 停止服务</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>developer tools</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>docker碎片拾遗</title>
    <url>/2018/06/24/docker%E7%A2%8E%E7%89%87%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h3 id="进入shell环境"><a href="#进入shell环境" class="headerlink" title="进入shell环境"></a>进入shell环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker exec -it &lt;container&gt; bash</span><br></pre></td></tr></table></figure>
<p>and run</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>
<h3 id="！不要去改系统配置"><a href="#！不要去改系统配置" class="headerlink" title="！不要去改系统配置"></a>！不要去改系统配置</h3><p>正常运行的docker先保存一下docker的ID，之后不要去改下面的配置，否则docker会更新为新的那个，导致数据丢失</p>
<p><img src="/2018/06/24/docker碎片拾遗/1529818594236.png" alt="1529818594236"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Xshell显示X11图形化界面</title>
    <url>/2018/06/17/Xshell%E6%98%BE%E7%A4%BAX11%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="安装Xmanager全家桶"><a href="#安装Xmanager全家桶" class="headerlink" title="安装Xmanager全家桶"></a>安装Xmanager全家桶</h3><p>使用前检查一下是否安装了Xshell、Xstart、Xmanager - Passive，正常安装Xmanager全家桶应该是全的</p>
<p><img src="/2018/06/17/Xshell显示X11图形化界面/1529248519265.png" alt="1529248519265"></p>
<h3 id="使用XStart登录"><a href="#使用XStart登录" class="headerlink" title="使用XStart登录"></a>使用XStart登录</h3><p>通过SSH的方式尝试登录VPS，</p>
<p><img src="/2018/06/17/Xshell显示X11图形化界面/1529248581921.png" alt="1529248581921"></p>
<p>正常成功后会这样提示</p>
<p><img src="/2018/06/17/Xshell显示X11图形化界面/1529248649118.png" alt="1529248649118"></p>
<p>当然更多的可能是弹出个错误框提示“已拒绝X11转移申请”，这是因为默认的VPS一般不会安装XAUTH导致，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install xorg-x11-xauth</span><br></pre></td></tr></table></figure>
<p>这里可能会缺一些其他组件，见招拆招即可，谷歌或者百度解决</p>
<h3 id="设置XSHELL"><a href="#设置XSHELL" class="headerlink" title="设置XSHELL"></a>设置XSHELL</h3><ol>
<li>打开会话对话框</li>
<li>选择要激活X11转发功能的会话</li>
<li>点击[属性]按钮</li>
<li>在[类别]中选择[连接-&gt;SSH-&gt;隧道]</li>
<li>选择[转发X11连接到]</li>
<li>如用户的PC上已<a href="http://www.xshellcn.com/xmg_column/xm-az.html" target="_blank" rel="noopener">安装Xmanager</a>，请勾选[Xmanager(M)]。如使用其他PC X 服务器，请选择[X DISPLAY(D)]后输入适用的DISPLAY </li>
<li>点击[确定] </li>
</ol>
<p><img src="/2018/06/17/Xshell显示X11图形化界面/1529248873947.png" alt="1529248873947"></p>
<h3 id="检查当前监听端口"><a href="#检查当前监听端口" class="headerlink" title="检查当前监听端口"></a>检查当前监听端口</h3><p><strong>IMPORTANT</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netstat -tnlp|grep sshd</span><br></pre></td></tr></table></figure>
<p><img src="/2018/06/17/Xshell显示X11图形化界面/1529249219317.png" alt="1529249219317"></p>
<p>注意上面监听的6010，Xmanager会把X DISPLAY选项自动查找为<a href="http://www.xshellcn.com/" target="_blank" rel="noopener">Xshell</a>。其他 PC X 服务器程序需由用户进行设置。如果PC X 服务器使用TCP 6000号端口，DISPLAY设置为“localhost:0.0” ，也就是说，X11的<strong>偏移量是6000</strong>，因此下面需要设置一个最终要的DISPLAY的值<strong>:10.0</strong>，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export DISPLAY=:10.0</span><br><span class="line">或者</span><br><span class="line">export DISPLAY=localhost:10.0</span><br></pre></td></tr></table></figure>
<h3 id="测试X11-DISPLAY"><a href="#测试X11-DISPLAY" class="headerlink" title="测试X11 DISPLAY"></a>测试X11 DISPLAY</h3><p>如果本地已经有需要X11界面展示的应用，直接运行查看即可，如无，推荐使用xclock检查是否生效[以下步骤不是必须，自行选择]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install xclock</span><br></pre></td></tr></table></figure>
<p>这里可能出现乱码之类的，可能需要安装x窗口相关包，和字体显示包 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum groupinstall "X Window System" "Fonts"</span><br></pre></td></tr></table></figure>
<p>然后执行xclock，看是否在PC桌面显示对应的时钟图形。如果xclock出现<a href="https://access.redhat.com/solutions/409033" target="_blank" rel="noopener">Warning: Missing charsets in String to FontSet conversion</a>，可以执行下面执行，然后重新执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>X11 Display</tag>
        <tag>XSHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加Gitalk评论插件</title>
    <url>/2018/06/01/Hexo%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a>提供了两种方式：</p>
<ul>
<li>直接引入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- or --&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>npm安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save gitalk</span><br><span class="line">import &apos;gitalk/dist/gitalk.css&apos;</span><br><span class="line">import Gitalk from &apos;gitalk&apos;</span><br></pre></td></tr></table></figure>
<p>相对来说第一种会更简单。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>A <strong>GitHub Application</strong> is needed for authorization, if you don’t have one, <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">Click here to register</a> a new one.</p>
<p><strong>Note:</strong> You must specify the website domain url in the <code>Authorization callback URL</code> field.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const gitalk = new Gitalk(&#123;</span><br><span class="line">  clientID: &apos;GitHub Application Client ID&apos;,</span><br><span class="line">  clientSecret: &apos;GitHub Application Client Secret&apos;,</span><br><span class="line">  repo: &apos;GitHub repo&apos;,</span><br><span class="line">  owner: &apos;GitHub repo owner&apos;,</span><br><span class="line">  admin: [&apos;GitHub repo owner and collaborators, only these guys can initialize github issues&apos;],</span><br><span class="line">  id: location.pathname,      // Ensure uniqueness and length less than 50</span><br><span class="line">  distractionFreeMode: false  // Facebook-like distraction free mode</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render(&apos;gitalk-container&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="修改主题文件"><a href="#修改主题文件" class="headerlink" title="修改主题文件"></a>修改主题文件</h3><ul>
<li>这里以next主题为例，参考<a href="https://github.com/iissnan/hexo-theme-next/pull/1814/files#diff-9f7e5af0c701ee066fc50dcf184a48ec" target="_blank" rel="noopener">Feature: Add Gitalk Support</a></li>
</ul>
<p>不同的主题目录和模板引擎不同，可以自己修改, 修改next主题配置文件<code>_config.yml</code>，添加字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Gitalk</span><br><span class="line"># more info please open https://github.com/gitalk/gitalk</span><br><span class="line">gitalk:</span><br><span class="line">  enable: false</span><br><span class="line">  clientID:</span><br><span class="line">  clientSecret:</span><br><span class="line">  repo:</span><br><span class="line">  owner:</span><br><span class="line">  admin: # support multiple admins split with comma, e.g. foo,bar</span><br><span class="line">  pagerDirection: first</span><br></pre></td></tr></table></figure>
<ul>
<li>找到<code>next/layout/_third-party/comments</code>文件夹，新建<code>gitalk.swig</code>文件，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125;</span><br><span class="line">  &#123;% if theme.gitalk.enable %&#125;</span><br><span class="line">    &#123;% if page.comments %&#125;</span><br><span class="line">      &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">      &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        const gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123;theme.gitalk.clientID&#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123;theme.gitalk.clientSecret&#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123;theme.gitalk.repo&#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123;theme.gitalk.owner&#125;&#125;&apos;,</span><br><span class="line">          admin: &apos;&#123;&#123;theme.gitalk.admin&#125;&#125;&apos;.split(&apos;,&apos;),</span><br><span class="line">          pagerDirection: &apos;&#123;&#123;theme.gitalk.pagerDirection&#125;&#125;&apos;,</span><br><span class="line">          // facebook-like distraction free mode</span><br><span class="line">          distractionFreeMode: false</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同目录下在<code>index.swig</code>文件末尾添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>下步搞起，<code>next/layout/_partials</code>文件夹下，找到<code>comments.swig</code>文件，添加代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">      &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br></pre></td></tr></table></figure>
<p> 因为github限制了issue的提交title长度不能超过50，可能会遇到<a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">Error: Validation Failed</a> 按照这里的方案，使用MD5的方式降低长度即可</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a href="https://www.jianshu.com/p/9be29ed2f4b7" target="_blank" rel="noopener">Hexo添加Gitalk评论插件</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">Next 第三方服务集成</a></li>
<li><a href="https://github.com/gitalk/gitalk/wiki/%E5%9C%A8hexo-next%E4%B8%BB%E9%A2%98%E4%B8%8A%E4%BD%BF%E7%94%A8gitalk" target="_blank" rel="noopener">在hexo next主题上使用gitalk</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用攻略</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo集成Algolia搜索插件</title>
    <url>/2018/06/01/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p><strong><em>本文转载自</em></strong><a href="http://zouzeir.xyz/2017/01/16/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">Hexo集成Algolia搜索插件</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>个人博客自从2016年10月21日搭建以来，迄今为止已经有49 篇日志了。虽然不是很多篇文章，但是搜索站内的内容已经力不从心了。</p>
<p>搜索了网上很多关于“Hexo 站内搜索”的内容，发现大部分都是使用<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>，但是发现Swiftype 搜索只有15 天的免费，之后就需要开始收费了。</p>
<p>因为只是为自己的<a href="https://jobbym.github.io/" target="_blank" rel="noopener">个人博客 </a>使用站内搜索，所以希望找一个类似与Swiftype 的，但是<strong>免费的</strong>站内搜索。最后找了Algolia 这个免费版本替代。</p>
<p>下面简单说下搭建过程：</p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>如果你的Next 版本为5.1.0 之后，可以使用Algolia。如果不是，请先升级到5.1.0 版本之后</p>
<h3 id="一个Algolia-帐号"><a href="#一个Algolia-帐号" class="headerlink" title="一个Algolia 帐号"></a>一个Algolia 帐号</h3><p><a href="https://www.algolia.com/users/sign_in" target="_blank" rel="noopener">官网地址</a> 使用GitHub 或Google 帐号登录。<br><a href="http://zouzeir.xyz/2017/01/16/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/algolia_login.jpg" target="_blank" rel="noopener"><img src="/2018/06/01/Hexo集成Algolia搜索插件/algolia_login.jpg" alt="img"></a></p>
<h3 id="创建Index"><a href="#创建Index" class="headerlink" title="创建Index"></a>创建Index</h3><p>进入<a href="https://www.algolia.com/dashboard" target="_blank" rel="noopener">Dashboard</a>，<br>选择<a href="https://www.algolia.com/explorer#?index=getstarted_actors" target="_blank" rel="noopener">Indices</a> 新建一个Index。<br><a href="http://zouzeir.xyz/2017/01/16/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/algolia_explorer.jpg" target="_blank" rel="noopener"><img src="/2018/06/01/Hexo集成Algolia搜索插件/algolia_explorer.jpg" alt="img"></a><br><a href="http://zouzeir.xyz/2017/01/16/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/algolia_newindex.jpg" target="_blank" rel="noopener"><img src="/2018/06/01/Hexo集成Algolia搜索插件/algolia_newindex.jpg" alt="img"></a></p>
<h3 id="安装Hexo-Algolia"><a href="#安装Hexo-Algolia" class="headerlink" title="安装Hexo Algolia"></a>安装Hexo Algolia</h3><p>Index 创建完成后，此时Index 为包含任何数据。需要安装Hexo Aloglia 扩展，这个扩展的功能是搜集站点的内容并通过API 发送给Aloglia。前往站点根目录，执行命令安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure>
<h3 id="获取Key，更新站点信配置"><a href="#获取Key，更新站点信配置" class="headerlink" title="获取Key，更新站点信配置"></a>获取Key，更新站点信配置</h3><p>点击Dashborad 左侧的<a href="https://www.algolia.com/api-keys" target="_blank" rel="noopener">API Keys</a>，其中的信息接下来将会被用到。<br><a href="http://zouzeir.xyz/2017/01/16/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/algolia_apikeys.jpg" target="_blank" rel="noopener"><img src="/2018/06/01/Hexo集成Algolia搜索插件/algolia_apikeys.jpg" alt="img"></a><br>包括<code>Application ID</code> 、<code>Search-Only API Key</code> 和 <code>Admin API Key</code>，其中<code>Admin API Key</code>需要保密保存</p>
<p>编辑站点配置文件，新增以下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: &apos;SV57WJ53OS&apos;</span><br><span class="line">  apiKey: &apos;c7d219504e44d09ab55f5f7a195fce98&apos;</span><br><span class="line">  adminApiKey: &apos;adminApiKey&apos;</span><br><span class="line">  indexName: &apos;dev_jobbymsblog&apos;</span><br><span class="line">  chunkSize: 5000</span><br></pre></td></tr></table></figure>
<h3 id="更新Index"><a href="#更新Index" class="headerlink" title="更新Index"></a>更新Index</h3><p>当配置完成，在站点根目录下执行<code>hexo algolia</code> 来更新Index。请注意观察命令的输出。<br><a href="http://zouzeir.xyz/2017/01/16/Hexo%E9%9B%86%E6%88%90Algolia%E6%90%9C%E7%B4%A2%E6%8F%92%E4%BB%B6/algolia_hexo_algolia.jpg" target="_blank" rel="noopener"><img src="/2018/06/01/Hexo集成Algolia搜索插件/algolia_hexo_algolia.jpg" alt="img"></a></p>
<h3 id="主题集成"><a href="#主题集成" class="headerlink" title="主题集成"></a>主题集成</h3><p>更改主题配置文件，找到Algolia Search 配置部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Algolia Search</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: false</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 10</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot;</span><br><span class="line">    hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span><br></pre></td></tr></table></figure>
<p>将<code>enable</code> 改为<code>true</code> 即可，根据需要你可以调整<code>labels</code> 中的文本。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 点击搜索结果，结果跳转地址为：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot GET /undefined/</span><br></pre></td></tr></table></figure>
<p>按照<a href="https://github.com/iissnan/hexo-theme-next/issues/1084" target="_blank" rel="noopener">5.1.0使用algolia搜索问题</a>这里进行的处理，在这里总结一下：</p>
<ul>
<li>因为hexo-aloglia 的作者没有把<code>post.path</code> 加入index，所以<code>data.path</code> 是<code>undefined</code>。</li>
<li>遇到这个问题，首先运行<code>npm uninstll hexo-algolia</code> 卸载之前的版本，再运行<code>npm install hexo-algolia@0.2.0 --save</code>,最后运行<code>hexo algolia</code> 命令重新index 就可以了。</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki/Swiftype%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener">Swiftype站内搜索</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">Next 第三方服务集成</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用攻略</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Algolia</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux xmr-stak挖矿教程</title>
    <url>/2018/05/27/Linux-xmr-stak%E6%8C%96%E7%9F%BF%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="在Linux上编译-xmr-stak"><a href="#在Linux上编译-xmr-stak" class="headerlink" title="在Linux上编译 xmr-stak"></a>在Linux上编译 <strong>xmr-stak</strong></h1><h2 id="Install-Dependencies"><a href="#Install-Dependencies" class="headerlink" title="Install Dependencies"></a>Install Dependencies</h2><h3 id="AMD-APP-SDK-3-0-only-needed-to-use-AMD-GPUs"><a href="#AMD-APP-SDK-3-0-only-needed-to-use-AMD-GPUs" class="headerlink" title="AMD APP SDK 3.0 (only needed to use AMD GPUs)"></a>AMD APP SDK 3.0 (only needed to use AMD GPUs)</h3><ul>
<li>download and install the latest version from <a href="https://www.dropbox.com/sh/mpg882ekirnsfa7/AADWz5X-TgVdsmWt0QwMgTWLa/AMD-APP-SDKInstaller-v3.0.130.136-GA-linux64.tar.bz2?dl=0" target="_blank" rel="noopener">https://www.dropbox.com/sh/mpg882ekirnsfa7/AADWz5X-TgVdsmWt0QwMgTWLa/AMD-APP-SDKInstaller-v3.0.130.136-GA-linux64.tar.bz2?dl=0</a><br>(do not wonder why it is a link to a dropbox but AMD has removed the SDK downloads, see <a href="https://community.amd.com/thread/228059" target="_blank" rel="noopener">https://community.amd.com/thread/228059</a>)</li>
</ul>
<h3 id="Cuda-8-0-only-needed-to-use-NVIDIA-GPUs"><a href="#Cuda-8-0-only-needed-to-use-NVIDIA-GPUs" class="headerlink" title="Cuda 8.0+ (only needed to use NVIDIA GPUs)"></a>Cuda 8.0+ (only needed to use NVIDIA GPUs)</h3><ul>
<li>download and install <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a></li>
<li>for minimal install choose <code>Custom installation options</code> during the install and select<ul>
<li>CUDA/Develpment</li>
<li>CUDA/Runtime</li>
<li>Driver components</li>
</ul>
</li>
</ul>
<h2 id="GNU-Compiler"><a href="#GNU-Compiler" class="headerlink" title="GNU Compiler"></a>GNU Compiler</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ubuntu / Debian</span><br><span class="line">sudo apt install libmicrohttpd-dev libssl-dev cmake build-essential libhwloc-dev</span><br><span class="line">git clone https://github.com/fireice-uk/xmr-stak.git</span><br><span class="line">mkdir xmr-stak/build</span><br><span class="line">cd xmr-stak/build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># Arch</span><br><span class="line">sudo pacman -S --needed base-devel hwloc openssl cmake libmicrohttpd</span><br><span class="line">git clone https://github.com/fireice-uk/xmr-stak.git</span><br><span class="line">mkdir xmr-stak/build</span><br><span class="line">cd xmr-stak/build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># Fedora</span><br><span class="line">sudo dnf install gcc gcc-c++ hwloc-devel libmicrohttpd-devel libstdc++-static make openssl-devel cmake</span><br><span class="line">git clone https://github.com/fireice-uk/xmr-stak.git</span><br><span class="line">mkdir xmr-stak/build</span><br><span class="line">cd xmr-stak/build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># CentOS</span><br><span class="line">sudo yum install centos-release-scl epel-release</span><br><span class="line">sudo yum install cmake3 devtoolset-4-gcc* hwloc-devel libmicrohttpd-devel openssl-devel make</span><br><span class="line">scl enable devtoolset-4 bash</span><br><span class="line">git clone https://github.com/fireice-uk/xmr-stak.git</span><br><span class="line">mkdir xmr-stak/build</span><br><span class="line">cd xmr-stak/build</span><br><span class="line">cmake3 ..</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># Ubuntu 14.04</span><br><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc-5 g++-5 make</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 1 --slave /usr/bin/g++ g++ /usr/bin/g++-5</span><br><span class="line">curl -L http://www.cmake.org/files/v3.4/cmake-3.4.1.tar.gz | tar -xvzf - -C /tmp/</span><br><span class="line">cd /tmp/cmake-3.4.1/ &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install &amp;&amp; cd -</span><br><span class="line">sudo update-alternatives --install /usr/bin/cmake cmake /usr/local/bin/cmake 1 --force</span><br><span class="line">sudo apt install libmicrohttpd-dev libssl-dev libhwloc-dev</span><br><span class="line">git clone https://github.com/fireice-uk/xmr-stak.git</span><br><span class="line">mkdir xmr-stak/build</span><br><span class="line">cd xmr-stak/build</span><br><span class="line">cmake ..</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"># TinyCore Linux 8.x</span><br><span class="line"># TinyCore is 32-bit only, but there is an x86-64 port, known as &quot;Pure 64,&quot;</span><br><span class="line"># hosted on the TinyCore home page, and it works well.</span><br><span class="line"># Beware that huge page support is not enabled in the kernel distributed</span><br><span class="line"># with Pure 64.  Consider http://wiki.tinycorelinux.net/wiki:custom_kernel</span><br><span class="line"># Note that as of yet there are no distro packages for microhttpd or hwloc.</span><br><span class="line"># hwloc is easy enough to install manually though, shown below.</span><br><span class="line"># Also note that only CPU mining has been tested on this platform, thus the</span><br><span class="line"># disabling of CUDA and OpenCL shown below.</span><br><span class="line">tce-load -iw openssl-dev.tcz cmake.tcz make.tcz gcc.tcz git.tcz \</span><br><span class="line">             glibc_base-dev.tcz linux-4.8.1_api_headers.tcz \</span><br><span class="line">             glibc_add_lib.tcz</span><br><span class="line">wget https://www.open-mpi.org/software/hwloc/v1.11/downloads/hwloc-1.11.8.tar.gz</span><br><span class="line">tar xzvf hwloc-1.11.8.tar.gz</span><br><span class="line">cd hwloc-1.11.8</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">cd ..</span><br><span class="line">git clone http://github.com/fireice-uk/xmr-stak</span><br><span class="line">cd xmr-stak</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">CC=gcc cmake .. -DCUDA_ENABLE=OFF \</span><br><span class="line">                -DOpenCL_ENABLE=OFF \</span><br><span class="line">                -DMICROHTTPD_ENABLE=OFF</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<ul>
<li><p>g++ version 5.1 or higher is required for full C++11 support.<br>If you want to compile the binary without installing libraries / compiler or just compile binary for some other distribution, please check the <a href="scripts/build_xmr-stak_docker/build_xmr-stak_docker.sh">build_xmr-stak_docker.sh script</a>.</p>
</li>
<li><p>Some newer gcc versions are not supported by CUDA (e.g. Ubuntu 17.10). It will require installing gcc 5 but you can avoid changing defaults.</p>
</li>
</ul>
<p>In that case you can force CUDA to use an older compiler in the following way:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -DCUDA_HOST_COMPILER=/usr/bin/gcc-5 ..</span><br></pre></td></tr></table></figure></p>
<h3 id="To-do-a-generic-and-static-build-for-a-system-without-gcc-5-1"><a href="#To-do-a-generic-and-static-build-for-a-system-without-gcc-5-1" class="headerlink" title="To do a generic and static build for a system without gcc 5.1+"></a>To do a generic and static build for a system without gcc 5.1+</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_LINK_STATIC=ON -DXMR-STAK_COMPILE=generic .</span><br><span class="line">make install</span><br><span class="line">cd bin\Release</span><br><span class="line">copy C:\xmr-stak-dep\openssl\bin\* .</span><br></pre></td></tr></table></figure>
<p>Note - cmake caches variables, so if you want to do a dynamic build later you need to specify ‘-DCMAKE_LINK_STATIC=OFF’</p>
<p>Reference <a href="https://github.com/fireice-uk/xmr-stak" target="_blank" rel="noopener">xmr-stak</a></p>
]]></content>
      <categories>
        <category>block-chain</category>
      </categories>
      <tags>
        <tag>xmr</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 1: Bower —— 管理你的客户端依赖关系</title>
    <url>/2018/05/26/Day-1-Bower-%E2%80%94%E2%80%94-%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p><em>编者注：我们发现了比较有趣的系列文章<a href="http://segmentfault.com/a/1190000000349384" target="_blank" rel="noopener">《30天学习30种新技术》</a>，准备翻译，一天一篇更新，年终礼包。以下是第一天技术的译文。</em></p>
<hr>
<p>我决定将第一天的学习主题选为<a href="http://bower.io/" target="_blank" rel="noopener">Bower</a>。</p>
<p><img src="/2018/05/26/Day-1-Bower-——-管理你的客户端依赖关系/bVbC4e.jpg" alt="img-1"></p>
<hr>
<h2 id="什么是Bower？"><a href="#什么是Bower？" class="headerlink" title="什么是Bower？"></a>什么是Bower？</h2><p>Bower是一个客户端技术的软件包管理器，它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源。其他一些建立在Bower基础之上的开发工具，如YeoMan和Grunt，这个会在以后的文章中介绍。</p>
<hr>
<h2 id="为什么我会在意Bower？"><a href="#为什么我会在意Bower？" class="headerlink" title="为什么我会在意Bower？"></a>为什么我会在意Bower？</h2><ol>
<li>节省时间。为什么要学习Bower的第一个原因，就是它会为你节省寻找客户端的依赖关系的时间。每次我需要安装jQuery的时候，我都需要去jQuery网站下载包或使用CDN版本。但是有了Bower，你只需要输入一个命令，jquery就会安装在本地计算机上，你不需要去记版本号之类的东西，你也可以通过Bower的info命令去查看任意库的信息。</li>
<li>脱机工作。Bower会在用户主目录下创建一个.bower的文件夹，这个文件夹会下载所有的资源、并安装一个软件包使它们可以离线使用。如果你熟悉Java，Bower即是一个类似于现在流行的Maven构建系统的<em>.m2</em>仓库。每次你下载任何资源库都将被安装在两个文件夹中 —— 一个在的应用程序文件夹，另一个在用户主目录下的.bower文件夹。因此，下一次你需要这个仓库时，就会用那个用户主目录下.bower中的版本。</li>
<li>可以很容易地展现客户端的依赖关系。你可以创建一个名为bower.json的文件，在这个文件里你可以指定所有客户端的依赖关系，任何时候你需要弄清楚你正在使用哪些库，你可以参考这个文件。</li>
<li>让升级变得简单。假设某个库的新版本发布了一个重要的安全修补程序，为了安装新版本，你只需要运行一个命令，bower会自动更新所有有关新版本的依赖关系。</li>
</ol>
<hr>
<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>为了安装bower，你首先需要安装如下文件：</p>
<blockquote>
<ol>
<li>Node：下载最新版本的<a href="http://nodejs.org/" target="_blank" rel="noopener">node.js</a></li>
<li>NPM：<a href="http://npmjs.org/" target="_blank" rel="noopener">NPM</a>是node程序包管理器。它是捆绑在nodejs的安装程序上的，所以一旦你已经安装了node，NPM也就安装好了。</li>
<li>Git：你需要从git仓库获取一些代码包。</li>
</ol>
</blockquote>
<hr>
<h2 id="安装Bower"><a href="#安装Bower" class="headerlink" title="安装Bower"></a>安装Bower</h2><p>一旦你已经安装了上面所说的所有必要文件，键入以下命令安装Bower：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g bower</span><br></pre></td></tr></table></figure>
<p>这行命令是Bower的全局安装，<code>-g</code> 操作表示全局。</p>
<hr>
<h2 id="开始使用Bower"><a href="#开始使用Bower" class="headerlink" title="开始使用Bower"></a>开始使用Bower</h2><p>安装完bower之后就可以使用所有的bower命令了。可以键入<code>help</code> 命令来查看bower可以完成那些操作，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower help</span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">    bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">    cache                   Manage bower cache</span><br><span class="line">    help                    Display help information about Bower</span><br><span class="line">    home                    Opens a package homepage into your favorite browser</span><br><span class="line">    info                    Info of a particular package</span><br><span class="line">    init                    Interactively create a bower.json file</span><br><span class="line">    install                 Install a package locally</span><br><span class="line">    link                    Symlink a package folder</span><br><span class="line">    list                    List local packages</span><br><span class="line">    lookup                  Look up a package URL by name</span><br><span class="line">    prune                   Removes local extraneous packages</span><br><span class="line">    register                Register a package</span><br><span class="line">    search                  Search for a package by name</span><br><span class="line">    update                  Update a local package</span><br><span class="line">    uninstall               Remove a local package</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">    -f, --force             Makes various commands more forceful</span><br><span class="line">    -j, --json              Output consumable JSON</span><br><span class="line">    -l, --log-level         What level of logs to report</span><br><span class="line">    -o, --offline           Do not hit the network</span><br><span class="line">    -q, --quiet             Only output important information</span><br><span class="line">    -s, --silent            Do not output anything, besides errors</span><br><span class="line">    -V, --verbose           Makes output more verbose</span><br><span class="line">    --allow-root            Allows running commands as root</span><br></pre></td></tr></table></figure>
<h3 id="包的安装"><a href="#包的安装" class="headerlink" title="包的安装"></a>包的安装</h3><p>Bower是一个软件包管理器，所以你可以在应用程序中用它来安装新的软件包。举例来看一下来如何使用Bower安装JQuery，在你想要安装该包的地方创建一个新的文件夹，键入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower install jquery</span><br></pre></td></tr></table></figure>
<p>上述命令完成以后，你会在你刚才创建的目录下看到一个<code>bower_components</code>的文件夹，其中目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree bower_components/</span><br><span class="line">bower_components/</span><br><span class="line">└── jquery</span><br><span class="line">    ├── README.md</span><br><span class="line">    ├── bower.json</span><br><span class="line">    ├── component.json</span><br><span class="line">    ├── composer.json</span><br><span class="line">    ├── jquery-migrate.js</span><br><span class="line">    ├── jquery-migrate.min.js</span><br><span class="line">    ├── jquery.js</span><br><span class="line">    ├── jquery.min.js</span><br><span class="line">    ├── jquery.min.map</span><br><span class="line">    └── package.json</span><br><span class="line"></span><br><span class="line">1 directory, 10 files</span><br></pre></td></tr></table></figure>
<h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><p>现在就可以在应用程序中使用jQuery包了，在jQuery里创建一个简单的html5文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Learning Bower&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;button&gt;Animate Me!!&lt;/button&gt;</span><br><span class="line">&lt;div style=&quot;background:red;height:100px;width:100px;position:absolute;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;bower_components/jquery/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    $(document).ready(function()&#123;</span><br><span class="line">        $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">            $(&quot;div&quot;).animate(&#123;left:&apos;250px&apos;&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，你刚刚引用jquery.min.js文件，现阶段完成。</p>
<h3 id="所有包的列表"><a href="#所有包的列表" class="headerlink" title="所有包的列表"></a>所有包的列表</h3><p>如果你想找出所有安装在应用程序中的包，可以使用list命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower list</span><br><span class="line">bower check-new     Checking for new versions of the project dependencies..</span><br><span class="line">blog /Users/shekhargulati/day1/blog</span><br><span class="line">└── jquery#2.0.3 extraneous</span><br></pre></td></tr></table></figure>
<h3 id="包的搜索"><a href="#包的搜索" class="headerlink" title="包的搜索"></a>包的搜索</h3><p>假如你想在你的应用程序中使用twitter的bootstrap框架，但你不确定包的名字，这时你可以使用<code>search</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower search bootstrap</span><br><span class="line">Search results:</span><br><span class="line"></span><br><span class="line">    bootstrap git://github.com/twbs/bootstrap.git</span><br><span class="line">    angular-bootstrap git://github.com/angular-ui/bootstrap-bower.git</span><br><span class="line">    sass-bootstrap git://github.com/jlong/sass-twitter-bootstrap.git</span><br></pre></td></tr></table></figure>
<h3 id="包的信息"><a href="#包的信息" class="headerlink" title="包的信息"></a>包的信息</h3><p>如果你想看到关于特定的包的信息，可以使用<code>info</code> 命令来查看该包的所有信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower info bootstrap</span><br><span class="line">bower bootstrap#*           not-cached git://github.com/twbs/bootstrap.git#*</span><br><span class="line">bower bootstrap#*              resolve git://github.com/twbs/bootstrap.git#*</span><br><span class="line">bower bootstrap#*             download https://github.com/twbs/bootstrap/archive/v3.0.0.tar.gz</span><br><span class="line">bower bootstrap#*              extract archive.tar.gz</span><br><span class="line">bower bootstrap#*             resolved git://github.com/twbs/bootstrap.git#3.0.0</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name: &apos;bootstrap&apos;,</span><br><span class="line">  version: &apos;3.0.0&apos;,</span><br><span class="line">  main: [</span><br><span class="line">    &apos;./dist/js/bootstrap.js&apos;,</span><br><span class="line">    &apos;./dist/css/bootstrap.css&apos;</span><br><span class="line">  ],</span><br><span class="line">  ignore: [</span><br><span class="line">    &apos;**/.*&apos;</span><br><span class="line">  ],</span><br><span class="line">  dependencies: &#123;</span><br><span class="line">    jquery: &apos;&gt;= 1.9.0&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  homepage: &apos;https://github.com/twbs/bootstrap&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Available versions:</span><br><span class="line">  - 3.0.0</span><br><span class="line">  - 3.0.0-rc1</span><br><span class="line">  - 3.0.0-rc.2</span><br><span class="line">  - 2.3.2</span><br><span class="line"> .....</span><br></pre></td></tr></table></figure>
<p>如果你想得到单个包的信息，也可以使用<code>info</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower info bootstrap#3.0.0</span><br><span class="line">bower bootstrap#3.0.0           cached git://github.com/twbs/bootstrap.git#3.0.0</span><br><span class="line">bower bootstrap#3.0.0         validate 3.0.0 against git://github.com/twbs/bootstrap.git#3.0.0</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name: &apos;bootstrap&apos;,</span><br><span class="line">  version: &apos;3.0.0&apos;,</span><br><span class="line">  main: [</span><br><span class="line">    &apos;./dist/js/bootstrap.js&apos;,</span><br><span class="line">    &apos;./dist/css/bootstrap.css&apos;</span><br><span class="line">  ],</span><br><span class="line">  ignore: [</span><br><span class="line">    &apos;**/.*&apos;</span><br><span class="line">  ],</span><br><span class="line">  dependencies: &#123;</span><br><span class="line">    jquery: &apos;&gt;= 1.9.0&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  homepage: &apos;https://github.com/twbs/bootstrap&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包的卸载"><a href="#包的卸载" class="headerlink" title="包的卸载"></a>包的卸载</h3><p>卸载包可以使用<code>uninstall</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower uninstall jquery</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="bower-json文件的使用"><a href="#bower-json文件的使用" class="headerlink" title="bower.json文件的使用"></a>bower.json文件的使用</h2><p>bower.json文件的使用可以让包的安装更容易，你可以在应用程序的根目录下创建一个名为“bower.json”的文件，并定义它的依赖关系。使用<code>bower init</code> 命令来创建bower.json文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower init</span><br><span class="line">[?] name: blog</span><br><span class="line">[?] version: 0.0.1</span><br><span class="line">[?] description:</span><br><span class="line">[?] main file:</span><br><span class="line">[?] keywords:</span><br><span class="line">[?] authors: Shekhar Gulati &lt;shekhargulati84@gmail.com&gt;</span><br><span class="line">[?] license: MIT</span><br><span class="line">[?] homepage:</span><br><span class="line">[?] set currently installed components as dependencies? Yes</span><br><span class="line">[?] add commonly ignored files to ignore list? Yes</span><br><span class="line">[?] would you like to mark this package as private which prevents it from being accidentally published to the registry? No</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name: &apos;blog&apos;,</span><br><span class="line">  version: &apos;0.0.1&apos;,</span><br><span class="line">  authors: [</span><br><span class="line">    &apos;Shekhar Gulati &lt;shekhargulati84@gmail.com&gt;&apos;</span><br><span class="line">  ],</span><br><span class="line">  license: &apos;MIT&apos;,</span><br><span class="line">  ignore: [</span><br><span class="line">    &apos;**/.*&apos;,</span><br><span class="line">    &apos;node_modules&apos;,</span><br><span class="line">    &apos;bower_components&apos;,</span><br><span class="line">    &apos;test&apos;,</span><br><span class="line">    &apos;tests&apos;</span><br><span class="line">  ],</span><br><span class="line">  dependencies: &#123;</span><br><span class="line">    jquery: &apos;~2.0.3&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[?] Looks good? Yes</span><br></pre></td></tr></table></figure>
<p>可以查看该文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;blog&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;Shekhar Gulati &lt;shekhargulati84@gmail.com&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &quot;**/.*&quot;,</span><br><span class="line">    &quot;node_modules&quot;,</span><br><span class="line">    &quot;bower_components&quot;,</span><br><span class="line">    &quot;test&quot;,</span><br><span class="line">    &quot;tests&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;jquery&quot;: &quot;~2.0.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看，它已经加入了jQuery依赖关系。</p>
<p>现在假设也想用twitter bootstrap，我们可以用下面的命令安装twitter bootstrap并更新bower.json文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower install bootstrap --save</span><br></pre></td></tr></table></figure>
<p>它会自动安装最新版本的bootstrap并更新bower.json文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;blog&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;Shekhar Gulati &lt;shekhargulati84@gmail.com&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &quot;**/.*&quot;,</span><br><span class="line">    &quot;node_modules&quot;,</span><br><span class="line">    &quot;bower_components&quot;,</span><br><span class="line">    &quot;test&quot;,</span><br><span class="line">    &quot;tests&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;jquery&quot;: &quot;~2.0.3&quot;,</span><br><span class="line">    &quot;bootstrap&quot;: &quot;~3.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是今天的学习，希望能让你对bower有个足够的了解，最好可以自己尝试一下。</p>
<hr>
<p>原文 <a href="https://www.openshift.com/blogs/day-1-bower-manage-your-client-side-dependencies" target="_blank" rel="noopener">Day 1: Bower–Manage Your Client Side Dependencies</a><br>翻译 <a href="http://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a></p>
]]></content>
      <categories>
        <category>30天学习30种新技术系列</category>
      </categories>
      <tags>
        <tag>30天学习30种新技术系列</tag>
      </tags>
  </entry>
  <entry>
    <title>30天学习30种新技术系列</title>
    <url>/2018/05/26/30-%E5%A4%A9%E5%AD%A6%E4%B9%A0-30-%E7%A7%8D%E6%96%B0%E6%8A%80%E6%9C%AF%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<p>编者注：我们发现了比较有趣的系列文章《30 天学习 30 种新技术》，准备翻译，一天一篇更新，年终礼包。以下是译文，英文标题表示还未翻译，附原文链接；中文标题表示已翻译，附译文链接。</p>
<p>更新：全系列已经全部翻译完成。</p>
<blockquote>
<p>让你 30 天学习 30 种新技术，你会觉得这是挑战吗？</p>
</blockquote>
<p><img src="/2018/05/26/30-天学习-30-种新技术系列/bvbc2p.jpg" alt="img-1"></p>
<p>我已经接受了挑战，我会在一个月的时间内每天学习一门新技术，挑战开始于 2013 年 10 月 29 日。下面就是我将要学习的新技术的列表，我会把每天学到的内容写出来。在我每天正常的工作之后，我会花几个小时学习一门新技术，再用一小时将今天学到的写在博客上。这项活动的目的是熟悉许多在开发者社区所使用的新技术。</p>
<p>我会把重点放在 JavaScript 及其相关技术的学习上，当然也会去了解一下像 Java 这类我比较感兴趣的其他技术。我也可能会在一门技术上花费好几天的时间，但我每次会选择和这门技术相关的不同的主题来讲。只要是有意义的，我将尽量展示它如何与 OpenShift 工作，我希望这是一次充满乐趣并能学到很多东西的旅程。（你可以在 twitter 上<a href="https://twitter.com/shekhargulati" target="_blank" rel="noopener">follow 我</a>）</p>
<p>下边是学习列表：</p>
<ul>
<li>2013.10.29 - <a href="https://segmentfault.com/a/1190000000349555" target="_blank" rel="noopener">Day 1: Bower —— 管理你的客户端依赖关系</a></li>
<li>2013.10.30 - <a href="http://segmentfault.com/a/1190000000350125" target="_blank" rel="noopener">Day 2: AngularJS —— 对 AngularJS 的初步认识</a></li>
<li>2013.10.31 - <a href="http://segmentfault.com/a/1190000000351512" target="_blank" rel="noopener">Day 3: Flask —— 使用 Python 和 OpenShift 进行即时 Web 开发</a></li>
<li>2013.11.01 - <a href="http://segmentfault.com/a/1190000000352163" target="_blank" rel="noopener">Day 4: PredictionIO —— 如何创建一个博客推荐器</a></li>
<li>2013.11.02 - <a href="http://segmentfault.com/a/1190000000353114" target="_blank" rel="noopener">Day 5: GruntJS —— 重复乏味的工作总会有人做（反正我不做）</a></li>
<li>2013.11.03 - <a href="http://segmentfault.com/a/1190000000353272" target="_blank" rel="noopener">Day 6: 在 Java 虚拟机上使用 Grails 进行快速 Web 开发</a></li>
<li>2013.11.04 - <a href="http://segmentfault.com/a/1190000000354555" target="_blank" rel="noopener">Day 7: GruntJS 在线重载 提升生产率至新境界</a></li>
<li>2013.11.05 - <a href="http://segmentfault.com/a/1190000000355181" target="_blank" rel="noopener">Day 8: Harp.JS —— 现代静态 Web 服务器</a></li>
<li>2013.11.06 - <a href="http://segmentfault.com/a/1190000000356029" target="_blank" rel="noopener">Day 9: TextBlob —— 对文本进行情感分析</a></li>
<li>2013.11.07 - <a href="http://segmentfault.com/a/1190000000357272" target="_blank" rel="noopener">Day 10: PhoneGap —— 开发手机应用如此简单</a></li>
<li>2013.11.08 - <a href="http://segmentfault.com/a/1190000000358740" target="_blank" rel="noopener">Day 11: AeroGear 推送服务器：使应用的通知推送变得简单</a></li>
<li>2013.11.09 - <a href="http://segmentfault.com/a/1190000000358809" target="_blank" rel="noopener">Day 12: OpenCV —— Java 开发者的人脸检测</a></li>
<li>2013.11.10 - <a href="http://segmentfault.com/a/1190000000359827" target="_blank" rel="noopener">Day 13: Dropwizard —— 非常棒的 Java REST 服务器栈</a></li>
<li>2013.11.11 - <a href="http://segmentfault.com/a/1190000000360213" target="_blank" rel="noopener">Day14：使用斯坦福 NER 软件包实现你自己的命名实体识别器（Named Entity Recognition，NER）</a></li>
<li>2013.11.12 - <a href="http://segmentfault.com/a/1190000000361440" target="_blank" rel="noopener">Day 15：Meteor —— 从零开始创建一个 Web 应用</a></li>
<li>2013.11.13 - <a href="http://segmentfault.com/a/1190000000362182" target="_blank" rel="noopener">Day 16: Goose Extractor —— 好用的文章提取工具</a></li>
<li>2013.11.14 - <a href="http://segmentfault.com/a/1190000000363485" target="_blank" rel="noopener">Day 17: 使用 JBoss Forge 和 OpenShift 构建部署 JAVA EE 6 应用</a></li>
<li>2013.11.15 - <a href="http://segmentfault.com/a/1190000000363797" target="_blank" rel="noopener">Day 18: BoilerPipe —— Java开发者的文章提取工具</a></li>
<li>2013.11.16 - <a href="http://segmentfault.com/a/1190000000365519" target="_blank" rel="noopener">Day 19: EmberJS 入门指南</a></li>
<li>2013.11.17 - <a href="http://segmentfault.com/a/1190000000365547" target="_blank" rel="noopener">Day 20: 斯坦福CoreNLP —— 用 Java 给 Twitter 情感分析</a></li>
<li>2013.11.18 - <a href="http://segmentfault.com/a/1190000000366923" target="_blank" rel="noopener">Day 21：Docker 入门教程</a></li>
<li>2013.11.19 - <a href="http://segmentfault.com/a/1190000000367441" target="_blank" rel="noopener">Day 22： 使用 Spring、MongoDB 和 AngularJS 开发单页面应用</a></li>
<li>2013.11.20 - <a href="http://segmentfault.com/a/1190000000368066" target="_blank" rel="noopener">Day 23： 使用 TimelineJS 构建精美的时间轴</a></li>
<li>2013.11.21 - <a href="http://segmentfault.com/a/1190000000368881" target="_blank" rel="noopener">Day 24: 使用 Yeoman 自动构建 Ember 项目</a></li>
<li>2013.11.22 - <a href="http://segmentfault.com/a/1190000000368729" target="_blank" rel="noopener">Day 25: Tornado —— 联合 Tornado、MongoDB 和 AngularJS 进行应用开发</a></li>
<li>2013.11.23 - <a href="http://segmentfault.com/a/1190000000370631" target="_blank" rel="noopener">Day 26: TogetherJS —— 让我们一起来编程！</a></li>
<li>2013.11.24 - <a href="http://segmentfault.com/a/1190000000369308" target="_blank" rel="noopener">Day 27: Restify —— 在Node.js中构建正确的REST Web服务</a></li>
<li>2013.11.25 - <a href="http://segmentfault.com/a/1190000000372498" target="_blank" rel="noopener">Day 28: OpenShift 的 Eclipse 集成</a></li>
<li>2013.11.26 - <a href="http://segmentfault.com/a/1190000000371543" target="_blank" rel="noopener">Day 29: 编写你的第一个 Google Chrome 扩展程序</a></li>
<li>2013.11.27 - <a href="http://segmentfault.com/a/1190000000374033" target="_blank" rel="noopener">Day 30: Play Framework —— Java 开发者的梦想框架</a></li>
</ul>
<hr>
<p>原文 <a href="https://www.openshift.com/blogs/learning-30-technologies-in-30-days-a-developer-challenge" target="_blank" rel="noopener">Learning 30 Technologies in 30 Days: A Developer Challenge</a><br>翻译 <a href="http://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a></p>
]]></content>
      <categories>
        <category>30天学习30种新技术系列</category>
      </categories>
      <tags>
        <tag>30天学习30种新技术系列</tag>
      </tags>
  </entry>
  <entry>
    <title>教你免费搭建个人博客，Hexo&amp;Github</title>
    <url>/2018/05/26/%E6%95%99%E4%BD%A0%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8CHexo-Github/</url>
    <content><![CDATA[<h1 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="一、配置Github"><a href="#一、配置Github" class="headerlink" title="一、配置Github"></a>一、配置Github</h1><p>首先注册、登录 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
<p>记住自己的Username（很重要）</p>
<p>然后右上角选择 Create a new repository <a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a></p>
<p>Repository name （填自己的名字） <strong>yourname.github.io</strong>(yourname与你的注册用户名一致,这个就是你博客的域名了)</p>
<p>例如，我的域名是github.com/zhihuya，就填入zhihuya.github.io。成功后出现下面的画面</p>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/JNWXHHS.jpg" alt="img"></p>
<h1 id="二、环境安装（node、git）"><a href="#二、环境安装（node、git）" class="headerlink" title="二、环境安装（node、git）"></a>二、环境安装（node、git）</h1><p>1、安装 Node.js <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<p>2、安装 Git <a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">https://github.com/waylau/git-for-win</a></p>
<p>Git教程 <a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">https://github.com/waylau/git-for-win</a>廖雪峰老师的教程，非常好。</p>
<p>3、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，名称和邮箱是Github上的</p>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/FAVYz0C.jpg" alt="img"></p>
<p>4、安装 Hexo。所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/xWjp6U3.jpg" alt="img"></p>
<p>（使用的cmder，超级好用~~。等待时间可能有点长）</p>
<p>好了到这一步我们环境全部安装好了。</p>
<h1 id="三、设置"><a href="#三、设置" class="headerlink" title="三、设置"></a>三、设置</h1><p>在电脑F盘（自己随意）目录下新建文件夹 test，进入test，按住Shift键点击鼠标右键</p>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/jOekzIE.png" alt="img"></p>
<p>因为我有安装Cmder，没有安装的点击“在此处打开命令窗口”，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>稍微等待下，速度有点慢。成功提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<p>因为你初始化hexo 之后source目录下自带一篇hello world文章, 所以直接执行下方命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line"># 启动本地服务器</span><br><span class="line">$ hexo server</span><br><span class="line"># 在浏览器输入 http://localhost:4000/就可以看见网页和模板了</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，便可以看到网站初步的模样，不要激动，我们还要把网页发布到Github上去。</p>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/wk2ybMK.jpg" alt="img"></p>
<p>重新打开CMD，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</span><br></pre></td></tr></table></figure>
<p>一路Enter过来就好，得到信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure>
<p>找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">https://github.com/settings/ssh</a></p>
<p>New SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key</p>
<h1 id="四、配置博客"><a href="#四、配置博客" class="headerlink" title="四、配置博客"></a>四、配置博客</h1><p>在blog目录下，用sublime打开_config.yml文件，修改参数信息</p>
<p><strong>特别提醒，在每个参数的：后都要加一个空格</strong></p>
<p>修改网站相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 崔斯特测试所用博客</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 网页描述</span><br><span class="line">author: 崔斯特</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>配置部署（我的是zhihuya，修改成自己的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/zhihuya/zhihuya.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h1 id="五、发表文章"><a href="#五、发表文章" class="headerlink" title="五、发表文章"></a>五、发表文章</h1><p>在CMD中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;崔斯特测试文章&quot;</span><br><span class="line">INFO  Created: F:\test\blog\source\_posts\崔斯特测试文章.md</span><br></pre></td></tr></table></figure>
<p>找到该文章，打开，使用Markdown语法，该语法介绍可以查看<a href="https://zhangslob.github.io/2017/02/26/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">https://zhangslob.github.io/2017/02/26/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 崔斯特测试文章</span><br><span class="line">date: 2017-02-28 13:03:44</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line">这是一篇测试文章，欢迎关注作者博客[1]: https://zhangslob.github.io/</span><br></pre></td></tr></table></figure>
<p>保存，然后执行下列步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\test\blog</span><br><span class="line">$ hexo clean</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line"></span><br><span class="line">F:\test\blog</span><br><span class="line">$ hexo generate</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 1.48 s</span><br><span class="line">#省略</span><br><span class="line">INFO  29 files generated in 4.27 s</span><br><span class="line"></span><br><span class="line">F:\test\blog</span><br><span class="line">$ hexo server</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>这个时候，打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，发现刚才的文章已经成功了</p>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/fGVNxkn.jpg" alt="img"></p>
<p>最后一步，发布到网上，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\test\blog</span><br><span class="line">$ hexo deploy</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">#省略</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/kKRV0UB.jpg" alt="img"></p>
<p>其中会跳出Github登录，直接登录，如果没有问题输入zhihuya（换成你的）.github.io/</p>
<p>崔斯特测试所用博客<a href="https://zhihuya.github.io/" target="_blank" rel="noopener">https://zhihuya.github.io/</a></p>
<p>然后就可以看到已经发布了</p>
<p><img src="/2018/05/26/教你免费搭建个人博客，Hexo-Github/g9wtZVk.jpg" alt="img"></p>
<h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>发布文章的步骤：</p>
<p>1、hexo new 创建文章</p>
<p>2、Markdown语法编辑文章</p>
<p>3、部署（所有打开CMD都是在blog目录下）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo generate #生成</span><br><span class="line">hexo server #启动服务预览，非必要，可本地浏览网页</span><br><span class="line">hexo deploy #部署发布</span><br></pre></td></tr></table></figure>
<p>简写Tips：</p>
<blockquote>
<p>hexo n “我的博客” == hexo new “我的博客” #新建文章</p>
<p>hexo p == hexo publish</p>
<p>hexo g == hexo generate#生成</p>
<p>hexo s == hexo server #启动服务预览</p>
<p>hexo d == hexo deploy#部署</p>
</blockquote>
<p>如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>出错是正常的，出错了自己先百度或google，实在不知道的可以询问我。</p>
<p>托管的话不仅有github可以用，还有个国内的<a href="https://coding.net/" target="_blank" rel="noopener">https://coding.net/</a>可选</p>
<h3 id="引用说明"><a href="#引用说明" class="headerlink" title="引用说明"></a>引用说明</h3><ul>
<li>作者：zhangslob</li>
<li>链接：<a href="https://zhangslob.github.io/2017/02/28/教你免费搭建个人博客，Hexo-Github" target="_blank" rel="noopener">https://zhangslob.github.io/2017/02/28/教你免费搭建个人博客，Hexo-Github</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo使用攻略</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客搭建</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用攻略-添加分类及标签</title>
    <url>/2018/05/26/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h3 id="1、创建“分类”选项"><a href="#1、创建“分类”选项" class="headerlink" title="1、创建“分类”选项"></a>1、创建“分类”选项</h3><h4 id="1-1-生成“分类”页并添加tpye属性"><a href="#1-1-生成“分类”页并添加tpye属性" class="headerlink" title="1.1 生成“分类”页并添加tpye属性"></a>1.1 生成“分类”页并添加tpye属性</h4><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure>
<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加<code>type: &quot;categories&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h4 id="1-2-给文章添加“categories”属性"><a href="#1-2-给文章添加“categories”属性" class="headerlink" title="1.2 给文章添加“categories”属性"></a>1.2 给文章添加“categories”属性</h4><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: web前端</code>表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了<code>categories: xxx</code>的文章才会被收录到首页的“分类”中。</p>
<h3 id="2、创建“标签”选项"><a href="#2、创建“标签”选项" class="headerlink" title="2、创建“标签”选项"></a>2、创建“标签”选项</h3><h4 id="2-1-生成“标签”页并添加tpye属性"><a href="#2-1-生成“标签”页并添加tpye属性" class="headerlink" title="2.1 生成“标签”页并添加tpye属性"></a>2.1 生成“标签”页并添加tpye属性</h4><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>
<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加<code>type: &quot;tags&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h4 id="2-2-给文章添加“tags”属性"><a href="#2-2-给文章添加“tags”属性" class="headerlink" title="2.2 给文章添加“tags”属性"></a>2.2 给文章添加“tags”属性</h4><p>打开需要添加标签的文章，为其添加tags属性。下方的<code>tags:</code>下方的<code>- jQuery</code> <code>- 表格</code><br> <code>- 表单验证</code>就是这篇文章的标签了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- 表格</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了<code>tags: xxx</code>的文章才会被收录到首页的“标签”中。</p>
<p>细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行<code>hexo new 文章名</code>命令生成的文件，页面里就有<code>categories:</code>项了。</p>
<p>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
]]></content>
      <categories>
        <category>Hexo使用攻略</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Hello World</title>
    <url>/2018/05/26/hexo-hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="hexo-algolia"><a href="#hexo-algolia" class="headerlink" title="hexo algolia"></a>hexo algolia</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> HEXO_ALGOLIA_INDEXING_KEY=[algolia.apiKey]</span><br><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure>
<h3 id="CI-with-jenkins"><a href="#CI-with-jenkins" class="headerlink" title="CI with jenkins"></a>CI with jenkins</h3><p><a href="http://www.niugm.me/2018/02/16/jenkins/" target="_blank" rel="noopener">使用Jenkins实现Hexo自动部署</a></p>
<p><a href="https://juejin.im/post/5adae7ee51882567127817ea" target="_blank" rel="noopener">hexo使用jenkins自动部署到阿里云</a></p>
<p>###Cooperation</p>
<ol>
<li><p>使用git <a href="mailto:clonegit@github.com" target="_blank" rel="noopener">clonegit@github.com</a>:vincentruan/vincentruan.github.io.git拷贝仓库（git checkout -b hexo）； </p>
</li>
<li><p>在新拷贝的vincentruan.github.io文件夹下通过Git bash依次执行下列指令：</p>
<p>npm install hexo-cli -g(首次安装)、npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要<strong><em>hexo init</em></strong>这条指令,如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重 ）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用攻略</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown吃了吗?</title>
    <url>/2018/05/20/Markdown%E5%90%83%E4%BA%86%E5%90%97/</url>
    <content><![CDATA[<h2 id="markdown-介绍"><a href="#markdown-介绍" class="headerlink" title="markdown 介绍"></a>markdown 介绍</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。 - <strong>wikipedia</strong></p>
</blockquote>
<ul>
<li><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Daring Fireball: Markdown</a> Project markdown</li>
<li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown wikipedia 介绍</a></li>
<li><a href="http://fletcherpenney.net/multimarkdown/" target="_blank" rel="noopener">MultiMarkdown</a> 引入更多标记特性和输出选项的改进版Markdown</li>
</ul>
<h2 id="why-markdown"><a href="#why-markdown" class="headerlink" title="why markdown"></a>why markdown</h2><ul>
<li>纯文本，兼容性极强，可以用任意文本编辑器打开.</li>
<li>语法简单（the syntax is so simple you can barely call it “syntax.”），零学习成本，极好的可读性，让你专注于文字写作而不是页面排版，并且兼容 HTML，simple but powerful .</li>
<li>格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf、epub、电子书等。</li>
<li>适合团队协作，可以使用 git/svn 等进行版本控制管理。</li>
<li><a href="http://www.yangzhiping.com/tech/r-markdown-knitr.html" target="_blank" rel="noopener">阳志平：为什么 Markdown 成为科技界写作主流？</a></li>
<li><a href="http://www.ituring.com.cn/article/828?q=markdown" target="_blank" rel="noopener">图灵社区：用Markdown来写自由书籍-开源技术的方案</a></li>
</ul>
<p>目前很多在线服务商均支持使用markdown编写：</p>
<ul>
<li><a href="https://github.com" target="_blank" rel="noopener">Github</a> 最先支持，使用Markdown的一个分支版本来格式化评论、消息以及其它内容。</li>
<li><a href="http://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a> 使用一种 Markdown 的分支作为它的文章格式化系统。</li>
<li><a href="http://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a> 国内技术人的博客家园，每天活跃上万用户，高质量社区。</li>
<li><a href="http://www.csdn.net/" target="_blank" rel="noopener">CSDN</a> 号称全球最大中文IT社区，涵盖了多种语言、架构、博客、俱乐部等模块的技术论坛。</li>
<li><a href="http://www.ituring.com.cn/" target="_blank" rel="noopener">图灵社区</a> 使用markdown语法供用户写作电子书.</li>
<li><a href="http://www.jianshu.com/" target="_blank" rel="noopener">简书</a> 重拾文字的力量，交流故事，沟通想法，一个基于内容分享的社区。</li>
<li><a href="http://www.wiz.cn/" target="_blank" rel="noopener">为知笔记</a> 国内顶尖笔记软件，支持使用Markdown语法编辑笔记。</li>
<li><a href="http://note.youdao.com/noteintro.html" target="_blank" rel="noopener">有道云笔记</a> 最新版本开始支持，并且支持一些扩展语法。</li>
<li>……</li>
</ul>
<h2 id="markdown-使用"><a href="#markdown-使用" class="headerlink" title="markdown 使用"></a>markdown 使用</h2><ul>
<li><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="noopener">Markdown: Basics （快速入门）</a></li>
<li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown 完整语法说明 (简体中文版)</a></li>
<li><a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Github: Mastering Markdown</a> GitHub 帮助中关于 Markdown 的语法帮助</li>
<li><a href="https://github.com/hzlzh/1MarkDown" target="_blank" rel="noopener">MarkDown 语法团队规范</a> 语法规范简洁版</li>
<li><a href="http://www.cirosantilli.com/markdown-style-guide/" target="_blank" rel="noopener">Markdown Style Guide</a> 语法规范复杂版</li>
<li><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="noopener">Markdown Cheatsheet</a></li>
<li><a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">GitHub Flavored Markdown</a> GitHub 使用的 Markdown 语法，略微不同于标准 Markdown 语法。提供了一些更加简洁的语法，类似 URL autolinking, Strikethrough, Fenced code blocks, Syntax highlighting 等等</li>
<li><a href="http://fletcherpenney.net/multimarkdown/" target="_blank" rel="noopener">MultiMarkdown 介绍</a> 对 markdown 进行的扩展功能</li>
</ul>
<h2 id="markdown-工具"><a href="#markdown-工具" class="headerlink" title="markdown 工具"></a>markdown 工具</h2><ul>
<li><p><a href="https://maxiang.info/" target="_blank" rel="noopener">马克飞象</a> web/chrome 离线客户端，markdown 全功能支持，最大特点内容能够同步到印象笔记（evernote）中，笔记的用户重度推荐，按年收费，目前作者 <a href="http://weibo.com/u/2788354117" target="_blank" rel="noopener">@weibo</a> 正在开发跨平台的客户端。</p>
</li>
<li><p><a href="https://stackedit.io/" target="_blank" rel="noopener">StackEdit</a> 在线 markdown 编辑器，可同步文档到Google Drive和 Dropbox，可发布文章到 Blogger，GitHub，Google Drive，Dropbox，Tumblr和WordPress。</p>
</li>
<li><p><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">cmd 作业部落</a> 支持 win/mac/linux/web/chrome 全平台，支持实时同步预览，支持代码高亮、数学公式，区分写作和阅读模式，支持在线存储，分享文稿网址。</p>
</li>
<li><p><a href="http://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a> OSX 上的 Markdown 开源编辑器，支持代码高亮，实时预览等。</p>
</li>
<li><p><a href="http://www.markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a> Windows上的全功能Markdown编辑器，推荐win上使用，基本全部功能。</p>
</li>
<li><p><a href="http://marked2app.com/" target="_blank" rel="noopener">Marked2</a> 多种 md 显示方案，不能够编辑文件，只用来展示文件，配合 <a href="https://packagecontrol.io/packages/MarkdownEditing" target="_blank" rel="noopener">subline text markdown edit</a> 插件，完美使用；</p>
</li>
<li><p><a href="http://zh.mweb.im/" target="_blank" rel="noopener">MWeb</a> 专业的 Markdown 写作、记笔记、静态博客生成软件，由国内独立开发者<a href="http://weibo.com/oulvhai" target="_blank" rel="noopener">@oulvhai</a>开发，支持Toc、Table、代码高亮、支持发布到 Wordrpess 博客、支持 Metaweblog API 的博客服务、Wordpress.com、Evernote 和印象笔记、Blogger、Scriptogr.am、Tumblr等服务。</p>
</li>
<li><p><a href="http://pad.haroopress.com/user.html" target="_blank" rel="noopener">Haroopad</a> 又一款简洁多功能的跨平台编辑器，全功能支持，再加上对社交网络友好的连接，多种主题等，感兴趣的可以看看。详情参考<a href="https://github.com/xirong/my-markdown/issues/1" target="_blank" rel="noopener">issue#1</a></p>
</li>
<li><p><a href="http://www.typora.io/" target="_blank" rel="noopener">Typora</a> 不分栏，实时展示看到写出的内容，对于不喜欢「两栏」设计的人来说是一个选择</p>
</li>
<li><a href="http://markeditor.com/app/markeditor" target="_blank" rel="noopener">MarkEditor - ME</a> MarkEditor以markdown为基础语法，多标签栏、文件夹结构，纯文本的方式带来优雅、高效的体验。 确实很棒的工具，带来很多新鲜的理念，支持、重构、提升 markdown，加快写作的体验。具体可以查看几篇评测文章：<ul>
<li><a href="http://sspai.com/34317" target="_blank" rel="noopener">简洁与强大，从不是矛盾的事物：写作工具 MarkEditor 功能详解</a></li>
<li><a href="http://sspai.com/34656" target="_blank" rel="noopener">不止是一款简单的码字工具：MarkEditor 进阶功能介绍</a></li>
</ul>
</li>
<li><p><a href="http://sspai.com/32483" target="_blank" rel="noopener">码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点</a> 喜欢哪一款，就看你的了。</p>
</li>
<li><p>这几款就够了，多了就有选择症 ……</p>
</li>
</ul>
<h2 id="reference-参考"><a href="#reference-参考" class="headerlink" title="reference 参考"></a>reference 参考</h2><ul>
<li><a href="http://brettterpstra.com/2011/08/31/why-markdown-a-two-minute-explanation/" target="_blank" rel="noopener">Why Markdown? A two-minute explanation</a></li>
<li><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">简书：献给写作者的 Markdown 新手指南</a></li>
<li><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/content/0.html" target="_blank" rel="noopener">Markdown simple world</a></li>
</ul>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
