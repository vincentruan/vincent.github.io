<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-mac-osx.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="HzD3jseSmctf--z1mHXLAwERIBzdqIvVavEv6fq47pI">




















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="The King is dead, long live the King!">
<meta name="keywords" content="tech">
<meta property="og:type" content="website">
<meta property="og:title" content="星辰大海">
<meta property="og:url" content="https://vincentruan.github.io/page/2/index.html">
<meta property="og:site_name" content="星辰大海">
<meta property="og:description" content="The King is dead, long live the King!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="星辰大海">
<meta name="twitter:description" content="The King is dead, long live the King!">






  <link rel="canonical" href="https://vincentruan.github.io/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>星辰大海</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星辰大海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">My Conquest Is the Sea of Stars.</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/11/Java8开发的4个小技巧/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/11/Java8开发的4个小技巧/" itemprop="url">
                  Java8开发的4个小技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-11 16:48:32" itemprop="dateCreated datePublished" datetime="2020-02-11T16:48:32+08:00">2020-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-24 15:31:01" itemprop="dateModified" datetime="2020-02-24T15:31:01+08:00">2020-02-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://dzone.com/articles/java-8-top-tips" target="_blank" rel="noopener">https://dzone.com/articles/java-8-top-tips</a></p>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional是一个评价过低的特性，它可以显著的降低代码抛出NullPointerException的可能。它在边界代码(你正在使用的API或者你发布的API)中特别有用。</p>
<p>但是对于它的不适当的使用和设计很容易使一个小的变动影响到很多的类，或者降低代码的可阅读性。这里有一些如何更加高效使用Optional的建议。</p>
<h3 id="Optional应该仅仅用在返回类型中"><a href="#Optional应该仅仅用在返回类型中" class="headerlink" title="Optional应该仅仅用在返回类型中"></a>Optional应该仅仅用在返回类型中</h3><p>不要用在参数或者域中。<a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="noopener">阅读这篇博文</a>可以看到如何正确使用Optional进行编码。幸运的是，IntelliJ IDEA可以打开inspections去检查你是否遵循了这些推荐规范。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalParamWarning.png" alt="OptionalParamWarning.png"></p>
<p>要尽早在Optional出现的地方对它进行处理。IntelliJ IDEA会阻止Optional出现在你代码的各个地方，所以记住一定要在Optional出现的地方就对他进行处理。</p>
<p><img src="https://www.rowkey.me/images/blog_images/java8/OptionalUseImmediately.png" alt="OptionalUseImmediately.png"></p>
<h3 id="不能简单地调用get-方法"><a href="#不能简单地调用get-方法" class="headerlink" title="不能简单地调用get()方法"></a>不能简单地调用get()方法</h3><p>Optional是用来表示这个值是有可能为空的，让你做好应对的准备。因此，很重要的一点就是在使用这个值之前务必要检查其是否存在。简单地调用get方法而不是先调用isPresent可能会导致产生空指针异常。幸运的是，IntelliJ IDEA再一次提供了对此种方案的检查。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalGetWithoutIsPresent.png" alt="OptionalGetWithoutIsPresent.png"></p>
<h3 id="更加优雅的方案"><a href="#更加优雅的方案" class="headerlink" title="更加优雅的方案"></a>更加优雅的方案</h3><p>如下代码，isPresent和get当然能够解决这个问题。</p>
<p><img src="https://www.rowkey.me/images/blog_images/java8/OptionalSimple.png" alt="OptionalSimple.png"></p>
<p>但是这里有更加优雅的方式，你可以使用orElse来设置一个默认值。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalOrElse.png" alt="OptionalOrElse.png"></p>
<p>或者你可以使用orElseGet来设置当值为null的时候去调用的方法。虽然看着和前面的方案没有什么大的不同。但是提供的方法应该仅仅在需要调用的时候才被调用。那么当这是个代价昂贵的方法时，那么使用lambda会带来更好的性能提升。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalOrElseGet.png" alt="OptionalOrElseGet.png"></p>
<h2 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h2><p>Lambda表达式是Java8最主要的卖点。即使你现在用不到Java8，你也应该对它有了一些基本的了解。下面讲述了一种新的方式使用Java编程，虽然这并不是一个“最佳实践”，仅仅是一个使用的指导。</p>
<h3 id="保持简短"><a href="#保持简短" class="headerlink" title="保持简短"></a>保持简短</h3><p>函数式编程对于长的lambda表达式是欢迎的，但是对于仅仅使用Java开发很多年的人发现编写短的lambda表达式会更容易一些。你甚至会想把表达式缩减到一行，也很容易把长的表达式重构成一个方法。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExtractMethod.png" alt="LambdaExtractMethod.png"></p>
<p>当然，这些甚至牵扯到了方法引用(Method References)。方法引用可能看着有点陌生，但是由于其能让代码达到更好的阅读性，还是有很大应用价值的。后面，我会讲到这个概念。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaCollapseToMethodRef.png" alt="LambdaCollapseToMethodRef.png"></p>
<h3 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h3><p>在lambda表达式中是没有类型信息的，所以你会发现在参数中包含类型信息是非常有用的。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExplicitParamTypes.png" alt="LambdaExplicitParamTypes.png"></p>
<p>如你所见，这会变得很笨重。所以我更喜欢赋予参数有意义的名字。当然，无论你是否这么做，Intellij IDEA都会让你可以看到参数的类型信息。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaParamTypes.png" alt="LambdaParamTypes.png"></p>
<p>甚至lambda表示的函数接口也能看到。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterface.png" alt="LambdaFunctionalInterface.png"></p>
<h2 id="设计Lambda表达式"><a href="#设计Lambda表达式" class="headerlink" title="设计Lambda表达式"></a>设计Lambda表达式</h2><p>我认为lambda表达式有一点类似于泛型-我们会经常使用到泛型(例如，添加类型信息到List&lt;&gt;)，但是比较罕见的是我们去设计一个具有泛型的方法或者一个类(比如像Person<t>)。同样的，我们经常会在使用诸如Streams API的时候传递lambda，但是却很少会创建一个需要传递lambda参数的方法。</t></p>
<p>如果你发现自己处在这样一种境况，那么这里有一些提示。</p>
<h3 id="IntelliJ-IDEA能够帮助你引入函数参数"><a href="#IntelliJ-IDEA能够帮助你引入函数参数" class="headerlink" title="IntelliJ IDEA能够帮助你引入函数参数"></a>IntelliJ IDEA能够帮助你引入函数参数</h3><p>能够让你创建一个参数，这个参数是一个lambda而不是一个Object。这个特性的最好的一点就是它会智能建议一个匹配规格的已存在的函数接口。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExtractFunctionalParameter.png" alt="LambdaExtractFunctionalParameter.png"></p>
<h3 id="使用存在的函数接口"><a href="#使用存在的函数接口" class="headerlink" title="使用存在的函数接口"></a>使用存在的函数接口</h3><p>随着开发者变得对Java8越来越熟悉，当使用Supplier和Consumer这些接口时，我们将会知道什么是我们所期望的，比如创建一个ErrorMessageCreator(例子)会是令人迷惑和浪费的。可以看一下<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">函数包</a>获取已经存在的那些函数接口。</p>
<h3 id="给你的函数接口添加-FunctionalInterface"><a href="#给你的函数接口添加-FunctionalInterface" class="headerlink" title="给你的函数接口添加@FunctionalInterface"></a>给你的函数接口添加@FunctionalInterface</h3><p>如果你确实需要创建自己的函数接口，那么用这个注解去标记它。看起来不需要这么做，但是Intellij IDEA会在你的函数接口没有符合规范时提示你。当没有方法实现这个接口时，它会提示你。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterfaceNoMethod.png" alt="LambdaFunctionalInterfaceNoMethod.png"></p>
<p>当方法太多时，也会提示你。</p>
<p><img src="https://www.rowkey.me/images/blog_images/java8/LambdaFunctionalInterfaceTooManyMethods.png" alt="LambdaFunctionalInterfaceTooManyMethods.png"></p>
<p>当你把注解应用到一个类而不是接口时，也会发出提醒。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterfaceNotInterface.png" alt="LambdaFunctionalInterfaceNotInterface.png"></p>
<p>Lambda表达式可以被用在任何有一个Single Abstract Method的接口中，但是它不能够应用到一个抽象类中。看起来没有啥逻辑，但它就是这样的。</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">Stream API</a>是Java8另一个最大的卖点，我认为我们到现在还是没有真的搞清楚这会如何改变我们的代码。这里有一些我自己发现很有用的东西。</p>
<h3 id="将点号对齐"><a href="#将点号对齐" class="headerlink" title="将点号对齐"></a>将点号对齐</h3><p>我个人比较喜欢对齐Stream操作。当然，你不需要非得这么做，但是我发现这样还是有很大好处的。</p>
<ul>
<li>一眼就看到所有的操作以及他们的顺序</li>
<li>更容易调试(虽然Intellij IDEA提供了在一行中的lambda表达式中任意地方打断点的功能，但是将他们分隔成单独的行会更简单)</li>
<li>可以很容易地注释掉一些操作以供测试</li>
<li>很容易地插入peek()供调试或者测试</li>
</ul>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamWrappingExample.png" alt="StreamWrappingExample.png"></p>
<p>这样做也会让代码看起来很舒服。当然，如果这么做，会增加代码的行数。</p>
<p>你可以修改一下格式化设置使点号对齐。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamWrapping.png" alt="StreamWrapping.png"></p>
<h3 id="使用方法引用-Method-References"><a href="#使用方法引用-Method-References" class="headerlink" title="使用方法引用(Method References)"></a>使用方法引用(Method References)</h3><p>你可能需要一会儿才能习惯这个奇怪的语法。但是，当我们能够正确地使用，它确实能够提高程序的可阅读性。考虑下面的代码：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamSimpleFilter.png" alt="StreamSimpleFilter.png"></p>
<p>对比一下使用新引入的Objects类的辅助方法(helper methods)：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamMethodRefFilter.png" alt="StreamMethodRefFilter.png"></p>
<p>后面的代码能够更加明显地表明它想保存的值。IntelliJ IDEA会提示你何时一个lambda可以被替换成方法引用。</p>
<h3 id="当迭代一个集合，尽可能地使用Streams-API"><a href="#当迭代一个集合，尽可能地使用Streams-API" class="headerlink" title="当迭代一个集合，尽可能地使用Streams API"></a>当迭代一个集合，尽可能地使用Streams API</h3><p>使用新的集合方法：forEach。IDEA会提示你。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamRepalceForWithForEach.png" alt="StreamRepalceForWithForEach.png"></p>
<p>使用Streams API相比起使用循环和if语句更加清晰明了。例如：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamBefore.png" alt="StreamBefore.png"></p>
<p>IDEA会建议重构为：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamAfter.png" alt="StreamAfter.png"></p>
<p>我做的性能测试表示这个重构是令人惊奇的-无论性能是不变、提升还是变差，都是不能被预测的。因此，当你的应用对性能要求很苛刻的话，重构的时候务必做好测试。</p>
<h3 id="当遍历数组时使用循环"><a href="#当遍历数组时使用循环" class="headerlink" title="当遍历数组时使用循环"></a>当遍历数组时使用循环</h3><p>使用Java8并不是意味着你必须到处都使用Stream和新的集合方法。IDEA会智能提示哪些地方可以转换为Stream操作，但是并不意味着你必须这么做。</p>
<p>特别是当遍历一个保存基本数据类型的小数组时，使用loop循环的性能是更加好的，而且更加可阅读(至少对哪些Stream的新手来说是这样的)。</p>
<p>以上的建议，并非是固定不变，也不是必须要遵守的。但是无论你倾向于继续使用loops做某些操作还是在能够使用的地方使用Stream API, 你都要做出你自己的决定。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><img src="/2020/02/11/Java8开发的4个小技巧/640-1581423585086.webp" alt="img"></p>
<h3 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h3><p>一行执行语句的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure>
<p>如果有多行执行语句，可以加上 <code>{}</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;    <span class="keyword">return</span> x + y;&#125;</span><br></pre></td></tr></table></figure>
<p>转换成Lambda表达式有以下几种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定参数类型及</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="comment">// 指定参数类型，不指定</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y;</span><br><span class="line"><span class="comment">// 不指定参数类型和return，编译器会自动推断</span></span><br><span class="line">(x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda用途"><a href="#Lambda用途" class="headerlink" title="Lambda用途"></a>Lambda用途</h3><h4 id="1、只有一个抽象方法的函数式接口"><a href="#1、只有一个抽象方法的函数式接口" class="headerlink" title="1、只有一个抽象方法的函数式接口"></a>1、只有一个抽象方法的函数式接口</h4><p>Lambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。</p>
<p>下面拿创建线程来举例，用lambda表达式可以有以下几种写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">		<span class="meta">@Override</span>        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">			System.out.println(<span class="string">"t1"</span>);        </span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;).start();    </span><br><span class="line">	Runnable runnable = () -&gt; System.out.println(<span class="string">"t2"</span>);    </span><br><span class="line">	<span class="keyword">new</span> Thread(runnable).start();    </span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"t3"</span>)).start();    </span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; run(<span class="string">"t4"</span>)).start();    </span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;        </span><br><span class="line">		String str = <span class="string">"t5"</span>;        </span><br><span class="line">		System.out.println(str);    </span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1t2t3t4t5</span><br></pre></td></tr></table></figure>
<h4 id="2、集合批量操作"><a href="#2、集合批量操作" class="headerlink" title="2、集合批量操作"></a>2、集合批量操作</h4><p>下面打印list集合的两种写法是等价的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : list) &#123;    </span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">list.forEach((e) -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>
<h4 id="3、流操作"><a href="#3、流操作" class="headerlink" title="3、流操作"></a>3、流操作</h4><p>下面是流查询list集合中等于 <code>&quot;a&quot;</code>的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter((e) -&gt; <span class="string">"a"</span>.equals(e)).count();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/11/如何提高服务器的并发处理能力/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/11/如何提高服务器的并发处理能力/" itemprop="url">
                  如何提高服务器的并发处理能力
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-11 15:22:05" itemprop="dateCreated datePublished" datetime="2020-02-11T15:22:05+08:00">2020-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/架构设计/" itemprop="url" rel="index"><span itemprop="name">架构设计</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下内容为入门级介绍，意在对老技术作较全的总结而不是较深的研究。主要参考《构建高性能Web站点》一书。</p>
<h2 id="什么是服务器并发处理能力"><a href="#什么是服务器并发处理能力" class="headerlink" title="什么是服务器并发处理能力"></a>什么是服务器并发处理能力</h2><p>一台服务器在单位时间里能处理的请求越多，服务器的能力越高，也就是服务器并发处理能力越强</p>
<h2 id="有什么方法衡量服务器并发处理能力"><a href="#有什么方法衡量服务器并发处理能力" class="headerlink" title="有什么方法衡量服务器并发处理能力"></a>有什么方法衡量服务器并发处理能力</h2><h3 id="1-吞吐率"><a href="#1-吞吐率" class="headerlink" title="1. 吞吐率"></a><strong>1. 吞吐率</strong></h3><p>吞吐率，单位时间里服务器处理的最大请求数，单位req/s</p>
<p>从服务器角度，实际并发用户数的可以理解为服务器当前维护的代表不同用户的文件描述符总数，也就是并发连接数。</p>
<p>服务器一般会限制同时服务的最多用户数，比如apache的MaxClents参数。</p>
<p>这里再深入一下，对于服务器来说，服务器希望支持高吞吐率，对于用户来说，用户只希望等待最少的时间，显然，双方不能满足，所以双方利益的平衡点，就是我们希望的最大并发用户数。</p>
<h3 id="2-压力测试"><a href="#2-压力测试" class="headerlink" title="2. 压力测试"></a><strong>2. 压力测试</strong></h3><p>有一个原理一定要先搞清楚，假如100个用户同时向服务器分别进行10个请求，与1个用户向服务器连续进行1000次请求，对服务器的压力是一样吗？</p>
<p>实际上是不一样的，因对每一个用户，连续发送请求实际上是指发送一个请求并接收到响应数据后再发送下一个请求。</p>
<p>这样对于1个用户向服务器连续进行1000次请求, 任何时刻服务器的网卡接收缓冲区中只有1个请求，而对于100个用户同时向服务器分别进行10个请求，服务器的网卡接收缓冲区最多有100个等待处理的请求，显然这时的服务器压力更大。</p>
<p>压力测试前提考虑的条件</p>
<ul>
<li>并发用户数: 指在某一时刻同时向服务器发送请求的用户总数(HttpWatch)</li>
<li>总请求数</li>
<li>请求资源描述</li>
<li>请求等待时间(用户等待时间)</li>
<li>用户平均请求的等待时间</li>
<li>服务器平均请求处理的时间</li>
<li>硬件环境</li>
</ul>
<p>压力测试中关心的时间又细分以下2种:</p>
<ol>
<li>用户平均请求等待时间（这里暂不把数据在网络的传输时间，还有用户PC本地的计算时间计算入内）</li>
<li>服务器平均请求处理时间</li>
</ol>
<p>用户平均请求等待时间主要用于衡量服务器在一定并发用户数下，单个用户的服务质量；而服务器平均请求处理时间就是吞吐率的倒数。</p>
<p>一般来说，用户平均请求等待时间 = 服务器平均请求处理时间 * 并发用户数</p>
<h2 id="怎么提高服务器的并发处理能力"><a href="#怎么提高服务器的并发处理能力" class="headerlink" title="怎么提高服务器的并发处理能力"></a>怎么提高服务器的并发处理能力</h2><h3 id="1-提高CPU并发计算能力"><a href="#1-提高CPU并发计算能力" class="headerlink" title="1. 提高CPU并发计算能力"></a><strong>1. 提高CPU并发计算能力</strong></h3><p>服务器之所以可以同时处理多个请求，在于操作系统通过多执行流体系设计使得多个任务可以轮流使用系统资源。</p>
<p>这些资源包括CPU，内存以及I/O. 这里的I/O主要指磁盘I/O, 和网络I/O。</p>
<h5 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程 &amp; 多线程"></a><strong>多进程 &amp; 多线程</strong></h5><p>多执行流的一般便是进程，多进程的好处可以对CPU时间的轮流使用，对CPU计算和IO操作重叠利用。这里的IO主要是指磁盘IO和网络IO，相对CPU而言，它们慢的可怜。</p>
<p>而实际上，大多数进程的时间主要消耗在I/O操作上。</p>
<p>现代计算机的DMA技术可以让CPU不参与I/O操作的全过程，比如进程通过系统调用，使得CPU向网卡或者磁盘等I/O设备发出指令，然后进程被挂起，释放出CPU资源，等待I/O设备完成工作后通过中断来通知进程重新就绪。</p>
<p>对于单任务而言，CPU大部分时间空闲，这时候多进程的作用尤为重要。</p>
<p>多进程不仅能够提高CPU的并发度。其优越性还体现在独立的内存地址空间和生命周期所带来的稳定性和健壮性，其中一个进程崩溃不会影响到另一个进程。</p>
<p>但是进程也有如下<strong>缺点</strong>：</p>
<ol>
<li>fork()系统调用开销很大: prefork</li>
<li>进程间调度和上下文切换成本: 减少进程数量</li>
<li>庞大的内存重复：共享内存</li>
<li>IPC编程相对比较麻烦</li>
</ol>
<h4 id="减少进程切换"><a href="#减少进程切换" class="headerlink" title="减少进程切换"></a><strong>减少进程切换</strong></h4><p>当硬件上下文频繁装入和移出时，所消耗的时间是非常可观的。可用Nmon工具监视服务器每秒的上下文切换次数。</p>
<p>为了尽量减少上下文切换次数，最简单的做法就是减少进程数，尽量使用线程并配合其它I/O模型来设计并发策略。</p>
<p>还可以考虑使用进程绑定CPU技术，增加CPU缓存的命中率。若进程不断在各CPU上切换，这样旧的CPU缓存就会失效。</p>
<h4 id="减少使用不必要的锁"><a href="#减少使用不必要的锁" class="headerlink" title="减少使用不必要的锁"></a><strong>减少使用不必要的锁</strong></h4><p>服务器处理大量并发请求时，多个请求处理任务时存在一些资源抢占竞争，这时一般采用“锁”机制来控制资源的占用。到底<code>什么是重入锁</code>附录内容推荐大家看下。</p>
<p>当一个任务占用资源时，我们锁住资源，这时其它任务都在等待锁的释放，这个现象称为<strong>锁竞争</strong>。</p>
<p>通过锁竞争的本质，我们要意识到尽量减少并发请求对于共享资源的竞争。</p>
<p>比如在允许情况下关闭服务器访问日志，这可以大大减少在锁等待时的延迟时间。要最大程度减少无辜的等待时间。</p>
<p>这里说下无锁编程，就是由内核完成这个锁机制，主要是使用原子操作替代锁来实现对共享资源的访问保护。</p>
<p>使用原子操作时，在进行实际的写操作时，使用了lock指令，这样就可以阻止其他任务写这块内存，避免出现数据竞争现象。<strong>原子操作速度比锁快，一般要快一倍以上</strong>。</p>
<p>例如fwrite(), fopen()，其是使用append方式写文件，其原理就是使用了无锁编程，无锁编程的复杂度高，但是效率快，而且发生死锁概率低。</p>
<h4 id="考虑进程优先级"><a href="#考虑进程优先级" class="headerlink" title="考虑进程优先级"></a><strong>考虑进程优先级</strong></h4><p>进程调度器会动态调整运行队列中进程的优先级，通过top观察进程的PR值</p>
<h4 id="考虑系统负载"><a href="#考虑系统负载" class="headerlink" title="考虑系统负载"></a><strong>考虑系统负载</strong></h4><p>可在任何时刻查看/proc/loadavg, top中的load average也可看出</p>
<h4 id="考虑CPU使用率"><a href="#考虑CPU使用率" class="headerlink" title="考虑CPU使用率"></a><strong>考虑CPU使用率</strong></h4><p>除了用户空间和内核空间的CPU使用率以外，还要关注I/O wait,它是指CPU空闲并且等待I/O操作完成的时间比例（top中查看wa的值）。</p>
<h3 id="2-考虑减少内存分配和释放"><a href="#2-考虑减少内存分配和释放" class="headerlink" title="2. 考虑减少内存分配和释放"></a><strong>2. 考虑减少内存分配和释放</strong></h3><p>服务器的工作过程中，需要大量的内存，使得内存的分配和释放工作尤为重要。</p>
<p>可以通过改善数据结构和算法复制度来适当减少中间临时变量的内存分配及数据复制时间，而服务器本身也使用了各自的策略来提高效率。</p>
<p>例如Apache,在运行开始时一次申请大片的内存作为内存池，若随后需要时就在内存池中直接获取，不需要再次分配，避免了频繁的内存分配和释放引起的内存整理时间。</p>
<p>再如Nginx使用多线程来处理请求，使得多个线程之间可以共享内存资源，从而令它的内存总体使用量大大减少。</p>
<p>另外，Nginx分阶段的内存分配策略，按需分配，及时释放，使得内存使用量保持在很小的数量范围。</p>
<p>另外，还可以考虑<strong>共享内存</strong>。</p>
<p>共享内存指在多处理器的计算机系统中，可以被不同中央处理器（CPU）访问的大容量内存，也可以由不同进程共享，是非常快的进程通信方式。</p>
<p>但是使用共享内存也有不好的地方，就是对于多机器时数据不好统一。</p>
<p>shell命令ipcs可用来显示系统下共享内存的状态，函数shmget可以创建或打开一块共享内存区，函数shmat将一个存在的共享内存段连接到本进程空间, 函数shmctl可以对共享内存段进行多种操作，函数shmdt函数分离该共享内存。</p>
<h3 id="3-考虑使用持久连接"><a href="#3-考虑使用持久连接" class="headerlink" title="3. 考虑使用持久连接"></a><strong>3. 考虑使用持久连接</strong></h3><p>持久连接也为<strong>长连接</strong>，它本身是TCP通信的一种普通方式，即在一次TCP连接中持续发送多分数据而不断开连接。</p>
<p>与它相反的方式称为<strong>短连接</strong>，也就是建立连接后发送一份数据就断开，然后再次建立连接发送下一份数据， 周而复始。</p>
<p>是否采用持久连接，完全取决于应用特点。</p>
<p>从性能角度看，建立TCP连接的操作本身是一项不小的开销，在允许的情况下，连接次数越少，越有利于性能的提升; 尤其对于密集型的图片或网页等小数据请求处理有明显的加速所用。</p>
<p>HTTP长连接需要浏览器和web服务器的共同协作，目前浏览器普遍支持长连接，表现在其发出的HTTP请求数据头中包含关于长连接的声明，如下：Connection: Keep-Alive</p>
<p>主流的web服务器都支持长连接，比如apache中，可以用KeepAlive off关闭长连接。</p>
<p>对于长连接的有效使用，还有关键一点在于长连接超时时间的设置，即长连接在什么时候关闭吗？</p>
<p>Apache的默认设置为5s, 若这个时间设置过长，则可能导致资源无效占有，维持大量空闲进程，影响服务器性能。</p>
<h3 id="4-改进I-O-模型"><a href="#4-改进I-O-模型" class="headerlink" title="4. 改进I/O 模型"></a><strong>4. 改进I/O 模型</strong></h3><p>I/O操作根据设备的不同分为很多类型，比如内存I/O, 网络I/O, 磁盘I/O。</p>
<p>对于网络I/O和磁盘I/O, 它们的速度要慢很多，尽管使用RAID磁盘阵列可通过并行磁盘磁盘来加快磁盘I/O速度，购买大连独享网络带宽以及使用高带宽网络适配器可以提高网络I/O的速度。</p>
<p>但这些I/O操作需要内核系统调用来完成，这些需要CPU来调度，这使得CPU不得不浪费宝贵的时间来等待慢速I/O操作。</p>
<p>我们希望让CPU足够少的时间在i/O操作的调度上，如何让高速的CPU和慢速的I/O设备更好地协调工作，是现代计算机一直探讨的话题。各种I/O模型的本质区别在于CPU的参与方式。</p>
<h4 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a><strong>DMA技术</strong></h4><p>I/O设备和内存之间的数据传输方式由DMA控制器完成。在DMA模式下，CPU只需向DMA下达命令，让DMA控制器来处理数据的传送，这样可以大大节省系统资源。</p>
<h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a><strong>异步I/O</strong></h4><p>异步I/O指主动请求数据后便可以继续处理其它任务，随后等待I/O操作的通知，这样进程在数据读写时不发生阻塞。</p>
<p>异步I/O是非阻塞的，当函数返回时，真正的I/O传输已经完成，这让CPU处理和I/O操作达到很好的重叠。</p>
<h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a><strong>I/O多路复用</strong></h4><p>epoll服务器同时处理大量的文件描述符是必不可少的，若采用同步非阻塞I/O模型，若同时接收TCP连接的数据，就必须轮流对每个socket调用接收数据的方法，不管这些socket有没有可接收的数据，都要询问一次。</p>
<p>假如大部分socket并没有数据可以接收，那么进程便会浪费很多CPU时间用于检查这些socket有没有可以接收的数据。</p>
<p>多路I/O就绪通知的出现，提供了对大量文件描述符就绪检查的高性能方案，它允许进程通过一种方法同时监视所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。</p>
<p>epoll可以同时支持水平触发和边缘触发，理论上边缘触发性能更高，但是代码实现复杂，因为任何意外的丢失事件都会造成请求处理错误。</p>
<p>epoll主要有2大改进：</p>
<ol>
<li><p>epoll只告知就绪的文件描述符，而且当调用epoll_wait()获得文件描述符时，返回并不是实际的描述符，而是一个代表就绪描述符数量的值，然后只需去epoll指定的一个数组中依次取得相应数量的文件描述符即可。</p>
<p>这里使用了内存映射(mmap)技术，这样彻底省掉了这些文件描述符在系统调用时复制的开销。</p>
</li>
<li><p>epoll采用基于事件的就绪通知方式。其事先通过epoll_ctrl()注册每一个文件描述符，一旦某个文件描述符就绪时，内核会采用类似callback的回调机制，当进程调用epoll_wait()时得到通知</p>
</li>
</ol>
<p>关于IO模型，可以参考笔者前面写的相关文章Java NIO.2；关于epoll，可以参考笔者前面写的文章select、poll和epoll简介。</p>
<h4 id="Sendfile"><a href="#Sendfile" class="headerlink" title="Sendfile"></a><strong>Sendfile</strong></h4><p>大多数时候，我们都向服务器请求静态文件，比如图片，样式表等。</p>
<p>在处理这些请求时，磁盘文件的数据先经过内核缓冲区，然后到用户内存空间，不需经过任何处理，其又被送到网卡对应的内核缓冲区，接着再被送入网卡进行发送。</p>
<p>Linux提供sendfile()系统调用，可以讲磁盘文件的特定部分直接传送到代表客户端的socket描述符，加快了静态文件的请求速度，同时减少CPU和内存的开销。</p>
<p>适用场景：对于请求较小的静态文件，sendfile发挥的作用不那么明显，因发送数据的环节在整个过程中所占时间的比例相比于大文件请求时小很多。</p>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a><strong>内存映射</strong></h4><p>Linux内核提供一种访问磁盘文件的特殊方式，它可以将内存中某块地址空间和我们指定的磁盘文件相关联，从而对这块内存的访问转换为对磁盘文件的访问。这种技术称为<strong>内存映射</strong>。</p>
<p>多数情况下，内存映射可以提高磁盘I/O的性能，无须使用read()或write()等系统调用来访问文件，而是通过mmap()系统调用来建立内存和磁盘文件的关联，然后像访问内存一样自由访问文件。</p>
<p><strong>缺点</strong>：在处理较大文件时，内存映射会导致较大的内存开销，得不偿失。</p>
<h4 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a><strong>直接I/O</strong></h4><p>在linux 2.6中，内存映射和直接访问文件没有本质差异，因为数据需要经过2次复制，即在磁盘与内核缓冲区之间以及在内核缓冲区与用户态内存空间。</p>
<p>引入内核缓冲区的目的在于<strong>提高磁盘文件的访问性能</strong>，然而对于一些复杂的应用，比如数据库服务器，它们为了进一步提高性能，希望绕过内核缓冲区，由自己在用户态空间实现并管理I/O缓冲区，比如数据库可根据更加合理的策略来提高查询缓存命中率。</p>
<p>另一方面，绕过内核缓冲区也可以减少系统内存的开销，因内核缓冲区本身就在使用系统内存。</p>
<p>Linux在open()系统调用中增加参数选项O_DIRECT,即可绕过内核缓冲区直接访问文件,实现直接I/O。</p>
<p>在Mysql中，对于Innodb存储引擎，自身进行数据和索引的缓存管理，可在my.cnf配置中分配raw分区跳过内核缓冲区，实现直接I/O。</p>
<h3 id="5-改进服务器并发策略"><a href="#5-改进服务器并发策略" class="headerlink" title="5. 改进服务器并发策略"></a><strong>5. 改进服务器并发策略</strong></h3><p>服务器并发策略的目的，是让I/O操作和CPU计算尽量重叠进行，一方面让CPU在I/O等待时不要空闲，另一方面让CPU在I/O调度上尽量花最少的时间。</p>
<h4 id="一个进程处理一个连接，非阻塞I-O"><a href="#一个进程处理一个连接，非阻塞I-O" class="headerlink" title="一个进程处理一个连接，非阻塞I/O"></a><strong>一个进程处理一个连接，非阻塞I/O</strong></h4><p>这样会存在多个并发请求同时到达时，服务器必然要准备多个进程来处理请求。其进程的开销限制了它的并发连接数。</p>
<p>但从稳定性和兼容性的角度，则其相对安全，任何一个子进程的崩溃不会影响服务器本身，父进程可以创建新的子进程；这种策略典型的例子就是Apache的fork和prefork模式。</p>
<p>对于并发数不高（如150以内）的站点同时依赖Apache其它功能时的应用选择Apache还是可以的。</p>
<h4 id="一个线程处理一个连接，非阻塞IO"><a href="#一个线程处理一个连接，非阻塞IO" class="headerlink" title="一个线程处理一个连接，非阻塞IO"></a><strong>一个线程处理一个连接，非阻塞IO</strong></h4><p>这种方式允许在一个进程中通过多个线程来处理多个连接，一个线程处理一个连接。Apache的worker模式就是这种典型例子，使其可支持更多的并发连接。不过这种模式的总体性能还不如prefork，所以一般不选用worker模式。</p>
<h4 id="一个进程处理多个连接，异步I-O"><a href="#一个进程处理多个连接，异步I-O" class="headerlink" title="一个进程处理多个连接，异步I/O"></a><strong>一个进程处理多个连接，异步I/O</strong></h4><p>一个线程同时处理多个连接，潜在的前提条件就是使用IO多路复用就绪通知。</p>
<p>这种情况下，将处理多个连接的进程叫做worker进程或服务进程。worker的数量可以配置，如Nginx中的worker_processes 4。</p>
<h4 id="一个线程处理多个连接，异步IO"><a href="#一个线程处理多个连接，异步IO" class="headerlink" title="一个线程处理多个连接，异步IO"></a><strong>一个线程处理多个连接，异步IO</strong></h4><p>即使有高性能的IO多路复用就绪通知，但磁盘IO的等待还是无法避免的。更加高效的方法是对磁盘文件使用异步IO，目前很少有Web服务器真正意义上支持这种异步IO。</p>
<h3 id="6-改进硬件环境"><a href="#6-改进硬件环境" class="headerlink" title="6. 改进硬件环境"></a><strong>6. 改进硬件环境</strong></h3><p>还有一点要提及的是硬件环境，服务器的硬件配置对应用程序的性能提升往往是最直接，也是最简单的方式，这就是所谓的scale up。这里不做论述。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h3><blockquote>
<p>java.util.concurrent.locks.ReentrantLock</p>
</blockquote>
<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>
<p><img src="/2020/02/11/如何提高服务器的并发处理能力/640.webp" alt="img"></p>
<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>
<blockquote>
<p>java.util.concurrent.locks.Lock</p>
</blockquote>
<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>
<h3 id="为什么叫重入锁呢？"><a href="#为什么叫重入锁呢？" class="headerlink" title="为什么叫重入锁呢？"></a>为什么叫重入锁呢？</h3><p><code>ReentrantLock</code>，我们把它拆开来看就明了了。</p>
<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>
<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>
<h3 id="重入锁最重要的几个方法"><a href="#重入锁最重要的几个方法" class="headerlink" title="重入锁最重要的几个方法"></a>重入锁最重要的几个方法</h3><p>这几个方法都是 Lock 接口中定义的：</p>
<p><img src="/2020/02/11/如何提高服务器的并发处理能力/640.webp" alt="img"></p>
<p><strong>1）lock()</strong></p>
<p>获取锁，有以下三种情况：</p>
<ul>
<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>
<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>
<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>
</ul>
<p><strong>2）lockInterruptibly()</strong></p>
<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>
<p><strong>3）tryLock()</strong></p>
<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>
<ul>
<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>
<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>
<li>其他线程持有锁：获取锁失败，返回：false；</li>
</ul>
<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>
<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>
<p><strong>5）unlock()</strong></p>
<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>
<p><strong>6）newCondition</strong></p>
<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！</p>
<h3 id="重入锁大概的用法"><a href="#重入锁大概的用法" class="headerlink" title="重入锁大概的用法"></a>重入锁大概的用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>
<h3 id="synchronized-是重入锁吗？"><a href="#synchronized-是重入锁吗？" class="headerlink" title="synchronized 是重入锁吗？"></a>synchronized 是重入锁吗？</h3><p>那么问题来了，synchronized 是重入锁吗？</p>
<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>
<p>答案是：yes，为什么？看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/06/分布式基础要点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/分布式基础要点/" itemprop="url">
                  分布式基础要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-06 20:20:12" itemprop="dateCreated datePublished" datetime="2020-02-06T20:20:12+08:00">2020-02-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/架构设计/" itemprop="url" rel="index"><span itemprop="name">架构设计</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a><strong>1 概念</strong></h2><h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a><strong>1.1 模型</strong></h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h4><p>在具体的工程项目中，一个节点往往是一个操作系统上的进程。在本文的模型中，认为节点是一个完整的、不可分的整体，如果某个程序进程实际上由若干相对独立部分构成，则在模型中可以将一个进程划分为多个节点。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><ol>
<li><strong>机器宕机</strong>：机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</li>
<li><strong>网络异常</strong>：消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</li>
<li><strong>分布式三态</strong>：如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</li>
<li><strong>存储数据丢失</strong>:对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。</li>
<li><strong><em>异常处理原则\</em></strong>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</li>
</ol>
<h3 id="1-2-副本"><a href="#1-2-副本" class="headerlink" title="1.2 副本"></a><strong>1.2 副本</strong></h3><p>副本（replica/copy）指在分布式系统中为数据或服务提供的冗余。对于数据副本指在不同的节点上持久化同一份数据，当出现某一个节点的存储的数据丢失时，可以从副本上读到数据。数据副本是分布式系统解决数据丢失异常的唯一手段。另一类副本是服务副本，指数个节点提供某种相同的服务，这种服务一般并不依赖于节点的本地存储，其所需数据一般来自其他节点。</p>
<p>副本协议是贯穿整个分布式系统的理论核心。</p>
<h4 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a><strong>副本一致性</strong></h4><p>分布式系统通过副本控制协议，使得从系统外部读取系统内部各个副本的数据在一定的约束条件下相同，称之为副本一致性(consistency)。副本一致性是针对分布式系统而言的，不是针对某一个副本而言。</p>
<ol>
<li><strong>强一致性(strong consistency)</strong>：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。</li>
<li><strong>单调一致性(monotonic consistency)</strong>：任何时刻，任何用户一旦读到某个数据在某次更新后的值，这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。</li>
<li><strong>会话一致性(session consistency)</strong>：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的概念，例如php 中的session 概念。</li>
<li><strong>最终一致性(eventual consistency)</strong>：最终一致性要求一旦更新成功，各个副本上的数据最终将达 到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的副本，则无法保障任何一致性。</li>
<li><strong>弱一致性(week consistency)</strong>：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。</li>
</ol>
<h3 id="1-3-衡量分布式系统的指标"><a href="#1-3-衡量分布式系统的指标" class="headerlink" title="1.3 衡量分布式系统的指标"></a><strong>1.3 衡量分布式系统的指标</strong></h3><ol>
<li><strong>性能</strong>：系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</li>
<li><strong>可用性</strong>：系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</li>
<li><strong>可扩展性</strong>：系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</li>
<li><strong>一致性</strong>：分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单。</li>
</ol>
<h2 id="2-分布式系统原理"><a href="#2-分布式系统原理" class="headerlink" title="2 分布式系统原理"></a><strong>2 分布式系统原理</strong></h2><h3 id="2-1-数据分布方式"><a href="#2-1-数据分布方式" class="headerlink" title="2.1 数据分布方式"></a><strong>2.1 数据分布方式</strong></h3><p>所谓分布式系统顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计算、存储等问题。单机系统与分布式系统的最大的区别在于问题的规模，即计算、存储的数据量的区别。将一个单机问题使用分布式解决，首先要解决的就是如何将问题拆解为可以使用多机分布式解决，使得分布式系统中的每台机器负责原问题的一个子集。由于无论是计算还是存储，其问题输入对象都是数据，所以如何拆解分布式系统的输入数据成为分布式系统的基本问题。</p>
<h4 id="哈希方式"><a href="#哈希方式" class="headerlink" title="哈希方式"></a><strong>哈希方式</strong></h4><p><img src="/2020/02/06/分布式基础要点/image-20200206203106202.png" alt="image-20200206203106202"></p>
<p>哈希分布数据的缺点同样明显，突出表现为可扩展性不高，一旦集群规模需要扩展，则几乎所有的数据需要被迁移并重新分布。工程中，扩展哈希分布数据的系统时，往往使得集群规模成倍扩展，按照数据重新计算哈希，这样原本一台机器上的数据只需迁移一半到另一台对应的机器上即可完成扩展。</p>
<p>针对哈希方式扩展性差的问题，一种思路是不再简单的将哈希值与机器做除法取模映射，而是将对应关系作为元数据由专门的元数据服务器管理.同时，哈希值取模个数往往大于机器个数，这样同一台机器上需要负责多个哈希取模的余数。但需要以较复杂的机制维护大量的元数据。哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题。</p>
<p>哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200207095335209.png" alt="image-20200207095335209"></p>
<h4 id="按数据范围分布"><a href="#按数据范围分布" class="headerlink" title="按数据范围分布"></a><strong>按数据范围分布</strong></h4><p>按数据范围分布是另一个常见的数据分布式，将数据按特征值的值域范围划分为不同的区间，使得集群中每台（组）服务器处理不同区间的数据。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203344509.png" alt="image-20200206203344509"></p>
<p>工程中，为了数据迁移等负载均衡操作的方便，往往利用动态划分区间的技术，使得每个区间中服务的数据量尽量的一样多。当某个区间的数据量较大时，通过将区间“分裂”的方式拆分为两个区间，使得每个数据区间中的数据量都尽量维持在一个较为固定的阈值之下。</p>
<p>一般的，往往需要使用专门的服务器在内存中维护数据分布信息，称这种数据的分布信息为一种元信息。甚至对于大规模的集群，由于元信息的规模非常庞大，单台 计算机无法独立维护，需要使用多台机器作为元信息服务器。</p>
<h4 id="按数据量分布"><a href="#按数据量分布" class="headerlink" title="按数据量分布"></a><strong>按数据量分布</strong></h4><p>数据量分布数据与具体的数据特征无关，而是将数据视为一个顺序增长的文件，并将这个文件按照某一较为固定的大小划分为若干数据块（chunk），不同的数据块分布到不同的服务器上。与按数据范围分布数据的方式类似的是，按数据量分布数据也需要记录数据块的具体分布情况，并将该分布信息作为元数据使用元数据服务器管理。</p>
<p>由于与具体的数据内容无关，按数据量分布数据的方式一般没有数据倾斜的问题，数据总是被均匀切分并分布到集群中。当集群需要重新负载均衡时，只需通过迁移数据块即可完成。集群扩容也没有太大的限制，只需将部分数据库迁移到新加入的机器上即可以完成扩容。按数据量划分数据的缺点是需要管理较为复杂的元信息，与按范围分布数据的方式类似，当集群规模较大时，元信息的数据量也变得很大，高效的管理元信息成为新的课题。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a><strong>一致性哈希</strong></h4><p>一致性哈希（consistent hashing）是另一个种在工程中使用较为广泛的数据分布方式。一致性哈希最初在P2P 网络中作为分布式哈希表（DHT）的常用数据分布算法。一致性哈希的基本方式是使用一个哈希函数计算数据或数据特征的哈希值，令该哈希函数的输出值域为一个封闭的环，即哈希函数输出的最大值是最小值的前序。将节点随机分布到这个环上，每个节点负责处理从自己开始顺时针至下一个节点的全部哈希值域上的数据。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203409796.png" alt="image-20200206203409796"></p>
<p>使用一致性哈希的方式需要将节点在一致性哈希环上的位置作为元信息加以管理，这点比直接使用哈希分布数据的方式要复杂。然而，节点的位置信息只于集群中的机器规模相关，其元信息的量通常比按数据范围分布数据和按数据量分布数据的元信息量要小很多。</p>
<p>为此一种常见的改进算法是引入虚节点（virtual node）的概念，系统初始时就创建许多虚节点，虚节点的个数一般远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希值域环上，其功能与基本一致性哈希算法中的节点相同。为每个节点分配若干虚节点。操作数据时，首先通过数据的哈希值在环上找到对应的虚节点，进而查找元数据找到对应的真实节点。使用虚节点改进有多个优点。首先，一旦某个节点不可用，该节点将使得多个虚节点不可用，从而使得多个相邻的真实节点负载失效节点的压里。同理，一旦加入一个新节点，可以分配多个虚节点，从而使得新节点可以 负载多个原有节点的压力，从全局看，较容易实现扩容时的负载均衡。</p>
<h4 id="副本与数据分布"><a href="#副本与数据分布" class="headerlink" title="副本与数据分布"></a><strong>副本与数据分布</strong></h4><p>分布式系统容错、提高可用性的基本手段就是使用副本。对于数据副本的分布方式主要影响系统的可扩展性。一种基本的数据副本策略是以机器为单位，若干机器互为副本，副本机器之间的数据完全相同。这种策略适用于上述各种数据分布方式。其优点是非常简单，其缺点是恢复数据的效率不高、可扩展性也不高。</p>
<p>更合适的做法不是以机器作为副本单位，而是将数据拆为较合理的数据段，以数据段为单位作为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小以内。数据段有很多不同的称谓，segment，fragment，chunk，partition 等等。数据段的选择与数据分布方式直接相关。对于哈希分数据的方式，每个哈希分桶后的余数可以作为一个数据段，为了控制数据段的大小，常常使得分桶个数大于集群规模。一旦将数据分为数据段，则可以以数据段为单位管理副本，从而副本与机器不再硬相关，每台机器都可以负责一定数据段的副本。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203433498.png" alt="image-20200206203433498"></p>
<p>一旦副本分布与机器无关，数据丢失后的恢复效率将非常高。这是因为，一旦某台机器的数据丢失，其上数据段的副本将分布在整个集群的所有机器中，而不是仅在几个副本机器中，从而可以从整个集群同时拷贝恢复数据，而集群中每台数据源机器都可以以非常低的资源做拷贝。作为恢复数据源的机器即使都限速1MB/s，若有100 台机器参与恢复，恢复速度也能达到100MB/s。再者，副本分布与机器无关也利于集群容错。如果出现机器宕机，由于宕机机器上的副本分散于整个集群，其压力也自然分散到整个集群。最后，副本分布与机器无关也利于集群扩展。理论上，设集群规模 为N 台机器，当加入一台新的机器时，只需从各台机器上迁移1/N – 1/N+1 比例的数据段到新机器即实现了新的负载均衡。由于是从集群中各机器迁移数据，与数据恢复同理，效率也较高。工程中，完全按照数据段建立副本会引起需要管理的元数据的开销增大，副本维护的难度也相应增大。一种折中的做法是将某些数据段组成一个数据段分组，按数据段分组为粒度进行副本管理。这样做可以将副本粒度控制在一个较为合适的范围内。</p>
<h4 id="本地化计算"><a href="#本地化计算" class="headerlink" title="本地化计算"></a><strong>本地化计算</strong></h4><p>在分布式系统中，数据的分布方式也深深影响着计算的分布方式。在分布式系统中计算节点和保存计算数据的存储节点可以在同一台物理机器上，也可以位于不同的物理机器。如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此种方式的开销很大，甚至网络带宽会成为系统的总体瓶颈。另一种思路是，将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一种重要优化，其体现了一种重要的分布式调度思想：“移动数据不如移动计算”。</p>
<h4 id="数据分布方式的选择"><a href="#数据分布方式的选择" class="headerlink" title="数据分布方式的选择"></a><strong>数据分布方式的选择</strong></h4><p>在实际工程实践中，可以根据需求及实施复杂度合理选择数据分布方式。另外，数据分布方式是可以灵活组合使用的，往往可以兼备各种方式的优点，收到较好的综合效果。</p>
<p>例：数据倾斜问题，在按哈希分数据的基础上引入按数据量分布数据的方式，解决该数据倾斜问题。按用户id 的哈希值分数据，当某个用户id 的数据量特别大时，该用户的数据始终落在某一台机器上。此时，引入按数据量分布数据的方式，统计用户的数据量，并按某一阈值将用户的数据切为多个均匀的数据段，将这些数据段分布到集群中去。由于大部分用户的数据量不会超过阈值，所以元数据中仅仅保存超过阈值的用户的数据段分布信息，从而可以控制元数据的规模。这种哈希分布数据方式与按数据量分布数据方式组合使用的方案，在某真实系统中使用，取得了较好的效果。</p>
<h3 id="2-2-基本副本协议"><a href="#2-2-基本副本协议" class="headerlink" title="2.2 基本副本协议"></a><strong>2.2 基本副本协议</strong></h3><p>副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一致性要求的分布式协议。副本控制协议要具有一定的对抗异常状态的容错能力，从而使得系统具有一定的可用性，同时副本控制协议要能提供一定一致性级别。由CAP 原理（在2.9 节详细分析）可知，要设计一种满足强一致性，且在出现任何网络异常时都可用的副本协议是不可能的。为此，实际中的副本控制协议总是在可用性、一致性与性能等各要素之间按照具体需求折中。</p>
<p>副本控制协议可以分为两大类：“中心化(centralized)副本控制协议”和“去中心化(decentralized)副本控制协议”。</p>
<h4 id="中心化副本控制协议"><a href="#中心化副本控制协议" class="headerlink" title="中心化副本控制协议"></a><strong>中心化副本控制协议</strong></h4><p>中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之间的一致性。图给出了中心化副本协议的通用架构。中心化副本控制协议的优点是协议相对较为简单，所有的副本相关的控制交由中心节点完成。并发控制将由中心节点完成，从而使得一个分布式并发控制问题，简化为一个单机并发控制问题。所谓并发控制，即多个节点同时需要修改副本数据时，需要解决“写写”、“读写”等并发冲突。单机系统上常用加锁等方式进行并发控制。对于分布式并发控制，加锁也是一个常用的方法，但如果没有中心节点统一进行锁管理，就需要完全分布式化的锁系统，会使得协议非常复杂。中心化副本控制协议的缺点是系统的可用性依赖于中心化节点，当中心节点异常或与中心节点通信中断时，系统将失去某些服务（通常至少失去更新服务），所以中心化副本控制协议的缺点正是存在一定的停服务时间。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203512899.png" alt="image-20200206203512899"></p>
<h4 id="primary-secondary-协议"><a href="#primary-secondary-协议" class="headerlink" title="primary-secondary 协议"></a><strong>primary-secondary 协议</strong></h4><p>在primary-secondary 类型的协议中，副本被分为两大类，其中有且仅有一个副本作为primary 副本，除primary 以外的副本都作为secondary 副本。维护primary 副本的节点作为中心节点，中心节点负责维护数据的更新、并发控制、协调副本的一致性。</p>
<p>Primary-secondary 类型的协议一般要解决四大类问题：数据更新流程、数据读取方式、Primary 副本的确定和切换、数据同步（reconcile）。</p>
<h5 id="数据更新基本流程"><a href="#数据更新基本流程" class="headerlink" title="数据更新基本流程"></a>数据更新基本流程</h5><ol>
<li>数据更新都由primary 节点协调完成。</li>
<li>外部节点将更新操作发给primary 节点</li>
<li>primary 节点进行并发控制即确定并发更新操作的先后顺序</li>
<li>primary 节点将更新操作发送给secondary 节点</li>
<li>primary 根据secondary 节点的完成情况决定更新是否成功并将结果返回外部节点</li>
</ol>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203526071.png" alt="image-20200206203526071"></p>
<p>在工程实践中，如果由primary 直接同时发送给其他N 个副本发送数据，则每个 secondary 的更新吞吐受限于primary 总的出口网络带宽，最大为primary 网络出口带宽的1/N。为了解决这个问题，有些系统（例如，GFS），使用接力的方式同步数据，即primary 将更新发送给第一 个secondary 副本，第一个secondary 副本发送给第二secondary 副本，依次类推。</p>
<h5 id="数据读取方式"><a href="#数据读取方式" class="headerlink" title="数据读取方式"></a><strong>数据读取方式</strong></h5><p>数据读取方式也与一致性高度相关。如果只需要最终一致性，则读取任何副本都可以满足需求。如果需要会话一致性，则可以为副本设置版本号，每次更新后递增版本号，用户读取副本时验证版本号，从而保证用户读到的数据在会话范围内单调递增。使用primary-secondary 比较困难的是实现强一致性。</p>
<ol>
<li>由于数据的更新流程都是由primary 控制的，primary 副本上的数据一定是最新的，所以 如果始终只读primary 副本的数据，可以实现强一致性。如果只读primary 副本，则secondary 副本将不提供读服务。实践中，如果副本不与机器绑定，而是按照数据段为单位维护副本，仅有primary 副本提供读服务在很多场景下并不会造出机器资源浪费。</li>
</ol>
<p>将副本分散到集群中个，假设primary 也是随机的确定的，那么每台机器上都有一些数据的primary 副本，也有另一些数据段的secondary 副本。从而某台服务器实际都提供读写服务。</p>
<ol>
<li>由primary 控制节点secondary 节点的可用性。当primary 更新某个secondary 副本不成功时，primary 将该secondary 副本标记为不可用，从而用户不再读取该不可用的副本。不可用的 secondary 副本可以继续尝试与primary 同步数据，当与primary 完成数据同步后，primary 可以副本标记为可用。这种方式使得所有的可用的副本，无论是primary 还是secondary 都是可读的，且在一个确定的时间内，某secondary 副本要么更新到与primary 一致的最新状态，要么被标记为不可用，从而符合较高的一致性要求。这种方式依赖于一个中心元数据管理系统，用于记录哪些副本可用，哪些副本不可用。某种意义上，该方式通过降低系统的可用性来提高系统的一致性。</li>
</ol>
<h5 id="primary-副本的确定与切换"><a href="#primary-副本的确定与切换" class="headerlink" title="primary 副本的确定与切换"></a><strong>primary 副本的确定与切换</strong></h5><p>在primary-secondary 类型的协议中，另一个核心的问题是如何确定primary 副本，尤其是在原primary 副本所在机器出现宕机等异常时，需要有某种机制切换primary 副本，使得某个secondary 副本成为新的primary 副本。</p>
<p>通常的，在primary-secondary 类型的分布式系统中，哪个副本是primary 这一信息都属于元信息，由专门的元数据服务器维护。执行更新操作时，首先查询元数据服务器获取副本的primary 信息，从而进一步执行数据更新流程。</p>
<p>由于分布式系统中可靠的发现节点异常是需要一定的探测时间的，这样的探测时间通常是10 秒级别，这也意味着一旦primary 异常，最多需要10 秒级别的发现时间，系统才能开始primary 的切换，在这10 秒时间内，由于没有primary，系统不能提供更 新服务，如果系统只能读primary 副本，则这段时间内甚至不能提供读服务。从这里可以看到，primary-backup 类副本协议的最大缺点就是由于primary 切换带来的一定的停服务时间。</p>
<h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a><strong>数据同步</strong></h5><p>不一致的secondary 副本需要与primary 进行同步（reconcile）。</p>
<p>通常不一致的形式有三种：一、由于网络分化等异常，secondary 上的数据落后于primary 上的数据。二、在某些协议下，secondary 上的数据有可能是脏数据，需要被丢弃。所谓脏数据是由于primary 副本没有进行某一更新操作，而secondary 副本上反而进行的多余的修改操作，从而造成secondary 副本数据错误。三、secondary 是一个新增加的副本，完全没有数据，需要从其他副本上拷贝数据。</p>
<p>对于第一种secondary 数据落后的情况，常见的同步方式是回放primary 上的操作日志（通常是redo 日志），从而追上primary 的更新进度。对于脏数据的情况，较好的做法是设计的分布式协议不产生脏数据。如果协议一定有产生脏数据的可能，则也应该使得产生脏数据的概率降到非常低得情况，从而一旦发生脏数据的情况可以简单的直接丢弃有脏数据的副本，这样相当于副本没有数据。另外，也可以设计一些基于undo 日志的方式从而可以删除脏数据。如果secondary 副本完全没有数据，则常见的做法是直接拷贝primary 副本的数据，这种方法往往比回放日志追更新进度的方法快很多。但拷贝数据时primary 副本需要能够继续提供更新服务，这就要求primary 副本支持快照(snapshot)功能。即对某一刻的副本数据形成快照，然后拷贝快照，拷贝完成后使用回放日志的方式追快照形成后的更新操作。</p>
<h4 id="去中心化副本控制协议"><a href="#去中心化副本控制协议" class="headerlink" title="去中心化副本控制协议"></a><strong>去中心化副本控制协议</strong></h4><p>去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商达到一致。从而去中心化协议没有因为中心化节点异常而带来的停服务等问题。</p>
<p>去中心化协议的最大的缺点是协议过程通常比较复杂。尤其当去中心化协议需要实现强一致性时，协议流程变得复杂且不容易理解。由于流程的复杂，去中心化协议的效率或者性能一般也较中心化协议低。一个不恰当的比方就是，中心化副本控制协议类似专制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影响较大；去中心化副本控制协议类似民主制度，节点集体协商，效率低下，但个别节点的异常不会对系统总体造成太大影响。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203546614.png" alt="image-20200206203546614"></p>
<h3 id="2-3-Lease-机制"><a href="#2-3-Lease-机制" class="headerlink" title="2.3 Lease 机制"></a><strong>2.3 Lease 机制</strong></h3><p>Lease 机制是最重要的分布式协议，广泛应用于各种实际的分布式系统中。</p>
<h4 id="基于lease-的分布式cache-系统"><a href="#基于lease-的分布式cache-系统" class="headerlink" title="基于lease 的分布式cache 系统"></a><strong>基于lease 的分布式cache 系统</strong></h4><p>基本的问题背景如下：在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据cache，在各个节点上 cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。另一方面，系统的正确运行严格依赖于元数据的正确，这就要求各个节点上cache 的数据始终与中心服务器上的数据一致，cache 中的数据不能是旧的脏数据。最后，设计的cache 系统要能最大可能的处理节点宕机、网络中断等异常，最大程度的提高系统的可用性。</p>
<p>为此，利用lease 机制设计一套cache 系统，其基本原理为如下。中心服务器在向各节点发送数据时同时向节点颁发一个lease。每个lease 具有一个有效期，和信用卡上的有效期类似，lease 上的 有效期通常是一个明确的时间点，例如12:00:10，一旦真实时间超过这个时间点，则lease 过期失效。这样lease 的有效期与节点收到lease 的时间无关，节点可能收到lease 时该lease 就已经过期失效。这里首先假设中心服务器与各节点的时钟是同步的，在下节中讨论时钟不同步对lease 的影响。中心服务器发出的lease 的含义为：在lease 的有效期内，中心服务器保证不会修改对应数据的值。因此，节点收到数据和lease 后，将数据加入本地Cache，一旦对应的lease 超时，节点将对应的本地cache 数据删除。中心服务器在修改数据时，首先阻塞所有新的读请求，并等待之前为该数据发出的所有lease 超时过期，然后修改数据的值。</p>
<p>基于lease 的cache，客户端节点读取元数据</p>
<ol>
<li>判断元数据是否已经处于本地cache 且lease 处于有效期内1.1 是：直接返回cache 中的元数据1.2 否：向中心服务器节点请求读取元数据信息1.2.1 服务器收到读取请求后，返回元数据及一个对应的lease 1.2.2 客户端是否成功收到服务器返回的数据  1.2.2.1 失败或超时：退出流程，读取失败，可重试1.2.2.2 成功：将元数据与该元数据的lease 记录到内存中，返回元数据</li>
<li>基于lease 的cache，客户端节点修改元数据流程2.1 节点向服务器发起修改元数据请求。2.2 服务器收到修改请求后，阻塞所有新的读数据请求，即接收读请求，但不返回数据。2.3 服务器等待所有与该元数据相关的lease 超时。2.4 服务器修改元数据并向客户端节点返回修改成功。</li>
</ol>
<p>上述机制可以保证各个节点上的cache 与中心服务器上的中心始终一致。这是因为中心服务器节点在发送数据的同时授予了节点对应的lease，在lease 有效期内，服务器不会修改数据，从而客户端节点可以放心的在lease 有效期内cache 数据。上述lease 机制可以容错的关键是：服务器一旦 发出数据及lease，无论客户端是否收到，也无论后续客户端是否宕机，也无论后续网络是否正常，服务器只要等待lease 超时，就可以保证对应的客户端节点不会再继续cache 数据，从而可以放心的修改数据而不会破坏cache 的一致性。</p>
<p>上述基础流程有一些性能和可用性上的问题，但可以很容易就优化改性。优化点一：服务器在修改元数据时首先要阻塞所有新的读请求，造成没有读服务。这是为了防止发出新的lease 从而引起不断有新客户端节点持有lease 并缓存着数据，形成“活锁”。优化的方法很简单，服务器在进入修改数据流程后，一旦收到读请求则只返回数据但不颁发lease。从而造成在修改流程执行的过程中，客户端可以读到元数据，只是不能缓存元数据。进一步的优化是，当进入修改流程，服务器颁发的lease 有效期限选择为已发出的lease 的最大有效期限。这样做，客户端可以继续在服务器进入修改流程后继续缓存元数据，但服务器的等待所有lease 过期的时间也不会因为颁发新的lease 而不断延长。</p>
<p>最后，cache 机制与多副本机制的区别。Cache 机制与多副本机制的相似之处都 是将一份数据保存在多个节点上。但Cache 机制却要简单许多，对于cache 的数据，可以随时删除丢弃，并命中cache 的后果仅仅是需要访问数据源读取数据；然而副本机制却不一样，副本是不能随意丢弃的，每失去一个副本，服务质量都在下降，一旦副本数下降到一定程度，则往往服务将不再可用。</p>
<h5 id="lease-机制的分析"><a href="#lease-机制的分析" class="headerlink" title="lease 机制的分析"></a><strong>lease 机制的分析</strong></h5><p>lease 的定义：Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发出lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要lease 不过期，颁发者一定严守承诺；另一方面，接收方在lease 的有效期内可以使用颁发者的承诺，但一旦lease 过期，接收方一定不能继续使用颁发者的承诺。</p>
<p>Lease 机制具有很高的容错能力。首先，通过引入有效期，Lease 机制能否非常好的容错网络异常。Lease 颁发过程只依赖于网络可以单向通信，即使接收方无法向颁发者发送消息，也不影响lease 的颁发。由于lease 的有效期是一个确定的时间点，lease 的语义与发送lease 的具体时间无关，所以 同一个lease 可以被颁发者不断重复向接受方发送。即使颁发者偶尔发送lease 失败，颁发者也可以 简单的通过重发的办法解决。一旦lease 被接收方成功接受，后续lease 机制不再依赖于网络通信，即使网络完全中断lease 机制也不受影响。再者，Lease 机制能较好的容错节点宕机。如果颁发者宕机，则宕机的颁发者通常无法改变之前的承诺，不会影响lease 的正确性。在颁发者机恢复后，如果颁发者恢复出了之前的lease 信息，颁发者可以继续遵守lease 的承诺。如果颁发者无法恢复lease 信息，则只需等待一个最大的lease 超时时间就可以使得所有的lease 都失效，从而不破坏lease机制。</p>
<p>例如上节中的cache 系统的例子中，一旦服务器宕机，肯定不会修改元数据，重新恢复后，只需等待一个最大的lease 超时时间，所有节点上的缓存信息都将被清空。对于接受方宕机的情况，颁发者 不需要做更多的容错处理，只需等待lease 过期失效，就可以收回承诺，实践中也就是收回之前赋予的权限、身份等。最后，lease 机制不依赖于存储。颁发者可以持久化颁发过的lease 信息，从而在 宕机恢复后可以使得在有效期的lease 继续有效。但这对于lease 机制只是一个优化，如之前的分析，即使颁发者没有持久化lease 信息，也可以通过等待一个最大的lease 时间的方式使得之前所有颁发 的lease 失效，从而保证机制继续有效。</p>
<p>Lease 机制依赖于有效期，这就要求颁发者和接收者的时钟是同步的。一方面，如果颁发者的 时钟比接收者的时钟慢，则当接收者认为lease 已经过期的时候，颁发者依旧认为lease 有效。接收者可以用在lease 到期前申请新的lease 的方式解决这个问题。另一方面，如果颁发者的时钟比接收 者的时钟快，则当颁发者认为lease 已经过期的时候，接收者依旧认为lease 有效，颁发者可能将lease 颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对lease 的有效性的影响。</p>
<h5 id="基于lease-机制确定节点状态"><a href="#基于lease-机制确定节点状态" class="headerlink" title="基于lease 机制确定节点状态"></a><strong>基于lease 机制确定节点状态</strong></h5><p>分布式协议依赖于对节点状态认知的全局一致性，即一旦节点Q 认为某个节点 A 异常，则节点A 也必须认为自己异常，从而节点A 停止作为primary，避免“双主”问题的出现。解决这种问题有两种思路，第一、设计的分布式协议可以容忍“双主”错误，即不依赖于对节点状 态的全局一致性认识，或者全局一致性状态是全体协商后的结果；第二、利用lease 机制。对于第一 种思路即放弃使用中心化的设计，而改用去中心化设计，超过本节的讨论范畴。下面着重讨论利用 lease 机制确定节点状态。</p>
<p>由中心节点向其他节点发送lease，若某个节点持有有效的lease，则认为该节点正常可以提供服 务。用于例2.3.1 中，节点A、B、C 依然周期性的发送heart beat 报告自身状态，节点Q 收到heart beat 后发送一个lease，表示节点Q 确认了节点A、B、C 的状态，并允许节点在lease 有效期内正常工 作。节点Q 可以给primary 节点一个特殊的lease，表示节点可以作为primary 工作。一旦节点Q 希望切换新的primary，则只需等前一个primary 的lease 过期，则就可以安全的颁发新的lease 给新的 primary 节点，而不会出现“双主”问题。</p>
<p>在实际系统中，若用一个中心节点发送lease 也有很大的风险，一旦该中心节点宕机或网络异常，则所有的节点没有lease，从而造成系统高度不可用。为此，实际系统总是使用多个中心节点互为副本，成为一个小的集群，该小集群具有高可用性，对外提供颁发lease 的功能。chubby 和zookeeper 都是基于这样的设计。</p>
<h5 id="lease-的有效期时间选择"><a href="#lease-的有效期时间选择" class="headerlink" title="lease 的有效期时间选择"></a><strong>lease 的有效期时间选择</strong></h5><p>工程中，常选择的lease 时长是10 秒级别，这是一个经过验证的经验值，实践中可以作为参考并综合选择合适的时长。</p>
<h3 id="2-4-Quorum-机制"><a href="#2-4-Quorum-机制" class="headerlink" title="2.4 Quorum 机制"></a><strong>2.4 Quorum 机制</strong></h3><p>先做这样的约定：更新操作（write）是一系列顺序的过程，通过其他机制确定更新操作的顺序（例如primary-secondary 架构中由primary 决定顺序），每个更新操作记为wi， i 为更新操作单调递增的序号，每个wi 执行成功后副本数据都发生变化，称为不同的数据版本，记 作vi。假设每个副本都保存了历史上所有版本的数据。</p>
<h4 id="write-all-read-one"><a href="#write-all-read-one" class="headerlink" title="write-all-read-one"></a><strong>write-all-read-one</strong></h4><p>Write-all-read-one（简称WARO）是一种最简单的副本控制规则，顾名思义即在更新时写所有的副本，只有在所有的副本上更新成功，才认为更新成功，从而保证所有的副本一致，这样在读取数据时可以读任一副本上的数据。</p>
<p>由于更新操作需要在所有的N 个副本上都成功，更新操作才能成 功，所以一旦有一个副本异常，更新操作失败，更新服务不可用。对于更新服务，虽然有N 个副本， 但系统无法容忍任何一个副本异常。另一方面，N 个副本中只要有一个副本正常，系统就可以提供读服务。对于读服务而言，当有N 个副本时，系统可以容忍N-1 个副本异常。从上述分析可以发现WARO 读服务的可用性较高，但更新服务的可用性不高，甚至虽然使用了副本，但更新服务的可用性等效于没有副本。</p>
<h4 id="Quorum-定义"><a href="#Quorum-定义" class="headerlink" title="Quorum 定义"></a><strong>Quorum 定义</strong></h4><p>在Quorum 机制下，当某次更新操作wi 一旦在所有N 个副本中的W 个副本上都成功，则就称 该更新操作为“成功提交的更新操作”，称对应的数据为“成功提交的数据”。令R&gt;N-W，由于更新 操作wi 仅在W 个副本上成功，所以在读取数据时，最多需要读取R 个副本则一定能读到wi 更新后 的数据vi 。如果某次更新wi 在W 个副本上成功，由于W+R&gt;N，任意R 个副本组成的集合一定与 成功的W个副本组成的集合有交集，所以读取R 个副本一定能读到wi 更新后的数据vi。如图 2-10， Quorum 机制的原理可以文森图表示。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203639455.png" alt="image-20200206203639455"></p>
<p>某系统有5 个副本，W=3，R=3，最初5 个副本的数据一致，都是v1，某次更新操作 w2 在前3 副本上成功，副本情况变成（v2 v2 v2 v1 v1）。此时，任意3 个副本组成的集合中一定包括 v2。在上述定义中，令W=N，R=1，就得到WARO，即WARO 是Quorum 机制的一种特例。与分析WARO 相似，分析Quorum 机制的可用性。限制Quorum 参数为W+R=N+1。由于更新 操作需要在W 个副本上都成功，更新操作才能成功，所以一旦N-W+1 个副本异常，更新操作始终无法在W 个副本上成功，更新服务不可用。另一方面，一旦N-R+1 个副本异常，则无法保证一定可以读到与W 个副本有交集的副本集合，则读服务的一致性下降。</p>
<p>再次强调：仅仅依赖quorum 机制是无法保证强一致性的。因为仅有quorum 机制时无法确定最新已成功提交的版本号，除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数据集群管理，否则很难确定最新成功提交的版本号。在下一节中，将讨论在哪些情况下，可以仅仅 通过quorum 机制来确定最新成功提交的版本号。</p>
<p>Quorum 机制的三个系统参数N、W、R 控制了系统的可用性，也是系统对用户的服务承诺：数据最多有N 个副本，但数据更新成功W 个副本即返回用户成功。对于一致性要求较高的Quorum 系统，系统还应该承诺任何时候不读取未成功提交的数据，即读取到的数据都是曾经在W 个副本上成功的数据。</p>
<h4 id="读取最新成功提交的数据"><a href="#读取最新成功提交的数据" class="headerlink" title="读取最新成功提交的数据"></a><strong>读取最新成功提交的数据</strong></h4><p>Quorum 机制只需成功更新N 个副本中的W 个，在读取R 个副本时，一定可以读到最新的成功提交的数据。但由于有不成功的更新情况存在，仅仅读取R 个副本却不一定能确定哪个版本的数据 是最新的已提交的数据。对于一个强一致性Quorum 系统，若存在个数据少于W 个，假设为X 个，则继续读取其他副本，直若成功读取到W 个 该版本的副本，则该数据为最新的成功提交的数据；如果在所有副本中该数据的个数肯定不满 足W 个，则R 中版本号第二大的为最新的成功提交的副本。例：在读取到（v2 v1 v1）时，继续读取剩余的副本，若读到剩余两个副本 为（v2 v2）则v2 是最新的已提交的副本；若读到剩余的两个副本为（v2 v1）或（v1 v1）则v1 是最新成功提交的版本；若读取后续两个副本有任一超时或失败，则无法判断哪个版本是最新的成功提交的版本。</p>
<p>可以看出，在单纯使用Quorum 机制时，若要确定最新的成功提交的版本，最多需要读取R+ （W-R-1）=N 个副本，当出现任一副本异常时，读最新的成功提交的版本这一功能都有可能不可用。实际工程中，应该尽量通过其他技术手段，回避通过Quorum 机制读取最新的成功提交的版本。例如，当quorum 机制与primary-secondary 控制协议结合使用时，可以通过读取primary 的方式读取到最新的已提交的数据。</p>
<h4 id="基于Quorum-机制选择primary副本"><a href="#基于Quorum-机制选择primary副本" class="headerlink" title="基于Quorum 机制选择primary副本"></a><strong>基于Quorum 机制选择primary副本</strong></h4><p>读取数据时依照一致性要求的不同可以有不同的做法：如果需要强一致性的立刻读取到最新的成功提交的数据，则可以简单的只读取primary 副本上的数据即可，也可以通过上节的方式读取；如果需要会话一致性，则可以根据之前已经读到的数据版本号在各个副本上进行选择性读取；如果只需要弱一致性，则可以选择任意副本读取。</p>
<p>在primary-secondary 协议中，当primary 异常时，需要选择出一个新的primary，之后secondary 副本与primary 同步数据。通常情况下，选择新的primary 的工作是由某一中心节点完成的，在引入 quorum 机制后，常用的primary 选择方式与读取数据的方式类似，即中心节点读取R 个副本，选择 R 个副本中版本号最高的副本作为新的primary。新primary 与至少W 个副本完成数据同步后作为新的primary 提供读写服务。首先，R 个副本中版本号最高的副本一定蕴含了最新的成功提交的数据。再者，虽然不能确定最高版本号的数是一个成功提交的数据，但新的primary 在随后与secondary 同 步数据，使得该版本的副本个数达到W，从而使得该版本的数据成为成功提交的数据。</p>
<p>例：在N=5，W=3，R=3 的系统中，某时刻副本最大版本号为（v2 v2 v1 v1 v1），此时v1 是系统的最新的成功提交的数据，v2 是一个处于中间状态的未成功提交的数据。假设此刻原primary 副本异常，中心节点进行primary 切换工作。这类“中间态”数据究竟作为“脏数据”被删除，还是作为新的数据被同步后成为生效的数据，完全取决于这个数据能否参与新primary 的选举。下面分别分析这两种情况。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203657503.png" alt="image-20200206203657503"></p>
<p>第一、如图 2-12，若中心节点与其中3 个副本通信成功，读取到的版本号为（v1 v1 v1），则任 选一个副本作为primary，新primary 以v1 作为最新的成功提交的版本并与其他副本同步，当与第1、第2 个副本同步数据时，由于第1、第2 个副本版本号大于primary，属于脏数据，可以按照2.2.2.4 节中介绍的处理脏数据的方式解决。实践中，新primary 也有可能与后两个副本完成同步后就提供数据服务，随后自身版本号也更新到v2，如果系统不能保证之后的v2 与之前的v2 完全一样，则新 primary 在与第1、2 个副本同步数据时不但要比较数据版本号还需要比较更新操作的具体内容是否一样。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203707864.png" alt="image-20200206203707864"></p>
<p>第二、若中心节点与其他3 个副本通信成功，读取到的版本号为（v2 v1 v1），则选取版本号为 v2 的副本作为新的primary，之后，一旦新primary 与其他2 个副本完成数据同步，则符合v2 的副 本个数达到W 个，成为最新的成功提交的副本，新primary 可以提供正常的读写服务。</p>
<h3 id="2-5-日志技术"><a href="#2-5-日志技术" class="headerlink" title="2.5 日志技术"></a><strong>2.5 日志技术</strong></h3><p>日志技术是宕机恢复的主要技术之一。日志技术最初使用在数据库系统中。严格来说日志技术不是一种分布式系统的技术，但在分布式系统的实践中，却广泛使用了日志技术做宕机恢复，甚 至如BigTable 等系统将日志保存到一个分布式系统中进一步增强了系统容错能力。</p>
<h4 id="Redo-Log-与Check-point"><a href="#Redo-Log-与Check-point" class="headerlink" title="Redo Log 与Check point"></a><strong>Redo Log 与Check point</strong></h4><p>设计一个高速的单机查询系统，将数据全部存放在内存中以实现高速的数据查询，每次更新操作更新一小部分数据（例如 key-value 中的某一个key）。现在问题为利用日志技术实现该内存查询系统的宕机恢复。与数据库的事务不同的是，这个问题模型中的每个成功的更新操作都会生效。这也等效为数据库的每个事务只有一个更新操作，且每次更新操作都可以也必须立即提交（Auto commit）。</p>
<ul>
<li><h5 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h5></li>
</ul>
<ol>
<li>将更新操作的结果（例如Set K1=1，则记录K1=1）以追加写（append）的方式写入磁盘的 日志文件</li>
<li>按更新操作修改内存中的数据</li>
<li>返回更新成功</li>
</ol>
<p>从Redo Log 的流程可以看出，Redo 写入日志的是更新操作完成后的结果（虽然本文不讨论Undo Log，这点是与Undo Log 的区别之一），且由于是顺序追加写日志文件，在磁盘等对顺序写有力的 存储设备上效率较高。</p>
<p>用Redo Log 进行宕机恢复非常简单，只需要“回放”日志即可。</p>
<p>流程2.5.2：Redo Log 的宕机恢复</p>
<ol>
<li>从头读取日志文件中的每次更新操作的结果，用这些结果修改内存中的数据。</li>
</ol>
<p>从Redo Log 的宕机恢复流程也可以看出，只有写入日志文件的更新结果才能在宕机后恢复。这也是为什么在Redo Log 流程中需要先更新日志文件再更新内存中的数据的原因。假如先更新内存中的数据，那么用户立刻就能读到更新后的数据，一旦在完成内存修改与写入日志之间发生宕机，那么最后一次更新操作无法恢复，但之前用户可能已经读取到了更新后的数据，从而引起不一致的问题。</p>
<ul>
<li><h5 id="Check-point"><a href="#Check-point" class="headerlink" title="Check point"></a>Check point</h5></li>
</ul>
<p>。在简化的模型下，check point 技术的过程即将内存中的数据以某种易于重新加载的数据组织方式完整的dump 到磁盘，从而减少宕机恢复时需要回放的日志数据。</p>
<p>流程：check point</p>
<ol>
<li>向日志文件中记录“Begin Check Point”</li>
<li>将内存中的数据以某种易于重新加载的数据组织方式dump 到磁盘上</li>
<li>向日志文件中记录“End Check Point” 在check point 流程中，数据可以继续按照流程2.5.1 被更新，这段过程中新更新的数据可以dump 到磁盘也可以不dump 到磁盘，具体取决于实现。例如，check point 开始时k1=v1，check point 过程 中某次更新为k1 = v2，那么dump 到磁盘上的k1 的值可以是v1 也可以是v2。</li>
</ol>
<p>流程：基于check point 的宕机恢复流程</p>
<ol>
<li>将dump 到磁盘的数据加载到内存。</li>
<li>从后向前扫描日志文件，寻找最后一个“End Check Point”日志。</li>
<li>从最后一个“End Check Point”日志向前找到最近的一个“Begin Check Point”日志，并回 放该日志之后的所有更新操作日志。</li>
</ol>
<ul>
<li><h4 id="No-Undo-No-Redo-log"><a href="#No-Undo-No-Redo-log" class="headerlink" title="No Undo/No Redo log"></a>No Undo/No Redo log</h4></li>
</ul>
<p>若数据维护在磁盘中，某批更新由若干个更新操作组成，这些更新操作需要原子生效，即要么同时生效，要么都不生效。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203755875.png" alt="image-20200206203755875"></p>
<p>0/1 目录技术中有两个目录结构，称为目录0(Directory 0)和目录1(Directory 1)。另有一个结构称为主记录（Master record）记录当前正在使用的目录称为活动目录。主记录中要么记录使用目录0，要么记录使用目录1。目录0 或目录1 中记录了各个数据的在日志文件中的位置。0/1 目录的数据更新过程始终在非活动目录上进行，只是在数据生效前，将主记录中的0、1 值反转，从而切换主记录。</p>
<p>流程：0/1 目录数据更新流程</p>
<ol>
<li>将活动目录完整拷贝到非活动目录。</li>
<li>对于每个更新操作，新建一个日志项纪录操作后的值，并在非活动目录中将相应数据的位置修改为新建的日志项的位置。</li>
<li>原子性修改主记录：反转主记录中的值，使得非活动目录生效。</li>
</ol>
<p>0/1 目录的更新流程非常简单，通过0、1 目录的主记录切换使得一批修改的生效是原子的。0/1 目录将批量事务操作的原子性通过目录手段归结到主记录的原子切换。由于多条记录的原子修改一般较难实现而单条记录的原子修改往往可以实现，从而降低了问题实现的难度。在工程中0/1 目录的思想运用非常广泛，其形式也不局限在上述流程中，可以是内存中的两个数据结构来回切换，也可以是磁盘上的两个文件目录来回生效切换。</p>
<h3 id="2-6-两阶段提交协议"><a href="#2-6-两阶段提交协议" class="headerlink" title="2.6 两阶段提交协议"></a><strong>2.6 两阶段提交协议</strong></h3><p>两阶段提交协议是一种经典的强一致性中心化副本控制协议。虽然在工程中该协议有较多的问题，但研究该协议能很好的理解分布式系统的几个典型问题。</p>
<h4 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a><strong>流程描述</strong></h4><p>两阶段提交协议是一种典型的“中心化副本控制”协议。在该协议中，参与的节点分为两类：一个中心化协调者节点（coordinator）和N 个参与者节点（participant）。每个参与者节点即上文背景介绍中的管理数据库副本的节点。</p>
<p>两阶段提交的思路比较简单，在第一阶段，协调者询问所有的参与者是否可以提交事务（请参与者投票），所有参与者向协调者投票。在第二阶段，协调者根据所有参与者的投票结果做出是否事务可以全局提交的决定，并通知所有的参与者执行该决定。在一个两阶段提交流程中，参与者不能改变自己的投票结果。两阶段提交协议的可以全局提交的前提是所有的参与者都同意提交事务，只要有一个参与者投票选择放弃(abort)事务，则事务必须被放弃。</p>
<p>流程：两阶段提交协调者流程</p>
<ol>
<li>写本地日志“begin_commit”，并进入WAIT 状态；</li>
<li>向所有参与者发送“prepare 消息”；</li>
<li>等待并接收参与者发送的对“prepare 消息”的响应；3.1 若收到任何一个参与者发送的“vote-abort 消息”；3.1.1 写本地“global-abort”日志，进入ABORT；3.1.2 向所有的参与者发送“global-abort 消息”；3.1.3 进入ABORT 状态；3.2 若收到所有参与者发送的“vote-commit”消息；3.2.1 写本地“global-commit”日志，进入COMMIT 状态；3.1.2 向所有的参与者发送“global-commit 消息”；</li>
<li>等待并接收参与者发送的对“global-abort 消息”或“global-commit 消息”的确认响应消息，一旦收到所有参与者的确认消息，写本地“end_transaction” 日志流程结束。</li>
</ol>
<p>流程：两阶段提交协调者流程</p>
<ol>
<li>写本地日志“init”记录，进入INIT 状态</li>
<li>等待并接受协调者发送的“prepare 消息”，收到后  2.1 若参与者可以提交本次事务 2.1.1 写本地日志“ready”，进入READY 状态 2.1.2 向协调者发送“vote-commit”消息 2.1.4 等待协调者的消息2.1.4.1 若收到协调者的“global-abort”消息2.1.4.1.1 写本地日志“abort”，进入ABORT 状态2.1.4.1.2 向协调者发送对“global-abort”的确认消息  2.1.4.2 若收到协调者的“global-commit”消息2.1.4.1.1 写本地日志“commit”，进入COMMIT 状态   2.1.4.1.2 向协调者发送对“global-commit”的确认消息  2.2 若参与者无法提交本次事务 2.2.1 写本地日志“abort”，进入ABORT 状态 2.2.2 向协调者发送“vote-abort”消息 2.2.3 流程对该参与者结束 2.2.4 若后续收到协调者的“global-abort”消息可以响应</li>
<li>即使流程结束，但任何时候收到协调者发送的“global-abort”消息或“global-commit”消息也都要发送一个对应的确认消息。</li>
</ol>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h4><h5 id="宕机恢复"><a href="#宕机恢复" class="headerlink" title="宕机恢复"></a>宕机恢复</h5><ol>
<li>协调者宕机恢复 协调者宕机恢复后，首先通过日志查找到宕机前的状态。如果日志中最后是“begin_commit”记录，说明宕机前协调者处于WAIT 状态，协调者可能已经发送过“prepare 消息”也可能还没发送，但协调者一定还没有发送过“global-commit 消息”或“global-abort 消息”，即事务的全局状态还没有确定。此时，协调者可以重新发送“prepare 消息” 继续两阶段提交流程，即使参与者已经发送过对“prepare 消息”的响应，也不过是再次重传之前的响应而不会影响协议的一致性。如果日志中最后是“global-commit”或“global-abort”记录，说明宕机前协调者处于COMMIT 或ABORT 状态。此时协调者只需重新向所有的参与者发送“global-commit 消息”或“global-abort 消息”就可以继续两阶段提交流程。</li>
<li>参与者宕机恢复参与者宕机恢复后，首先通过日志查找宕机前的状态。如果日志中最后是“init”记录，说明参与者处于INIT 状态，还没有对本次事务做出投票选择，参与者可以继续流程等待协调者发送的“prepare 消息”。如果日志中最后是“ready”记录，说明参与者处于REDAY 状态，此时说明参与者已经就本次 事务做出了投票选择，但宕机前参与者是否已经向协调者发送“vote-commit”消息并不可知。所以此时参与者可以向协调者重发“vote-commit”，并继续协议流程。如果日志中最后是“commit”或“abort”记录，说明参与者已经收到过协调者的“global-commit 消息”（处于COMMIT 状态）或者“global-abort 消息”（处于ABORT 状态）。至于是否向协调者发 送过对“global-commit”或“global-abort”的确认消息则未知。但即使没有发送过确认消息，由于协调者会不断重发“global-commit”或“global-abort”，只需在收到这些消息时发送确认消息既可，不影响协议的全局一致性。</li>
</ol>
<h4 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a><strong>协议分析</strong></h4><p>两阶段提交协议在工程实践中真正使用的较少，主要原因有以下几点：</p>
<ol>
<li>两阶段提交协议的容错能力较差。从上文的分析可以看出，两阶段提交协议在某些情况下存在流程无法执行下去的情况，且也无法判断流程状态。在工程中好的分布式协议往往总是可以在即使发生异常的情况下也能执行下去。例如，回忆Lease 机制（2.3 ），一旦lease 发出，无论出现任何异常，Lease 服务器节点总是可以通过时间判定出Lease 是否有效，也可以用等待Lease 超时的方法收回Lease 权限，整个Lease 协议的流程不存在任何流程被阻塞而无法执行下去的情况。与Lease 机制的简单有效相比，两阶段提交的协议显得较为复杂且容错能力差。</li>
<li>两阶段提交协议的性能较差。一次成功的两阶段提交协议流程中，协调者与每个参与者 之间至少需要两轮交互4 个消息“prepare”、“vote-commit”、“global-commit”、“确认global-commit”。过多的交互次数会降低性能。另一方面，协调者需要等待所有的参与者的投票结果，一旦存在较慢的参与者，会影响全局流程执行速度。</li>
</ol>
<p>虽然存在一些改进的两阶段提交协议可以提高容错能力和性能，然而这类协议依旧是在工程中使用较少的一类协议，其理论价值大于实践意义。</p>
<h3 id="2-7-MVCC"><a href="#2-7-MVCC" class="headerlink" title="2.7 MVCC"></a><strong>2.7 MVCC</strong></h3><p>MVCC(Multi-version Cocurrent Control，多版本并发控制)技术。MVCC 技术最初也是在数据库系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系统中同样有效。</p>
<p>MVCC 即多个不同版本的数据实现并发控制的技术，其基本思想是为每次事务生成 一个新版本的数据，在读数据时选择不同版本的数据即可以实现对事务结果的完整性读取。在使用MVCC 时，每个事务都是基于一个已生效的基础版本进行更新，事务可以并行进行，从而可以产生一种图状结构。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203851316.png" alt="image-20200206203851316"></p>
<p>基础数据的版本为1，同时产生了两个事务：事务A 与事务B。这两个事务都各自对数据进行了一些本地修改（这些修改只有事务自己可见，不影响真正的数据），之后事务A 首先提交，生成数据版本2；基于数据版本2，又发起了事务C，事务C 继续提交，生成了数据版 本3；最后事务B 提交，此时事务B 的结果需要与事务C 的结果合并，如果数据没有冲突，即事务 B 没有修改事务A 与事务C 修改过的变量，那么事务B 可以提交，否则事务B 提交失败。MVCC 的流程过程非常类似于SVN 等版本控制系统的流程，或者说SVN 等版本控制系统就是 使用的MVCC 思想。事务在基于基础数据版本做本地修改时，为了不影响真正的数据，通常有两种做法，一是将基础数据版本中的数据完全拷贝出来再修改，SVN 即使用了这种方法，SVN check out 即是拷贝的过程；二是每个事务中只记录更新操作，而不记录完整的数据，读取数据时再将更新操作应用到用基础版本的数据从而计算出结果，这个过程也类似SVN 的增量提交。</p>
<h3 id="2-8-Paxos协议"><a href="#2-8-Paxos协议" class="headerlink" title="2.8 Paxos协议"></a><strong>2.8 Paxos协议</strong></h3><p>Paxos 协议是少数在工程实践中证实的强一致性、高可用的去中心化分布式协议。Paxos 协议的流程较为复杂，但其基本思想却不难理解，类似于人类社会的投票过程。Paxos 协议中，有一组完全对等的参与节点（称为accpetor），这组节点各自就某一事件做出决议，如果某个决议获得了超过半数节点的同意则生效。Paxos 协议中只要有超过一半的节点正常，就可以工作，能很好对抗宕机、网络分化等异常情况。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h4><p>Proposer：提案者。Proposer 可以有多个，Proposer 提出议案（value）。所谓value，在工程中可以是任何操作，例如“修改某个变量的值为某个值”、“设置当前primary 为某个节点”等等。Paxos 协议中统一将这些操作抽象为value。不同的Proposer 可以提出不同的甚至矛盾的value，例如某个Proposer 提议“将变量X 设置为1”，另一个Proposer 提议“将变量X 设置为2”，但对同一轮Paxos 过程，最多只有一个value 被批准。Acceptor：批准者。Acceptor 有N 个，Proposer 提出的value 必须获得超过半数(N/2+1)的Acceptor 批准后才能通过。Acceptor 之间完全对等独立。Learner：学习者。Learner 学习被批准的value。所谓学习就是通过读取各个Proposer 对value 的选择结果，如果某个value 被超过半数Proposer 通过，则Learner 学习到了这个value。回忆（2.4 ） 不难理解，这里类似Quorum 机制，某个value 需要获得W=N/2 + 1 的Acceptor 批准，从而学习者需要至少读取N/2+1 个Accpetor，至多读取N 个Acceptor 的结果后，能学习到一个通过的value。上述三类角色只是逻辑上的划分，实践中一个节点可以同时充当这三类角色。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h4><p>Paxos 协议一轮一轮的进行，每轮都有一个编号。每轮Paxos 协议可能会批准一个value，也可 能无法批准一个value。如果某一轮Paxos 协议批准了某个value，则以后各轮Paxos 只能批准这个 value。上述各轮协议流程组成了一个Paxos 协议实例，即一次Paxos 协议实例只能批准一个value，这也是Paxos 协议强一致性的重要体现。每轮Paxos 协议分为阶段，准备阶段和批准阶段，在这两个阶段Proposer 和Acceptor 有各自的处理流程。</p>
<p>流程：Proposer 的流程 （准备阶段）</p>
<ol>
<li>向所有的Acceptor 发送消息“Prepare(b)”；这里b 是Paxos 的轮数，每轮递增</li>
<li>如果收到任何一个Acceptor 发送的消息“Reject(B)”，则对于这个Proposer 而言本轮Paxos 失败，将轮数b 设置为B+1 后重新步骤1；（批准阶段，根据收到的Acceptor 的消息作出不同选择）</li>
<li>如果接收到的Acceptor 的“Promise(b, v_i)”消息达到N/2+1 个（N 为Acceptor 总数，除法取整， 下同）；v_i 表示Acceptor 最近一次在i 轮批准过value v。3.1 如果收到的“Promise(b, v)”消息中，v 都为空，Proposer 选择一个value v，向所有Acceptor 广播Accept(b, v)；3.2 否则，在所有收到的“Promise(b, v_i)”消息中，选择i 最大的value v，向所有Acceptor 广播消息Accept(b，v)；</li>
<li>如果收到Nack(B)，将轮数b 设置为B+1 后重新步骤1；</li>
</ol>
<p>流程：Accpetor 流程 （准备阶段）</p>
<ol>
<li>接受某个Propeser 的消息Prepare(b)。参数B 是该Acceptor 收到的最大Paxos 轮数编号；V 是Acceptor 批准的value，可以为空 1.1 如果b&gt;B，回复Promise(b, V_B)，设置B=b; 表示保证不再接受编号小于b 的提案。1.2 否则，回复Reject(B) （批准阶段）</li>
<li>接收Accept(b, v)， 2.1 如果b &lt; B, 回复Nack(B)，暗示proposer 有一个更大编号的提案被这个Acceptor 接收了 2.2 否则设置V=v。表示这个Acceptor 批准的Value 是v。广播Accepted 消息。</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p>基本例子里有5 个Acceptor，1 个Proposer，不存在任何网络、宕机异常。我们着重考察各个Accpetor 上变量B 和变量V 的变化，及Proposer 上变量b 的变化。</p>
<ol>
<li><p>初始状态</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206204136621.png" alt="image-20200206204136621"></p>
</li>
<li><p>Proposer 向所有Accpetor 发送“Prepare(1)”，所有Acceptor 正确处理，并回复Promise(1, NULL)</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206204147068.png" alt="image-20200206204147068"></p>
</li>
<li><p>Proposer 收到5 个Promise(1, NULL)，满足多余半数的Promise 的value 为空，此时发送 Accept(1, v1)，其中v1 是Proposer 选择的Value。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206204211472.png" alt="image-20200206204211472"></p>
</li>
<li><p>此时，v1 被超过半数的Acceptor 批准，v1 即是本次Paxos 协议实例批准的Value。如果Learner 学习value，学到的只能是v1</p>
</li>
</ol>
<p>在同一个Paxos 实例中，批准的Value 是无法改变的，即使后续Proposer 以更高的序号发起Paxos 协议也无法改变value。Paxos 协议的核心就在于“批准的value 无法改变”，这也是整个协议正确性的基础。</p>
<p>Paxos 协议是被人为设计出来，其设计过程也是协议的推导过程。Paxos 协议利用了Quorom 机 制，选择的W=R=N/2+1。简单而言，协议就是Proposer 更新Acceptor 的过程，一旦某个Acceptor 成功更新了超过半数的Acceptor，则更新成功。Learner 按Quorum 去读取Acceptor，一旦某个value 在超过半数的Proposer 上被成功读取，则说明这是一个被批准的value。协议通过引入轮次，使得高轮次的提议抢占低轮次的提议来避免死锁。协议设计关键点是如何满足“在一次Paxos 算法实例过程中只批准一个Value”这一约束条件。</p>
<h3 id="2-9-CAP"><a href="#2-9-CAP" class="headerlink" title="2.9 CAP"></a><strong>2.9 CAP</strong></h3><p>CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性：</p>
<ul>
<li>Consistency (一致性)：CAP 理论中的副本一致性特指强一致性（1.3.4 ）；</li>
<li>Availiablity(可用性)：指系统在出现异常时已经可以提供服务；</li>
<li>Tolerance to the partition of network (分区容忍)：指系统可以对网络分区（1.1.4.2 ）这种异常情 况进行容错处理；</li>
</ul>
<p>CAP 理论指出：无法设计一种分布式协议，使得同时完全具备CAP 三个属性，即1)该种协议下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统协议只能在CAP 这三者间所有折中。</p>
<p>热力学第二定律说明了永动机是不可能存在的，不要去妄图设计永动机。与之类似，CAP 理论的意义就在于明确提出了不要去妄图设计一种对CAP 三大属性都完全拥有的完美系统，因为这种系统在理论上就已经被证明不存在。</p>
<ul>
<li>Lease 机制: Lease 机制牺牲了部分异常情况下的A，从而获得了完全的C 与很好的P。</li>
<li>Quorum 机制: Quorum 机制，在CAP 三大因素中都各做了折中，有一定的C，有较好 的A，也有较好的P，是一种较为平衡的分布式协议。</li>
<li>两阶段提交协议: 两阶段提交系统具有完全的C，很糟糕的A，很糟糕的P。</li>
<li>Paxos 协议：同样是强一致性协议，Paxos 在CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的C，较好的A，较好的P。Paxos 的A 与P 的属性与Quorum 机制类似，因为Paxos 的协议本 身就具有Quorum 机制的因素。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/06/HTTP协议要点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/HTTP协议要点/" itemprop="url">
                  HTTP协议要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-06 14:22:39" itemprop="dateCreated datePublished" datetime="2020-02-06T14:22:39+08:00">2020-02-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下文章来源于Java建设者 ，作者cxuan</p>
<h2 id="HTTP-内容协商"><a href="#HTTP-内容协商" class="headerlink" title="HTTP 内容协商"></a><strong>HTTP 内容协商</strong></h2><h3 id="什么是内容协商"><a href="#什么是内容协商" class="headerlink" title="什么是内容协商"></a><strong>什么是内容协商</strong></h3><p>在 HTTP 中，<code>内容协商</code>是一种用于在同一 URL 上提供资源的不同表示形式的机制。内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的标准。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<h3 id="内容协商的种类"><a href="#内容协商的种类" class="headerlink" title="内容协商的种类"></a><strong>内容协商的种类</strong></h3><p>内容协商主要有以下3种类型：</p>
<ul>
<li><code>服务器驱动协商（Server-driven Negotiation）</code></li>
</ul>
<p>这种协商方式是由服务器端进行内容协商。服务器端会根据请求首部字段进行自动处理</p>
<ul>
<li><code>客户端驱动协商（Agent-driven Negotiation）</code></li>
</ul>
<p>这种协商方式是由客户端来进行内容协商。</p>
<ul>
<li><code>透明协商（Transparent Negotiation）</code></li>
</ul>
<p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p>
<p>内容协商的分类有很多种，主要的几种类型是 <strong>Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language</strong>。</p>
<p>一般来说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</p>
<h3 id="为什么需要内容协商"><a href="#为什么需要内容协商" class="headerlink" title="为什么需要内容协商"></a><strong>为什么需要内容协商</strong></h3><p>我们为什么需要内容协商呢？在回答这个问题前我们先来看一下 TCP 和 HTTP 的不同。</p>
<p>在 TCP / IP 协议栈里，传输数据基本上都是 <code>header+body</code> 的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</p>
<p>而 HTTP 协议则不同，它是应用层的协议，数据到达之后需要告诉应用程序这是什么数据。当然不告诉应用这是哪种类型的数据，应用也可以通过不断尝试来判断，但这种方式无疑十分低效，而且有很大几率会检查不出来文件类型。</p>
<p>所以鉴于此，浏览器和服务器需要就数据的传输达成一致，浏览器需要告诉服务器自己希望能够接收什么样的数据，需要什么样的压缩格式，什么语言，哪种字符集等；而服务器需要告诉客户端自己能够提供的服务是什么。</p>
<p>所以我们就引出了内容协商的几种概念，下面依次来进行探讨</p>
<h3 id="内容协商标头"><a href="#内容协商标头" class="headerlink" title="内容协商标头"></a><strong>内容协商标头</strong></h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>接受请求 HTTP 标头会通告客户端自己能够接受的 <code>MIME</code> 类型</p>
<p>那么什么是 MIME 类型呢？在回答这个问题前你应该先了解一下什么是 MIME</p>
<blockquote>
<p>MIME: MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
</blockquote>
<p>也就是说，MIME 类型其实就是一系列消息内容类型的集合。那么 MIME 类型都有哪些呢？</p>
<p><code>文本文件</code>：text/html、text/plain、text/css、application/xhtml+xml、application/xml</p>
<p><code>图片文件</code>：image/jpeg、image/gif、image/png</p>
<p><code>视频文件</code>：video/mpeg、video/quicktime</p>
<p><code>应用程序二进制文件</code>：application/octet-stream、application/zip</p>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。</p>
<p>一般 MIME 类型也会和 <code>q</code> 这个属性一起使用，q 是什么？q 表示的是权重，来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure>
<p>这是什么意思呢？若想要给显示的<strong>媒体类型增加优先级</strong>，则使用 <code>q=</code> 来额外表示权重值，没有显示权重的时候默认值是1.0 ，我给你列个表格你就明白了</p>
<table>
<thead>
<tr>
<th style="text-align:left">q</th>
<th style="text-align:left">MIME</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.0</td>
<td style="text-align:left">text/html</td>
</tr>
<tr>
<td style="text-align:left">1.0</td>
<td style="text-align:left">application/xhtml+xml</td>
</tr>
<tr>
<td style="text-align:left">0.9</td>
<td style="text-align:left">application/xml</td>
</tr>
<tr>
<td style="text-align:left">0.8</td>
<td style="text-align:left"><em> / </em></td>
</tr>
</tbody>
</table>
<p>也就是说，这是一个放置顺序，权重高的在前，低的在后，<code>application/xml;q=0.9</code> 是不可分割的整体。</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>Accept-charset 属性规定服务器处理表单数据所接受的字符编码；Accept-charset 属性允许你指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。</p>
<p>Accept-Charset 没有对应的标头，服务器会把这个值放在 <code>Content-Type</code>中用<strong>charset=xxx</strong>来表示，</p>
<p>例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: gbk, utf-8</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和 Accept 首部字段一样，按权重值 <code>q=</code> 来表示相对优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: en-US,en;q=0.5</span><br></pre></td></tr></table></figure>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>表示 HTTP 标头会标明客户端希望服务端返回的内容编码，这通常是一种压缩算法。Accept-Encoding 也是属于<code>内容协商</code> 的一部分，使用并通过客户端选择 <code>Content-Encoding</code> 内容进行返回。</p>
<p>即使客户端和服务器都能够支持相同的压缩算法，服务器也可能选择不压缩并返回，这种情况可能是由于这两种情况造成的:</p>
<ul>
<li>要发送的数据已经被压缩了一次，第二次压缩并不会导致发送的数据更小</li>
<li>服务器过载，无法承受压缩带来的性能开销，通常，如果服务器使用 CPU 超过 80% ，<code>Microsoft</code> 则建议不要使用压缩</li>
</ul>
<p>下面是 Accept-Encoding 的使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Encoding: compress</span><br><span class="line">Accept-Encoding: deflate</span><br><span class="line">Accept-Encoding: br</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Encoding: *</span><br><span class="line">Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5</span><br></pre></td></tr></table></figure>
<p>上面的几种表述方式就已经把 Accept-Encoding 的属性列全了</p>
<ul>
<li><p><code>gzip</code>: 由文件压缩程序 gzip 生成的编码格式，使用 <code>Lempel-Ziv编码（LZ77）</code>和32位CRC的压缩格式，感兴趣的同学可以读一下 （<a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77）</a></p>
</li>
<li><p><code>compress</code>: 使用<code>Lempel-Ziv-Welch（LZW）</code>算法的压缩格式，有兴趣的同学可以读 （<a href="https://en.wikipedia.org/wiki/LZW）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LZW）</a></p>
</li>
<li><p><code>deflate</code>: 使用 zlib 结构和 deflate 压缩算法的压缩格式，参考 （<a href="https://en.wikipedia.org/wiki/Zlib）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Zlib）</a> 和 （<a href="https://en.wikipedia.org/wiki/DEFLATE）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/DEFLATE）</a></p>
</li>
<li><p><code>br</code>: 使用 Brotli 算法的压缩格式，参考 （<a href="https://en.wikipedia.org/wiki/Brotli）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Brotli）</a></p>
</li>
<li><p>不执行压缩或不会变化的默认编码格式</p>
</li>
<li><p><code>*</code> : 匹配标头中未列出的任何内容编码，如果没有列出 <code>Accept-Encoding</code> ，这就是默认值，并不意味着支</p>
<p>持任何算法，只是表示没有偏好</p>
</li>
<li><p><code>;q=</code> 采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。</p>
</li>
</ul>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>Content-Type 实体标头用于指示资源的 MIME 类型。作为响应，Content-Type 标头告诉客户端返回的内容的内容类型实际上是什么。Content-type 有两种值 : MIME 类型和字符集编码，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些情况下，浏览器将执行 MIME 嗅探，并且不一定遵循此标头的值；为防止此行为，可以将标头 X-Content-Type-Options 设置为 nosniff。</p>
</blockquote>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>Content-Encoding 实体标头用于压缩媒体类型，它让客户端知道如何进行解码操作，从而使客户端获得 Content-Type 标头引用的 MIME 类型。表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br><span class="line">Content-Encoding: identity</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Encoding: gzip, identity</span><br><span class="line">Content-Encoding: deflate, gzip</span><br></pre></td></tr></table></figure>
<h3 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h3><p>Content-Language 实体标头用于描述面向受众的语言，以便使用户根据用户自己的首选语言进行区分。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: de-DE</span><br><span class="line">Content-Language: en-US</span><br><span class="line">Content-Language: de-DE, en-CA</span><br></pre></td></tr></table></figure>
<p>下面根据内容协商对应的请求/响应标头，我列了一张图供你参考，注意其中 Accept-Charset 没有对应的 Content-Charset ，而是通过 Content-Type 来表示。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>HTTP 认证</p>
<p>HTTP 提供了用于访问控制和身份认证的功能，下面就对 HTTP 的权限和认证功能进行介绍</p>
<h3 id="通用-HTTP-认证框架"><a href="#通用-HTTP-认证框架" class="headerlink" title="通用 HTTP 认证框架"></a><strong>通用 HTTP 认证框架</strong></h3><p>RFC 7235 定义了 HTTP 身份认证框架，服务器可以根据其文档的定义来检查客户端请求。客户端也可以根据其文档定义来提供身份验证信息。</p>
<p>请求/响应的工作流程如下：服务器以<code>401(未授权)</code> 的状态响应客户端告诉客户端服务器需要认证信息，客户端提供至少一个 <code>www-Authenticate</code> 的响应标头进行授权信息的认证。想要通过服务器进行身份认证的客户端可以在请求标头字段中添加认证标头进行身份认证，一般的认证过程如下</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>首先客户端发起一个 HTTP 请求，不带有任何认证标头，服务器对此 HTTP 请求作出响应，发现此 HTTP 信息未带有认证凭据，服务器通过 <code>www-Authenticate</code>标头返回 401 告诉客户端此请求未通过认证。然后客户端进行用户认证，认证完毕后重新发起 HTTP 请求，这次 HTTP 请求带有用户认证凭据（注意，整个身份认证的过程必须通过 HTTPS 连接保证安全），到达服务器后服务器会检查认证信息，如果不符合服务器认证信息，会返回 <code>403 Forbidden</code> 表示用户认证失败，如果满足认证信息，则返回 <code>200 OK</code>。</p>
<p>我们知道，客户端和服务器之间的 HTTP 连接可以被代理缓存重新发送，所以认证信息也适用于代理服务器。</p>
<h3 id="代理认证"><a href="#代理认证" class="headerlink" title="代理认证"></a><strong>代理认证</strong></h3><p>由于资源认证和代理认证可以共存，因此需要不同的头和状态码，在代理的情况下，会返回状态码 <code>407(需要代理认证)</code>， <code>Proxy-Authenticate</code> 响应头包含至少一个适用于代理的情况，<code>Proxy-Authorization</code>请求头用于将证书提供给代理服务器。下面分别来认识一下这两个标头</p>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><p>HTTP <code>Proxy-Authenticate</code> 响应标头定义了身份验证方法，应使用该身份验证方法来访问代理服务器后面的资源。它将请求认证到代理服务器，从而允许它进一步发送请求。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic</span><br><span class="line">Proxy-Authenticate: Basic realm=&quot;Access to the internal site&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><p>这个 HTTP <code>请求</code>标头和上面的 <code>Proxy-Authenticate</code> 拼接很相似，但是概念不同，这个标头用于向代理服务器提供凭据，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</span><br></pre></td></tr></table></figure>
<p>下面是代理服务器的请求/响应认证过程</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这个过程和通用的过程类似，我们就不再详细展开描述了。</p>
<h3 id="禁止访问"><a href="#禁止访问" class="headerlink" title="禁止访问"></a><strong>禁止访问</strong></h3><p>如果<code>代理服务器</code>收到的有效凭据不足以获取对给定资源的访问权限，则服务器应使用<code>403 Forbidden</code>状态代码进行响应。与 <code>401 Unauthorized</code> 和 <code>407 Proxy Authorization Required</code> 不同，该用户无法进行身份验证。</p>
<h4 id="WWW-Authenticate-和-Proxy-Authenticate-头"><a href="#WWW-Authenticate-和-Proxy-Authenticate-头" class="headerlink" title="WWW-Authenticate 和 Proxy-Authenticate 头"></a>WWW-Authenticate 和 Proxy-Authenticate 头</h4><p><code>WWW-Authenticate</code> 和 <code>Proxy-Authenticate</code> 响应头定义了获得对资源访问权限的身份验证方法。他们需要指定使用哪种身份验证方案，以便希望授权的客户端知道如何提供凭据。它们的一般表示形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: &lt;type&gt; realm=&lt;realm&gt;</span><br><span class="line">Proxy-Authenticate: &lt;type&gt; realm=&lt;realm&gt;</span><br></pre></td></tr></table></figure>
<p>我想你从上面看到这里一定会好奇 <code></code> 和 <code>realm</code>是什么东西，现在就来解释下。</p>
<ul>
<li><code></code> 是认证协议，<code>Basic</code> 是下面协议中最普遍使用的</li>
</ul>
<blockquote>
<p>RFC 7617 中定义了<code>Basic</code> HTT P身份验证方案，该方案将凭据作为用户ID /密码对传输，并使用 base64 进行编码。(感兴趣的同学可以看看 <a href="https://tools.ietf.org/html/rfc7617" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7617</a>)</p>
</blockquote>
<p>其他的认证协议主要有</p>
<table>
<thead>
<tr>
<th style="text-align:left">认证协议</th>
<th style="text-align:left">参考来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Basic</td>
<td style="text-align:left">查阅 RFC 7617，base64编码的凭据</td>
</tr>
<tr>
<td style="text-align:left">Bearer</td>
<td style="text-align:left">查阅 RFC 6750，承载令牌来访问受 OAuth 2.0保护的资源</td>
</tr>
<tr>
<td style="text-align:left">Digest</td>
<td style="text-align:left">查阅 RFC 7616，Firefox仅支持md5哈希，请参见错误bug 472823以获得SHA加密支持</td>
</tr>
<tr>
<td style="text-align:left">HOBA</td>
<td style="text-align:left">查阅 RFC 7486</td>
</tr>
<tr>
<td style="text-align:left">Mutual</td>
<td style="text-align:left">查阅 RFC 8120</td>
</tr>
<tr>
<td style="text-align:left">AWS4-HMAC-SHA256</td>
<td style="text-align:left">查阅 <strong>AWS docs</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><code>realm</code> 用于描述保护区或指示保护范围，这可能是诸如 <strong>Access to the staging site(访问登陆站点)</strong> 或者类似的，这样用户就可以知道他们要访问哪个区域。</li>
</ul>
<h4 id="Authorization-和-Proxy-Authorization-标头"><a href="#Authorization-和-Proxy-Authorization-标头" class="headerlink" title="Authorization 和 Proxy-Authorization 标头"></a>Authorization 和 Proxy-Authorization 标头</h4><p>Authorization 和 Proxy-Authorization 请求标头包含用于通过代理服务器对用户代理进行身份验证的凭据。在此，再次需要类型，其后是凭据，取决于使用哪种身份验证方案，可以对凭据进行编码或加密。一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</span><br><span class="line">Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a><strong>HTTP 缓存</strong></h2><p>通过把<code>请求/响应</code>缓存起来有助于提升系统的性能，<code>Web 缓存</code>减少了延迟和网络传输量，因此减少资源获取锁需要的时间。由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把数据缓存起来，下次再请求的时候尽可能地复用。当 Web 缓存在其存储中具有请求的资源时，它将拦截该请求并直接返回资源，而不是到达源服务器重新下载并获取。这样做可以实现两个小目标</p>
<ul>
<li>减轻服务器负载</li>
<li>提升系统性能</li>
</ul>
<p>下面我们就一起来探讨一下 HTTP 缓存都有哪些</p>
<h3 id="不同类型的缓存"><a href="#不同类型的缓存" class="headerlink" title="不同类型的缓存"></a>不同类型的缓存</h3><p>HTTP 缓存有几种不同的类型，这些可以分为两个主要类别：<code>私有缓存</code> 和 <code>共享缓存</code>。</p>
<ul>
<li>共享缓存：共享缓存是一种缓存，它可以存储多个用户重复使用的请求/响应。</li>
<li>私有缓存：私有缓存也称为<code>专用缓存</code>，它只适用于单个用户。</li>
<li>不缓存过期资源：所有的请求都会直接到达服务器，由服务器来下载资源并返回。</li>
</ul>
<blockquote>
<p>我们主要探讨<code>浏览器缓存</code>和<code>代理缓存</code>，但真实情况不只有这两种缓存，还有网关缓存，CDN，反向代理缓存和负载平衡器，把它们部署在 Web 服务器上，可以提高网站和 Web 应用程序的可靠性，性能和可伸缩性。</p>
</blockquote>
<h4 id="不缓存过期资源"><a href="#不缓存过期资源" class="headerlink" title="不缓存过期资源"></a>不缓存过期资源</h4><p>不缓存过期资源即浏览器和代理不会缓存过期资源，客户端发起的请求会直接到达服务器，可以使用 <code>no-cache</code> 标头代表不缓存过期资源。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>no-cache 属于 Cache-Control 通用标头，其一般的表示方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>max-age = 0</code> 来实现不缓存的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>
<h4 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h4><p>私有缓存只用来缓存单个用户，你可能在浏览器设置中看到了 <code>缓存</code>，浏览器缓存包含服务器通过 HTTP 下载下来的所有文档。这个高速缓存用于使访问的文档可以进行前进/后退，保存操作而无需重新发送请求到源服务器。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>可以使用 <code>private</code> 来实现私有缓存，这与 <code>public</code> 的用法相反，缓存服务器只对特定的客户端进行缓存，其他客户端发送过来的请求，缓存服务器则不会返回缓存。它的一般表示方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>
<h4 id="共享缓存"><a href="#共享缓存" class="headerlink" title="共享缓存"></a>共享缓存</h4><p>共享缓存是一种用于存储要由多个用户重用的响应缓存。共享缓存一般使用 <code>public</code> 来表示，<code>public</code> 属性只出现在客户端响应中，表示响应可以被任何缓存所缓存。一般表示方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a><strong>缓存控制</strong></h3><p>HTTP/1.1 中的 <code>Cache-Control</code> 常规标头字段用于执行缓存控制，使用此标头可通过其提供的各种指令来定义缓存策略。下面我们依次介绍一下这些属性</p>
<h4 id="不缓存"><a href="#不缓存" class="headerlink" title="不缓存"></a>不缓存</h4><p><code>no-store</code> 才是真正意义上的<code>不缓存</code>，每次服务器接受到客户端的请求后，都会返回最新的资源给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>
<h4 id="缓存但需要验证"><a href="#缓存但需要验证" class="headerlink" title="缓存但需要验证"></a>缓存但需要验证</h4><p>同上面的 不缓存过期资源</p>
<h4 id="私有和共享缓存"><a href="#私有和共享缓存" class="headerlink" title="私有和共享缓存"></a>私有和共享缓存</h4><p>同上</p>
<h4 id="缓存过期"><a href="#缓存过期" class="headerlink" title="缓存过期"></a>缓存过期</h4><p>缓存中一个很重要的指令就是<code>max-age</code>，这是资源被视为<code>新鲜</code>的最长时间 ，与 <code>Expires</code>相反，此指令是相对于请求时间的。对于应用程序中不会更改的文件，通常可以添加主动缓存。下面是 mag-age 的表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>
<h4 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h4><p><code>must-revalidate</code> 表示缓存必须在使用之前验证过时资源的状态，并且不应使用过期的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>
<p>下面是一个缓存验证图</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>什么是新鲜的数据</p>
<p>一旦资源存储在缓存中，理论上就可以永远被缓存使用。但是不管是浏览器缓存还是代理缓存，其存储空间是有限的，所以缓存会定期进行清除，这个过程叫做 <code>缓存回收(cache eviction)</code> （自译）。另一方面，服务器上的缓存也会定期进行更新，HTTP 作为应用层的协议，它是一种<code>客户-服务器</code>模式，HTTP 是无状态的协议，因此当资源发生更改时，服务器无法通知缓存和客户端。因此服务器必须通过某种方式告知客户端缓存已经被更新。服务器会提供<code>过期时间</code>这个概念，告知客户端在此到期时间之前，资源是<code>新鲜的</code>，也就是未更改过的。在此到期时间的范围之外，资源已过时。<code>过期算法(Eviction algorithms)</code> 通常会将新资源优先于陈旧资源使用。</p>
<p>这里需要注意一下，过期的资源并不会被回收或忽略，当高速缓存接收到过期资源时，它会使用 <code>If-None-Match</code> 转发此请求，以检查它是否仍然有效。如果有效，服务器会返回 <code>304 Not Modified</code>响应头并且没有任何响应体，从而节省了一些带宽。</p>
<p>下面是使用共享缓存代理的过程</p>
<p>这个图应该比较好理解，只说一下 Age 的作用，Age 是 HTTP 响应标头告诉客户端源服务器在多久之前创建了响应，它的单位为<code>秒</code>，Age 标头通常接近于0，如果是0则可能是从源服务器获取的，如果不是表示可能是由代理服务器创建，那么 Age 的值表示的是<strong>缓存后的响应再次发起认证到认证完成的时间值</strong>。</p>
<p>缓存的有效性是由多个标头来共同决定的，而并非某一个标头来决定。如果指定了<code>Cache-control:max-age=N</code> ，那么缓存会保存 N 秒。如果这个通用标头不存在的话，则会检查是否存在 <code>Expires</code> 标头。如果 Exprires 标头存在，那么它的值减去 Date 标头的值就可以确定其有效性。最后，如果<code>max-age</code> 和 <code>expires</code> 都不存在，就去寻找 <code>Last-Modified</code> 标头，如果存在此标头，则高速缓存的有效性等于 Date 标头的值减去 Last-modified 标头的值除以10。</p>
<h3 id="缓存验证-1"><a href="#缓存验证-1" class="headerlink" title="缓存验证"></a><strong>缓存验证</strong></h3><p>当到达缓存资源的有效期时，将对其进行验证或再次获取。仅当服务器提供了<code>强验证器</code>或<code>弱验证器</code>时，才可以进行验证。</p>
<p>当用户按下重新加载按钮时，将触发重新验证。如果缓存的响应包含 <code>Cache-control：must-revalidate</code>标头，则在正常浏览下也会触发该事件。另一个因素是 高级 -&gt; 缓存首选项 面板中的缓存验证首选项。有一个选项可在每次加载文档时强制进行验证。</p>
<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>我们上面提到了强验证器和弱验证器，实现验证器功能的标头正式 Etag 的作用，这意味着 HTTP 用户代理（例如浏览器）不知道该字符串表示什么，并且无法预测其值。如果 Etag 标头是资源响应的一部分，则客户端可以在未来请求的标头中发出 <code>If-None-Match</code>，以验证缓存的资源。</p>
<p><code>Last-Modified</code>响应标头可以用作弱验证器，因为它只有1秒可以分辨的时间。如果响应中存在 <code>Last-Modified</code>标头，则客户端可以发出 <code>If-Modified-Since</code>请求标头来验证缓存资源。（关于 Etag 更多我们会在条件请求介绍）</p>
<h4 id="避免碰撞"><a href="#避免碰撞" class="headerlink" title="避免碰撞"></a>避免碰撞</h4><p>通过使用 Etag 和 If-Match 标头，你可以检测避免碰撞。</p>
<p>例如，在编辑 MDN 时，将对当前 Wiki 内容进行哈希处理并将其放入响应中的 Etag 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<p>当将更改保存到 Wiki 页面（发布数据）时，POST 请求将包含 If-Match 标头，其中包含 Etag 值以检查有效性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<p>如果哈希值不匹配，则表示文档已在中间进行了编辑，并返回 <code>412 Precondition Failed</code>错误。</p>
<h4 id="缓存未占用资源"><a href="#缓存未占用资源" class="headerlink" title="缓存未占用资源"></a>缓存未占用资源</h4><p>Etag 标头的另一个典型用法是缓存未更改的资源，如果用户再次访问给定的 URL（已设置Etag），并且该 URL过时，则客户端将在 If-None-Match 标头字段中发送其 Etag 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<p>服务器将客户端的 Etag（通过 If-None-Match 发送）与 Etag 进行比较，以获取其当前资源版本，如果两个值都匹配（即资源未更改），则服务器会发回 <code>304 Not Modified</code>状态，没有主体，它告诉客户端响应的缓存仍然可以使用。</p>
<h2 id="HTTP-CROS-跨域"><a href="#HTTP-CROS-跨域" class="headerlink" title="HTTP CROS 跨域"></a><strong>HTTP CROS 跨域</strong></h2><p>CROS 的全称是 <code>Cross-Origin Resource Sharing(CROS)</code>，中文译为 <code>跨域资源共享</code>，它是一种机制。是一种什么机制呢？它是一种让运行在一个<code>域(origin)</code>上的 Web 应用被准许访问来自不同源服务器上指定资源的机制。在搞懂这个机制前，你需要线了解什么是 <code>域(origin)</code></p>
<h3 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a><strong>Origin</strong></h3><p>Web 概念中<code>域(Origin)</code> 的内容由<code>scheme(protocol) - 协议</code>，<code>host(domain) - 主机</code>和用于访问它的 URL <code>port - 端口</code>定义。仅仅当 scheme 、host、port 都匹配时，两个对象才有相同的来源。这种协议相同，域名相同，端口相同的安全策略也被称为 <code>同源策略（Same Origin Policy)</code>。某些操作仅限于具有相同来源的内容，可以使用 CORS 取消此限制。</p>
<h3 id="跨域的特点"><a href="#跨域的特点" class="headerlink" title="跨域的特点"></a><strong>跨域的特点</strong></h3><ul>
<li>下面是跨域问题的例子，看看你是否清楚什么是跨域了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) http://example.com/app1/index.html</span><br><span class="line">(2) http://example.com/app2/index.html</span><br></pre></td></tr></table></figure>
<p>上面这两个 URL 是否具有跨域问题呢？</p>
<p>上面两个 URL 是不具有跨域问题的，因为这两个 URL 具有相同的<code>协议(scheme)</code>和<code>主机(host)</code></p>
<ul>
<li>那么下面这两个是否具有跨域问题呢？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://Example.com:80</span><br><span class="line">http://example.com</span><br></pre></td></tr></table></figure>
<p>这两个 URL 也不具有跨域问题，为什么不具有，端口不一样啊。其实它们两个端口是一样的。</p>
<p>或许你会认为这两个 URL 是不一样的，放心，关于一样不一样的论据我给你抛出来了</p>
<blockquote>
<p>协议和域名部分是不区分大小写的，但是路径部分则根据服务器平台而定。Windows 和 Mac OS X 系统是不区分大小写的，而采用UNIX和Linux系的服务器系统是区分大小写的，</p>
</blockquote>
<p>也就是说上面的 <code>Example.com</code> 和 <code>example.com</code> 其实是一个网址，并且由于两个地址具有相同的 scheme 和 host ，默认情况下服务器通过端口80传递 HTTP 内容，所以上面这两个地址也是相同的。</p>
<ul>
<li>下面这两个 URL 地址是否具有跨域问题？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/app1</span><br><span class="line">https://example.com/app2</span><br></pre></td></tr></table></figure>
<p>这两个 URL 的 scheme 不同，所以这两个 URL 具有跨域问题</p>
<ul>
<li>再看下面这三个 URL 是否具有跨域问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://www.example.com</span><br><span class="line">http://myapp.example.com</span><br></pre></td></tr></table></figure>
<p>这三个 URL 也是具有跨域问题的，因为它们隶属于不通服务器的主机 host。</p>
<ul>
<li>下面这两个 URL 是否具有跨域问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com:8080</span><br></pre></td></tr></table></figure>
<p>这两个 URL 也是具有跨域问题，因为这两个 URL 的默认端口不一样。</p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><strong>同源策略</strong></h3><p>处于安全的因素，浏览器限制了从脚本发起跨域的 HTTP 请求。<code>XMLHttpRequest</code> 和其他 <code>Fetch 接口</code> 会遵循 <code>同源策略(same-origin policy)</code>。也就是说使用这些 API 的应用程序想要请求相同的资源，那么他们应该具有相同的来源，除非来自其他来源的响应包括正确的 CORS 标头也可以。</p>
<p>同源策略是一种很重要的安全策略，它限制了从一个来源加载的文档或脚本如何与另一个来源的资源进行交互。它有助于隔离潜在的恶意文档，减少可能的攻击媒介。</p>
<p>我们上面提到，如果两个 URL 具有相同的协议、主机和端口号（如果指定）的话，那么两个 URL 具有相同的来源。下面有一些实例，你判断一下是不是具有相同的来源</p>
<p>目标来源 <code>http://store.company.com/dir/page.html</code></p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>现在我带你认识了两遍不同的源，现在你应该知道如何区分两个 URL 是否属于同一来源了吧！</p>
<p>好，你现在知道了什么是跨域问题，现在我要问你，哪些请求会产生跨域请求呢？这是我们下面要讨论的问题</p>
<h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a><strong>跨域请求</strong></h3><p>跨域请求可能会从下面这几种请求中发出：</p>
<ol>
<li>调用 <code>XMLHttpRequest</code> 或者 <code>Fetch</code> api。</li>
</ol>
<p>XMLHttpRequest 是什么？（我是后端程序员，前端不太懂，简单解释下，如果解释的不好，还请前端大佬们不要胖揍我）</p>
<p>所有的现代浏览器都有一个内置的 <code>XMLHttpReqeust</code> 对象，这个对象可以用于从服务器请求数据。</p>
<p>XMLHttpReqeust 对于开发人员来说很重要，XMLHttpReqeust 对象可以用来做下面这些事情</p>
<ul>
<li>更新网页无需重新刷新页面</li>
<li>页面加载后从服务器请求数据</li>
<li>页面加载后从服务端获取数据</li>
<li>在后台将数据发送到服务器</li>
</ul>
<p>使用 XMLHttpRequest(XHR) 对象与服务器进行交互，你可以从 URL 检索数据从而不必刷新整个页面，这使网页可以更新页面的一部分，而不会中断用户的操作。XMLHttpRequest 在 <code>AJAX</code> 异步编程中使用很广泛。</p>
<p>再来说一下 Fetch API 是什么，Fetch 提供了请求和响应对象（以及其他网络请求）的通用定义。它还提供了相关概念的定义，例如 CORS 和 HTTP Origin 头语义，并在其他地方取代了它们各自的定义。</p>
<ol>
<li>Web 字体（用于 CSS 中@ font-face中的跨域字体使用），以便服务器可以部署 TrueType 字体，这些字体只能由允许跨站点加载和使用的网站使用。</li>
<li>WebGL 纹理</li>
<li>使用 <code>drawImage()</code> 绘制到画布上的图像/视频帧</li>
<li>图片的 CSS 形状</li>
</ol>
<h3 id="跨域功能概述"><a href="#跨域功能概述" class="headerlink" title="跨域功能概述"></a><strong>跨域功能概述</strong></h3><p>跨域资源共享标准通过添加新的 HTTP 标头来工作，这些标头允许服务器描述允许哪些来源从 Web 浏览器读取信息。另外，对于可能导致服务器数据产生副作用的 HTTP 请求方法（尤其是 GET 或者具有某些 MIME 类型 POST 方法以外 HTTP 方法），该规范要求浏览器<code>预检</code>请求，使用 HTTP OPTIONS 请求方法从服务器请求受支持的方法，然后在服务器<code>批准</code>后发送实际请求。服务器还可以通知客户端是否应与请求一起发送<code>凭据</code>（例如 Cookies 和 HTTP 身份验证）。</p>
<blockquote>
<p>注意：CORS 故障会导致错误，但是出于安全原因，该错误的详细信息不适用于 JavaScript。所有代码都知道发生了错误。确定具体出问题的唯一方法是查看浏览器的控制台以获取详细信息。</p>
</blockquote>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h3><p>下面我会和大家探讨三种方案，这些方案都演示了跨域资源共享的工作方式。所有这些示例都使用XMLHttpRequest，它可以在任何支持的浏览器中发出跨站点请求。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>一些请求不会触发 <code>CORS预检</code>（关于预检我们后面再介绍）。<code>简单请求</code>是满足一下所有条件的请求</p>
<ul>
<li><p>允许以下的方法：<code>GET</code>、<code>HEAD</code>和 <code>POST</code></p>
</li>
<li><p>除了由用户代理自动设置的标头（例如 Connection、User-Agent 或者在 Fetch 规范中定义为禁止标头名称的其他标头）外，唯一允许手动设置的标头是那些 Fetch 规范将其定义为 <code>CORS安全列出的请求标头</code> ，它们是：</p>
</li>
<li><ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type（下面会介绍）</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li><p>Content-Type 标头的唯一允许的值是</p>
</li>
<li><ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li><p>没有在请求中使用的任何 XMLHttpRequestUpload 对象上注册事件侦听器；这些可以使用XMLHttpRequest.upload 属性进行访问。</p>
</li>
<li><p>请求中未使用 ReadableStream对象。</p>
<p>例如，假定 web 内容 <code>https://foo.example</code> 想要获取 <code>https://bar.other</code> 域的资源，那么 JavaScript 中的代码可能会像下面这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">const url = &apos;https://bar.other/resources/public-data/&apos;;</span><br><span class="line">   </span><br><span class="line">xhr.open(&apos;GET&apos;, url);</span><br><span class="line">xhr.onreadystatechange = someHandler;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这使用 CORS 标头来处理特权，从而在客户端和服务器之间执行某种转换。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>让我们看看在这种情况下浏览器将发送到服务器的内容，并让我们看看服务器如何响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/public-data/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Origin: https://foo.example</span><br></pre></td></tr></table></figure>
<p>注意请求的标头 Origin ，它表明调用来自于 <code>https://foo.example</code>。让我们看看服务器是如何响应的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application/xml</span><br><span class="line"></span><br><span class="line">[…XML Data…]</span><br></pre></td></tr></table></figure>
<p>服务端发送 <code>Access-Control-Allow-Origin</code> 作为响应。使用 <code>Origin</code> 标头和  <code>Access-Control-Allow-Origin</code> 展示了最简单的访问控制协议。在这个事例中，服务端使用<code>Access-Control-Allow-Origin</code> 作为响应，也就说明该资源可以被任何域访问。</p>
<p>如果位于<code>https://bar.other</code>的资源所有者希望将对资源的访问限制为仅来自<code>https://foo.example</code>的请求，他们应该发送如下响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br></pre></td></tr></table></figure>
<p>现在除了 <code>https://foo.example</code> 之外的任何域都无法以跨域方式访问到 <code>https://bar.other</code>的资源。</p>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>和上面探讨的简单请求不同，<code>预检</code>请求首先通过 <code>OPTIONS</code> 方法向另一个域上的资源发送 HTTP 请求，用来确定实际请求是否可以安全的发送。跨站点这样被<code>预检</code>，因为它们可能会影响用户数据。</p>
<p>下面是一个预检事例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, &apos;https://bar.other/resources/post-here/&apos;);</span><br><span class="line">xhr.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;);</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;);</span><br><span class="line">xhr.onreadystatechange = handler;</span><br><span class="line">xhr.send(&apos;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的事例创建了一个 XML 请求体用来和 POST 请求一起发送。此外，设置了非标准请求头 <code>X-PINGOTHER</code> ，这个标头不是 HTTP/1.1 的一部分，但通常对 Web 程序很有用。由于请求的 <code>Content-Type</code> 使用 <code>application/xml</code>，并且设置了自定义标头，因此该请求被<code>预检</code>。如下图所示</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<blockquote>
<p>如下所述，实际的 POST 请求不包含 Access-Control-Request- * 标头；只有 OPTIONS 请求才需要它们。</p>
</blockquote>
<p>下面我们来看一下完整的客户端/服务器交互，首先是预检请求/响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Origin: http://foo.example</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">Vary: Accept-Encoding, Origin</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>上面的1 -11 行代表预检请求，预检请求使用 <code>OPYIIONS</code> 方法，浏览器根据上面的 JavaScript 代码段所使用的请求参数确定是否需要发送此请求，以便服务器可以响应是否可以使用实际请求参数发送请求。OPTIONS 是一种 HTTP / 1.1方法，用于确定来自服务器的更多信息，并且是一种安全的方法，这意味着它不能用于更改资源。请注意，与 OPTIONS 请求一起，还发送了另外两个请求标头（分别是第9行和第10行）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>
<p><code>Access-Control-Request-Method</code> 标头作为预检请求的一部分通知服务器，当发送实际请求时，将使用<code>POST</code> 请求方法发送该请求。</p>
<p><code>Access-Control-Request-Headers</code> 标头通知服务器，当发送请求时，它将与X-PINGOTHER 和 Content-Type 自定义标头一起发送。服务器可以确定这种情况下是否接受请求。</p>
<p>下面的 1 - 11行是服务器发回的响应，表示<code>POST</code> 请求和 <code>X-PINGOTHER</code> 是可以接受的，我们着重看一下下面这几行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://foo.example</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
<p>服务器完成响应表明源 <code>http://foo.example</code> 是可以接受的 URL，能够允许 <code>POST、GET、OPTIONS</code> 进行请求，允许自定义标头 <code>X-PINGOTHER, Content-Type</code>。最后，<code>Access-Control-Max-Age</code> 以秒为单位给出一个值，这个值表示对预检请求的响应可以缓存多长时间，在此期间内无需发送其他预检请求。</p>
<p>完成预检请求后，将发送实际请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST /resources/post-here/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-PINGOTHER: pingpong</span><br><span class="line">Content-Type: text/xml; charset=UTF-8</span><br><span class="line">Referer: https://foo.example/examples/preflightInvocation.html</span><br><span class="line">Content-Length: 55</span><br><span class="line">Origin: https://foo.example</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:40 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">Vary: Accept-Encoding, Origin</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 235</span><br><span class="line">Keep-Alive: timeout=2, max=99</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">[Some GZIP&apos;d payload]</span><br></pre></td></tr></table></figure>
<p>正式响应中很多标头我们在之前的文章已经探讨过了，本篇不再做详细的介绍，读者可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;mid=2247485214&amp;idx=1&amp;sn=2cec80cfd606f4b4444db974246ee75e&amp;chksm=fc45faedcb3273fb48dd5a16e4c375680adb8c6e59a52455f14ac2c2e0afda0c9265ff544044&amp;token=347964925&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"><strong>你还在为 HTTP 的这些概念头疼吗？</strong></a> 查阅</p>
<h4 id="带凭证的请求"><a href="#带凭证的请求" class="headerlink" title="带凭证的请求"></a>带凭证的请求</h4><p>XMLHttpRequest 或 Fetch 和 CORS 最有趣的功能就是能够发出知道 HTTP Cookie 和 HTTP 身份验证的 <code>凭证</code> 请求。默认情况下，在跨站点 XMLHttpRequest 或 Fetch 调用中，浏览器将不发送凭据。调用 XMLHttpRequest对象或 Request 构造函数时必须设置一个特定的标志。</p>
<p>在下面这个例子中，最初从 <code>http://foo.example</code> 加载的内容对设置了 Cookies 的<code>http://bar.other</code> 上的资源进行了简单的 GET 请求， foo.example 上可能的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const invocation = new XMLHttpRequest();</span><br><span class="line">const url = &apos;http://bar.other/resources/credentialed-content/&apos;;</span><br><span class="line">    </span><br><span class="line">function callOtherDomain() &#123;</span><br><span class="line">  if (invocation) &#123;</span><br><span class="line">    invocation.open(&apos;GET&apos;, url, true);</span><br><span class="line">    invocation.withCredentials = true;</span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行显示 XMLHttpRequest 上的标志，必须设置该标志才能使用 Cookie 进行调用。默认情况下，调用是不在使用 Cookie 的情况下进行的。由于这是一个简单的 GET 请求，因此不会进行预检，但是浏览器将拒绝任何没有 Access-Control-Allow-Credentials 的响应：标头为true，指的是响应不会返回 web 页面的内容。</p>
<p>上面的请求用下图可以表示</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这是客户端和服务器之间的示例交换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/access-control-with-credentials/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://foo.example/examples/credential.html</span><br><span class="line">Origin: http://foo.example</span><br><span class="line">Cookie: pageAccess=2</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:34:52 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</span><br><span class="line">Vary: Accept-Encoding, Origin</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 106</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[text/plain payload]</span><br></pre></td></tr></table></figure>
<p>上面第10行包含指向<code>http://bar.other</code> 上的内容 Cookie，但是如果 bar.other 没有以<code>Access-Control-Allow-Credentials:true</code> 响应（下面第五行），响应将被忽略，并且不能使用网站返回的内容。</p>
<p><strong>请求凭证和通配符</strong></p>
<p>当回应凭证请求时，服务器必须在 <code>Access-Control-Allow-Credentials</code> 中指定一个来源，而不能直接写<code>*</code> 通配符</p>
<p>因为上面示例代码中的请求标头包含 Cookie 标头，如果 <code>Access-Control-Allow-Credentials</code> 中是指定的通配符 <code>*</code> 的话，请求会失败。</p>
<p>注意上面示例中的 <code>Set-Cookie</code> 响应标头还设置了另外一个值，如果发生故障，将引发异常（取决于所使用的API）。</p>
<h3 id="HTTP-响应标头"><a href="#HTTP-响应标头" class="headerlink" title="HTTP 响应标头"></a><strong>HTTP 响应标头</strong></h3><p>下面会列出一些服务器跨域共享规范定义的 HTTP 标头，上面简单概述了一下，现在一起来认识一下，主要会介绍下面这些</p>
<ul>
<li>Access-Control-Allow-Origin</li>
<li>Access-Control-Allow-Credentials</li>
<li>Access-Control-Allow-Headers</li>
<li>Access-Control-Allow-Methods</li>
<li>Access-Control-Expose-Headers</li>
<li>Access-Control-Max-Age</li>
<li>Access-Control-Request-Headers</li>
<li>Access-Control-Request-Method</li>
<li>Origin</li>
</ul>
<h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h4><p><code>Access-Control-Allow-Origin</code> 是 HTTP 响应标头，指示响应是否能够和给定的源共享资源。Access-Control-Allow-Origin 指定单个资源会告诉浏览器允许指定来源访问资源。对于没有凭据的请求 <code>*</code>通配符，告诉浏览器允许任何源访问资源。</p>
<p>例如，如果要允许源 <code>https://mozilla.org</code> 的代码访问资源，可以使用如下的指定方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://mozilla.org</span><br><span class="line">Vary: Origin</span><br></pre></td></tr></table></figure>
<p>如果服务器指定单个来源而不是<code>*</code>通配符，则服务器还应在 Vary 响应标头中包含该来源。</p>
<h4 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h4><p><code>Access-Control-Allow-Credentials</code> 是 HTTP 的响应标头，这个标头告诉浏览器，当包含凭证请求（Request.credentials）时是否将响应公开给前端 JavaScript 代码。</p>
<p>这时候你会问到 <code>Request.credentials</code> 是什么玩意？不要着急，来给你看一下，首先来看 Request 是什么玩意，</p>
<p>实际上，Request 是 Fetch API 的一类接口代表着资源请求。一般创建 Request 对象有两种方式</p>
<ul>
<li>使用 Request() 构造函数创建一个 Request 对象</li>
<li>还可以通过 FetchEvent.request api 操作来创建</li>
</ul>
<p>再来说下 Request.credentials 是什么意思，Request 接口的凭据只读属性指示在跨域请求的情况下，用户代理是否应从其他域发送 cookie。（其他 Request 对象的方法详见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request）" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Request）</a></p>
<p>当发送的是凭证模式的请求包含 （Request.credentials）时，如果 Access-Control-Allow-Credentials 值为 true，浏览器将仅向前端 JavaScript 代码公开响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>凭证一般包括 <strong>cookie、认证头和 TLS 客户端证书</strong></p>
<blockquote>
<p>当用作对预检请求响应的一部分时，这表明是否可以使用凭据发出实际请求。注意简单的<code>GET</code> 请求不会进行预检。</p>
</blockquote>
<p>可以参考一个实际的例子 <a href="https://www.jianshu.com/p/ea485e5665b3" target="_blank" rel="noopener">https://www.jianshu.com/p/ea485e5665b3</a></p>
<h4 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h4><p><code>Access-Control-Allow-Headers</code> 是一个响应标头，这个标头用来响应预检请求，它发出实际请求时可以使用哪些HTTP标头。</p>
<p><strong>示例</strong></p>
<ul>
<li>自定义标头</li>
</ul>
<p>这是 Access-Control-Allow-Headers 标头的示例。它表明除了像 CROS 安全列出的请求标头外，对服务器的 CROS 请求还支持名为 <code>X-Custom-Header</code> 的自定义标头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure>
<ul>
<li>多个标头</li>
</ul>
<p>这个例子展示了 Access-Control-Allow-Headers 如何使用多个标头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: X-Custom-Header, Upgrade-Insecure-Requests</span><br></pre></td></tr></table></figure>
<ul>
<li>绕过其他限制</li>
</ul>
<p>尽管始终允许使用 CORS 安全列出的请求标头，并且通常不需要在 Access-Control-Allow-Headers 中列出这些标头，但是无论如何列出它们都将绕开适用的其他限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: Accept</span><br></pre></td></tr></table></figure>
<p>这里你可能会有疑问，哪些是 CORS 列出的安全标头？（别嫌累，就是这么麻烦）</p>
<p>有下面这些 <strong>Accep、Accept-Language、Content-Language、Content-Type</strong> ，当且仅当包含这些标头时，无需在 CORS 上下文中发送预检请求。</p>
<h4 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a>Access-Control-Allow-Methods</h4><p><code>Access-Control-Allow-Methods</code> 也是响应标头，它指定了哪些访问资源的方法可以使用预检请求。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Methods: *</span><br></pre></td></tr></table></figure>
<h4 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a>Access-Control-Expose-Headers</h4><p>Access-Control-Expose-Headers 响应标头表明哪些标头可以作为响应的一部分公开。默认情况下，仅公开6个CORS安全列出的响应标头，分别是</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>如果希望客户端能够访问其他标头，则必须使用 Access-Control-Expose-Headers 标头列出它们。下面是示例</p>
<p>要公开非 CORS 安全列出的请求标头，可以像如下这样指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: Content-Length</span><br></pre></td></tr></table></figure>
<p>要另外公开自定义标头，例如 X-Kuma-Revision，可以指定多个标头，并用逗号分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision</span><br></pre></td></tr></table></figure>
<p>在不是凭证请求中，你还可以使用通配符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: *</span><br></pre></td></tr></table></figure>
<p>但是，这不会通配 <code>Authorization</code> 标头，因此如果需要公开它，则需要明确列出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: *, Authorization</span><br></pre></td></tr></table></figure>
<h4 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h4><p>Access-Control-Max-Age 响应头表示预检请求的结果可以缓存多长时间，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: 600</span><br></pre></td></tr></table></figure>
<p>表示预检请求可以缓存10分钟</p>
<h4 id="Access-Control-Request-Headers"><a href="#Access-Control-Request-Headers" class="headerlink" title="Access-Control-Request-Headers"></a>Access-Control-Request-Headers</h4><p>浏览器在发出预检请求时使用 Access-Control-Request-Headers 请求标头，使服务器知道在发出实际请求时客户端可能发送的 HTTP 标头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>
<h4 id="Access-Control-Request-Method"><a href="#Access-Control-Request-Method" class="headerlink" title="Access-Control-Request-Method"></a>Access-Control-Request-Method</h4><p>同样的，Access-Control-Request-Method 响应标头告诉服务器发出预检请求时将使用那种 HTTP 方法。此标头是必需的，<strong>因为预检请求始终是 OPTIONS</strong>，并且使用的方法与实际请求不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br></pre></td></tr></table></figure>
<h4 id="Origin-1"><a href="#Origin-1" class="headerlink" title="Origin"></a>Origin</h4><p>Origin 请求标头表明匹配的来源，它不包含任何信息，仅仅包含服务器名称，它与 CORS 请求以及 POST 请求一起发送，它类似于 <code>Referer</code> 标头，但与此标头不同，它没有公开整个路径。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: https://developer.mozilla.org</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-条件请求"><a href="#HTTP-条件请求" class="headerlink" title="HTTP 条件请求"></a><strong>HTTP 条件请求</strong></h2><p>HTTP 具有条件请求的概念，通过比较资源更新生成的值与验证器的值进行比较，来确定资源是否进行过更新。这样的请求对于验证缓存的内容、条件请求、验证资源的完整性来说非常重要。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>HTTP 条件请求是根据特定标头的值执行不同的请求，这些标头定义了一个前提条件，如果前提条件匹配或不匹配，则请求的结果将有所不同。</p>
<ul>
<li>对于 <code>安全</code> 的方法，像是 <code>GET</code>、用于请求文档的资源，仅当条件请求的条件满足时发回文档资源，所以，这种方式可以节约带宽。</li>
</ul>
<blockquote>
<p>什么是安全的方法，对于 HTTP 来说，<strong>安全的方法是不会改变服务器状态的方法</strong>，换句话说，如果方法只是只读操作，那么它肯定是安全的方法，比如说 GET 请求，它肯定是安全的方法，因为它只是请求资源。几种常见的方法肯定是安全的，它们是 <strong>GET、HEAD和 OPTIONS</strong>。所有安全的方法都是<code>幂等的</code>（这他妈幂等又是啥意思？）但不是所有幂等的方法都是安全的，例如 PUT 和 DELETE 都是幂等的，但不安全。</p>
<p>幂等性：如果相同的客户端发起一次或者多次 HTTP 请求会得到相同的结果，则说明 HTTP 是幂等的。（我们这次不深究幂等性）</p>
</blockquote>
<ul>
<li>对于 <code>非安全</code> 的方法，像是 PUT，只有原始文档与服务器上存储的资源相同时，才可以使用条件请求来传输文档。（PUT 方法通常用来传输文件，就像 FTP 协议的文件上传一样）</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><p>所有的条件请求都会尝试检查服务器上存储的资源是否与某个特定版本的资源相匹配。为了满足这种情况，条件请求需要指示资源的版本。由于无法和整个文件逐个字符进行比较，因此需要把整个文件描绘成一个值，然后把此值和服务器上的资源进行比较，这种方式称为比较器，比较器有两个条件</p>
<ul>
<li>文档的最后修改日期</li>
<li>一个不透明的字符串，用于唯一标识每个版本，称为实体标签或 <code>Etag</code>。</li>
</ul>
<p>比较两个资源是否时相同的版本有些复杂，根据上下文，有两种相等性检查</p>
<ul>
<li>当期望的是字节对字节进行比较时，例如在恢复下载时，使用<code>强 Etag</code>进行验证</li>
<li>当用户代理需要比较两个资源是否具有相同的内容时，使用<code>若 Etag</code> 进行验证</li>
</ul>
<p>HTTP 协议默认使用 <code>强验证</code>，它指定何时进行弱验证</p>
<h4 id="强验证"><a href="#强验证" class="headerlink" title="强验证"></a>强验证</h4><p>强验证保证的是<code>字节</code> 级别的验证，严格的验证非常严格，可能在服务器级别难以保证，但是它能够保证任何时候都不会丢失数据，但这种验证丢失性能。</p>
<p>要使用 <code>Last-Modified</code> 很难实现强验证，通常，这是通过使用带有资源的 MD5 哈希值的<code>Etag</code> 来完成的。</p>
<h4 id="弱验证"><a href="#弱验证" class="headerlink" title="弱验证"></a>弱验证</h4><p>弱验证不同于强验证，因为如果内容相等，它将认为文档的两个版本相同，例如，一个页面与另一个页面的不同之处仅在于页脚的日期不同，因此该页面被认为与其他页面相同。而使用强验证时则被认为这两个版本是不同的。构建一个若验证的 Etag 系统可能会非常复杂，因为这需要了解每个页面元素的重要性，但是对于优化缓存性能非常有用。</p>
<p>下面介绍一下 Etag 如何实现强弱验证。</p>
<p>Etag 响应头是<code>特定版本</code>的标识，它能够使缓存变得更高效并能够节省带宽，因为如果缓存内容未发生变更，Web 服务器则不需要重新发送完整的响应。除此之外，Etag 能够防止资源同时更新互相覆盖。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>如果给定 URL 上的资源发生变更，必须生成一个新的 <code>Etag</code> 值，通过比较它们可以确定资源的两个表示形式是否相同。</p>
<p>Etag 值有两种，一种是强 Etag，一种是弱 Etag；</p>
<ul>
<li>强 Etag 值，无论实体发生多么细微的变化都会改变其值，一般的表示如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>弱 Etag 值，弱 Etag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 Etag 值。这时，会在字段值最开始处附加 W/。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: W/&quot;0815&quot;</span><br></pre></td></tr></table></figure>
<p>下面就来具体探讨一下条件请求的标头和 Etag 的关系</p>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a><strong>条件请求</strong></h3><p>条件请求主要包含的标头如下</p>
<ul>
<li>If-Match</li>
<li>If-None-Match</li>
<li>If-Modified-Since</li>
<li>If-Unmodified-Since</li>
<li>If-Range</li>
</ul>
<h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>对于 <code>GET</code> 和 <code>POST</code> 方法，服务器仅在与列出的 <code>Etag（响应标头）</code> 之一匹配时才返回请求的资源。这里又多了一个新词 <code>Etag</code>，我们稍后再说 Etag 的用法。对于像是 <code>PUT</code>和其他非安全的方法，在这种情况下，它仅仅将上传资源。</p>
<p>下面是两种常见的案例</p>
<ul>
<li>对于 <code>GET</code> 和 <code>POST</code> 方法，会结合使用 <code>Range</code> 标头，它可以确保新发送请求的范围与上一个请求的资源相同，如果不匹配的话，会返回 <code>416</code> 响应。</li>
<li>对于其他方法，特别是 <code>PUT</code> 方法，<code>If-Match</code> 可以防止丢失更新，服务器会比对 If-Match 的字段值和资源的 Etag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。例如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;</span><br><span class="line">If-Match: *</span><br></pre></td></tr></table></figure>
<h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>条件请求，它与 <code>If-Match</code> 的作用相反，仅当 <code>If-None-Match</code> 的字段值与 <code>Etag</code> 值不一致时，可处理该请求。对于<code>GET</code> 和 <code>HEAD</code> ，仅当服务器没有与给定资源匹配的 <code>Etag</code> 时，服务器将返回 <code>200 OK</code>作为响应。对于其他方法，仅当最终现有资源的 Etag 与列出的任何值都不匹配时，才会处理请求。</p>
<p>当 <code>GET</code> 和 <code>POST</code> 发送的 <code>If-None-Match</code>与 <code>Etag</code> 匹配时，服务器会返回 <code>304</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;</span><br><span class="line">If-None-Match: W/&quot;67ab43&quot;, &quot;54ed21&quot;, &quot;7892dd&quot;</span><br><span class="line">If-None-Match: *</span><br></pre></td></tr></table></figure>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p><code>If-Modified-Since</code> 是 HTTP 条件请求的一部分，只有在给定日期之后，服务端修改了请求所需要的资源，才会返回 200 OK 的响应。如果在给定日期之后，服务端没有修改内容，响应会返回 <code>304</code> 并且不带任何响应体。If-Modified-Since 只能使用 <code>GET</code> 和 <code>HEAD</code>请求。</p>
<p>If-Modified-Since 与 If-None-Match 结合使用时，它将被忽略，除非服务器不支持 If-None-Match。一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这是格林威治标准时间。HTTP 日期始终以格林尼治标准时间表示，而不是本地时间。</p>
</blockquote>
<h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p><code>If-Range</code> 也是条件请求，如果满足条件（If-Range 的值和 Etag 值或者更新的日期时间一致），则会发出范围请求，否则将会返回全部资源。它的一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-Range: Wed, 21 Oct 2015 07:28:00 GMT</span><br><span class="line">If-Range: bfc13a64729c4290ef5b2c2730249c88ca92d82d</span><br></pre></td></tr></table></figure>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><p><code>If-Unmodified-Since</code> HTTP 请求标头也是一个条件请求，服务器只有在给定日期之后没有对其进行修改时，服务器才返回请求资源。如果在指定日期时间后发生了更新，则以状态码 <code>412 Precondition Failed</code> 作为响应返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<h3 id="条件请求示例"><a href="#条件请求示例" class="headerlink" title="条件请求示例"></a><strong>条件请求示例</strong></h3><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>条件请求最常见的示例就是更新缓存，如果缓存是空或没有缓存，则以<code>200 OK</code>的状态发送回请求的资源。如下图所示</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>客户端第一次发送请求没有，缓存为空并且没有条件请求，服务器在收到客户端请求后，设置验证器 <code>Last-Modified</code> 和 <code>Etag</code> 标签，并把这两个标签随着响应一起发送回客户端。</p>
<p>下一次客户端再发送相同的请求后，会直接从缓存中提取，只要缓存没有过期，就不会有任何新的请求到达服务器重新下载资源。但是，一旦缓存过期，客户端不会直接使用缓存的值，而是发出条件请求。验证器的值用作 <code>If-Modified-Since</code> 和<code>If-Match</code>标头的参数。</p>
<p>缓存过期后客户端重新发起请求，服务器收到请求后发现如果资源没有更改，服务器会发回 <code>304 Not Modified</code>响应，这使缓存再次刷新，并让客户端使用缓存的资源。尽管有一个响应/请求往返消耗一些资源，但是这比再次通过有线传输整个资源更有效。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>如果资源已经发生更改，则服务器仅使用新版本的资源返回 200 OK 响应，就像没有条件请求，并且客户端会重新使用新的资源，从这个角度来讲，<strong>缓存是条件请求的前置条件</strong>。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>HTTP 可以支持文件的部分下载，通过保留已获得的信息，此功能允许恢复先前的操作，从而节省带宽和时间。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>支持断点续传的服务器通过发送 <code>Accept-Ranges</code> 标头广播此消息，一旦发生这种情况，客户端可以通过发送缺少范围的 <code>Ranges</code>标头来恢复下载</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这里你可能有疑问 <code>Ranges</code> 和 <code>Content-Range</code>是什么，来解释一下</p>
<p><strong>Range</strong></p>
<p><code>Range</code> HTTP 请求标头指示服务器应返回文档指定部分的资源，可以一次请求一个 Range 来返回多个部分，服务器会将这些资源返回各个文档中。如果服务器成功返回，那么将返回 206 响应；如果 Range 范围无效，服务器返回<code>416 Range Not Satisfiable</code>错误；服务器还可以忽略 Range 标头，并且返回 200 作为响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=200-1000, 2000-6576, 19000-</span><br></pre></td></tr></table></figure>
<p>还有一种表示是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=0-499, -500</span><br></pre></td></tr></table></figure>
<p>它们分别表示请求前500个字节和最后500个字节，如果范围重叠，则服务器可能会拒绝该请求。</p>
<p><strong>Content-Range</strong></p>
<p>HTTP 的 Content-Range 响应标头是针对范围请求而设定的，返回响应时使用首部字段<code>Content-Range</code>，能够告知客户端响应实体的哪部分是符合客户端请求的，字段以字节为单位。它的一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 200-1000/67589</span><br></pre></td></tr></table></figure>
<p>上段代码表示从所有 <code>67589</code> 个字节中返回 <code>200-1000</code> 个字节的内容</p>
<p>那么上面的 <code>Content-Range</code>你也应该知道是什么意思了</p>
<p><code>断点续传</code>的原理比较简单，但是这种方式存在潜在的问题：如果在两次下载资源的期间进行了资源更新，那么获得的范围将对应于资源的两个不同版本，并且最终文档将被破坏。</p>
<p>为了阻止这种情况的出现，就会使用<code>条件请求</code>。对于范围来说，有两种方法可以做到这一点。一种方法是使用 <code>If-Modified-Since</code>和<code>If-Match</code>，如果前提条件失败，服务器将返回错误；然后客户端从头开始重新下载。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>即使此方法有效，当文档资源发生改变时，它也会添加额外的 <code>响应/请求</code> 交换。这会降低性能，并且 HTTP 具有特定的标头来避免这种情况 <code>If-Range</code>。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>该解决方案效率更高，但灵活性稍差一些，因为在这种情况下只能使用一个 Etag。</p>
<h4 id="通过乐观锁避免丢失更新"><a href="#通过乐观锁避免丢失更新" class="headerlink" title="通过乐观锁避免丢失更新"></a>通过乐观锁避免丢失更新</h4><p>Web 应用程序中最普遍的操作是资源更新。这在任何文件系统或应用程序中都很常见，但是任何允许存储远程资源的应用程序都需要这种机制。</p>
<p>使用 <code>put</code> 方法，你可以实现这一点，客户端首先读取原始文件对其进行修改，然后把它们发送到服务器。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>上面这种请求响应存在问题，一旦考虑到并发性，事情就会变得不准确。当客户端在本地修改资源打算重新发送之前，第二个客户端可以获取相同的资源并对资源进行修改操作，这样就会造成问题。当它们重新发送请求到服务器时，第一个客户端所做的修改将被第二次客户端的修改所覆盖，因为第二次客户端修改并不知道第一次客户端正在修改。资源提交并更新的一方不会传达给另外一方，所以要保留哪个客户的更改，将随着他们提交的速度而变化；这取决于客户端，服务器的性能，甚至取决于人工在客户端编辑文档的性能。例如下面这个流程</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>如果没有两个用户同时操作服务器，也就不存在这个问题。但是，现实情况是不可能只有单个用户出现的，所以为了规避或者避免这个问题，我们希望客户端资源在更新时进行提示或者修改被拒绝时收到通知。</p>
<p>条件请求允许实现乐观锁算法。这个概念是允许所有的客户端获取资源的副本，然后让他们在本地修改资源，并成功通过允许第一个客户端提交更新来控制并发，基于此服务端的后面版本的更新都将被拒绝。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这是使用 <code>If-Match</code> 或 <code>If-Unmodified-Since</code>标头实现的。如果 Etag 与原始文件不匹配，或者自获取以来已对文件进行了修改，则更改为拒绝更新，并显示<code>412 Precondition Failed</code>错误。</p>
<h2 id="HTTP-Cookies"><a href="#HTTP-Cookies" class="headerlink" title="HTTP Cookies"></a><strong>HTTP Cookies</strong></h2><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p>
<blockquote>
<p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p>
</blockquote>
<p>Cookie 主要用于下面三个目的</p>
<ul>
<li><code>会话管理</code></li>
</ul>
<p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p>
<ul>
<li><code>个性化</code></li>
</ul>
<p>用户偏好、主题或者其他设置</p>
<ul>
<li><code>追踪</code></li>
</ul>
<p>记录和分析用户行为</p>
<p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。客户端存储的现代 API 是 Web 存储 API（localStorage 和 sessionStorage）和 IndexedDB。</p>
<h3 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a><strong>创建 Cookie</strong></h3><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。可以指定到期日期或持续时间，之后将不再发送Cookie。此外，可以设置对特定域和路径的限制，从而限制 cookie 的发送位置。</p>
<h4 id="Set-Cookie-和-Cookie-标头"><a href="#Set-Cookie-和-Cookie-标头" class="headerlink" title="Set-Cookie 和 Cookie 标头"></a>Set-Cookie 和 Cookie 标头</h4><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<p>此标头告诉客户端存储 Cookie</p>
<p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 cookie 发送回服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/2.0</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<p>Cookie 主要分为三类，它们是 <code>会话Cookie</code>、<code>永久Cookie</code> 和 <code>Cookie的 Secure 和 HttpOnly 标记</code>，下面依次来介绍一下</p>
<h4 id="会话-Cookies"><a href="#会话-Cookies" class="headerlink" title="会话 Cookies"></a><strong>会话 Cookies</strong></h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定Expires 或 Max-Age 指令。这两个指令你看到这里应该比较熟悉了。</p>
<p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样</p>
<h4 id="永久性-Cookies"><a href="#永久性-Cookies" class="headerlink" title="永久性 Cookies"></a><strong>永久性 Cookies</strong></h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在特定日期（Expires）或特定时间长度（Max-Age）外过期。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>
<h4 id="Cookie的-Secure-和-HttpOnly-标记"><a href="#Cookie的-Secure-和-HttpOnly-标记" class="headerlink" title="Cookie的 Secure 和 HttpOnly 标记"></a><strong>Cookie的 Secure 和 HttpOnly 标记</strong></h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p>
<p><strong>HttpOnly 的作用</strong></p>
<ul>
<li>会话 cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 cookie  信息，造成用户cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</li>
<li>HttpOnly 是微软对 cookie 做的扩展，该值指定 cookie 是否可通过客户端脚本访问。</li>
<li>如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</li>
</ul>
<h3 id="Cookie-的作用域"><a href="#Cookie-的作用域" class="headerlink" title="Cookie 的作用域"></a><strong>Cookie 的作用域</strong></h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p>
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/docs</span><br><span class="line">/docs/Web/</span><br><span class="line">/docs/Web/HTTP</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/Mermaid-实用教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/Mermaid-实用教程/" itemprop="url">
                  Mermaid 实用教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:40:12" itemprop="dateCreated datePublished" datetime="2020-02-04T21:40:12+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/mermaid/" itemprop="url" rel="index"><span itemprop="name">mermaid</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p><a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://github.com/knsv/mermaid" target="_blank" rel="noopener">Github地址</a></p>
<p>语句末尾分号是可选的。<code>%%</code> 行注释。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="图表方向"><a href="#图表方向" class="headerlink" title="图表方向"></a>图表方向</h3><p>Mermaid 支持多种图表的方向，语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph 方向描述</span><br><span class="line">    图表中的其他语句...</span><br></pre></td></tr></table></figure>
<p>其中“方向描述”为</p>
<table>
<thead>
<tr>
<th>用词</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TB</td>
<td>从上到下</td>
</tr>
<tr>
<td>BT</td>
<td>从下到上</td>
</tr>
<tr>
<td>RL</td>
<td>从右到左</td>
</tr>
<tr>
<td>LR</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
<h3 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h3><p>即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid 中每个节点都有一个 id，以及节点的文字。</p>
<table>
<thead>
<tr>
<th>表述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id[文字]</code></td>
<td>矩形节点</td>
</tr>
<tr>
<td><code>id(文字)</code></td>
<td>圆角矩形节点</td>
</tr>
<tr>
<td><code>id((文字))</code></td>
<td>圆形节点</td>
</tr>
<tr>
<td><code>id&gt;文字]</code></td>
<td>右向旗帜状节点</td>
</tr>
<tr>
<td><code>id{文字}</code></td>
<td>菱形节点</td>
</tr>
</tbody>
</table>
<p>需要注意的是，如果节点的文字中包含标点符号，需要时用双引号包裹起来。<br>另外如果希望在文字中使用换行，请使用<br>替换换行</p>
<h3 id="节点间的连线"><a href="#节点间的连线" class="headerlink" title="节点间的连线"></a>节点间的连线</h3><table>
<thead>
<tr>
<th>表述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>添加尾部箭头</td>
</tr>
<tr>
<td><code>-</code></td>
<td>不添加尾部箭头</td>
</tr>
<tr>
<td><code>--</code></td>
<td>单线</td>
</tr>
<tr>
<td><code>--text--</code></td>
<td>单线上加文字</td>
</tr>
<tr>
<td><code>==</code></td>
<td>粗线</td>
</tr>
<tr>
<td><code>==text==</code></td>
<td>粗线加文字</td>
</tr>
<tr>
<td><code>-.-</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>-.text.-</code></td>
<td>虚线加文字</td>
</tr>
</tbody>
</table>
<h3 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h3><p>使用以下语法添加子图表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph 子图表名称</span><br><span class="line">    子图表中的描述语句...</span><br><span class="line">end123</span><br></pre></td></tr></table></figure>
<h3 id="对-font-awesome-的支持"><a href="#对-font-awesome-的支持" class="headerlink" title="对 font awesome 的支持"></a>对 font awesome 的支持</h3><p>使用 <code>fa: #图表名称#</code> 的语法添加 fontawesome。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/p2chh5tny9.png" alt="img"></p>
<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><ul>
<li>TB/TD - top bottom</li>
<li>BT - bottom top</li>
<li>RL - right left</li>
<li>LR - left right</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    Start --&gt; Stop</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/rpmt1s8371.png" alt="img"></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/k5j7lcf2he.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id[带文字节点]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/5oqklmc0rz.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id(圆角节点)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/m1l8w2srpz.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id((圆形节点))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/hzg2snr471.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id&gt;不对称节点]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/d28pv3fqx3.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id&#123;菱形节点&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/3v5j4fczmb.png" alt="img"></p>
<h2 id="连接线"><a href="#连接线" class="headerlink" title="连接线"></a>连接线</h2><h3 id="实线，箭头，无文字"><a href="#实线，箭头，无文字" class="headerlink" title="实线，箭头，无文字"></a>实线，箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/riv4kf6dae.png" alt="img"></p>
<h3 id="实线，无箭头，无文字"><a href="#实线，无箭头，无文字" class="headerlink" title="实线，无箭头，无文字"></a>实线，无箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/101km96s26.png" alt="img"></p>
<h3 id="实线，无箭头，文字"><a href="#实线，无箭头，文字" class="headerlink" title="实线，无箭头，文字"></a>实线，无箭头，文字</h3><p>前面<strong>两个</strong> <code>-</code>，后面<strong>三个</strong> <code>-</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A-- 文字 ---B</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--- |文字| B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/vofik65ttt.png" alt="img"></p>
<h3 id="实线，箭头，文字"><a href="#实线，箭头，文字" class="headerlink" title="实线，箭头，文字"></a>实线，箭头，文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A-- 文字 --&gt;B</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt; |文字| B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/hlimub9499.png" alt="img"></p>
<h3 id="虚线，箭头，无文字"><a href="#虚线，箭头，无文字" class="headerlink" title="虚线，箭头，无文字"></a>虚线，箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">   A-.-&gt;B;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/793ve0ql3.png" alt="img"></p>
<h3 id="虚线，箭头，文字"><a href="#虚线，箭头，文字" class="headerlink" title="虚线，箭头，文字"></a>虚线，箭头，文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   A-. text .-&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/famuxq0vqf.png" alt="img"></p>
<h3 id="大箭头，无文字"><a href="#大箭头，无文字" class="headerlink" title="大箭头，无文字"></a>大箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   A ==&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/0kdfo5h802.png" alt="img"></p>
<h3 id="大箭头，文字"><a href="#大箭头，文字" class="headerlink" title="大箭头，文字"></a>大箭头，文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   A == text ==&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/za7vuejw2d.png" alt="img"></p>
<h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>文字里用引号避免一些特殊字符的错误。比如矩形节点里有 <code>()</code> 时就无法渲染，所以加上引号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1[<span class="string">"This is the (text) in the box"</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/zcfze0sen3.png" alt="img"></p>
<h3 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h3><p>可以使用 HTML 中的实体字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">     A[<span class="string">"A double quote:#quot;"</span>] --&gt;B[<span class="string">"A dec char:#9829;"</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/fjcviqs56s.png" alt="img"></p>
<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/z3b2vu7vmf.png" alt="img"></p>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    linkStyle 0 stroke:#0ff,stroke-width:2px;</span><br><span class="line">    linkStyle 3 stroke:#ff3,stroke-width:4px;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/9mwcxke502.png" alt="img"></p>
<p>可以设置节点背景，边框颜色，粗细，实线还是虚线</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br><span class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px</span><br><span class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/deqsocy55j.png" alt="img"></p>
<h3 id="样式类"><a href="#样式类" class="headerlink" title="样式类"></a>样式类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br><span class="line"></span><br><span class="line">    %% 定义样式类</span><br><span class="line">    classDef className fill:#f9f,stroke:#333,stroke-width:4px;</span><br><span class="line"></span><br><span class="line">    %% 应用样式类，markdown里没效果</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">className</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/pdafavbwpk.png" alt="img"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDef default fill:#f9f,stroke:#333,stroke-width:4px;</span><br></pre></td></tr></table></figure>
<p>定义一个名为 <code>default</code> 的类，节点没有指定特定样式类时，将都会应用这个样式类。</p>
<h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>可以使用 <a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a> 图标。语法 <code>fa:icon class name</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">   B[<span class="string">"fa:fa-twitter for peace"</span>]</span><br><span class="line">   B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">   B--&gt;D(fa:fa-spinner);</span><br><span class="line">   B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/xdstdd6e2k.png" alt="img"></p>
<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right <span class="keyword">of</span> John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/180rjui5io.png" alt="img"></p>
<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><p>如果不显示声明，参与者将根据第一次出现的顺序排列，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/eleicv4hs1.png" alt="img"></p>
<p>第一条语句出现了两个参与者角色，而在这条语句中，Alice 在 John 之前，所以图中也是这个顺序。如果不想根据第一次出现的顺序来排，可以主动声明以定义顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant John</span><br><span class="line">    participant Alice</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/aq8hilfa2o.png" alt="img"></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>可以给角色写一个简短的别名以方便书写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A <span class="keyword">as</span> Alice</span><br><span class="line">    participant J <span class="keyword">as</span> John</span><br><span class="line">    A-&gt;&gt;J: Hello John, how are you?</span><br><span class="line">    J-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/ys9jab2wqg.png" alt="img"></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息连线有六种样式。</p>
<p>有<strong>一个</strong><code>-</code>是实线，<strong>两个</strong><code>-</code>是虚线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    A-&gt;B: 无箭头实线</span><br><span class="line">    A--&gt;B: 无箭头虚线(点线)</span><br><span class="line">    A-&gt;&gt;B: 有箭头实线</span><br><span class="line">    A--&gt;&gt;B: 有箭头实线</span><br><span class="line">    A-x B: 有箭头实线，加上叉</span><br><span class="line">    A--x B: 有箭头虚线，加上叉</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/7qplows8g4.png" alt="img"></p>
<h2 id="活动期"><a href="#活动期" class="headerlink" title="活动期"></a>活动期</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    %% activate 角色名 表示激活控制焦点</span><br><span class="line">    activate John</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    %% deactivate 角色名 表示控制焦点结束</span><br><span class="line">    deactivate John</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/jx85ho8ny2.png" alt="img"></p>
<p>使用 <code>+/-</code> 的更方便的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;+John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;-Alice: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/2q1cxx79gd.png" alt="img"></p>
<p>可以嵌套：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;+John: Hello John, how are you?</span><br><span class="line">    Alice-&gt;&gt;+John: John, can you hear me?</span><br><span class="line">    John--&gt;&gt;-Alice: Hi Alice, I can hear you!</span><br><span class="line">    John--&gt;&gt;-Alice: I feel great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/jee37p2zzs.png" alt="img"></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>语法：Note [ right of | left of | over ] [Actor]。</p>
<table>
<thead>
<tr>
<th>表述</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>right of</td>
<td>右侧</td>
</tr>
<tr>
<td>left of</td>
<td>左侧</td>
</tr>
<tr>
<td>over</td>
<td>在当中，可以横跨多个参与者</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant John</span><br><span class="line">    Note right <span class="keyword">of</span> John: Text <span class="keyword">in</span> note</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/vks6zmd1s5.png" alt="img"></p>
<p>over 可用于单独一个角色上，也可以用于相邻两个角色间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    Note over Alice,<span class="attr">John</span>: A typical interaction</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/5b8q8sacis.png" alt="img"></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loop Loop text</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    %% loop 后跟循环体说明文字</span><br><span class="line">    loop Every minute</span><br><span class="line">        John--&gt;Alice: Great!</span><br><span class="line">    %% 标记循环结束</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/4o0mms4o5z.png" alt="img"></p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alt Describing text</span><br><span class="line">... statements ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">... statements ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可选条件，比如在没有 else 分支的情况下使用，有点类似 java 中的 switch 的 default 分支，代表剩下所有情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opt Describing text</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">        Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    <span class="keyword">else</span> is well</span><br><span class="line">        Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">        Bob-&gt;&gt;Alice: Thanks <span class="keyword">for</span> asking</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/ruwizvoin8.png" alt="img"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/" itemprop="url">
                  使用Apache Bench和Gnuplot产生性能测试图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:13:26" itemprop="dateCreated datePublished" datetime="2020-02-04T21:13:26+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/性能测试/" itemprop="url" rel="index"><span itemprop="name">性能测试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener">Apache Beach</a> (ab)是Apache自带的一个性能测试工具，专门用来测试网站的性能， 不仅限于Apache web服务器。</p>
<p>它可以同时模拟多个并发请求，测试Web服务器的最大承载压力，同时也可以根据Apache Bench提供的测试结果对服务器性能参数进行调整。它可以记录测试数据，其它工具比如Gnuplot可以利用测试数据进行分析。它也可以提供一个summary，可以直观显示当前测试的web服务器的性能。</p>
<h2 id="安装ab"><a href="#安装ab" class="headerlink" title="安装ab"></a>安装ab</h2><p>  ab是Apache httpd的一部分。不同的发行版提供了不同的安装方法。<br>  比如在笔者使用的redhat 6.4上可以查看此工具在哪个包里：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#yum provides /usr/bin/ab</span></span><br><span class="line">......</span><br><span class="line">httpd-tools-2.2.15-30.el6.centos.x86_64 : Tools <span class="keyword">for</span> use with the Apache HTTP</span><br><span class="line">                                        : Server</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/ab</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>它被打包在httpd-tools包里，安装httpd-tools:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure>
<p>安装成功后查看帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -h</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ab</span><br></pre></td></tr></table></figure>
<h2 id="运行ab"><a href="#运行ab" class="headerlink" title="运行ab"></a>运行ab</h2><p>  一个最简单的ab例子就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ab -n 100 -c 10 http://www.google.com/</span></span><br></pre></td></tr></table></figure>
<p>注意网址后面要加”/“或者明确的path如”<a href="https://www.google.com/?gfe_rd=cr&amp;ei=_BvfU77ZGMeL8QfugIHAAw&quot;" target="_blank" rel="noopener">https://www.google.com/?gfe_rd=cr&amp;ei=_BvfU77ZGMeL8QfugIHAAw&quot;</a>.<br>“-c”是并发数，可以模拟同时有多少个clients并发访问。<br>“-n”表示总的请求数。每个client发送的请求数为此数字除以client数（上面的数字）。<br>“-t”可以指定测试的最大时间，如果还不到此数请求已经发完，那么测试也会结束。当使用-t参数时，ab内部默认最大的请求数为50000，为了同时使用”-n”指定的参数，可以将”-t”参数放在”-n”参数之前， 如果想了解更多的信息， 可以查看这篇<a href="http://100continue.iteye.com/blog/1325398" target="_blank" rel="noopener">文章</a>.</p>
<h2 id="实际运行ab"><a href="#实际运行ab" class="headerlink" title="实际运行ab"></a>实际运行ab</h2><p>  我使用apache ab要测试的是一个tomcat搭建的集群，上面跑着CPU密集型的一个应用程序，前面使用nginx作为load balancer。<br>  此应用的一个主要的服务通过RESTful service提供， 并且是POST类型的。 Request body是一个XML。<br>  我想随机的替换body中的一个属性，以便测试动态请求对服务器的影响。 但是Apache ab只能提供静态的数据，所以我下载了它的代码并改造了一下。<br>  <strong>首先创建了一个request.xml， 并将其中的那个属性改为占位符</strong> 修改ab.c文件，将发送请求中的占位符用随机数代替<br>  修改的代码可重用性不高，在这里就不贴了。</p>
<p>写了一个脚本，可以测试不同的并发数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;4,20,50,100,150,200,300&#125;</span><br><span class="line">do</span><br><span class="line">        ab -g plot/biz$var.dat -r -c $&#123;var&#125; -n $&#123;total&#125; -H 'Accept:application/xml'  -p request.xml -T 'application/xml' http://localhost:8080/app/biz</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="使用Gnuplot生成图表"><a href="#使用Gnuplot生成图表" class="headerlink" title="使用Gnuplot生成图表"></a>使用Gnuplot生成图表</h2><p>  在上一步中生成了测试数据，我们可以通过Gnuplot这一强大的工具生成漂亮的图表了。<br>  在生成图表之前，我们还需要处理一下获得的数据，<br>  如果直接使用测试生成报表，我们可能得到这样一个图表：<br>  <img src="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/image-20200204213258370.png" alt="响应时间"></p>
<p>相应的Gnuplot文件为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#output as png image</span></span><br><span class="line"><span class="string">set</span> <span class="string">terminal</span> <span class="string">png</span> <span class="string">size</span> <span class="number">1000</span><span class="string">,560</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#save file to "domain.png"</span></span><br><span class="line"><span class="string">set</span> <span class="string">output</span> <span class="string">"biz.png"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#graph title</span></span><br><span class="line"><span class="string">set</span> <span class="string">title</span> <span class="string">"Biz Performance"</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">invert</span> <span class="string">reverse</span> <span class="string">Left</span> <span class="string">outside</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nicer aspect ratio for image size</span></span><br><span class="line"><span class="comment">#set size 1,0.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># y-axis grid</span></span><br><span class="line"><span class="string">set</span> <span class="string">grid</span> <span class="string">y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#x-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">xlabel</span> <span class="string">"requests"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#y-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">ylabel</span> <span class="string">"response time (ms)"</span></span><br><span class="line"><span class="comment">#plot data from "biz.dat" using column 9 with smooth sbezier lines</span></span><br><span class="line"><span class="comment">#and title of "Biz Performance" for the given data</span></span><br><span class="line"><span class="string">plot</span> <span class="string">"biz4.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 4"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz20.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 20"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz50.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 50"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz100.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 100"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz150.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 150"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz200.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 200"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz300.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 300"</span></span><br></pre></td></tr></table></figure>
<p>这张图有参考价值，我们可以看到大部分的请求的相应时间落在那个数值段中，但是不能以时间序列显示服务器的性能。 它是以”总用时“ (ttime) 进行排序，所以一般它会一条上升的曲线来显示。<br>这篇<a href="http://www.bradlanders.com/2013/04/15/apache-bench-and-gnuplot-youre-probably-doing-it-wrong/" target="_blank" rel="noopener">文章</a>中指出了一种按照时间序列显示数据的方法。 Apapche ab生成的测试数据中已经包含了时间戳，可以修改Gnuplot生成按时间序列显示的响应时间图：<br>[<img src="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/image-20200204213452892.png" alt="时间序列"></p>
<p>Gnuplot文件为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let's output to a jpeg file</span></span><br><span class="line"><span class="string">set</span> <span class="string">terminal</span> <span class="string">jpeg</span> <span class="string">size</span> <span class="number">500</span><span class="string">,500</span></span><br><span class="line"><span class="comment"># This sets the aspect ratio of the graph</span></span><br><span class="line"><span class="string">set</span> <span class="string">size</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># The file we'll write to</span></span><br><span class="line"><span class="string">set</span> <span class="string">output</span> <span class="string">"graphs/timeseries.jpg"</span></span><br><span class="line"><span class="comment"># The graph title</span></span><br><span class="line"><span class="string">set</span> <span class="string">title</span> <span class="string">"Benchmark testing"</span></span><br><span class="line"><span class="comment"># Where to place the legend/key</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">left</span> <span class="string">top</span></span><br><span class="line"><span class="comment"># Draw gridlines oriented on the y axis</span></span><br><span class="line"><span class="string">set</span> <span class="string">grid</span> <span class="string">y</span></span><br><span class="line"><span class="comment"># Specify that the x-series data is time data</span></span><br><span class="line"><span class="string">set</span> <span class="string">xdata</span> <span class="string">time</span></span><br><span class="line"><span class="comment"># Specify the *input* format of the time data</span></span><br><span class="line"><span class="string">set</span> <span class="string">timefmt</span> <span class="string">"%s"</span></span><br><span class="line"><span class="comment"># Specify the *output* format for the x-axis tick labels</span></span><br><span class="line"><span class="string">set</span> <span class="string">format</span> <span class="string">x</span> <span class="string">"%S"</span></span><br><span class="line"><span class="comment"># Label the x-axis</span></span><br><span class="line"><span class="string">set</span> <span class="string">xlabel</span> <span class="string">'seconds'</span></span><br><span class="line"><span class="comment"># Label the y-axis</span></span><br><span class="line"><span class="string">set</span> <span class="string">ylabel</span> <span class="string">"response time (ms)"</span></span><br><span class="line"><span class="comment"># Tell gnuplot to use tabs as the delimiter instead of spaces (default)</span></span><br><span class="line"><span class="string">set</span> <span class="string">datafile</span> <span class="string">separator</span> <span class="string">'\t'</span></span><br><span class="line"><span class="comment"># Plot the data</span></span><br><span class="line"><span class="string">plot</span> <span class="string">"data/testing.tsv"</span> <span class="string">every</span> <span class="string">::2</span> <span class="string">using</span> <span class="number">2</span><span class="string">:5</span> <span class="string">title</span> <span class="string">'response time'</span> <span class="string">with</span> <span class="string">points</span></span><br><span class="line"><span class="string">exit</span></span><br></pre></td></tr></table></figure>
<p>为了得到按时间序列显示的吞吐率图表，我们可以处理一下得到的测试数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;4,20,50,100,150,200,300&#125;</span><br><span class="line">do</span><br><span class="line">   start_time=`awk '&#123;print $6&#125;' plot/biz$var.dat | grep -v 'wait' | sort | uniq -c|head -1|awk '&#123;print $2&#125;'`</span><br><span class="line">  awk '&#123;print $6&#125;' plot/biz$var.dat | grep -v 'wait' | sort | uniq -c|awk -v t=$start_time '&#123;print $2-t,$1&#125;' &gt; plot/epochtime$var.dat</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>然后根据一下的Gnuplot配置生成图表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#output as png image</span></span><br><span class="line"><span class="string">set</span> <span class="string">terminal</span> <span class="string">png</span>  <span class="string">size</span> <span class="number">1000</span><span class="string">,560</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">output</span> <span class="string">"throughput.png"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#graph title</span></span><br><span class="line"><span class="string">set</span> <span class="string">title</span> <span class="string">"Throughput"</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">invert</span> <span class="string">reverse</span> <span class="string">Left</span> <span class="string">outside</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nicer aspect ratio for image size</span></span><br><span class="line"><span class="comment">#set size 1,0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># y-axis grid</span></span><br><span class="line"><span class="string">set</span> <span class="string">grid</span> <span class="string">y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#x-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">xlabel</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#y-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">ylabel</span> <span class="string">"responses per second"</span></span><br><span class="line"><span class="string">plot</span> <span class="string">"epochtime4.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 4"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime20.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 20"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime50.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 50"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime100.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 100"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime150.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 150"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime200.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 200"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime300.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 300"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/image-20200204213604555.png" alt="吞吐率"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/12个Git高级命令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/12个Git高级命令/" itemprop="url">
                  12个Git高级命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:03:00" itemprop="dateCreated datePublished" datetime="2020-02-04T21:03:00+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用Git时常用的命令有pull、commit、push等，貌似很简单。不过，有时你会遇到合并冲突的情况，Git这时会将冲突标记出来，需要你手工来解决。有时，你会不小心将代码提交到错误的分支上，并且又推送到了远程仓库。还有些时候，你需要切换到不同的分支，但Git却不让你这么做，因为还有未保存的修改。如果需要通过另一个分支的提交来为代码打补丁该怎么做呢？本文就将介绍12个Git高级命令，合理使用这些命令可以大大提升应用Git的效率。</p>
<h2 id="1-使用rebase而非merge来拉取上游修改"><a href="#1-使用rebase而非merge来拉取上游修改" class="headerlink" title="1. 使用rebase而非merge来拉取上游修改"></a><strong>1. 使用rebase而非merge来拉取上游修改</strong></h2><p>分支合并会被记录为一次合并提交，这种做法是很有意义的。比如说，可以通过这种方式来标识一个新特性被合并到了发布分支中。不过，当多个团队成员工作在一个项目中并使用常规的git pull来同步分支时，提交时间线就会被不必要的合并提交所污染。更好的做法则是使用git rebase将一个feature分支变基到master分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout feature</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>
<p>这么做会将整个feature分支移动到master分支的起点，它会合并master分支上所有新的提交。不过，相比于使用合并提交来说，变基会通过在原来的分支中为每次提交创建全新提交来重写项目历史。变基的主要好处在于你会得到一个更加整洁的项目历史。此外，这里还有关于变基的陷阱的一些讨论。</p>
<h2 id="2-在执行git-rebase后解决合并冲突"><a href="#2-在执行git-rebase后解决合并冲突" class="headerlink" title="2. 在执行git rebase后解决合并冲突"></a><strong>2. 在执行git rebase后解决合并冲突</strong></h2><p>正如能力越大责任就越大一样。在执行git rebase时，你可能会遇到合并冲突的情况。合并冲突表示两个提交修改了同一个文件的同一行，Git不知道该应用哪一个修改。</p>
<p>Git会为你提供3个选择来修复导致冲突的提交（fa39187）：</p>
<ul>
<li>可以运行git rebase –abort来完全取消变基。这么做会取消变基修改，并将分支置回到执行git rebase之前的状态。</li>
<li>可以运行git rebase –skip来完全忽略该提交。这样，有问题的提交所引入的变化就不会被添加到历史中。</li>
<li>可以使用与合并冲突相同的标准步骤来解决冲突。</li>
</ul>
<h2 id="3-临时性保存修改"><a href="#3-临时性保存修改" class="headerlink" title="3. 临时性保存修改"></a><strong>3. 临时性保存修改</strong></h2><p>在工作进行中时，有些东西常常会处于凌乱的状态。如果这时需要切换到不同的分支该怎么办呢？Git是不允许你这么做的，因为还有尚未保存的修改。坦率地说，你并不想将半成品提交上去，后面再来修改。这个问题的解决之道就是使用git stash命令。Stash会接收工作目录的当前状态（比如说，修改了的追踪文件与暂存区的修改等），并将其保存到未完成的修改栈中，这样后面随时可以再来修改。可以通过如下命令来暂存你的工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on feature: 3fc175f fix race condition</span><br><span class="line">HEAD is now at 3fc175f fix race condition</span><br></pre></td></tr></table></figure>
<p>现在，工作目录就是干净的了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch feature</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>这时就可以安全地切换分支做别的事情了。不过不必担心，暂存的提交依旧还在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 3fc175f fix race condition</span><br></pre></td></tr></table></figure>
<p>稍后，在回到feature分支后，你就可以取回所有暂存的变更了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add ..."</span> to update what will be committed)</span><br><span class="line"></span><br><span class="line">     modified:   index.html</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (ac2321cc3a33ba712b8e50c99a99d3c20da9d6b8)</span><br></pre></td></tr></table></figure>
<p>关于暂存，还有其他一些选项可用，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash save <span class="string">"describe it"</span>   <span class="comment"># give the stash a name</span></span><br><span class="line">$ git stash clear                <span class="comment"># delete a stashed commit</span></span><br><span class="line">$ git stash save --keep-index    <span class="comment"># stash only unstaged files</span></span><br></pre></td></tr></table></figure>
<h2 id="4-克隆一个特定的远程分支"><a href="#4-克隆一个特定的远程分支" class="headerlink" title="4. 克隆一个特定的远程分支"></a><strong>4. 克隆一个特定的远程分支</strong></h2><p>如果想要从远程仓库中克隆一个特定的分支该怎么做呢？通常你会使用git clone，不过这么做会将所有其他分支都一并克隆下来。一个便捷的方式是使用git remote add：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init  </span><br><span class="line">$ git remote add -t  -f origin </span><br><span class="line">$ git checkout</span><br></pre></td></tr></table></figure>
<h2 id="5-将cherry-pick远程提交合并到自己的分支中"><a href="#5-将cherry-pick远程提交合并到自己的分支中" class="headerlink" title="5. 将cherry-pick远程提交合并到自己的分支中"></a><strong>5. 将cherry-pick远程提交合并到自己的分支中</strong></h2><p>更有甚者，如果只想将远程仓库的一个特定提交合并到自己的分支中该怎么做呢？可以使用git cherry-pick 来选择给定SHA值的提交，然后将其合并到当前分支中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick</span><br></pre></td></tr></table></figure>
<h2 id="6-应用来自于不相关的本地仓库的补丁"><a href="#6-应用来自于不相关的本地仓库的补丁" class="headerlink" title="6. 应用来自于不相关的本地仓库的补丁"></a><strong>6. 应用来自于不相关的本地仓库的补丁</strong></h2><p>如果需要将另一个不相关的本地仓库的提交补丁应用到当前仓库该怎么做呢？答案就是下面这条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --git-dir=/.git format-patch -k -1 --stdout  | git am -3 -k</span><br></pre></td></tr></table></figure>
<h2 id="7-忽略追踪文件中的变更"><a href="#7-忽略追踪文件中的变更" class="headerlink" title="7. 忽略追踪文件中的变更"></a><strong>7. 忽略追踪文件中的变更</strong></h2><p>如果你和你的同事操纵的是相同分支，那么很有可能需要频繁执行git merge或是git rebase。不过，这么做可能会重置一些与环境相关的配置文件，这样在每次合并后都需要修改。与之相反，你可以通过如下命令永久性地告诉Git不要管某个本地文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --assume-unchanged</span><br></pre></td></tr></table></figure>
<h2 id="8-每隔X秒运行一次git-pull"><a href="#8-每隔X秒运行一次git-pull" class="headerlink" title="8. 每隔X秒运行一次git pull"></a><strong>8. 每隔X秒运行一次git pull</strong></h2><p>通常，合并冲突出现的原因在于你正在工作的本地仓库不再反映远程仓库的当前状态。这正是我们为什么每天早晨要首先执行一次git pull的缘故。此外，你还可以在后台通过脚本（或是使用GNU Screen）每隔X秒调用一次git pull：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen</span><br><span class="line">$ <span class="keyword">for</span>((i=1;i&lt;=10000;i+=1)); <span class="keyword">do</span> sleep X &amp;&amp; git pull; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="9-将子目录分隔为新的仓库"><a href="#9-将子目录分隔为新的仓库" class="headerlink" title="9. 将子目录分隔为新的仓库"></a><strong>9. 将子目录分隔为新的仓库</strong></h2><p>有时，你可能需要将Git仓库中某个特定的目录转换为一个全新的仓库。这可以通过git filter-branch来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --prune-empty --subdirectory-filter  master</span><br><span class="line"><span class="comment"># Filter the master branch to your directory and remove empty commits</span></span><br><span class="line">Rewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (89/89)</span><br><span class="line">Ref <span class="string">'refs/heads/master'</span> was rewritten</span><br></pre></td></tr></table></figure>
<p>现在，仓库会包含指定子目录中的所有文件。虽然之前的所有文件都会被删除，但他们依旧存在于Git历史中。现在可以将新的本地仓库推送到远程了。</p>
<h2 id="10-清理"><a href="#10-清理" class="headerlink" title="10. 清理"></a><strong>10. 清理</strong></h2><p>有时，Git会提示“untracked working tree files”会“overwritten by checkout”。造成这种情况的原因有很多。不过通常来说，我们可以使用如下命令来保持工作树的整洁，从而防止这种情况的发生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -f     <span class="comment"># remove untracked files</span></span><br><span class="line">$ git clean -fd    <span class="comment"># remove untracked files/directories</span></span><br><span class="line">$ git clean -nfd   <span class="comment"># list all files/directories that would be removed</span></span><br></pre></td></tr></table></figure>
<h2 id="11-将项目文件打成tar包，并且排除-git目录"><a href="#11-将项目文件打成tar包，并且排除-git目录" class="headerlink" title="11. 将项目文件打成tar包，并且排除.git目录"></a><strong>11. 将项目文件打成tar包，并且排除.git目录</strong></h2><p>有时，你需要将项目副本提供给无法访问GitHub仓库的外部成员。最简单的方式就是使用tar或zip来打包所有的项目文件。不过，如果不小心，隐藏的.git目录就会包含到tar文件中，这会导致文件体积变大；同时，如果里面的文件与接收者自己的Git仓库弄混了，那就更加令人头疼了。轻松的做法则是自动从tar文件中排除掉.git目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar cJf .tar.xz / --exclude-vcs</span><br></pre></td></tr></table></figure>
<h2 id="12-查找修改者"><a href="#12-查找修改者" class="headerlink" title="12. 查找修改者"></a><strong>12. 查找修改者</strong></h2><p>最后，如果出现混乱的情况，你一定想要找出是谁造成的。如果生产服务器宕机，那么找到罪魁祸首是比较容易的事情：只需执行git blame。该命令会显示出文件中每一行的作者，提交hash则会找出该行的上一次修改，还能看到提交的时间戳：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/在CentOS上安装Git/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/在CentOS上安装Git/" itemprop="url">
                  在CentOS上安装Git
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:00:57" itemprop="dateCreated datePublished" datetime="2020-02-04T21:00:57+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CentOS的yum源中没有git，只能自己编译安装，现在记录下编译安装的内容，留给自己备忘。</p>
<p>确保已安装了依赖的包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install curl</span><br><span class="line">yum install curl-devel</span><br><span class="line">yum install zlib-devel</span><br><span class="line">yum install openssl-devel</span><br><span class="line">yum install perl</span><br><span class="line">yum install cpio</span><br><span class="line">yum install expat-devel</span><br><span class="line">yum install gettext-devel yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure>
<p>下载最新的git包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.gz</span><br><span class="line">tar xzvf git-latest.tar.gz</span><br><span class="line"><span class="built_in">cd</span> git-2011-11-30 ＃你的目录可能不是这个</span><br><span class="line">autoconf</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>检查下安装的版本，大功告成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/大规模网站架构的缓存机制和几何分形学/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/大规模网站架构的缓存机制和几何分形学/" itemprop="url">
                  大规模网站架构的缓存机制和几何分形学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 17:42:42" itemprop="dateCreated datePublished" datetime="2020-02-04T17:42:42+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/缓存/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>缓存机制在我们的实际研发工作中，被极其广泛地应用，通过这些缓存机制来提升系统交互的效率。简单的总结来说，就是在两个环节或者系统之间，会引入一个cache/buffer做为提升整体效率的角色。</p>
<p>而 有趣的是，这种缓存机制令人惊奇并且优美的遵循着“几何分形”的规律，也就是几何分形学中的“自相似性”：从整体上看遵循某种组成规律或者特性，同时从每 一个局部看，仍然遵循某种组成的规律或者特性。我们的这些系统，从整体上看遵循了缓存机制，每一个组成的局部也遵循缓存机制。</p>
<p>等同类比的一个概念，我们常常说的“空间换时间”，牺牲一部分空间代价，来换取整体效率的提升。</p>
<pre class="mermaid">graph LR
A[A] ==> B(Cache) ==> C[B]
C[B] ==> B(Cache) ==> A[A]</pre>

<p>例如A和B两者之间的数据交换，为了提升整体的效率，引入角色C，而C被用于当做热点数据的存储，或者是某种中间处理的机制。</p>
<p>我们先从web前端层面开始，看看有哪些比较关键的缓存机制？它们又是怎样协调工作的呢？</p>
<h1 id="一、前端Cache机制"><a href="#一、前端Cache机制" class="headerlink" title="一、前端Cache机制"></a><strong>一、前端Cache机制</strong></h1><h2 id="1-域名转为IP地址（域名服务器DNS缓存）"><a href="#1-域名转为IP地址（域名服务器DNS缓存）" class="headerlink" title="1. 域名转为IP地址（域名服务器DNS缓存）"></a><strong>1. 域名转为IP地址（域名服务器DNS缓存）</strong></h2><p>我们知道域名其实只是一个别名，真实的服务器请求地址，实际上是一个IP地址。获得IP地址的方式，就是查询DNS映射表。虽然这是一个非常简单的查询， 但如果每次用户访问一个url都去查询DNS一次，未免显得太频繁，会产生一个可怕的访问量级。DNS服务器会告诉你，你别老是经常过来，万一我挂了，我们就无法愉快地玩耍了。</p>
<p>各个浏览器的缓存时间，会有一定的差别。例如，在chrome浏览器中查看dns的缓存时间的方式是：chrome://net-internals/#dns。</p>
<p>浏览器一般会在本地会建立一个DNS缓存，在一段比较长的时间里，都是使用本地的缓存映射。例如，在Win7系统的cmd里，可以通过“ipconfig /flushdns ”的方式来立刻刷新本地DNS。</p>
<pre class="mermaid">graph LR
A[浏览器] ==> B(Cache) ==> C[DNS]
C[DNS] ==> B(Cache) ==> A[浏览器]</pre>

<p>优点：域名映射为IP非常快。</p>
<p>成本：消耗一定的浏览器空间来存储映射关系</p>
<h2 id="2-访问服务器，获取静态内容（地理位置分布式服务CDN）"><a href="#2-访问服务器，获取静态内容（地理位置分布式服务CDN）" class="headerlink" title="2. 访问服务器，获取静态内容（地理位置分布式服务CDN）"></a><strong>2. 访问服务器，获取静态内容（地理位置分布式服务CDN）</strong></h2><p>可能有人会觉得，这个CDN不是缓存。其实，CDN的原理就是将离你很远的东西，放在离你很近的地方，通过这种方式提高用户的访问速度。从这个角 度，它也可以理解为牺牲空间成本换取了时间，本质上也是一种特殊的中间cache。腾讯、阿里等这些大的一线互联网公司一般倾向于自己建立CDN系统，中 小型企业也经常使用第三方的CDN服务。</p>
<pre class="mermaid">graph LR
A[浏览器] ==> B(CDN) ==> C[很远的服务器]
C[很远的服务器] ==> B(Cache) ==> A[浏览器]</pre>

<p>优点：解决用户离服务器太远的时候，网络路由中跳来跳去的严重耗时。</p>
<p>成本：全国各地部署多套静态存储服务，管理成本比较高，发布新文件的时候，需要等待全国节点的更新等。</p>
<h2 id="3-浏览器本地缓存（无网络交互类型）"><a href="#3-浏览器本地缓存（无网络交互类型）" class="headerlink" title="3. 浏览器本地缓存（无网络交互类型）"></a><strong>3. 浏览器本地缓存（无网络交互类型）</strong></h2><p>在前端优化原则中，其中一条就是尽量消灭请求，以达到降低服务器压力和提升用户体验的效果。静态文件，例如Js、html、css、图片等内容，很多内容可以1次请求，然后未来就直接访问本地，不再请求web服务器。</p>
<p>常用的实现方法是通过Http协议头中的expire和max-age来控制，这两者的使用方法和区别，我这里就不赘叙了。还有一种HTML5中很热的方式，则是localStorage，尤其在移动端也被做为一个强大的缓存，甚至当做一种本地存储来广泛使用。</p>
<pre class="mermaid">graph LR
A[浏览器] ==> B(本地缓存localStore) ==> C[web服务器]
C[web服务器] ==> B(本地缓存localStore) ==> A[浏览器]</pre>

<p>优点：减少网络传输，加快页面内容展示速度，提升用户体验。</p>
<p>成本：占用客户端的部分内存和磁盘，影响实时性。</p>
<h2 id="4-浏览器和web服务协议缓存（有网络交互类型）"><a href="#4-浏览器和web服务协议缓存（有网络交互类型）" class="headerlink" title="4. 浏览器和web服务协议缓存（有网络交互类型）"></a><strong>4. 浏览器和web服务协议缓存（有网络交互类型）</strong></h2><p>浏览器的本地缓存是存在过期时间的，一旦过期，就必须重新向服务器请求。这个时候，会有两种情形：</p>
<p>服务器的文件或者内容没有更新，可以继续使用浏览器本地缓存。</p>
<p>服务器的文件或者内容已经更新，需要重新请求，通过网络传输新的文件或者内容。</p>
<p>这里的协商方式也可以通过Http协议来控制，Last-Modified和Etag，这个时候请求服务器，如果是内容没有发生变更的情况，服务器会返回 304 Not Modified。这样的话，就不需要每次访问服务器都通过网络传输一个比较大的文件或者数据包，只要简单的http应答就可以达到相同的请求文件效果。</p>
<pre class="mermaid">graph LR
A[浏览器] ==> B(Last-MofifiedEtag机制) ==> C[web服务器]
C[web服务器] ==> B(Last-MofifiedEtag机制) ==> A[浏览器]</pre>
下图中的例子，是腾讯的自建CDN（imgcache.gtime.cn）：
![image-20200204180300749](大规模网站架构的缓存机制和几何分形学/image-20200204180300749.png)

优点：减少频繁的网络大数据包传输，节约带宽，提升用户体验。

成本：增加了服务器处理的步骤，消耗更多的CPU资源。

## **5. 浏览器中间代理**

上面的几种cache机制，实际上都是非常常见。但是，在移动互联网时代，流量昂贵是很多用户心中深深的痛。于是，又出现了一种新型的中间cache， 也就是在浏览器和web服务器再架设一个中间代理。这个代理服务器会帮助手机浏览器去请求web页面，然后将web页面进行处理和压缩（例如压缩文件和图片），使页面变小，然后再传输给手机端的浏览器。

<pre class="mermaid">graph LR
A[手机浏览器] ==> B(浏览器商的中间代理服务器) ==> C[压缩后的Html和图片] ==> A[手机浏览器]
B(浏览器商的中间代理服务器) ==> D[www.qq.com的web服务器]
D[www.qq.com的web服务器] ==> B(浏览器商的中间代理服务器)</pre>
部分手机浏览器（例如Chrome）号称可以节省流量，提升访问速度，实际上就是上述做法。但是，也分为两种情况：

- 用户的网络和手机配置都比较差，因为页面被压缩变小，加载和传输速度变快，并且节约了流量。
- 用户的网络和手机配置都比较好，本身直连速度已经很快了，反而因为设置了中间代理，加载速度变慢，也可节约流量。

下图是chrome手机浏览器中，开启和不开启中间代理的对比图：

![image-20200204180713768](大规模网站架构的缓存机制和几何分形学/image-20200204180713768.png)

优点：节约用户流量，大部分情况下提升了加载速度。

成本：需要架设中间代理服务器，对各种文件进行压缩，有比较高的服务器维护成本。

## **6. 预加载缓存机制**

这种加载方式主要流行在移动端，为了解决手机网速慢和浏览器加载性能问题，浏览器会判断页面的关联内容，进行“预加载”。 也就是说，在用户浏览A页面的时候，就提前下载并且加载B页面的内容。给用户的体验就是，B页面一瞬间就出现了，中间没有任何延迟的感觉，从而带来更好的 极佳的用户体验。

这种实现机制，往往由浏览器来实现，当然，手机页面本身，也可以通过JS来自身实现。而这种机制也存在一些问题，浏览器需要预判用户的浏览行为，在一些场景下，这个预判算法本身不一定准确，如果不准确则带来一定的流量、内存和系统资源的浪费。

<pre class="mermaid">graph LR
A[浏览器] ==> C[页面内容A]
A[浏览器] -.- B(预加载) -.-> D[页面内容B]
A[浏览器] -.- E(预加载) -.-> F[页面内容C/D/E/...]</pre>

<p>优点：给用户带来极佳的页面展示体验。</p>
<p>缺点：预判实现比较复杂，占据一定的内存和手机系统资源，可能产生流量和资源浪费。</p>
<p>前端的cache当然不仅仅如此简单，如果细致到每一个小环节和组成部分，我们会发现实际上是无处不在的，例如浏览器的渲染行为、网络网卡的传输环节，小环节和小环节之间也有无数这种类型的cache角色。</p>
<p>这个就如同几何分形学中的自相似性：从整体上看符合某种组成规律或者特性，同时，从局部看，仍然符合某种组成的规律或者特性。</p>
<p>几何分形的现象在我们生活中，也是非常常见的，例如：</p>
<p>人体中的几何分形例子，例如：人体有1个头部+4肢，局部上看人的手指也是1个手指头+4个手指；人体无论整体或者局部，都大致遵循黄金分割点0.618的比例来生长（五官按照这个比例越多，越好看）。</p>
<p>例如下图中的叶子，每个局部都和主干组成结构相似。</p>
<p><img src="/2020/02/04/大规模网站架构的缓存机制和几何分形学/image-20200204181000405.png" alt="image-20200204181000405"></p>
<h1 id="二、Web系统和几何分形学"><a href="#二、Web系统和几何分形学" class="headerlink" title="二、Web系统和几何分形学"></a><strong>二、Web系统和几何分形学</strong></h1><h2 id="1-Web系统中的缓存机制"><a href="#1-Web系统中的缓存机制" class="headerlink" title="1. Web系统中的缓存机制"></a><strong>1. Web系统中的缓存机制</strong></h2><p>看完上面的前端cache，我们会感觉到缓存机制在前端中的确无处不在，那么它在其他地方和环节，是否也无处不在？</p>
<p>可以看看这张图：</p>
<pre class="mermaid">graph TB
A[浏览器] ==> C[前端cache机制] ==> D[web服务器]
D[web服务器] ==> C[前端cache机制] ==> A[浏览器]
D[web服务器] ==放大web服务器==> B(memcache缓存) ==> E[MySQL]
B(memcache缓存) ==> F[Apache]
E[MySQL] ==> B(memcache缓存)
F[Apache] ==> B(memcache缓存)
E[MySQL] ==放大MySQL==> G(innodb_buffer_pool存放热点数据) ==> H[MySQL内部数据]
G(innodb_buffer_pool存放热点数据) ==> I[外界请求]
H[MySQL内部数据] ==> G(innodb_buffer_pool存放热点数据)
I[外界请求] ==> G(innodb_buffer_pool存放热点数据)</pre>

<p>实际上，每一个环节本身是可以又再次被放大的，放大以后，我们又看见了更多缓存机制的“特性”存在。从一个整体来看，符合该规律，从组成部分来看，仍然符合该规律。</p>
<p>每一个组成缓存机制的“成员”的内部，又存在着更多的缓存机制。</p>
<p>Apache内部的一些“缓存机制”：</p>
<ul>
<li>url映射缓存mod_cache（有mode_disk_cache和mod_mem_cache，后者官方已不推荐）</li>
<li>缓存热点文件打开描述符mod_file_cache（对于静态文件的情况，减少打开文件中open行为的耗时）</li>
<li>启动的时候，通过prefork模式设置的StartServers服务进程池，牺牲内存空间。</li>
</ul>
<p>MySQL内的一些“缓存机制”：</p>
<ul>
<li>数据库的索引，牺牲磁盘空间（组合索引等会占据很大的磁盘空间）</li>
<li>innodb_buffer_pool_size，热点数据的缓存，牺牲内存空间</li>
<li>innodb_flush_method写入磁盘的机制，可以配置成缓冲写入的方式</li>
<li>query_cache_size查询缓存，牺牲内存空间</li>
<li>thread_cache_size数据库连接池的缓存个数，牺牲内存空间</li>
</ul>
<h2 id="2-接近硬件层面的“空间换时间”"><a href="#2-接近硬件层面的“空间换时间”" class="headerlink" title="2. 接近硬件层面的“空间换时间”"></a><strong>2. 接近硬件层面的“空间换时间”</strong></h2><p>那我们再来看更细小的一个环节，计算机写的操作。我们会发现，在内存和物理磁盘之间，还有一个磁盘缓冲区（页高速缓存）的存在，这个是内存和磁盘之间的“缓存”。当然，读取的操作也是同理。</p>
<p>下图是“放大”MySQL中的写入磁盘：</p>
<pre class="mermaid">graph LR
A[外界请求] ==> C[innodb_buffer_pool存放热点数据] ==> B[MySQL内部数据]
B[MySQL内部数据] ==> C[innodb_buffer_pool存放热点数据] ==> A[外界请求]
B[MySQL内部数据] ==放大写入数据==> D[磁盘写入缓冲区在内存中] ==> E[MySQL] ==队列满或超时==> F[物理磁盘]
G[内存] ==> D[磁盘写入缓冲区在内存中]</pre>

<p>实际上，更进一步看，CPU和内存之间也存在缓存机制（常用指令会存在放在寄存器中，因为CPU访问寄存器会远快于访问内存，中间为了缓冲它们之间差距，设置了多级高速缓存）。</p>
<pre class="mermaid">graph LR
A[Mem] ==Bus总线==> B[L3 Cache] ==> C[L2 Cache] ==> D[L1 Cache] ==> E[CPU core]
E[CPU core] ==> D[L1 Cache] ==> C[L2 Cache] ==> B[L3 Cache] ==Bus总线==> A[Mem]</pre>

<p>例如下图是Intel i7 920的各级缓存大小：</p>
<p><img src="/2020/02/04/大规模网站架构的缓存机制和几何分形学/image-20200204195827800.png" alt="image-20200204195827800"></p>
<p>这个时候，我们可以看出来，计算机系统从大的系统层面看，是遵循“缓存机制”的规律的，同时，在每个局部成员的层面，同样遵循该规律。</p>
<h2 id="3-现实世界中的“缓存机制”"><a href="#3-现实世界中的“缓存机制”" class="headerlink" title="3. 现实世界中的“缓存机制”"></a><strong>3. 现实世界中的“缓存机制”</strong></h2><p>我们现在喝水通常使用的是杯子，杯子实际上也扮演着一个特殊的Cache角色。举个例子：一个人离饮水机比较远，他渴了，他有如下两种“喝水”的方式：</p>
<ul>
<li>不用杯子，每次渴了直接去饮水机喝（这个比较霸气侧漏，不要在意细节）。结果：频繁跑动，耗费体力。</li>
<li>使用杯子，渴了先喝杯子（Cache）上的水，如果杯子没有，带上杯子去装水，再喝。结果：比较少跑动，节省体力。</li>
</ul>
<p>这样看不直观，简化为一个流程图如下：</p>
<pre class="mermaid">graph LR
A((人)) -.口渴则过去喝.-> B[比较远的饮水机]
A((人)) ==> D[杯子 Cache] --杯子空则过去--> B[比较远的饮水机]</pre>

<p>这虽然是个人尽皆知的道理，但是，这个方法本身是“进化”出来的。百万年前的原始人类和其他大自然的动物一样的，喝水遵循了第一种方式，只是随着人类的发展，“进化”出第二种喝水的方式。</p>
<p>这里也存在一个缓存机制，就是用杯子的空间获取喝水效率的时间。</p>
<p>还有一个更为典型的例子，就是坐车/运输，假设我们从深圳去广州，我们会去坐客运车。而客运车（假设上面有40个 座位）实际上相当于一个40个座位的“队列”。遵循着网络传输的相同的规律“队列满或者超时则发送”。客车本身的40个位置，就像一个“发送缓冲区”。使 用和不使用这个大的缓冲区，客车也可以有两者运作方式：</p>
<ol>
<li>车站发现来一个人，用只能容纳一个人的小车，不等待直接送一个人去广州。</li>
<li>车站发现来一个人，先放进客车buffer中，等待人满或者达到班车约定时间（队列超时）再出发。</li>
</ol>
<pre class="mermaid">graph LR
A(深圳车站) -.1.来一个立刻用车运走.-> B(广州车站)
A(深圳车站) ==2==> D[40座客车buffer] --> B(广州车站)</pre>

<p>显而易见，第一种是太浪费资源了。</p>
<p>除此之外，还有很多各种各样的例子，如江河上的大坝、我们桌面上的一些东西（它们占据宝贵的桌面空间）、我们公司附近小店里的商品、离我们近的东西等等。</p>
<p>看到这里，很多人会渐渐发觉，计算机的一些原理，竟然在现实世界里有无处不在的“映射和影子”。</p>
<p>几何分形学是个非常有趣的东西，某些规律，实际上还贯穿在整个宏观和微观世界中。</p>
<p>例如“绕转”的现象：</p>
<pre class="mermaid">graph LR
A[电子围绕原子核转] ==> B[月球自转] ==> C[月球围绕地球转] ==> D[地月系围绕太阳转] ==> E[太阳系围绕银河系中心转]</pre>

<h2 id="4-现实世界和计算机“缓存机制”原理的关系，为什么遵循“几何分形”？"><a href="#4-现实世界和计算机“缓存机制”原理的关系，为什么遵循“几何分形”？" class="headerlink" title="4. 现实世界和计算机“缓存机制”原理的关系，为什么遵循“几何分形”？"></a><strong>4. 现实世界和计算机“缓存机制”原理的关系，为什么遵循“几何分形”？</strong></h2><p>实际上，计算机的原理来源于数学，而数学是日常生活现象和规律的高度抽象，源于生活，高于生活。</p>
<pre class="mermaid">graph LR
A[现实世界] -.高度抽象.-> B[数学] -.应用实现.-> C[计算机原理]</pre>

<p>同时，不仅仅“缓存机制”，还有很多其他技术的原理，也能找到这种遵循“几何分形学”的样子。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/01/31/electron-vue开发入门指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/31/electron-vue开发入门指南/" itemprop="url">
                  electron-vue开发入门指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-01-31 12:48:08" itemprop="dateCreated datePublished" datetime="2020-01-31T12:48:08+08:00">2020-01-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Electron概述"><a href="#Electron概述" class="headerlink" title="Electron概述"></a>Electron概述</h1><p><img src="/2020/01/31/electron-vue开发入门指南/68747470733a2f2f656c656374726f6e6a732e6f72672f696d616765732f656c656374726f6e2d6c6f676f2e737667.svg" alt="Electron Logo"></p>
<ol>
<li><a href="https://github.com/electron/electron" target="_blank" rel="noopener">GitHub</a> 官网不翻墙太卡，本着能偷懒就偷懒，GayHub就够了，不用翻官网了</li>
<li><a href="https://github.com/electron/i18n/tree/master/content/zh-CN" target="_blank" rel="noopener">中文文档</a></li>
<li><a href="https://www.w3cschool.cn/electronmanual/wcx31ql6.html" target="_blank" rel="noopener">W3C教程</a></li>
</ol>
<h1 id="VUE概述"><a href="#VUE概述" class="headerlink" title="VUE概述"></a>VUE概述</h1><p><img src="/2020/01/31/electron-vue开发入门指南/68747470733a2f2f7675656a732e6f72672f696d616765732f6c6f676f2e706e67.png" alt="Vue logo"></p>
<ol>
<li><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">VUE官网</a> 官网资料齐全，中英文档都齐备，基本看完够搞个工程了</li>
</ol>
<h1 id="Electron-Vue-联合使用"><a href="#Electron-Vue-联合使用" class="headerlink" title="Electron + Vue 联合使用"></a>Electron + Vue 联合使用</h1><h2 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h2><p>安装成功之后<code>node -v</code>，会显示版本，版本可以不用这么新，看心情安装。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line"><span class="selector-tag">v12</span><span class="selector-class">.14</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure>
<h2 id="搭建Vue开发环境"><a href="#搭建Vue开发环境" class="headerlink" title="搭建Vue开发环境"></a>搭建Vue开发环境</h2><p>直接使用脚手架工具vue-cli，因为在国内的npm非常慢，所以需要重新设置npm镜像，设置为淘宝的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>
<p>我们可以看一下镜像地址是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue npm config get registry  </span><br><span class="line">https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>
<p>如果不想修改默认npm地址，也可以<a href="https://npm.taobao.org/" target="_blank" rel="noopener">设置cnpm</a>(因为自带翻墙光环，考虑到后面可能不方便翻墙，后面全程优先使用墙内网络操作。)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">//输入命令,查看是否安装成功</span><br><span class="line">cnpm</span><br></pre></td></tr></table></figure>
<p>安装脚手架工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global vue-cli</span><br></pre></td></tr></table></figure>
<p>安装web-pack：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure>
<p>yarn 使用国内镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">yarn config list</span><br></pre></td></tr></table></figure>
<h3 id="npm更新package-json"><a href="#npm更新package-json" class="headerlink" title="npm更新package.json"></a>npm更新package.json</h3><p>将package.json中的依赖更新为最新版</p>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>
<p>显示当前目录下项目中所有新的依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu</span><br></pre></td></tr></table></figure>
<p>更新项目package文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure>
<p><a href="https://www.npmjs.com/package/npm-check-updates" target="_blank" rel="noopener">npm-check-updates更多参数</a></p>
<h3 id="什么是Yarn和NPM"><a href="#什么是Yarn和NPM" class="headerlink" title="什么是Yarn和NPM?"></a>什么是Yarn和NPM?</h3><p><strong>Yarn:Yet Another Resource Negotiator，是一个快速、可靠、安全的依赖管理工具，一款新的JavaScript包管理工具。</strong></p>
<p>Yarn工作流：</p>
<p> <img src="/2020/01/31/electron-vue开发入门指南/1087883-20190909202049178-776852540-1580637729972.png" alt="img"></p>
<p>Yarn使用方法：<a href="https://yarn.bootcss.com/docs/usage/" target="_blank" rel="noopener">https://yarn.bootcss.com/docs/usage</a>/</p>
<p>Yarn使用方法-如图：</p>
<p><img src="/2020/01/31/electron-vue开发入门指南/1087883-20190909202053234-421219548-1580637730004.png" alt="img"></p>
<p>Yarn是什么：<a href="https://yarn.bootcss.com" target="_blank" rel="noopener">https://yarn.bootcss.com</a></p>
<p>Npm是什么 :<a href="https://www.npmjs.cn/" target="_blank" rel="noopener">https://www.npmjs.cn/</a></p>
<h3 id="yarn和npm命令对比"><a href="#yarn和npm命令对比" class="headerlink" title="yarn和npm命令对比"></a>yarn和npm命令对比</h3><h4 id="一、命令对比"><a href="#一、命令对比" class="headerlink" title="一、命令对比"></a>一、命令对比</h4><table>
<thead>
<tr>
<th style="text-align:center">yarn</th>
<th style="text-align:center">npm</th>
<th style="text-align:left">命令功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong><code>yarn install</code></strong></td>
<td style="text-align:center"><strong><code>npm install</code></strong></td>
<td style="text-align:left"><strong>根据<code>pack.json</code>安装项目所需的依赖包</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn install --flat</code></strong></td>
<td style="text-align:center"><strong><code>--</code></strong></td>
<td style="text-align:left"><strong>注释1</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn install --no-lockfile</code></strong></td>
<td style="text-align:center"><strong><code>npm install --no-package-lock</code></strong></td>
<td style="text-align:left"><strong>不读取或生成<code>yarn.lock</code>锁文件</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn install --pure-lockfile</code></strong></td>
<td style="text-align:center"><strong><code>--</code></strong></td>
<td style="text-align:left"><strong>不要生成<code>yarn.lock</code>锁文件</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package]</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package]</code></strong></td>
<td style="text-align:left"><strong>安装需要的依赖包</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --dev</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --save-dev</code></strong></td>
<td style="text-align:left"><strong>注释2</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --D</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --save-dev</code></strong></td>
<td style="text-align:left"><strong>同上</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --peer</code></strong></td>
<td style="text-align:center"><strong><code>--</code></strong></td>
<td style="text-align:left"><strong>注释3</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --P</code></strong></td>
<td style="text-align:center"><strong><code>--</code></strong></td>
<td style="text-align:left"><strong>同上</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --optional</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --save-optional</code></strong></td>
<td style="text-align:left"><strong>注释4</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --O</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --save-optional</code></strong></td>
<td style="text-align:left"><strong>同上</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --exact</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --save-exact</code></strong></td>
<td style="text-align:left"><strong>注释5</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add [package] --E</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --save-exact</code></strong></td>
<td style="text-align:left"><strong>同上</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn global add [package]</code></strong></td>
<td style="text-align:center"><strong><code>npm install [package] --global</code></strong></td>
<td style="text-align:left"><strong>全局安装依赖包</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn global upgrade</code></strong></td>
<td style="text-align:center"><strong><code>npm update --global</code></strong></td>
<td style="text-align:left"><strong>全局更新依赖包</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn add --force</code></strong></td>
<td style="text-align:center"><strong><code>npm rebuild</code></strong></td>
<td style="text-align:left"><strong>更改包内容后进行重建</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn remove [package]</code></strong></td>
<td style="text-align:center"><strong><code>npm uninstall [package]</code></strong></td>
<td style="text-align:left"><strong>卸载已经安装的依赖包</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn cache clean [package]</code></strong></td>
<td style="text-align:center"><strong><code>npm cache clean</code></strong></td>
<td style="text-align:left"><strong>注释6</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn upgrade</code></strong></td>
<td style="text-align:center"><strong><code>rm -rf node_modules &amp;&amp; npm install</code></strong></td>
<td style="text-align:left"><strong>更新依赖包</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn version --major</code></strong></td>
<td style="text-align:center"><strong><code>npm version major</code></strong></td>
<td style="text-align:left"><strong>更新依赖包的版本</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn version --minor</code></strong></td>
<td style="text-align:center"><strong><code>npm version minor</code></strong></td>
<td style="text-align:left"><strong>更新依赖包的版本</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong><code>yarn version --patch</code></strong></td>
<td style="text-align:center"><strong><code>npm version patch</code></strong></td>
<td style="text-align:left"><strong>更新依赖包的版本</strong></td>
</tr>
</tbody>
</table>
<h4 id="二、命令注释"><a href="#二、命令注释" class="headerlink" title="二、命令注释"></a>二、命令注释</h4><ul>
<li><strong>注释1</strong> ：安装所有依赖项，但每个依赖项只允许一个版本。在第一次运行时，这将提示你为多版本的依赖包选择一个版本，进行安装。这些将添加到您package.json的 resolutions字段下。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"resolutions": &#123;</span><br><span class="line">  "package-a": "2.0.0",</span><br><span class="line">  "package-b": "5.0.0",</span><br><span class="line">  "package-c": "1.5.2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注释2</strong> ：安装所需的依赖包，并将该包的记录写到<code>package.json</code>文件的 <strong>devDependencies</strong> 选项中。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">    "autoprefixer": "^7.1.2",</span><br><span class="line">    "babel-core": "^6.22.1",</span><br><span class="line">    "babel-helper-vue-jsx-merge-props": "^2.0.3",</span><br><span class="line">    "babel-loader": "^7.1.1",</span><br><span class="line">    "babel-plugin-syntax-jsx": "^6.18.0",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注释3</strong> ：安装所需的依赖包，并将该包的记录写到<code>package.json</code>文件的 <strong>peerDependencies</strong> 选项中。</li>
<li><strong>注释4</strong> ：安装所需的依赖包，并将该包的记录写到<code>package.json</code>文件的 <strong>optionalDependencies</strong> 选项中。</li>
<li><strong>注释5</strong> ：安装依赖包的确切版本，默认设置是使用依赖包的最新版本。例如， <code>yarn add foo@1.2.3</code>将接受版本1.9.1，但 <code>yarn add foo@1.2.3 --exact</code> 只接受版本1.2.3。</li>
<li><strong>注释6</strong> ：运行此命令将清除全局缓存依赖包。当再次yarn或yarn install运行，进行下载依赖包</li>
</ul>
<h2 id="安装Electron"><a href="#安装Electron" class="headerlink" title="安装Electron"></a>安装Electron</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g electron</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;electron -v</span><br><span class="line"></span><br><span class="line"> v7.1.10</span><br></pre></td></tr></table></figure>
<h2 id="搭建electron-vue项目"><a href="#搭建electron-vue项目" class="headerlink" title="搭建electron-vue项目"></a>搭建electron-vue项目</h2><p>simulatedgreg/electron-vue用的vue-cli2，<strong><em>不建议再使用</em></strong>，如果vue-cli用的3或者4，建议直接跳到下面的章节</p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul>
<li><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/" target="_blank" rel="noopener">electron-vue</a>文档</li>
</ul>
<h3 id="使用electron-vue脚手架工具初始化项目"><a href="#使用electron-vue脚手架工具初始化项目" class="headerlink" title="使用electron-vue脚手架工具初始化项目"></a>使用electron-vue脚手架工具初始化项目</h3><p>可能会比较慢，可以通过webpack方式初始化vue项目，然后在引入electron方式，这个会快很多</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ vue init simulatedgreg/electron-vue alistar</span><br><span class="line"></span><br><span class="line">? Application Name alistar</span><br><span class="line">? Application Id org.evue.alistar</span><br><span class="line">? Application Version 0.0.1</span><br><span class="line">? Project description 哞利斯塔, 快乐辅助</span><br><span class="line">? Use Sass / Scss? Yes</span><br><span class="line">? Select <span class="built_in">which</span> Vue plugins to install axios, vue-electron, vue-router, vuex, vuex-electron</span><br><span class="line">? Use linting with ESLint? Yes</span><br><span class="line">? Which ESLint config would you like to use? Standard</span><br><span class="line">? Set up unit testing with Karma + Mocha? Yes</span><br><span class="line">? Set up end-to-end testing with Spectron + Mocha? Yes</span><br><span class="line">? What build tool would you like to use? builder</span><br><span class="line">? author vincentruan &lt;rzw0813@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">   vue-cli · Generated <span class="string">"alistar"</span>.</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">All <span class="built_in">set</span>. Welcome to your new electron-vue project!</span><br><span class="line"></span><br><span class="line">Make sure to check out the documentation <span class="keyword">for</span> this boilerplate at</span><br><span class="line">https://simulatedgreg.gitbooks.io/electron-vue/content/.</span><br><span class="line"></span><br><span class="line">Next Steps:</span><br><span class="line"></span><br><span class="line">  $ <span class="built_in">cd</span> alistar</span><br><span class="line">  $ yarn (or `npm install`)</span><br><span class="line">  $ yarn run dev (or `npm run dev`)</span><br></pre></td></tr></table></figure>
<p>上面已经有提示下一步做什么了，<code>cd alistar</code>目录下，之后对照执行，如果用yarn记得设置代理或者用国内镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install</span><br><span class="line">| [22/67] Installing get-stdin@^4.0.1platform unsupported babel-loader@7.1.5 › webpack@4.41.5 › watchpack@1.6.0 › chokidar@2.1.8 › fsevents@^1.2.7 Package require os(darwin) not compatible with your platform(win32)</span><br><span class="line">[fsevents@^1.2.7] optional install error: Package require os(darwin) not compatible with your platform(win32)</span><br><span class="line">√ Installed 67 packages</span><br><span class="line">√ Linked 1218 latest versions</span><br><span class="line">[1/7] scripts.postinstall babel-core@6.26.3 › babel-register@6.26.0 › core-js@^2.5.0 run <span class="string">"node -e \"try&#123;require('./postinstall')&#125;catch(e)&#123;&#125;\""</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_core-js@2.6.11@core-js"</span></span><br><span class="line">Thank you <span class="keyword">for</span> using core-js ( https://github.com/zloirock/core-js ) <span class="keyword">for</span> polyfilling JavaScript standard library!</span><br><span class="line"></span><br><span class="line">The project needs your <span class="built_in">help</span>! Please consider supporting of core-js on Open Collective or Patreon:</span><br><span class="line">&gt; https://opencollective.com/core-js</span><br><span class="line">&gt; https://www.patreon.com/zloirock</span><br><span class="line"></span><br><span class="line">Also, the author of core-js ( https://github.com/zloirock ) is looking <span class="keyword">for</span> a good job -)</span><br><span class="line"></span><br><span class="line">[1/7] scripts.postinstall babel-core@6.26.3 › babel-register@6.26.0 › core-js@^2.5.0 finished <span class="keyword">in</span> 2s</span><br><span class="line">[2/7] scripts.postinstall electron-builder@20.44.4 › app-builder-lib@20.44.4 › ejs@^2.6.2 run <span class="string">"node ./postinstall.js"</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_ejs@2.7.4@ejs"</span></span><br><span class="line">Thank you <span class="keyword">for</span> installing EJS: built with the Jake JavaScript build tool (https://jakejs.com/)</span><br><span class="line"></span><br><span class="line">[2/7] scripts.postinstall electron-builder@20.44.4 › app-builder-lib@20.44.4 › ejs@^2.6.2 finished <span class="keyword">in</span> 2s</span><br><span class="line">[3/7] scripts.postinstall electron@^2.0.4 run <span class="string">"node install.js"</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_electron@2.0.18@electron"</span></span><br><span class="line">Downloading SHASUMS256.txt</span><br><span class="line">[============================================&gt;] 100.0% of 5.39 kB (5.39 kB/s)</span><br><span class="line">[3/7] scripts.postinstall electron@^2.0.4 finished <span class="keyword">in</span> 17s</span><br><span class="line">[4/7] scripts.install spectron@3.8.0 › electron-chromedriver@~1.8.0 run <span class="string">"node ./download-chromedriver.js"</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_electron-chromedriver@1.8.0@electron-chromedriver"</span></span><br><span class="line">Downloading tmp-2644-1-SHASUMS256.txt-1.8.0</span><br><span class="line">[============================================&gt;] 100.0% of 8.02 kB (8.02 kB/s)</span><br><span class="line">successfully dowloaded and extracted!</span><br><span class="line">[4/7] scripts.install spectron@3.8.0 › electron-chromedriver@~1.8.0 finished <span class="keyword">in</span> 5s</span><br><span class="line">[5/7] scripts.install karma@2.0.5 › socket.io@2.0.4 › engine.io@3.1.5 › uws@~9.14.0 run <span class="string">"node-gyp rebuild &gt; build_log.txt 2&gt;&amp;1 || exit 0"</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_uws@9.14.0@uws"</span></span><br><span class="line">[5/7] scripts.install karma@2.0.5 › socket.io@2.0.4 › engine.io@3.1.5 › uws@~9.14.0 finished <span class="keyword">in</span> 3s</span><br><span class="line">[6/7] scripts.install node-sass@^4.9.2 run <span class="string">"node scripts/install.js"</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_node-sass@4.13.1@node-sass"</span></span><br><span class="line">Downloading binary from https://cdn.npm.taobao.org/dist/node-sass/v4.13.1/win32-x64-72_binding.node</span><br><span class="line">Download complete</span><br><span class="line">Binary saved to D:\gitspace\alistar\node_modules\_node-sass@4.13.1@node-sass\vendor\win32-x64-72\binding.node</span><br><span class="line">Caching binary to C:\Users\vincentruan\.npminstall_tarball\node-sass\4.13.1\win32-x64-72_binding.node</span><br><span class="line">[6/7] scripts.install node-sass@^4.9.2 finished <span class="keyword">in</span> 4s</span><br><span class="line">[6/7] scripts.postinstall node-sass@^4.9.2 run <span class="string">"node scripts/build.js"</span>, root: <span class="string">"D:\\gitspace\\alistar\\node_modules\\_node-sass@4.13.1@node-sass"</span></span><br><span class="line">Binary found at D:\gitspace\alistar\node_modules\_node-sass@4.13.1@node-sass\vendor\win32-x64-72\binding.node</span><br><span class="line">Testing binary</span><br><span class="line">Binary is fine</span><br><span class="line">[6/7] scripts.postinstall node-sass@^4.9.2 finished <span class="keyword">in</span> 2s</span><br><span class="line">[7/7] scripts.postinstall alistar@0.0.1 run <span class="string">"npm run lint:fix"</span>, root: <span class="string">"D:\\gitspace\\alistar"</span></span><br><span class="line"></span><br><span class="line">&gt; alistar@0.0.1 lint:fix D:\gitspace\alistar</span><br><span class="line">&gt; eslint --ext .js,.vue -f ./node_modules/eslint-friendly-formatter --fix src <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">[7/7] scripts.postinstall alistar@0.0.1 finished <span class="keyword">in</span> 11s</span><br><span class="line">√ Run 7 scripts</span><br><span class="line">peerDependencies link ajv@5.5.2 <span class="keyword">in</span> D:\gitspace\alistar\node_modules\_ajv-keywords@2.1.1@ajv-keywords unmet with D:\gitspace\alistar\node_modules\ajv(6.11.0)</span><br><span class="line">peerDependencies WARNING karma-webpack@^3.0.0 requires a peer of webpack@^2.0.0 || ^3.0.0 but webpack@4.41.5 was installed</span><br><span class="line">deprecate css-loader@0.28.11 › cssnano@3.10.0 › autoprefixer@6.7.7 › browserslist@^1.7.6 Browserslist 2 could fail on reading Browserslist &gt;3.0 config used <span class="keyword">in</span> other tools.</span><br><span class="line">deprecate babel-core@6.26.3 › babel-register@6.26.0 › core-js@^2.5.0 core-js@&lt;3 is no longer maintained and not recommended <span class="keyword">for</span> usage due to the number of issues. Please, upgrade your dependencies to the actual version of core-js@3.</span><br><span class="line">deprecate eslint@4.19.1 › file-entry-cache@2.0.0 › flat-cache@1.3.4 › circular-json@^0.3.1 CircularJSON is <span class="keyword">in</span> maintenance only, flatted is its successor.</span><br><span class="line">deprecate karma-coverage@1.1.2 › istanbul@^0.4.0 This module is no longer maintained, try this instead:</span><br><span class="line">  npm i nyc</span><br><span class="line">Visit https://istanbul.js.org/integrations <span class="keyword">for</span> other alternatives.</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › circular-json@^0.5.4 CircularJSON is <span class="keyword">in</span> maintenance only, flatted is its successor.</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › nodemailer@^2.5.0 All versions below 4.0.1 of Nodemailer are deprecated. See https://nodemailer.com/status/</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › nodemailer@2.7.2 › socks@1.1.9 If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced <span class="keyword">in</span> 2.1.0</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › nodemailer@2.7.2 › mailcomposer@4.0.1 This project is unmaintained</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › loggly@1.1.1 › request@2.75.0 › node-uuid@~1.4.7 Use uuid module instead</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › loggly@1.1.1 › request@2.75.0 › hawk@~3.1.3 This module moved to @hapi/hawk. Please make sure to switch over as this distribution is no longer supported and may contain bugs and critical security issues.</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › nodemailer@2.7.2 › mailcomposer@4.0.1 › buildmail@4.0.1 This project is unmaintained</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › loggly@1.1.1 › request@2.75.0 › hawk@3.1.3 › cryptiles@2.x.x This version has been deprecated <span class="keyword">in</span> accordance with the hapi support policy (hapi.im/support). Please upgrade to the latest version to get the best features, bug fixes, and security patches. If you are unable to upgrade at this time, paid support is available <span class="keyword">for</span> older versions (hapi.im/commercial).</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › loggly@1.1.1 › request@2.75.0 › hawk@3.1.3 › sntp@1.x.x This module moved to @hapi/sntp. Please make sure to switch over as this distribution is no longer supported and may contain bugs and critical security issues.</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › loggly@1.1.1 › request@2.75.0 › hawk@3.1.3 › hoek@2.x.x This version has been deprecated <span class="keyword">in</span> accordance with the hapi support policy (hapi.im/support). Please upgrade to the latest version to get the best features, bug fixes, and security patches. If you are unable to upgrade at this time, paid support is available <span class="keyword">for</span> older versions (hapi.im/commercial).</span><br><span class="line">deprecate karma@2.0.5 › log4js@2.11.0 › loggly@1.1.1 › request@2.75.0 › hawk@3.1.3 › boom@2.x.x This version has been deprecated <span class="keyword">in</span> accordance with the hapi support policy (hapi.im/support). Please upgrade to the latest version to get the best features, bug fixes, and security patches. If you are unable to upgrade at this time, paid support is available <span class="keyword">for</span> older versions (hapi.im/commercial).</span><br><span class="line">deprecate spectron@3.8.0 › webdriverio@^4.8.0 outdated version, please use @next</span><br><span class="line">deprecate karma@2.0.5 › socket.io@2.0.4 › engine.io@3.1.5 › uws@~9.14.0 New code is available at github.com/uNetworking/uWebSockets.js</span><br><span class="line">Recently updated (since 2020-01-23): 10 packages (detail see file D:\gitspace\alistar\node_modules\.recently_updates.txt)</span><br><span class="line">  Today:</span><br><span class="line">    → babel-preset-env@1.7.0 › browserslist@3.2.8 › electron-to-chromium@^1.3.47(1.3.342) (09:02:31)</span><br><span class="line">    → webpack-dev-server@3.10.1 › del@4.1.1 › @types/glob@7.1.1 › @types/node@*(13.5.2) (05:51:42)</span><br><span class="line">√ All packages installed (1560 packages installed from npm registry, used 1m(network 27s), speed 2.23MB/s, json 1285(3.12MB), tarball 58.05MB)</span><br></pre></td></tr></table></figure>
<p>编译完成后<code>run dev</code>，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm run dev</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/31/electron-vue开发入门指南/image-20200130174511175.png" alt="image-20200130174511175"></p>
<h3 id="问题收集与处理"><a href="#问题收集与处理" class="headerlink" title="问题收集与处理"></a>问题收集与处理</h3><p><strong>修复问题前先将项目初始化提交github</strong></p>
<h4 id="问题一：ERROR-in-Template-execution-failed-ReferenceError-process-is-not-defined"><a href="#问题一：ERROR-in-Template-execution-failed-ReferenceError-process-is-not-defined" class="headerlink" title="问题一：ERROR in Template execution failed: ReferenceError: process is not defined"></a>问题一：ERROR in Template execution failed: ReferenceError: process is not defined</h4><p>高版本的node，大于12的版本时候。使用electron-vue项目时候会报错！Webpack ReferenceError: process is not defined!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: process is not defined</span><br><span class="line">  </span><br><span class="line">  - index.ejs:11 <span class="built_in">eval</span></span><br><span class="line">    [.]/[_html-webpack-plugin@3.2.0@html-webpack-plugin]/lib/loader.js!./src/index.ejs:11:2</span><br><span class="line">  </span><br><span class="line">  - index.ejs:16 module.exports</span><br><span class="line">    [.]/[_html-webpack-plugin@3.2.0@html-webpack-plugin]/lib/loader.js!./src/index.ejs:16:3</span><br><span class="line">  </span><br><span class="line">  - index.js:284 </span><br><span class="line">    [alistar]/[_html-webpack-plugin@3.2.0@html-webpack-plugin]/index.js:284:18</span><br><span class="line">  </span><br><span class="line">  - runMicrotasks</span><br><span class="line">  </span><br><span class="line">  - task_queues.js:93 processTicksAndRejections</span><br><span class="line">    internal/process/task_queues.js:93:5</span><br></pre></td></tr></table></figure>
<p>修改 .electron-vue/webpack.renderer.config.js 和  .electron-vue/webpack.web.config.js如下</p>
<p>webpack.renderer.config.js：L125</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">'../src/index.ejs'</span>),</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">    removeComments: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  templateParameters(compilation, assets, options) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compilation: compilation,</span><br><span class="line">      webpack: compilation.getStats().toJson(),</span><br><span class="line">      webpackConfig: compilation.options,</span><br><span class="line">      htmlWebpackPlugin: &#123;</span><br><span class="line">        files: assets,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;,</span><br><span class="line">      process,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  nodeModules: process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">    ? path.resolve(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">    : <span class="literal">false</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>webpack.web.config.js: L97</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  template: path.resolve(__dirname, <span class="string">'../src/index.ejs'</span>),</span><br><span class="line">  templateParameters(compilation, assets, options) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      compilation: compilation,</span><br><span class="line">      webpack: compilation.getStats().toJson(),</span><br><span class="line">      webpackConfig: compilation.options,</span><br><span class="line">      htmlWebpackPlugin: &#123;</span><br><span class="line">        files: assets,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;,</span><br><span class="line">      process,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  minify: &#123;</span><br><span class="line">    collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">    removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">    removeComments: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  nodeModules: <span class="literal">false</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>重新执行<code>run dev</code></p>
<h4 id="问题二：-Unable-to-install-vue-devtools"><a href="#问题二：-Unable-to-install-vue-devtools" class="headerlink" title="问题二： Unable to install vue-devtools"></a>问题二： Unable to install <code>vue-devtools</code></h4><p>electron-devtools-installer无法安装远程的vue-devtool，采用手动安装方式。</p>
<p>从本地浏览器已安装的插件中拷贝到项目路径，在项目目录下创建文件夹<code>devTools\vue-devtools</code>，拷贝</p>
<p>C:\Users\${userName}\AppData\Local\Google\Chrome\User Data\Default\Extensions\nhdogjmejiglipccpnnnanhbledajbpd\5.1.1_0文件夹内容<code>devTools\vue-devtools</code>下，</p>
<p>修改src/main/index.dev.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This file is used specifically and only for development. It installs</span></span><br><span class="line"><span class="comment"> * `electron-debug` &amp; `vue-devtools`. There shouldn't be any need to</span></span><br><span class="line"><span class="comment"> *  modify this file, but it can be used to extend your development</span></span><br><span class="line"><span class="comment"> *  environment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install `electron-debug` with `devtron`</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'electron-debug'</span>)(&#123; <span class="attr">showDevTools</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增变量定义</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserWindow &#125; <span class="keyword">from</span> <span class="string">'electron'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Install `vue-devtools`</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'electron'</span>).app.on(<span class="string">'ready'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 注释掉的这部分是 Electron-Vue 中预装devtool的代码，没有用</span></span><br><span class="line">  <span class="comment">// let installExtension = require('electron-devtools-installer')</span></span><br><span class="line">  <span class="comment">// installExtension.default(installExtension.VUEJS_DEVTOOLS)</span></span><br><span class="line">  <span class="comment">//   .then(() =&gt; &#123;&#125;)</span></span><br><span class="line">  <span class="comment">//   .catch(err =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log('Unable to install `vue-devtools`: \n', err)</span></span><br><span class="line">  <span class="comment">//   &#125;)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 安装vue-devtools</span></span><br><span class="line">  BrowserWindow.addDevToolsExtension(path.resolve(__dirname, <span class="string">'../../devTools/vue-devtools'</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Require `main` process to boot app</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./index'</span>)</span><br></pre></td></tr></table></figure>
<p>应用自动重启，注意首次启动vue插件被&gt;&gt;这个隐藏了，需要手动拖动一下</p>
<p><img src="/2020/01/31/electron-vue开发入门指南/image-20200130183344218.png" alt="image-20200130183344218"></p>
<h4 id="问题三：ERROR-in-Error-node-modules-html-webpack-plugin-node-modules-clean-css-index-js-1-SyntaxError-Invalid-or-unexpected-token"><a href="#问题三：ERROR-in-Error-node-modules-html-webpack-plugin-node-modules-clean-css-index-js-1-SyntaxError-Invalid-or-unexpected-token" class="headerlink" title="问题三：ERROR in  Error: .\node_modules\html-webpack-plugin\node_modules\clean-css\index.js:1 SyntaxError: Invalid or unexpected token"></a>问题三：ERROR in  Error: .\node_modules\html-webpack-plugin\node_modules\clean-css\index.js:1 SyntaxError: Invalid or unexpected token</h4><p>找到这个文件发现下载的是一串ASII乱码，尝试删除重新安装，发现用yarn install下载的这个文件总有问题，改为cnpm下载就行了</p>
<h4 id="问题四：-ERROR-in-TypeError-compilation-templatesPlugin-is-not-a-function"><a href="#问题四：-ERROR-in-TypeError-compilation-templatesPlugin-is-not-a-function" class="headerlink" title="问题四： ERROR in   TypeError: compilation.templatesPlugin is not a function"></a>问题四： ERROR in   TypeError: compilation.templatesPlugin is not a function</h4><p>webpack不是最新版</p>
<p>解决方法：</p>
<p>1.删除node_modules，重新安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>2.安装最新webpack</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm add webpack@latest</span><br></pre></td></tr></table></figure>
<h1 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h1><h2 id="vue项目转换为electron-vue"><a href="#vue项目转换为electron-vue" class="headerlink" title="vue项目转换为electron-vue"></a>vue项目转换为electron-vue</h2><ol>
<li>把原有项目package.json的dependencies，devDependencies中不同的配置项，添加到 my-project 的package.json中</li>
<li>把vue项目src的内容全部拷贝到 my-project/src/renderer 中</li>
<li>安装依赖 npm install</li>
<li>运行 npm run dev 就可以看到跑起来的客户端</li>
<li>打包 npm run build 项目的安装文件放进build里面，执行.exe文件就可以安装了（build文件有点大）</li>
</ol>
<h2 id="electron-vue使用electron-builder指定打包32位"><a href="#electron-vue使用electron-builder指定打包32位" class="headerlink" title="electron-vue使用electron-builder指定打包32位"></a>electron-vue使用electron-builder指定打包32位</h2><p>//package.json</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"win"</span>: &#123;</span><br><span class="line">  <span class="string">"icon"</span>: <span class="string">"build/icons/icon.ico"</span>,</span><br><span class="line">  <span class="string">"target"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"target"</span>: <span class="string">"nsis"</span>,</span><br><span class="line">      <span class="string">"arch"</span>: [</span><br><span class="line">        <span class="string">"ia32"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="electron-vue开发环境跨域代理设置"><a href="#electron-vue开发环境跨域代理设置" class="headerlink" title="electron-vue开发环境跨域代理设置"></a>electron-vue开发环境跨域代理设置</h2><p>//.electron-vue/dev-runner.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startRenderer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">        proxy: &#123;</span><br><span class="line">          <span class="string">'/api'</span>: &#123;</span><br><span class="line">            target: <span class="string">'http://192.168.74.222:6019'</span>,</span><br><span class="line">            <span class="comment">// secure: false,  // 如果是https接口，需要配置这个参数</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>, <span class="comment">// 如果接口跨域，需要进行这个参数配置</span></span><br><span class="line">            pathRewrite: &#123;</span><br><span class="line">              <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过BrowserWindow新窗口打开项目内页面"><a href="#通过BrowserWindow新窗口打开项目内页面" class="headerlink" title="通过BrowserWindow新窗口打开项目内页面"></a>通过<a href="https://electronjs.org/docs/api/browser-window#browserwindow" target="_blank" rel="noopener">BrowserWindow</a>新窗口打开项目内页面</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BrowserWindow = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote.BrowserWindow</span><br><span class="line"><span class="keyword">const</span> winURL = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line">  ? <span class="string">`http://localhost:9080/#/new`</span></span><br><span class="line">  : <span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html#new`</span></span><br><span class="line"><span class="keyword">let</span> newWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  height: <span class="number">600</span>,</span><br><span class="line">  width: <span class="number">800</span></span><br><span class="line">&#125;)</span><br><span class="line">newWindow.loadURL(winURL)</span><br><span class="line">newWindow.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">  newWindow = <span class="literal">null</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="放弃SimulatedGREG-electron-vue"><a href="#放弃SimulatedGREG-electron-vue" class="headerlink" title="放弃SimulatedGREG/electron-vue"></a>放弃SimulatedGREG/electron-vue</h1><p>SimulatedGREG/electron-vue已经很久没有更新了，而且其生成的工程结构并不是vue-cli3，在尝试升级vue-cli3过程中，发现简直是无底洞，直接放弃治疗，重头升级！！！</p>
<h1 id="electron-vue3-4从0单排"><a href="#electron-vue3-4从0单排" class="headerlink" title="electron-vue3/4从0单排"></a>electron-vue3/4从0单排</h1><h2 id="安装-升级vue-cli3-4"><a href="#安装-升级vue-cli3-4" class="headerlink" title="安装/升级vue-cli3/4"></a>安装/升级vue-cli3/4</h2><p>先执行以下命令，确认下本地安装的vue-cli版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure>
<p>如果本地使用的是vue-cli2.x或者更早版本，可先卸载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm uninstall vue-cli -g</span><br></pre></td></tr></table></figure>
<blockquote>
<p>※注：vue-cli3和vue-cli4使用了新的npm包名，与旧版本不一样。</p>
</blockquote>
<p>如果还没有安装vue-cli3/4，先执行以下命令安装：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cnpm</span> <span class="selector-tag">install</span> @<span class="keyword">vue</span>/<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure>
<p>如果你已安装vue-cli3/4，但不是最新版本，可执行以下命令升级：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cnpm</span> <span class="selector-tag">update</span> @<span class="keyword">vue</span>/<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure>
<p>直接安装vue-cli4</p>
<h2 id="创建vue项目"><a href="#创建vue项目" class="headerlink" title="创建vue项目"></a>创建vue项目</h2><p>找个喜欢的目录，执行以下命令，创建vue项目：</p>
<p>（这里把项目名称定为alistar）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create alistar</span><br></pre></td></tr></table></figure>
<p>会出现以下选项（如果熟悉此步骤可跳过本节内容）：<strong>这里建议直接选择default一步搞定，后续有需要插件自己在package.json选配，刚创建项目没必要折腾</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v3<span class="number">.8</span><span class="number">.4</span></span><br><span class="line">? Please pick a preset: (Use arrow keys)</span><br><span class="line">  <span class="keyword">default</span> (babel, eslint) </span><br><span class="line">&gt; Manually <span class="keyword">select</span> features</span><br></pre></td></tr></table></figure>
<p>选择“Manually select features” (自定义安装)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed for your project: (Press <span class="tag">&lt;<span class="name">space</span>&gt;</span> to select, <span class="tag">&lt;<span class="name">a</span>&gt;</span> to t</span><br><span class="line">oggle all, <span class="tag">&lt;<span class="name">i</span>&gt;</span> to invert selection)</span><br><span class="line">❯◉ Babel</span><br><span class="line"> ◯ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◉ Router</span><br><span class="line"> ◉ Vuex</span><br><span class="line"> ◉ CSS Pre-processors</span><br><span class="line"> ◉ Linter / Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure>
<p>这里选择了常用的模块，请根据实际需求进行选择。</p>
<hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">? Use <span class="built_in">history</span> mode <span class="keyword">for</span> router? (Requires proper server setup <span class="keyword">for</span> index fallback </span><br><span class="line"><span class="keyword">in</span> production) (Y/n)  n</span><br></pre></td></tr></table></figure>
<p>如果选择了router，这里会询问是否使用history模式。</p>
<p>vue-router 默认使用hash模式（即通过url#hash来跳转页面），使用URL的hash来模拟一个完整的 URL，当URL改变时，页面不会重新加载。<br> 如果使用history，URL就像正常的url，比较好看。但是还需要后台配置支持。</p>
<p>这里我们选择“n”。</p>
<hr>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported </span><br><span class="line">by <span class="keyword">default</span>): (Use arrow keys)</span><br><span class="line">  Sass/SCSS (<span class="keyword">with</span> dart-sass) </span><br><span class="line">  Sass/SCSS (<span class="keyword">with</span> node-sass) </span><br><span class="line">  Less </span><br><span class="line">❯ Stylus</span><br></pre></td></tr></table></figure>
<p>选择CSS预处理模块，这里我们使用“Stylus”。</p>
<hr>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a linter / formatter config: (Use arrow keys)</span><br><span class="line">  ESLint <span class="keyword">with</span> error prevention only </span><br><span class="line">  ESLint + Airbnb config </span><br><span class="line">❯ ESLint + Standard config </span><br><span class="line">  ESLint + Prettier</span><br></pre></td></tr></table></figure>
<p>选择ESLint代码格式检查工具的配置，选择“ESLint + Standard config”，标准配置。</p>
<hr>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Pick additional lint features: (Press &lt;space&gt; to <span class="keyword">select</span>, &lt;a&gt; to toggle all, &lt;i</span><br><span class="line">&gt; to invert selection)</span><br><span class="line">❯◉ Lint <span class="keyword">on</span> save</span><br><span class="line"> ◯ Lint and fix <span class="keyword">on</span> commit</span><br></pre></td></tr></table></figure>
<p>Line on save表示在保存代码的时候，进行格式检查。</p>
<p>Lint and fix on commit表示在git commit的时候自动纠正格式。</p>
<p>这里只选择“Lint on save”。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, PostCSS, ESLint, etc.? </span><br><span class="line">  In dedicated config files </span><br><span class="line">❯ In <span class="keyword">package</span>.json</span><br></pre></td></tr></table></figure>
<p>这里问把 babel, postcss, eslint 这些配置文件放哪？</p>
<p>In dedicated config files 表示独立文件</p>
<p>In package.json 表示放在package.json里</p>
<p>这里选择“In package.json”。</p>
<hr>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Save <span class="keyword">this</span> <span class="keyword">as</span> a preset <span class="keyword">for</span> future projects? (y/N) N</span><br></pre></td></tr></table></figure>
<p>是否为以后的项目保留这些设置？选择“N”。</p>
<p>然后耐心等待项目安装完成。</p>
<h2 id="自动安装electron"><a href="#自动安装electron" class="headerlink" title="自动安装electron"></a>自动安装electron</h2><p>使用<a href="https://github.com/nklayman/vue-cli-plugin-electron-builder" target="_blank" rel="noopener">electron-builder</a>安装</p>
<p>进入到项目根目录，执行：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">add</span> electron-builder</span><br></pre></td></tr></table></figure>
<p>在安装过程中，很可能会卡在这一步不动了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./download-chromedriver.js</span><br></pre></td></tr></table></figure>
<p>没关系，我们先强制结束掉。再执行一次vue add electron-builder，然后就可以顺利通过了。</p>
<p>接下来出现配置选项：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? <span class="selector-tag">Choose</span> <span class="selector-tag">Electron</span> <span class="selector-tag">Version</span></span><br><span class="line">  ^4<span class="selector-class">.0</span><span class="selector-class">.0</span></span><br><span class="line">&gt; ^5<span class="selector-class">.0</span><span class="selector-class">.0</span></span><br><span class="line">  ^6<span class="selector-class">.0</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure>
<p>选择Electron版本为<code>5.0.0</code></p>
<blockquote>
<p>Electron<code>5.0</code>和<code>6.0</code>的语法变化不大 选用<code>5.0</code>是因为<code>node-ffi</code>第三方修改版也只能支持到<code>5.0</code></p>
</blockquote>
<p>然后耐心等待安装完成。出现报错，跟上面安装的一样VueDevtools不翻墙安装不了，不理他，直接用本地方案开搞</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-  Running completion hooks...error: Unexpected console statement (no-console) at src\background.js:64:3:</span><br><span class="line">  62 |   await installVueDevtools()</span><br><span class="line">  63 | &#125; catch (e) &#123;</span><br><span class="line">&gt; 64 |   console.error(<span class="string">'Vue Devtools failed to install:'</span>, e.toString())</span><br><span class="line">     |   ^</span><br><span class="line">  65 | &#125;</span><br><span class="line">  66 |</span><br><span class="line">  67 |   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 error found.</span><br></pre></td></tr></table></figure>
<p>安装完成后会自动在src目录下生成background.js并修改了package.json。</p>
<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>在项目根目录执行，安装全部依赖包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>
<p>如果安装过程中报错：Error: post install error, please remove node_modules before retry!可以忽略，不影响后续使用。</p>
<h2 id="编译并启动APP"><a href="#编译并启动APP" class="headerlink" title="编译并启动APP"></a>编译并启动APP</h2><p>执行以下命令，开始编译APP，并启动开发环境APP：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">yarn</span> <span class="selector-tag">electron</span><span class="selector-pseudo">:serve</span></span><br></pre></td></tr></table></figure>
<p>首次启动可能会等待很久，出现以下信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO  Launching Electron...</span><br><span class="line">Failed to fetch extension, trying 4 more <span class="built_in">times</span></span><br><span class="line">Failed to fetch extension, trying 3 more <span class="built_in">times</span></span><br><span class="line">Failed to fetch extension, trying 2 more <span class="built_in">times</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这是因为在请求安装vuejs devtools插件。需要科学上网才能安装成功。如果不能科学上网也没关系，耐心等待5次请求失败后会自动跳过(可以本地安装）。编译成功后，就会出现开发环境的APP了。</p>
<h2 id="配置ESLint代码格式检查工具"><a href="#配置ESLint代码格式检查工具" class="headerlink" title="配置ESLint代码格式检查工具"></a>配置ESLint代码格式检查工具</h2><p>ESlint可以高效的检查代码格式，让参与项目的所有工程师都能保持统一的代码风格。其检测精度甚至可以精确到是否多一个空格或者少一个空格。代码格式的统一对提高团队的协同开发效率有很大的帮助，特别是对有代码洁癖的工程师。</p>
<p>在项目根目录下创建.eslintrc.js （注意文件名前面有个“.”）</p>
<p>请粘贴以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  root: <span class="keyword">true</span>,</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: <span class="keyword">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'extends'</span>: [</span><br><span class="line">    <span class="string">'plugin:vue/essential'</span>,</span><br><span class="line">    <span class="string">'@vue/standard'</span></span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'error'</span> : <span class="string">'off'</span>,</span><br><span class="line">    <span class="comment">// 不检测语句末尾的分号</span></span><br><span class="line">    <span class="string">'semi'</span>: [<span class="string">'off'</span>, <span class="string">'always'</span>],</span><br><span class="line">    <span class="comment">// 强制缩进为2个空格</span></span><br><span class="line">    <span class="string">'indent'</span>: [<span class="string">'error'</span>, <span class="number">2</span>],</span><br><span class="line">    <span class="comment">// 关闭函数名称跟括号之间的空格检测</span></span><br><span class="line">    <span class="string">'space-before-function-paren'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 忽略大括号内的空格</span></span><br><span class="line">    <span class="string">'object-curly-spacing'</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">'babel-eslint'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里说明下关于indent缩进的配置，要配合项目根目录下的.editorconfig</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">*.&#123;js,jsx,ts,tsx,vue&#125;</span>]</span><br><span class="line">indent_style = space   &lt;--这里定义缩进类型是空格还是tab</span><br><span class="line">indent_size = <span class="number">2</span>        &lt;--这里需要与.eslintrc.js的indent对应</span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>.editorconfig 用于IDE自动格式化代码<br> .eslintrc.js 用于ESlint检测</p>
</blockquote>
<p>以上是常用的配置。如果你有更多的配置需求，可参阅： <a href="https://cloud.tencent.com/developer/doc/1078" target="_blank" rel="noopener">https://cloud.tencent.com/developer/doc/1078</a></p>
<h2 id="配置vue"><a href="#配置vue" class="headerlink" title="配置vue"></a>配置vue</h2><p>在项目根目录下创建vue.config.js，粘贴以下代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = require(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">resolve</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="keyword">join</span>(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">'./'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// can be overwritten by process.env.HOST</span></span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,  </span><br><span class="line">    port: <span class="number">8080</span></span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.resolve.<span class="keyword">alias</span></span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'src'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'common'</span>, resolve(<span class="string">'src/common'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'components'</span>, resolve(<span class="string">'src/components'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>devServer 用于设置开发环境的服务，这里表示在本地8080端口启动web服务。</p>
<p>chainWebpack 我们给项目目录起了“别名(alias)”，在代码中，我们可以直接用“别名”访问资源，省去了每次输入完整相对路径的麻烦。</p>
<blockquote>
<p>※注：<br> ◉ 在js代码中可直接使用别名，例如：<br> @/common/js/xxx.js 等价于 src/common/js/xxx.js<br> common/js/xxx.js 等价于 src/common/js/xxx.js<br> ◉ 在css或者html中使用别名，需要在别名前加“~”，例如：<br> @import “~common/stylus/font.styl”;</p>
</blockquote>
<h2 id="项目基本设定"><a href="#项目基本设定" class="headerlink" title="项目基本设定"></a>项目基本设定</h2><h3 id="主进程和渲染进程简介"><a href="#主进程和渲染进程简介" class="headerlink" title="主进程和渲染进程简介"></a>主进程和渲染进程简介</h3><p>在开始下面的步骤之前，很有必要简单了解下Electron的应用架构。</p>
<h4 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h4><p>Electron 运行 package.json 的 main 脚本（background.js）的进程被称为主进程。 在主进程中运行的脚本通过创建web页面来展示用户界面。 一个 Electron 应用总是有且只有一个主进程。</p>
<h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个 Electron 中的 web 页面运行在它自己的渲染进程中。</p>
<p>在普通的浏览器中，web页面通常在一个沙盒环境中运行，不被允许去接触原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些底层交互。</p>
<h4 id="主进程与渲染进程的关系"><a href="#主进程与渲染进程的关系" class="headerlink" title="主进程与渲染进程的关系"></a>主进程与渲染进程的关系</h4><p>主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。</p>
<p>主进程管理所有的web页面和它们对应的渲染进程。 每个渲染进程都是独立的，它只关心它所运行的 web 页面。</p>
<p>具体可参阅官方文档： <a href="https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes" target="_blank" rel="noopener">https://electronjs.org/docs/tutorial/application-architecture#main-and-renderer-processes</a></p>
<h3 id="APP窗口大小"><a href="#APP窗口大小" class="headerlink" title="APP窗口大小"></a>APP窗口大小</h3><p>修改background.js：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Create the browser window.</span></span><br><span class="line">      win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">M       width: <span class="number">1200</span>,</span><br><span class="line">M       height: <span class="number">620</span>,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">          nodeIntegration: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="取消跨域限制"><a href="#取消跨域限制" class="headerlink" title="取消跨域限制"></a>取消跨域限制</h3><p>修改background.js：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Create the browser window.</span></span><br><span class="line">      win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">        width: <span class="number">1200</span>,</span><br><span class="line">        height: <span class="number">620</span>,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">+         webSecurity: <span class="literal">false</span>,</span><br><span class="line">          nodeIntegration: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="取消菜单栏"><a href="#取消菜单栏" class="headerlink" title="取消菜单栏"></a>取消菜单栏</h3><p>在我们生成的桌面APP中，我们可以看到默认的菜单栏。</p>
<p>在windows中，菜单栏在APP窗口内的顶部；在macOS中，菜单栏位于电脑屏幕顶部。</p>
<p>为了方便项目将来也能直接生成纯web应用，尽量把APP的全部功能都做到渲染进程里，这里我们取消菜单栏。</p>
<p>由于macOS的特殊性，顶部菜单栏无法删除，所以我们针对macOS特殊处理，把菜单栏只保留“关于”和“退出”。</p>
<p>修改background.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">M   import &#123; app, protocol, BrowserWindow, Menu &#125; from &apos;electron&apos;</span><br><span class="line">    ...</span><br><span class="line">    function createWindow () &#123;</span><br><span class="line">        ...</span><br><span class="line">        win.on(&apos;closed&apos;, () =&gt; &#123;</span><br><span class="line">            win = null</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">+       createMenu()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">+   // 设置菜单栏</span><br><span class="line">+   function createMenu() &#123;</span><br><span class="line">+       // darwin表示macOS，针对macOS的设置</span><br><span class="line">+       if (process.platform === &apos;darwin&apos;) &#123;</span><br><span class="line">+           const template = [</span><br><span class="line">+           &#123;</span><br><span class="line">+               label: &apos;App Demo&apos;,</span><br><span class="line">+               submenu: [</span><br><span class="line">+                   &#123;</span><br><span class="line">+                       role: &apos;about&apos;</span><br><span class="line">+                   &#125;,</span><br><span class="line">+                   &#123;</span><br><span class="line">+                       role: &apos;quit&apos;</span><br><span class="line">+                   &#125;]</span><br><span class="line">+           &#125;]</span><br><span class="line">+           let menu = Menu.buildFromTemplate(template)</span><br><span class="line">+           Menu.setApplicationMenu(menu)</span><br><span class="line">+       &#125; else &#123;</span><br><span class="line">+           // windows及linux系统</span><br><span class="line">+           Menu.setApplicationMenu(null)</span><br><span class="line">+       &#125;</span><br><span class="line">+   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>macOS菜单栏名称label的“App Demo”会在build版本生效，dev版本会显示“Electron”</p>
</blockquote>
<p>更多关于菜单栏设置，请参阅：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Felectronjs.org%2Fdocs%2Fapi%2Fmenu" target="_blank" rel="noopener">https://electronjs.org/docs/api/menu</a></p>
<h3 id="设置APP窗口图标"><a href="#设置APP窗口图标" class="headerlink" title="设置APP窗口图标"></a>设置APP窗口图标</h3><p>准备windows和macOS两版图标。</p>
<blockquote>
<p>windows:  app.ico  最小尺寸：256x256<br> macOS:  app.png或app.icns  最小尺寸：512x512</p>
</blockquote>
<p>把图标文件放到public/目录下，项目结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|- /dist_electron</span><br><span class="line">  （略）</span><br><span class="line">|- /<span class="keyword">public</span></span><br><span class="line">   |- app.icns  &lt;-- 本教程暂时未使用icns</span><br><span class="line">   |- app.ico</span><br><span class="line">   |- app.png</span><br><span class="line">   |- favicon.ico</span><br><span class="line">   |- index.html</span><br><span class="line">|- /src</span><br><span class="line">  （略）</span><br><span class="line">|- .editorconfig    </span><br><span class="line">|- .eslintrc.js</span><br><span class="line">|- .gitignore</span><br><span class="line">|- babel.config.js</span><br><span class="line">|- <span class="keyword">package</span>.json</span><br><span class="line">|- <span class="keyword">package</span>-lock.json</span><br><span class="line">|- README.md</span><br></pre></td></tr></table></figure>
<p>可以顺便把favicon.ico也修改一下，但是在桌面版APP上是用不到的。如果以后生成纯web项目才会用到。</p>
<p>修改background.js，让APP窗口应用图标：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Create the browser window.</span></span><br><span class="line">      win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">        width: <span class="number">1200</span>,</span><br><span class="line">        height: <span class="number">620</span>,</span><br><span class="line">        webPreferences: &#123;</span><br><span class="line">          nodeIntegration: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">+       <span class="comment">// eslint-disable-next-line no-undef</span></span><br><span class="line">+       icon: <span class="string">`<span class="subst">$&#123;__static&#125;</span>/app.ico`</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的${__static}对应的是public目录</p>
</blockquote>
<p>现在，Windows系统上可以看到开发环境的APP窗口图标已经生效了。</p>
<p>macOS图标请参照相关章节，并且需要在build后才能生效。</p>
<h3 id="设置APP窗口标题栏名称"><a href="#设置APP窗口标题栏名称" class="headerlink" title="设置APP窗口标题栏名称"></a>设置APP窗口标题栏名称</h3><p>修改public/index.html:</p>
<p>我们把electron-vue-demo改为App Demo。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span>&gt;</span></span><br><span class="line">M       <span class="tag">&lt;<span class="name">title</span>&gt;</span>App Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="build最终产品"><a href="#build最终产品" class="headerlink" title="build最终产品"></a>build最终产品</h2><p>这里我们已经集成了electron-builder工具，官方文档可以参阅：<a href="https://www.electron.build/" target="_blank" rel="noopener">https://www.electron.build/</a></p>
<h3 id="设置APP及安装包图标"><a href="#设置APP及安装包图标" class="headerlink" title="设置APP及安装包图标"></a>设置APP及安装包图标</h3><p>在窗口图标章节，我们的图标生效于运行APP的窗口。本小节将生效于最终生成的可执行文件和安装包图标。需要准备的图标文件请回看对应章节。</p>
<p>修改vue.config.js</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;...&#125;,</span><br><span class="line">+   pluginOptions: &#123;</span><br><span class="line">+       electronBuilder: &#123;</span><br><span class="line">+           builderOptions: &#123;</span><br><span class="line">+               win: &#123;</span><br><span class="line">+                   icon: <span class="string">'./public/app.ico'</span></span><br><span class="line">+               &#125;,</span><br><span class="line">+               mac: &#123;</span><br><span class="line">+                   icon: <span class="string">'./public/app.png'</span></span><br><span class="line">+               &#125;</span><br><span class="line">+           &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">+   &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>运行build后的mac版本，可以看到图标都已生效了。</p>
<p>安装包和可执行文件的截图就不再放出了。</p>
<p>更多详细介绍，可参阅： <a href="https://www.electron.build/icons.html" target="_blank" rel="noopener">https://www.electron.build/icons.html</a></p>
<h3 id="设置APP名称"><a href="#设置APP名称" class="headerlink" title="设置APP名称"></a>设置APP名称</h3><p>APP名称包括安装包中APP的名称、可执行文件的文件名。</p>
<p>修改vue.config.js:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    pluginOptions: &#123;</span><br><span class="line">        electronBuilder: &#123;</span><br><span class="line">            builderOptions: &#123;</span><br><span class="line">                win: &#123;</span><br><span class="line">                    icon: <span class="string">'./public/app.ico'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                mac: &#123;</span><br><span class="line">                    icon: <span class="string">'./public/app.png'</span></span><br><span class="line">                &#125;,</span><br><span class="line">+               productName: <span class="string">'AppDemo'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="打包APP"><a href="#打包APP" class="headerlink" title="打包APP"></a>打包APP</h3><p>执行以下命令，可以build工程：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">run</span> <span class="selector-tag">electron</span><span class="selector-pseudo">:build</span></span><br></pre></td></tr></table></figure>
<p>最终在dist_electron目录下生成build后的产品。</p>
<h4 id="windows版本"><a href="#windows版本" class="headerlink" title="windows版本"></a>windows版本</h4><p>目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/dist_electron</span><br><span class="line">|- /bundled</span><br><span class="line">  （略）</span><br><span class="line">|- /win-unpacked  &lt;-- 绿色版</span><br><span class="line">  （略）</span><br><span class="line">|- AppDemo Setup 0.1.0.exe  &lt;-- 安装文件</span><br><span class="line">|- AppDemo Setup 0.1.0.exe.blockmap</span><br><span class="line">|- builder-effective-config.yaml</span><br><span class="line">|- index.js</span><br></pre></td></tr></table></figure>
<p>这里其实就win-unpacked和AppDemo Setup 0.1.0.exe有用。</p>
<blockquote>
<p>※注：在32位环境下打包生成的是32位APP，在64位环境下打包生成的是64位APP。</p>
</blockquote>
<h4 id="mac版本"><a href="#mac版本" class="headerlink" title="mac版本"></a>mac版本</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/dist_electron</span><br><span class="line">|- /bundled</span><br><span class="line">  （略）</span><br><span class="line">|- /mac</span><br><span class="line">   |- <span class="type">AppDemo</span>   &lt;-- 绿色版</span><br><span class="line">|- <span class="type">AppDemo</span>-<span class="number">0.1</span>.<span class="number">0</span>-mac.<span class="built_in">zip</span>  &lt;-- 绿色版压缩包</span><br><span class="line">|- <span class="type">AppDemo</span>-<span class="number">0.1</span>.<span class="number">0</span>-mac.dmg  &lt;-- 安装包</span><br><span class="line">|- <span class="type">AppDemo</span>-<span class="number">0.1</span>.<span class="number">0</span>.dmg.blockmap</span><br><span class="line">|- builder-effective-config.yaml</span><br><span class="line">|- index.js</span><br></pre></td></tr></table></figure>
<h3 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h3><p>我曾经在Win10 64bit 1809版本上build失败，保存信息中提示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error output:</span><br><span class="line">Can<span class="symbol">'t</span> open output file</span><br><span class="line">Error - aborting creation process</span><br></pre></td></tr></table></figure>
<p>与此同时，在win7和win10 1803版本build正常。经研究，无果。后来把windows升级到1903版本，问题解决了。应该是vue-cli-plugin-electron-builder插件与系统之间的问题导致。</p>
<h2 id="关于项目开发的一些经验"><a href="#关于项目开发的一些经验" class="headerlink" title="关于项目开发的一些经验"></a>关于项目开发的一些经验</h2><p>在完成以上章节后，后面基本可以完全按照web方式开发了。这里简单分享下一些小经验。</p>
<h3 id="src目录结构参考"><a href="#src目录结构参考" class="headerlink" title="src目录结构参考"></a>src目录结构参考</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/src</span><br><span class="line">|- /common</span><br><span class="line">   |- /fonts</span><br><span class="line">   |- /images</span><br><span class="line">   |- /js</span><br><span class="line">      |- api</span><br><span class="line">      |- libs</span><br><span class="line">   |- /stylus</span><br><span class="line">   |- /components</span><br><span class="line">   |- /<span class="keyword">base</span></span><br><span class="line">   |- /modules</span><br><span class="line">      |- /moduleA</span><br><span class="line">      |- /moduleB</span><br><span class="line">      ...</span><br><span class="line">   |- /views</span><br><span class="line">   |- App.vue</span><br><span class="line">   |- background.js</span><br><span class="line">   |- main.js</span><br><span class="line">   |- router.js</span><br><span class="line">   |- store.js</span><br></pre></td></tr></table></figure>
<p>下面对部分重要目录简要说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">common/ - 项目公用库</span><br><span class="line">common/fonts/ - 字体文件</span><br><span class="line">common/images/ - 公用图片</span><br><span class="line">common/js/ - 公用js目录</span><br><span class="line">common/js/api/ - 把api按类别封装成函数，并<span class="built_in">export</span>出去，减少业务逻辑中的重复代码</span><br><span class="line">common/js/lib/ - 存放一些公用函数库、定义的常量库等</span><br><span class="line">common/stylus/ - Stylus样式文件</span><br><span class="line">components/ - vue组件目录</span><br><span class="line">component/base/ - vue基础组件，例如自定义的CheckBox、日期选择器、Dialog、Toaster、分页组件等</span><br><span class="line">component/modules/ - vue模块</span><br><span class="line">views/ - vue页面</span><br></pre></td></tr></table></figure>
<h3 id="换肤功能的实现"><a href="#换肤功能的实现" class="headerlink" title="换肤功能的实现"></a>换肤功能的实现</h3><p>很多项目都有实时换肤的需求，在实际开发中，虽然我们使用了Sass、Less、Stylus等高端样式工具，但最终经过编译还是要回归到最原始的CSS。换肤的本质还是实时替换皮肤样式文件。</p>
<h4 id="失败案例"><a href="#失败案例" class="headerlink" title="失败案例"></a>失败案例</h4><p>以Stylus为例，抽象出皮肤文件skin.styl:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>-<span class="built_in">bg</span> = <span class="comment">#fff</span></span><br><span class="line"><span class="variable">$color</span>-text = <span class="comment">#333</span></span><br></pre></td></tr></table></figure>
<p>在业务样式中引用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">'skin.styl'</span></span><br><span class="line"></span><br><span class="line">body</span><br><span class="line"> background: <span class="variable">$color</span>-<span class="built_in">bg</span></span><br><span class="line"> color: <span class="variable">$color</span>-text</span><br></pre></td></tr></table></figure>
<p>当经过编译后，生成的css为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">background</span>: <span class="number">#fff</span>; <span class="attribute">color</span>: <span class="number">#333</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>样式已经写死了，无法换肤。</p>
<p>那么应该怎么做呢？</p>
<h4 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h4><p>项目根目录下的public目录是静态目录，也就是说在build最终产品的时候，它里面的文件将原封不动保留。所以，可以将皮肤文件放在这里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|- /<span class="keyword">public</span></span><br><span class="line">+  |- /skin</span><br><span class="line">+     |- /skin01</span><br><span class="line">+        |- skin.css</span><br><span class="line">+     |- /skin02</span><br><span class="line">+        |- skin.css     </span><br><span class="line">   |- app.icns</span><br><span class="line">   |- app.ico</span><br><span class="line">   |- app.png</span><br><span class="line">   |- favicon.ico</span><br><span class="line">   |- index.html</span><br></pre></td></tr></table></figure>
<p>由于Electron的是基于chromium内核，所以不用担心代码的浏览器兼容问题。接下来就是发挥CSS3变量var(–*)的时候了。</p>
<p>public/skin/skin01/skin.css：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--color-bg</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">--color-text</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public/skin/skin02/skin.css：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--color-bg</span>: <span class="number">#263238</span>;</span><br><span class="line">    <span class="attribute">--color-text</span>: <span class="number">#b2ccd6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改src/App.vue：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">    &lt;style lang=<span class="string">"stylus"</span>&gt;</span><br><span class="line">+   body</span><br><span class="line">+     background: <span class="keyword">var</span>(--color-bg)</span><br><span class="line">+     color: <span class="keyword">var</span>(--color-text)</span><br><span class="line">    <span class="meta">#app</span></span><br><span class="line">      font-family <span class="string">'Avenir'</span>, Helvetica, Arial, sans-serif</span><br><span class="line">      -webkit-font-smoothing antialiased</span><br><span class="line">      -moz-osx-font-smoothing grayscale</span><br><span class="line">      text-align center</span><br><span class="line">M     color: <span class="keyword">var</span>(--color-text)</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#nav</span></span><br><span class="line">      padding <span class="number">30</span>px</span><br><span class="line">      a</span><br><span class="line">        font-weight bold</span><br><span class="line">M       color: <span class="keyword">var</span>(--color-text)</span><br><span class="line">        &amp;.router-link-exact-active</span><br><span class="line">          color <span class="meta">#42b983</span></span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>在public/index.html引入皮肤样式，注意加上id=”app-skin”：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;favicon.ico"</span>&gt;</span></span><br><span class="line">+       <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"&lt;%= BASE_URL %&gt;skin/skin01/skin.css"</span> <span class="attr">id</span>=<span class="string">"app-skin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>App Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>篇幅有限，这里就不写通过js修改皮肤的代码了。通过调试工具手动修改skin的css路径，可看到换肤效果</p>
<h3 id="从Electron4-x升级到5-x"><a href="#从Electron4-x升级到5-x" class="headerlink" title="从Electron4.x升级到5.x"></a>从Electron4.x升级到5.x</h3><p>如果你之前用的是Electron4.x，升级到5.x很简单。</p>
<p>修改package.json中electron的版本(写作本文时是5.0.6)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">M   <span class="string">"electron"</span>: <span class="string">"^5.0.6"</span>,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>修改background.js中的这部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scheme must be registered before the app is ready</span></span><br><span class="line"><span class="comment">// Electron 4.x代码</span></span><br><span class="line"><span class="comment">// protocol.registerStandardSchemes(['app'], &#123;secure: true&#125;)</span></span><br><span class="line"><span class="comment">// Electron 5.x代码</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span>.<span class="title">registerSchemesAsPrivileged</span>([</span>&#123;</span><br><span class="line">  scheme: 'app',</span><br><span class="line">  privileges: &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    standard: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<p>然后执行，等待升级安装完成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">vincent</p>
              <p class="site-description motion-element" itemprop="description">The King is dead, long live the King!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">48</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/vincentruan" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vincent</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>





  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  
    
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/xiaomai.model.json"},"display":{"position":"left","width":280,"height":375},"mobile":{"show":false},"log":false});</script></body>
</html>
