<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-mac-osx.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="HzD3jseSmctf--z1mHXLAwERIBzdqIvVavEv6fq47pI">




















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="The King is dead, long live the King!">
<meta name="keywords" content="tech">
<meta property="og:type" content="website">
<meta property="og:title" content="星辰大海">
<meta property="og:url" content="https://vincentruan.github.io/page/2/index.html">
<meta property="og:site_name" content="星辰大海">
<meta property="og:description" content="The King is dead, long live the King!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="星辰大海">
<meta name="twitter:description" content="The King is dead, long live the King!">






  <link rel="canonical" href="https://vincentruan.github.io/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>星辰大海</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星辰大海</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">My Conquest Is the Sea of Stars.</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">
    <a href="/sitemap.xml" rel="section">
      <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/11/操作系统基础概念简述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/11/操作系统基础概念简述/" itemprop="url">
                  操作系统基础概念简述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-11 21:35:14" itemprop="dateCreated datePublished" datetime="2020-02-11T21:35:14+08:00">2020-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-21 11:03:52" itemprop="dateModified" datetime="2020-02-21T11:03:52+08:00">2020-02-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/架构/" itemprop="url" rel="index"><span itemprop="name">架构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>大部分操作系统提供了特定的基础概念和抽象，例如进程、地址空间、文件等，它们是需要理解的核心内容。下面我们会简要介绍一些基本概念，为了说明这些概念，我们会不时的从 <code>UNIX</code> 中提出示例，相同的示例也会存在于其他系统中，我们后面会进行介绍。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统一个很关键的概念就是 <code>进程(Process)</code>。进程的本质就是操作系统执行的一个程序。与每个进程相关的是<code>地址空间(address space)</code>，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。地址空间中存放有可执行程序，程序所需要的数据和它的栈。与每个进程相关的还有资源集，通常包括<code>寄存器(registers)</code>（寄存器一般包括<code>程序计数器(program counter)</code>和<code>堆栈指针(stack pointer)</code>）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。你可以把进程看作是容纳运行一个程序所有信息的一个容器。</p>
<p>对进程建立一种直观感觉的方式是考虑建立一种多程序的系统。考虑下面这种情况：用户启动一个视频编辑程序，指示它按照某种格式转换视频，然后再去浏览网页。同时，一个检查电子邮件的后台进程被唤醒并开始运行，这样，我们目前就会有三个活动进程：视频编辑器、Web 浏览器和电子邮件接收程序。操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于过去一两秒钟程序用完了 CPU 分配的时间片，而 CPU 转而运行另外的程序。</p>
<p>像这样暂时中断进程后，下次应用程序在此启动时，必须要恢复到与中断时刻相同的状态，这在我们用户看起来是习以为常的事情，但是操作系统内部却做了巨大的事情。<strong>这就像和足球比赛一样，一场完美精彩的比赛是可以忽略裁判的存在的</strong>。这也意味着在挂起时该进程的所有信息都要被保存下来。例如，进程可能打开了多个文件进行读取。与每个文件相关联的是提供当前位置的指针（即下一个需要读取的字节或记录的编号）。当进程被挂起时，必须要保存这些指针，以便在重新启动进程后执行的 <code>read</code>调用将能够正确的读取数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为 <code>进程表(process table)</code>，进程表是数组或者链表结构，当前存在每个进程都要占据其中的一项。</p>
<p>所以，一个挂起的进程包括：进程的地址空间（往往称作<code>磁芯映像</code>， core image，纪念过去的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后启动该进程所需要的许多其他信息）。</p>
<p>与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用。考虑一个典型的例子，有一个称为 <code>命令解释器(command interpreter)</code> 或 <code>shell</code> 的进程从终端上读取命令。此时，用户刚键入一条命令要求编译一个程序。shell 必须先创建一个新进程来执行编译程序，当编译程序结束时，它执行一个系统调用来终止自己的进程。</p>
<p>如果一个进程能够创建一个或多个进程（称为<code>子进程</code>），而且这些进程又可以创建子进程，则很容易找到进程数，如下所示</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNDgwNDc2MS05Mjg5OTEzMTUucG5n.jpg" alt="img"></p>
<p>上图表示一个进程树的示意图，进程 A 创建了两个子进程 B 和进程 C，子进程 B 又创建了三个子进程 D、E、F。</p>
<p>合作完成某些作业的相关进程经常需要彼此通信来完成作业，这种通信称为<code>进程间通信(interprocess communication)</code>。我们在后面会探讨进程间通信。</p>
<p>其他可用的进程系统调用包括：申请更多的内存（或释放不再需要的内存），等待一个子进程结束，用另一个程序覆盖该程序。</p>
<p>有时，需要向一个正在运行的进程传递信息，而该进程并没有等待接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进行通信。为了保证一条消息或消息的应答不丢失。发送者要求它所在的操作系统在指定的若干秒后发送一个通知，这样如果对方尚未收到确认消息就可以进行重新发送。在设定该定时器后，程序可以继续做其他工作。</p>
<p>在限定的时间到达后，操作系统会向进程发送一个 <code>警告信号(alarm signal)</code>。这个信号引起该进程暂时挂起，无论该进程正在做什么，系统将其寄存器的值保存到堆栈中，并开始重新启动一个特殊的信号处理程，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以通过各种原因产生。许多由硬件检测出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。</p>
<p>系统管理器授权每个进程使用一个给定的 <code>UID(User IDentification)</code>。每个启动的进程都会有一个操作系统赋予的 UID，子进程拥有与父进程一样的 UID。用户可以是某个组的成员，每个组也有一个 <code>GID(Group IDentification)</code>。</p>
<p>在 UNIX 操作系统中，有一个 UID 是 <code>超级用户(superuser)</code>，或者 Windows 中的<code>管理员(administrator)</code>，它具有特殊的权利，可以违背一些保护规则。在大型系统中，只有系统管理员掌握着那些用户可以称为超级用户。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>每台计算机都有一些主存用来保存正在执行的程序。在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中。为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存。</p>
<p>复杂一些的操作系统会允许多个应用程序同时装入内存中运行。为了防止应用程序之间相互干扰（包括操作系统），需要有某种保护机制。虽然此机制是在硬件中实现，但却是由操作系统控制的。</p>
<p>上述观点涉及对计算机主存的管理和保护。另一种同等重要并与存储器有关的内容是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p>
<p>但是，在许多 32 位或 64 位地址的计算机中，分别有 2^32 或 2^64 字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那该怎么处理？在早期的计算机中是无法处理的。但是现在有了一种<code>虚拟内存</code>的技术，正如前面讲到过的，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>几乎所有操作系统都支持的另一个关键概念就是文件系统。如前所述，操作系统的一项主要功能是屏蔽磁盘和其他 I/O 设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型。<strong>创建文件、删除文件、读文件和写文件</strong> 都需要系统调用。在文件可以读取之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文件，有关的系统调用则用于完成这类操作。</p>
<p>为了提供保存文件的地方，大多数个人计算机操作系统都有<code>目录(directory)</code> 的概念，从而可以把文件分组。比如，学生可以给每个课程都创建一个目录，用于保存该学科的资源，另一个目录可以存放电子邮件，再有一个目录可以存放万维网主页。这就需要系统调用创建和删除目录、将已有文件放入目录中，从目录中删除文件等。目录项可以是文件或者目录，目录和目录之间也可以嵌套，这样就产生了文件系统</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTY0MjkzNS0zMTEyNDY1NDQucG5n.jpg" alt="img"></p>
<p>进程和文件层次都是以树状的结构组织，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件系统的树状结构要深一些，通常会到四层甚至五层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在很长时间。进程和文件在权限保护方面也是有区别的。一般来说，父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也能访问该文件。</p>
<p>目录层结构中的每一个文件都可以通过从目录的顶部即 <code>根目录(Root directory)</code> 开始的<code>路径名(path name)</code> 来确定。绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用斜杠分隔符分开，在上面的大学院系文件系统中，文件 CS101 的路径名是 <code>/Faculty/Prof.Brown/Courses/CS101</code>。最开始的斜杠分隔符代表的是<code>根目录 /</code>，也就是文件系统的绝对路径。</p>
<blockquote>
<p>出于历史原因，Windows 下面的文件系统以 <code>\</code> 来作为分隔符，但是 Linux 会以 <code>/</code> 作为分隔符。</p>
</blockquote>
<p>在上面的系统中，每个进程会有一个 <code>工作目录(working directory)</code>，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下寻找。如果 <code>/Faculty/Prof.Brown</code> 是工作目录，那么 <code>/Courses/CS101</code> 与上面给定的绝对路径名表示的是同一个文件。进程可以通过使用系统调用指定新的工作目录，从而变更其工作目录。</p>
<p>在读写文件之前，首先需要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作<code>文件描述符(file descriptor)</code>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p>
<p>在 UNIX 中，另一个重要的概念是 <code>特殊文件(special file)</code>。提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可以通过同样的系统调用进行读写。特殊文件有两种，一种是<code>块儿特殊文件(block special file)</code> 和 <code>字符特殊文件(character special file)</code>。块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读取第4块，程序可以直接访问设备的第4块而不必考虑存放在该文件的文件系统结构。类似的，字符特殊文件用于打印机、调制解调器和其他接受或输出字符流的设备。按照惯例，特殊文件保存在 <code>/dev</code> 目录中。例如，/devv/lp 是打印机。</p>
<p>还有一种与进程和文件相关的特性是管道，<code>管道(pipe)</code> 是一种虚文件，他可以连接两个进程</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTY1MjEwMy0zNzQ4Nzc5NzYucG5n.jpg" alt="img"></p>
<p>如果 A 和 B 希望通过管道对话，他们必须提前设置管道。当进程 A 相对进程 B 发送数据时，它把数据写到管道上，相当于管道就是输出文件。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。</p>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>计算机中含有大量的信息，用户希望能够对这些信息中有用而且重要的信息加以保护，这些信息包括电子邮件、商业计划等，管理这些信息的安全性完全依靠操作系统来保证。例如，文件提供授权用户访问。</p>
<p>比如 UNIX 操作系统，UNIX 操作系统通过对每个文件赋予一个 9 位二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个位子段，一个用于所有者，一个用于与所有者同组（用户被系统管理员划分成组）的其他成员，一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是著名的 <code>rwx位</code>。例如，保护代码<code>rwxr-x--x</code> 的含义是所有者可以读、写或执行该文件，其他的组成员可以读或执行（但不能写）此文件、而其他人可以执行（但不能读和写）该文件。</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>操作系统是执行系统调用的代码。编辑器、编译器、汇编程序、链接程序、使用程序以及命令解释符等，尽管非常重要，非常有用，但是它们确实不是操作系统的组成部分。下面我们着重介绍一下 UNIX 下的命令提示符，也就是 <code>shell</code>，shell 虽然有用，但它也不是操作系统的一部分，然而它却能很好的说明操作系统很多特性，下面我们就来探讨一下。</p>
<p>shell 有许多种，例如 <strong>sh、csh、ksh 以及 bash</strong>等，它们都支持下面这些功能，最早起的 shell 可以追溯到 sh</p>
<p>用户登录时，会同时启动一个 shell，它以终端作为标准输入和标准输出。首先显示<code>提示符(prompt)</code>，它可能是一个<code>美元符号($)</code>，提示用户 shell 正在等待接收命令，假如用户输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>shell 会创建一个子进程，并运行 date 做为子进程。在该子进程运行期间，shell 将等待它结束。在子进程完成时，shell 会显示提示符并等待下一行输入。</p>
<p>用户可以将标准输出重定向到一个文件中，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date &gt; file</span><br></pre></td></tr></table></figure>
<p>同样的，也可以将标准输入作为重定向</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort &lt;file1&gt; file2</span><br></pre></td></tr></table></figure>
<p>这会调用 sort 程序来接收 file1 的内容并把结果输出到 file2。</p>
<p>可以将一个应用程序的输出通过管道作为另一个程序的输入，因此有</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 file3 | sort &gt; /dev/lp</span><br></pre></td></tr></table></figure>
<p>这会调用 cat 应用程序来合并三个文件，将其结果输送到 sort 程序中并按照字典进行排序。sort 应用程序又被重定向到 /dev/lp ，显然这是一个打印操作。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>我们已经可以看到操作系统提供了两种功能：为用户提供应用程序抽象和管理计算机资源。对于大部分在应用程序和操作系统之间的交互主要是应用程序的抽象，例如创建、写入、读取和删除文件。计算机的资源管理对用户来说基本上是透明的。因此，用户程序和操作系统之间的接口主要是处理抽象。为了真正理解操作系统的行为，我们必须仔细的分析这个接口。</p>
<p>多数现代操作系统都有功能相同但是细节不同的系统调用，引发操作系统的调用依赖于计算机自身的机制，而且必须用汇编代码表达。<strong>任何单 CPU 计算机一次执行执行一条指令</strong>。如果一个进程在用户态下运行用户程序，例如从文件中读取数据。那么如果想要把控制权交给操作系统控制，那么必须执行一个异常指令或者系统调用指令。操作系统紧接着需要参数检查找出所需要的调用进程。操作系统紧接着进行参数检查找出所需要的调用进程。然后执行系统调用，把控制权移交给系统调用下面的指令。大致来说，系统调用就像是执行了一个特殊的过程调用，但是只有<strong>系统调用能够进入内核态而过程调用则不能进入内核态</strong>。</p>
<p>为了能够了解具体的调用过程，下面我们以 <code>read</code> 方法为例来看一下调用过程。像上面提到的那样，会有三个参数，第一个参数是指定文件、第二个是指向缓冲区、第三个参数是给定需要读取的字节数。就像几乎所有系统调用一样，它通过使用与系统调用相同的名称来调用一个函数库，从而从C程序中调用：read。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="built_in">read</span>(fd,buffer,nbytes);</span><br></pre></td></tr></table></figure>
<p>系统调用在 count 中返回实际读出的字节数。这个值通常与 nbytes 相同，但也可能更小。比如在读过程中遇到了文件尾的情况。</p>
<p>如果系统调用不能执行，不管是因为无效的参数还是磁盘错误，count 的值都会被置成 -1，然后在全局变量 <code>errno</code> 中放入错误信号。程序应该进场检查系统调用的结果以了解是否出错。</p>
<p>系统调用是通过一系列的步骤实现的，为了更清楚的说明这个概念，我们还以 read 调用为例，在准备系统调用前，首先会把参数压入堆栈，如下所示</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTcwNzc2OC01ODY3NTgxNzUucG5n.jpg" alt="img"></p>
<p>C 和 C++ 编译器使用逆序（必须把第一个参数赋值给 printf(格式字符串)，放在堆栈的顶部）。第一个参数和第三个参数都是值调用，但是第二个参数通过引用传递，即传递的是缓冲区的地址（由 &amp; 指示），而不是缓冲的内容。然后是 C 调用系统库的 read 函数，这也是第四步。</p>
<p>在由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器（第五步）。然后执行一个 <code>TRAP</code> 指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行第六步。TRAP 指令实际上与过程调用指令非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。</p>
<p>TRAP 指令与过程调用指令存在两个方面的不同</p>
<ul>
<li>TRAP 指令会改变操作系统的状态，由用户态切换到内核态，而过程调用不改变模式</li>
<li>其次，TRAP 指令不能跳转到任意地址上。根据机器的体系结构，要么跳转到一个单固定地址上，或者指令中有一 8 位长的字段，它给定了内存中一张表格的索引，这张表格中含有跳转地址，然后跳转到指定地址上。</li>
</ul>
<p>跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后<code>dispatch</code>给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成第七步。此时，系统调用处理器运行第八步，一旦系统调用处理器完成工作，控制权会根据 TRAP 指令后面的指令中返回给函数调用库第九步。这个过程接着以通常的过程调用返回的方式，返回到客户应用程序，这是第十步。然后调用完成后，操作系统还必须清除用户堆栈，然后增加<code>堆栈指针(increment stackpointer)</code>，用来清除调用 read 之前压入的参数。从而完成整个 read 调用过程。</p>
<p>在上面的第九步中我们说道，控制可能返回 TRAP 指令后面的指令，把控制权再移交给调用者这个过程中，系统调用会发生阻塞，从而避免应用程序继续执行。这么做是有原因的。例如，如果试图读键盘，此时并没有任何输入，那么调用者就必须被阻塞。在这种情形下，操作系统会检查是否有其他可以运行的进程。这样，当有用户输入 时候，进程会提醒操作系统，然后返回第 9 步继续运行。</p>
<p>下面，我们会列出一些常用的 <code>POSIX</code> 系统调用，POSIX 系统调用大概有 100 多个，它们之中最重要的一些调用见下表</p>
<p><strong>进程管理</strong></p>
<table>
<thead>
<tr>
<th>调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid = fork()</td>
<td>创建与父进程相同的子进程</td>
</tr>
<tr>
<td>pid = waitpid(pid, &amp;statloc,options)</td>
<td>等待一个子进程终止</td>
</tr>
<tr>
<td>s = execve(name,argv,environp)</td>
<td>替换一个进程的核心映像</td>
</tr>
<tr>
<td>exit(status)</td>
<td>终止进程执行并返回状态</td>
</tr>
</tbody>
</table>
<p><strong>文件管理</strong></p>
<table>
<thead>
<tr>
<th>调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fd = open(file, how,…)</td>
<td>打开一个文件使用读、写</td>
</tr>
<tr>
<td>s = close(fd)</td>
<td>关闭一个打开的文件</td>
</tr>
<tr>
<td>n = read(fd,buffer,nbytes)</td>
<td>把数据从一个文件读到缓冲区中</td>
</tr>
<tr>
<td>n = write(fd,buffer,nbytes)</td>
<td>把数据从缓冲区写到一个文件中</td>
</tr>
<tr>
<td>position = iseek(fd,offset,whence)</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>s = stat(name,&amp;buf)</td>
<td>取得文件状态信息</td>
</tr>
</tbody>
</table>
<p><strong>目录和文件系统管理</strong></p>
<table>
<thead>
<tr>
<th>调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s = mkdir(nname,mode)</td>
<td>创建一个新目录</td>
</tr>
<tr>
<td>s = rmdir(name)</td>
<td>删去一个空目录</td>
</tr>
<tr>
<td>s = link(name1,name2)</td>
<td>创建一个新目录项 name2,并指向 name1</td>
</tr>
<tr>
<td>s = unlink(name)</td>
<td>删去一个目录项</td>
</tr>
<tr>
<td>s = mount(special,name,flag)</td>
<td>安装一个文件系统</td>
</tr>
<tr>
<td>s = umount(special)</td>
<td>卸载一个文件系统</td>
</tr>
</tbody>
</table>
<p><strong>其他</strong></p>
<table>
<thead>
<tr>
<th>调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s = chdir(dirname)</td>
<td>改变工作目录</td>
</tr>
<tr>
<td>s = chmod(name,mode)</td>
<td>修改一个文件的保护位</td>
</tr>
<tr>
<td>s = kill(pid, signal)</td>
<td>发送信号给进程</td>
</tr>
<tr>
<td>seconds = time(&amp;seconds)</td>
<td>获取从 1970 年1月1日至今的时间</td>
</tr>
</tbody>
</table>
<p>上面的系统调用参数中有一些公共部分，例如 pid 系统进程 id，fd 是文件描述符，n 是字节数，position 是在文件中的偏移量、seconds 是流逝时间。</p>
<p>从宏观角度上看，这些系统调所提供的服务确定了多数操作系统应该具有的功能，下面分别来对不同的系统调用进行解释</p>
<h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><p>在 UNIX 中，<code>fork</code> 是唯一可以在 POSIX 中创建进程的途径，它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。在 fork 之后，原有进程以及副本（父与子）就分开了。在 fork 过程中，所有的变量都有相同的值，虽然父进程的数据通过复制给子进程，但是后续对其中任何一个进程的修改不会影响到另外一个。fork 调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的 <code>进程标识符(Process IDentified,PID)</code>。使用返回的 PID，就可以看出来哪个是父进程和子进程。</p>
<p>在多数情况下， 在 fork 之后，子进程需要执行和父进程不一样的代码。从终端读取命令，创建一个子进程，等待子进程执行命令，当子进程结束后再读取下一个输入的指令。为了等待子进程完成，父进程需要执行 <code>waitpid</code> 系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个比较老的子进程。当 waitpid 完成后，会将第二个参数 <code>statloc</code> 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立刻返回。</p>
<p>那么 shell 该如何使用 fork 呢？在键入一条命令后，shell 会调用 fork 命令创建一个新的进程。这个子进程会执行用户的指令。通过使用 <code>execve</code>系统调用可以实现系统执行，这个系统调用会引起整个核心映像被一个文件所替代，该文件由第一个参数给定。下面是一个简化版的例子说明 fork、waitpid 和 execve 的使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;											<span class="comment">/* 一直循环下去 */</span></span><br><span class="line">	type_prompt(); 									<span class="comment">/* 在屏幕上显示提示符 */</span></span><br><span class="line">	read_command(command,parameters) 					<span class="comment">/* 从终端读取输入 */</span></span><br><span class="line">	<span class="keyword">if</span>(fork() != <span class="number">0</span>)&#123; 										<span class="comment">/* fork 子进程 */</span></span><br><span class="line">		<span class="comment">/* 父代码 */</span></span><br><span class="line">		waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);							<span class="comment">/* 等待子进程执行完毕 */</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">/* 子代码 */</span></span><br><span class="line">		execve(command,parameters,<span class="number">0</span>)					<span class="comment">/* 执行命令 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，execve 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。这里对这些参数做一个简要的说明。</p>
<p>先看一个 shell 指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure>
<p>此命令把 file1 复制到 file2 文件中，在 shell 执行 fork 之后，子进程定位并执行文件拷贝，并将源文件和目标文件的名称传递给它。</p>
<p>cp 的主程序（以及包含其他大多数 C 程序的主程序）包含声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(argc,argv,envp)</span><br></pre></td></tr></table></figure>
<p>其中 argc 是命令行中参数数目的计数，包括程序名称。对于上面的例子，<code>argc</code> 是3。第二个参数<code>argv</code> 是数组的指针。该数组的元素 i 是指向该命令行第 i 个字符串的指针。在上面的例子中，argv[0] 指向字符串 cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main 的第三个参数是指向环境的指针，该环境是一个数组，含有 <code>name = value</code> 的赋值形式，用以将诸如终端类型以及根目录等信息传送给程序。这些变量通常用来确定用户希望如何完成特定的任务（例如，使用默认打印机）。在上面的例子中，没有环境参数传递给 execve ，所以环境变量是 0 ，所以 execve 的第三个参数为 0 。</p>
<p>可能你觉得 execve 过于复杂，这时候我要鼓励一下你，execve 可能是 POSIX 的全部系统调用中最复杂的一个了，其他都比较简单。作为一个简单的例子，我们再来看一下 <code>exit</code> ，这是进程在执行完成后应执行的系统调用。这个系统调用有一个参数，它的退出状态是 0 - 255 之间，它通过 waitpid 系统调用中的 statloc 返回给父级。</p>
<p>UNIX 中的进程将内存划分成三个部分：<code>text segment,文本区</code>，例如程序代码，<code>data segment，数据区</code>，例如变量，<code>stack segment</code>，栈区域。数据向上增长而堆栈向下增长，如下图所示</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDExNTczNzMyOC0xNzYzNDE4MzAxLnBuZw.jpg" alt="img"></p>
<p>上图能说明三个部分的内存分配情况，夹在中间的是空闲区，也就是未分配的区域，堆栈在需要时自动的挤压空闲区域，不过数据段的扩展是显示地通过系统调用 <code>brk</code> 进行的，在数据段扩充后，该系统调用指向一个新地址。但是，这个调用不是 POSIX 标准中定义的，对于存储器的动态分配，鼓励程序员使用 <code>malloc</code> 函数，而 malloc 的内部实现则不是一个适合标准化的主题，因为几乎没有程序员直接使用它。</p>
<h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><p>许多系统调用都与文件系统有关，要读写一个文件，必须先将其打开。这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开文件的名称，而代码 <code>O_RDONLY</code>、 <code>O_WRONLY</code> 或 <code>O_RDWR</code> 的含义分别是只读、只写或者两者都可以，为了创建一个新文件，使用 <code>O_CREATE</code>参数。然后可使用返回的文件描述符进行读写操作。接着，可以使用 close 关闭文件，这个调用使得文件描述符在后续的 open 中被再次使用。</p>
<p>最常用的调用还是 <code>read</code> 和 <code>write</code>，我们再前面探讨过 read 调用，write 具有与 read 相同的参数。</p>
<p>尽管多数程序频繁的读写文件，但是仍有一些应用程序需要能够随机访问一个文件的任意部分。与每个文件相关的是一个指向文件当前位置的指针。在顺序读写时，该指针通常指向要读出（写入）的下一个字节。<code>Iseek</code> 调用可以改变该位置指针的值，这样后续的 read 或 write 调用就可以在文件的任何地方开始。</p>
<p>Iseek 有三个参数，<code>position = iseek(fd,offset,whence)</code>，第一个是文件描述符，第二个是文件位置，第三个是说明该文件位置是相对于文件起始位置，当前位置还是文件的结尾。在修改了指针之后，Iseek 所返回的值是文件中的绝对位置。</p>
<p>UNIX 为每个文件保存了该文件的类型（普通文件、特殊文件、目录等）、大小，最后修改时间以及其他信息，程序可以通过 <code>stat</code> 系统调用查看这些信息。<code>s = stat(name,&amp;buf)</code>，第一个参数指定了被检查的文件；第二个参数是一个指针，该指针指向存放这些信息的结构。对于一个打开的文件而言，fstat 调用完成同样的工作。</p>
<h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><p>下面我们探讨目录和整个文件系统的系统调用，上面探讨的是和某个文件有关的系统调用。<code>mkdir</code> 和 <code>rmdir</code> 分别用于创建<code>s = mkdir(nname,mode)</code>和删除 <code>s = rmdir(name)</code> 空目录，下一个调用是 <code>s = link(name1,name2)</code> 它的作用是允许同一个文件以两个或者多个名称出现，多数情况下是在不同的目录中使用 link ，下面我们探讨一下 link 是如何工作的</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzMyNjk3My0xNDEyMzM0ODM5LnBuZw.jpg" alt="img"></p>
<p>图中有两个用户 <code>ast</code> 和 <code>jim</code>，每个用户都有他自己的一个目录和一些文件，如果 ast 要执行一个包含下面系统调用的应用程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link(<span class="string">"/usr/jim/memo"</span>, <span class="string">"/usr/ast/note"</span>);</span><br></pre></td></tr></table></figure>
<p>jim 中的 memo 文件现在会进入到 ast 的目录中，在 note 名称下。此后，<code>/usr/jim/memo</code>和 <code>/usr/ast/note</code> 会有相同的名称。</p>
<blockquote>
<p>用户目录是保存在 /usr，/user，/home 还是其他位置，都是由本地系统管理员决定的。</p>
</blockquote>
<p>要理解 link 是如何工作的需要清楚 link 做了什么操作。UNIX 中的每个文件都有一个独一无二的版本，也称作 <code>i - number，i-编号</code>，它标示着不同文件的版本。这个 i - 编号是 <code>i-nodes,i-节点</code> 表的索引。每个文件都会表明谁拥有这个文件，这个磁盘块的位置在哪，等等。目录只是一个包含一组（i编号，ASCII名称）对应的文件。UNIX 中的第一个版本中，每个目录项都会有 16 个字节，2 个字节对应 i - 编号和 14 个字节对应其名称。现在需要一个更复杂的结构需要支持长文件名，但是从概念上讲一个目录仍是一系列（i-编号，ASCII 名称）的集合。在上图中，<code>mail</code> 的 i-编号为 16，依此类推。link 只是利用某个已有文件的 i-编号，创建一个新目录项（也许用一个新名称）。在上图 b 中，你会发现有两个相同的 70 i-编号的文件，因此它们需要有相同的文件。如果其中一个使用了 <code>unlink</code> 系统调用的话，其中一个会被移除，另一个将保留。如果两个文件都移除了，则 UNIX 会发现该文件不存在任何没有目录项（i-节点中的一个域记录着指向该文件的目录项），就会把该文件从磁盘中移除。</p>
<p>就像我们上面提到过的那样，<code>mount</code> 系统 <code>s = mount(special,name,flag)</code>调用会将两个文件系统合并为一个。通常的情况是将根文件系统分布在硬盘（子）分区上，并将用户文件分布在另一个（子）分区上，该根文件系统包含常用命令的二进制（可执行）版本和其他使用频繁的文件。然后，用户就会插入可读取的 USB 硬盘。</p>
<p>通过执行 mount 系统调用，USB 文件系统可以被添加到根文件系统中，</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzMzNzc1My04NzYyOTI4OTgucG5n.jpg" alt="img"></p>
<p>图 a 是安装前的系统文件，图 b 是安装后的系统文件。</p>
<p>如果用 C 语言来执行那就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount(<span class="string">"/dev/sdb0"</span>,<span class="string">"/mnt"</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这里，第一个参数是 USB 驱动器 0 的块特殊文件名称，第二个参数是被安装在树中的位置，第三个参数说明将要安装的文件系统是可读写的还是只读的。</p>
<p>当不再需要一个文件系统时，可以使用 umount 移除之。</p>
<h3 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h3><p>除了进程、文件、目录系统调用，也存在其他系统调用的情况，下面我们来探讨一下。我们可以看到上面其他系统调用只有四种，首先来看第一个 chdir，chdir 调用更改当前工作目录，在调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">"/usr/ast/test"</span>);</span><br></pre></td></tr></table></figure>
<p>后，打开 xyz 文件，会打开 <code>/usr/ast/test/xyz</code> 文件，工作目录的概念消除了总是需要输入长文件名的需要。</p>
<p>在 UNIX 系统中，每个文件都会有保护模式，这个模式会有一个<code>读-写-执行</code>位，它用来区分所有者、组和其他成员。<code>chmod</code> 系统调用提供改变文件模式的操作。例如，要使一个文件除了对所有者之外的用户可读，你可以执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod(<span class="string">"file"</span>,<span class="number">0644</span>);</span><br></pre></td></tr></table></figure>
<p><code>kill</code> 系统调用是用户和用户进程发送信号的方式，如果一个进程准备好捕捉一个特定的信号，那么在信号捕捉之前，会运行一个信号处理程序。如果进程没有准备好捕捉特定的信号，那么信号的到来会杀掉该进程（此名字的由来）。</p>
<p>POSIX 定义了若干时间处理的进程。例如，<code>time</code> 以秒为单位返回当前时间，0 对应着 1970 年 1月 1日。在一台 32 位字的计算机中，time 的最大值是 (2^32) - 1秒，这个数字对应 136 年多一点。所以在 2106 年，32 位的 UNIX 系统会发飙。如果读者现在有 32 位 UNIX 系统，建议在 2106 年更换位 64 位操作系统（偷笑～）。</p>
<h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>上面我们提到的都是 UNIX 系统调用，现在我们来聊聊 Win 32 中的系统调用。Windows 和 UNIX 在各自的编程方式上有着根本的不同。UNIX 程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。Windows 系统则不同，Windows 应用程序通常是由事件驱动的。主程序会等待一些事件发生，然后调用程序去处理。最简单的事件处理是键盘敲击和鼠标滑过，或者是鼠标点击，或者是插入 USB 驱动，然后操作系统调用处理器去处理事件，更新屏幕和更新程序内部状态。这是与 UNIX 不同的设计风格。</p>
<p>当然，Windows 也有系统调用。在 UNIX 中，系统调用（比如 read）和系统调用所使用的调用库（例如 read）几乎是一对一的关系。而在 Windows 中，情况则大不相同。首先，函数库的调用和实际的系统调用几乎是不对应的。微软定义了一系列过程，称为 <code>Win32应用编程接口(Application Programming Interface)</code>，程序员通过这套标准的接口来实现系统调用。这个接口支持从 Windows 95 版本以来所有的 Windows 版本。</p>
<p>Win32 API 调用的数量是非常巨大的，有数千个多。但这些调用并不都是在内核态的模式下运行时，有一些是在用户态的模型下运行。Win32 API 有大量的调用，用来管理视窗、几何图形、文本、字体、滚动条、对话框、菜单以及 GUI 的其他功能。为了使图形子系统在内核态下运行，需要系统调用，否则就只有函数库调用。</p>
<p>我们把关注点放在和 Win32 系统调用中来，我们可以简单看一下 Win32 API 中的系统调用和 UNIX 中有什么不同（并不是所有的系统调用）</p>
<table>
<thead>
<tr>
<th>UNIX</th>
<th>Win32</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>CreateProcess</td>
<td>创建一个新进程</td>
</tr>
<tr>
<td>waitpid</td>
<td>WaitForSingleObject</td>
<td>等待一个进程退出</td>
</tr>
<tr>
<td>execve</td>
<td>none</td>
<td>CraeteProcess = fork + servvice</td>
</tr>
<tr>
<td>exit</td>
<td>ExitProcess</td>
<td>终止执行</td>
</tr>
<tr>
<td>open</td>
<td>CreateFile</td>
<td>创建一个文件或打开一个已有的文件</td>
</tr>
<tr>
<td>close</td>
<td>CloseHandle</td>
<td>关闭文件</td>
</tr>
<tr>
<td>read</td>
<td>ReadFile</td>
<td>从单个文件中读取数据</td>
</tr>
<tr>
<td>write</td>
<td>WriteFile</td>
<td>向单个文件写数据</td>
</tr>
<tr>
<td>lseek</td>
<td>SetFilePointer</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>stat</td>
<td>GetFileAttributesEx</td>
<td>获得不同的文件属性</td>
</tr>
<tr>
<td>mkdir</td>
<td>CreateDirectory</td>
<td>创建一个新的目录</td>
</tr>
<tr>
<td>rmdir</td>
<td>RemoveDirectory</td>
<td>移除一个空的目录</td>
</tr>
<tr>
<td>link</td>
<td>none</td>
<td>Win32 不支持 link</td>
</tr>
<tr>
<td>unlink</td>
<td>DeleteFile</td>
<td>销毁一个已有的文件</td>
</tr>
<tr>
<td>mount</td>
<td>none</td>
<td>Win32 不支持 mount</td>
</tr>
<tr>
<td>umount</td>
<td>none</td>
<td>Win32 不支持 mount，所以也不支持mount</td>
</tr>
<tr>
<td>chdir</td>
<td>SetCurrentDirectory</td>
<td>切换当前工作目录</td>
</tr>
<tr>
<td>chmod</td>
<td>none</td>
<td>Win32 不支持安全</td>
</tr>
<tr>
<td>kill</td>
<td>none</td>
<td>Win32 不支持信号</td>
</tr>
<tr>
<td>time</td>
<td>GetLocalTime</td>
<td>获取当前时间</td>
</tr>
</tbody>
</table>
<p>上表中是 UNIX 调用大致对应的 Win32 API 系统调用，简述一下上表。<code>CreateProcess</code> 用于创建一个新进程，它把 UNIX 中的 fork 和 execve 两个指令合成一个，一起执行。它有许多参数用来指定新创建进程的性质。Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。<code>WaitForSingleObject</code> 用于等待一个事件，等待的事件可以是多种可能的事件。如果有参数指定了某个进程，那么调用者将等待指定的进程退出，这通过 <code>ExitProcess</code> 来完成。</p>
<p>然后是6个文件操作，在功能上和 UNIX 的调用类似，然而在参数和细节上是不同的。和 UNIX 中一样，文件可以打开，读取，写入，关闭。<code>SetFilePointer</code> 和 <code>GetFileAttributesEx</code> 设置文件的位置并取得文件的属性。</p>
<p>Windows 中有目录，目录分别用 <code>CreateDirectory</code> 以及 <code>RemoveDirectory</code>API 调用创建和删除。也有对当前的目录的标记，这可以通过 <code>SetCurrentDirectory</code> 来设置。使用<code>GetLocalTime</code> 可获得当前时间。</p>
<p>Win32 接口中没有文件的链接、文件系统的 mount、umount 和 stat ，当然， Win32 中也有大量 UNIX 中没有的系统调用，特别是对 GUI 的管理和调用。</p>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>下面我们会探讨操作系统的几种结构，主要包括<strong>单体结构、分层系统、微内核、客户-服务端系统、虚拟机和外核</strong>等。下面以此来探讨一下</p>
<h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><p>到目前为止，在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序。使用此技术时，如果系统中的每个过程都提供了前者所需的一些有用的计算，则它可以自由调用任何其他过程。在单体系统中，调用任何一个所需要的程序都非常高效，但是上千个不受限制的彼此调用往往非常臃肿和笨拙，而且单体系统必然存在单体问题，那就是只要系统发生故障，那么任何系统和应用程序将不可用，这往往是灾难性的。</p>
<p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中</p>
<p>对于单体系统，往往有下面几种建议</p>
<ul>
<li>需要有一个主程序，用来调用请求服务程序</li>
<li>需要一套服务过程，用来执行系统调用</li>
<li>需要一套服务程序，用来辅助服务过程调用</li>
</ul>
<p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p>
<p><img src="/2020/02/11/操作系统基础概念简述/image-20200211213916896.png" alt="image-20200211213916896"></p>
<p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 <code>共享库(shared library)</code>，在 Windows 中则被称为 <code>动态链接库(Dynamic Link Library,DLL)</code>。他们的扩展名为 <code>.dll</code>，在 <code>C:\Windows\system32</code> 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p>
<h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzM1NjcxNy0yMTA5NjEwMTMyLnBuZw.jpg" alt="img"></p>
<p>分层系统是由 <code>E.W.Dijkstar</code> 和他的学生在荷兰技术学院所开发的 THE 系统。</p>
<p>把上面单体系统进一步通用化，就变为了一个层次式结构的操作系统，它的上层软件都是在下层软件的基础之上构建的。该系统分为六层，如下所示</p>
<table>
<thead>
<tr>
<th style="text-align:left">层号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">操作员</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">用户程序</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">输入/输出管理</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">操作员-进程通信</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">存储器和磁鼓管理</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">处理器分配和多道程序编程</td>
</tr>
</tbody>
</table>
<p>处理器在 0 层运行，当中断发生或定时器到期时，由该层完成进程切换；在第 0 层之上，系统由一些连续的进程组成，编写这些进程时不用再考虑在单处理器上多进程运行的细节。内存管理在第 1 层，它分配进程的主存空间。第 1 层软件保证一旦需要访问某一页面，该页面必定已经在内存中，并且在页面不需要的时候将其移出。</p>
<p>第 2 层处理进程与操作员控制台（即用户）之间的通信。第 3 层管理 I/O 设备和相关的信息流缓冲区。第 4 层是用户程序层，用户程序不用考虑进程、内存、控制台或 I/O 设备管理等细节。系统操作员在第 5 层。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>在分层方式中，设计者要确定在哪里划分 <code>内核-用户</code> 的边界。传统上，所有的层都在内核中，但是这样做没有必要。事实上，尽可能减少内核态中功能可能是更好的做法。因为内核中的错误很难处理，一旦内核态中出错误会拖累整个系统。</p>
<p>所以，为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 — 微内核 — 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p>
<p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzQxNDIwMi0xNDMxMTgzMzcyLnBuZw.jpg" alt="img"></p>
<p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。</p>
<p>位于用户态的驱动程序上面是<code>服务器</code>层，包含有服务器，它们完成操作系统的多数工作。由一个或多个文件服务器管理着文件系统，进程管理器创建、销毁和管理进程。服务器中有一个特殊的服务器称为 <code>再生服务器(reincarnation server)</code>，它的任务就是检查服务器和驱动程序的功能是否正确，一旦检查出来错误，它就会补上去，无需用户干预。这种方式使得系统具有可恢复性，并具有较高的可靠性。</p>
<p>微内核中的内核还具有一种 <code>机制</code> 与 <code>策略</code> 分离的思想。比如系统调度，一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行具有最高优先级的进程。这里，内核机制就是寻找最高的优先级进程并运行。而策略（赋予进程优先级）可以在用户态中的进程完成。在这种模式中，策略和机制是分离的，从而使内核变得更小。</p>
<h3 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h3><p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的 <code>客户-服务器</code>模式。</p>
<p>客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p>
<p><img src="/2020/02/11/操作系统基础概念简述/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUxNTExMS8yMDIwMDIvMTUxNTExMS0yMDIwMDIxMDEyMzQyMjgzNC0xNTk3MjAxOTcucG5n.jpg" alt="img"></p>
<p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p>
<p>越来越多的系统，包括家里的 PC，都成为客户端，而在某地运行的大型机器则成为服务器。许多 web 就是以这种方式运行的。一台 PC 向某个服务器请求一个 Web 页面，服务器把 Web 页面返回给客户端，这就是典型的客服-服务器模式</p>
<h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h2><ol>
<li><a href="第四版https://baike.baidu.com/item/操作系统/192?fr=aladdin">《现代操作系统》</a></li>
<li>《Modern Operating System》forth edition</li>
<li><a href="http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm" target="_blank" rel="noopener">http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm</a></li>
<li><a href="https://www.computerhope.com/jargon/c/clockcyc.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/c/clockcyc.htm</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/11/14个Java并发容器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/11/14个Java并发容器/" itemprop="url">
                  14个Java并发容器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-11 17:00:26" itemprop="dateCreated datePublished" datetime="2020-02-11T17:00:26+08:00">2020-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发容器介绍"><a href="#并发容器介绍" class="headerlink" title="并发容器介绍"></a><strong>并发容器介绍</strong></h1><ol>
<li>ConcurrentHashMap：并发版HashMap</li>
<li>CopyOnWriteArrayList：并发版ArrayList</li>
<li>CopyOnWriteArraySet：并发Set</li>
<li>ConcurrentLinkedQueue：并发队列(基于链表)</li>
<li>ConcurrentLinkedDeque：并发队列(基于双向链表)</li>
<li>ConcurrentSkipListMap：基于跳表的并发Map</li>
<li>ConcurrentSkipListSet：基于跳表的并发Set</li>
<li>ArrayBlockingQueue：阻塞队列(基于数组)</li>
<li>LinkedBlockingQueue：阻塞队列(基于链表)</li>
<li>LinkedBlockingDeque：阻塞队列(基于双向链表)</li>
<li>PriorityBlockingQueue：线程安全的优先队列</li>
<li>SynchronousQueue：读写成对的队列</li>
<li>LinkedTransferQueue：基于链表的数据交换队列</li>
<li>DelayQueue：延时队列</li>
</ol>
<h2 id="1-ConcurrentHashMap-并发版HashMap"><a href="#1-ConcurrentHashMap-并发版HashMap" class="headerlink" title="1.ConcurrentHashMap 并发版HashMap"></a><strong>1.ConcurrentHashMap 并发版HashMap</strong></h2><p>最常见的并发容器之一，可以用作并发场景下的缓存。底层依然是哈希表，但在JAVA 8中有了不小的改变，而JAVA 7和JAVA 8都是用的比较多的版本，因此经常会将这两个版本的实现方式做一些比较（比如面试中）</p>
<p>一个比较大的差异就是，JAVA 7中采用分段锁来减少锁的竞争，JAVA 8中放弃了分段锁，采用CAS，同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）。</p>
<h2 id="2-CopyOnWriteArrayList-并发版ArrayList"><a href="#2-CopyOnWriteArrayList-并发版ArrayList" class="headerlink" title="2.CopyOnWriteArrayList 并发版ArrayList"></a><strong>2.CopyOnWriteArrayList 并发版ArrayList</strong></h2><p>并发版ArrayList，底层结构也是数组，和ArrayList不同之处在于：当新增和删除元素时会创建一个新的数组，在新的数组中增加或者排除指定对象，最后用新增数组替换原来的数组。</p>
<p>适用场景：由于读操作不加锁，写（增、删、改）操作加锁，因此适用于读多写少的场景。</p>
<p>局限：由于读的时候不会加锁（读的效率高，就和普通ArrayList一样），读取的当前副本，因此可能读取到脏数据。如果介意，建议不用。</p>
<p>看看源码感受下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">  <span class="comment">// 添加元素，有锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 修改时加锁，保证并发安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object[] elements = getArray(); <span class="comment">// 当前数组</span></span><br><span class="line">      <span class="keyword">int</span> len = elements.length;</span><br><span class="line">      Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 创建一个新数组，比老的大一个空间</span></span><br><span class="line">      newElements[len] = e; <span class="comment">// 要添加的元素放进新数组</span></span><br><span class="line">      setArray(newElements); <span class="comment">// 用新数组替换原来的数组</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读元素，不加锁，因此可能读取到旧数据</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-CopyOnWriteArraySet-并发Set"><a href="#3-CopyOnWriteArraySet-并发Set" class="headerlink" title="3.CopyOnWriteArraySet 并发Set"></a><strong>3.CopyOnWriteArraySet 并发Set</strong></h2><p>基于CopyOnWriteArrayList实现（内含一个CopyOnWriteArrayList成员变量），也就是说底层是一个数组，意味着每次add都要遍历整个集合才能知道是否存在，不存在时需要插入（加锁）。</p>
<p>适用场景：在CopyOnWriteArrayList适用场景下加一个，集合别太大（全部遍历伤不起）。</p>
<h2 id="4-ConcurrentLinkedQueue-并发队列-基于链表"><a href="#4-ConcurrentLinkedQueue-并发队列-基于链表" class="headerlink" title="4.ConcurrentLinkedQueue 并发队列(基于链表)"></a><strong>4.ConcurrentLinkedQueue 并发队列(基于链表)</strong></h2><p>基于链表实现的并发队列，使用乐观锁(CAS)保证线程安全。因为数据结构是链表，所以理论上是没有队列大小限制的，也就是说添加数据一定能成功。</p>
<h2 id="5-ConcurrentLinkedDeque-并发队列-基于双向链表"><a href="#5-ConcurrentLinkedDeque-并发队列-基于双向链表" class="headerlink" title="5.ConcurrentLinkedDeque 并发队列(基于双向链表)"></a><strong>5.ConcurrentLinkedDeque 并发队列(基于双向链表)</strong></h2><p>基于双向链表实现的并发队列，可以分别对头尾进行操作，因此除了先进先出(FIFO)，也可以先进后出（FILO），当然先进后出的话应该叫它栈了。</p>
<h2 id="6-ConcurrentSkipListMap-基于跳表的并发Map"><a href="#6-ConcurrentSkipListMap-基于跳表的并发Map" class="headerlink" title="6.ConcurrentSkipListMap 基于跳表的并发Map"></a><strong>6.ConcurrentSkipListMap 基于跳表的并发Map</strong></h2><p>SkipList即跳表，跳表是一种空间换时间的数据结构，通过冗余数据，将链表一层一层索引，达到类似二分查找的效果</p>
<p><img src="/2020/02/11/14个Java并发容器/640.webp" alt="img"></p>
<h2 id="7-ConcurrentSkipListSet-基于跳表的并发Set"><a href="#7-ConcurrentSkipListSet-基于跳表的并发Set" class="headerlink" title="7.ConcurrentSkipListSet 基于跳表的并发Set"></a><strong>7.ConcurrentSkipListSet 基于跳表的并发Set</strong></h2><p>类似HashSet和HashMap的关系，ConcurrentSkipListSet里面就是一个ConcurrentSkipListMap，就不细说了。</p>
<h2 id="8-ArrayBlockingQueue-阻塞队列-基于数组"><a href="#8-ArrayBlockingQueue-阻塞队列-基于数组" class="headerlink" title="8.ArrayBlockingQueue 阻塞队列(基于数组)"></a><strong>8.ArrayBlockingQueue 阻塞队列(基于数组)</strong></h2><p>基于数组实现的可阻塞队列，构造时必须制定数组大小，往里面放东西时如果数组满了便会阻塞直到有位置（也支持直接返回和超时等待），通过一个锁ReentrantLock保证线程安全。</p>
<p>用offer操作举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 读写共用此锁，线程间通过下面两个Condition通信</span></span><br><span class="line"><span class="comment">   * 这两个Condition和lock有紧密联系（就是lock的方法生成的）</span></span><br><span class="line"><span class="comment">   * 类似Object的wait/notify</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">  <span class="comment">/** 队列不为空的信号，取数据的线程需要关注 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line">  <span class="comment">/** 队列没满的信号，写数据的线程需要关注 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line">  <span class="comment">// 一直阻塞直到有东西可以拿出来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在尾部插入一个元素，队列已满时等待指定时间，如果还是不能插入则返回</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 锁住</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 循环等待直到队列有空闲</span></span><br><span class="line">      <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 等待超时，返回</span></span><br><span class="line">        <span class="comment">// 暂时放出锁，等待一段时间（可能被提前唤醒并抢到锁，所以需要循环判断条件）</span></span><br><span class="line">        <span class="comment">// 这段时间可能其他线程取走了元素，这样就有机会插入了</span></span><br><span class="line">        nanos = notFull.awaitNanos(nanos);</span><br><span class="line">      &#125;</span><br><span class="line">      enqueue(e);<span class="comment">//插入一个元素</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看会有点疑惑，读和写都是同一个锁，那要是空的时候正好一个读线程来了不会一直阻塞吗？</p>
<p>答案就在notEmpty、notFull里，这两个出自lock的小东西让锁有了类似synchronized + wait + notify的功能。</p>
<h2 id="9-LinkedBlockingQueue-阻塞队列-基于链表"><a href="#9-LinkedBlockingQueue-阻塞队列-基于链表" class="headerlink" title="9.LinkedBlockingQueue 阻塞队列(基于链表)"></a><strong>9.LinkedBlockingQueue 阻塞队列(基于链表)</strong></h2><p>基于链表实现的阻塞队列，想比与不阻塞的ConcurrentLinkedQueue，它多了一个容量限制，如果不设置默认为int最大值。</p>
<h2 id="10-LinkedBlockingDeque-阻塞队列-基于双向链表"><a href="#10-LinkedBlockingDeque-阻塞队列-基于双向链表" class="headerlink" title="10.LinkedBlockingDeque 阻塞队列(基于双向链表)"></a><strong>10.LinkedBlockingDeque 阻塞队列(基于双向链表)</strong></h2><p>类似LinkedBlockingQueue，但提供了双向链表特有的操作。</p>
<h2 id="11-PriorityBlockingQueue-线程安全的优先队列"><a href="#11-PriorityBlockingQueue-线程安全的优先队列" class="headerlink" title="11.PriorityBlockingQueue 线程安全的优先队列"></a><strong>11.PriorityBlockingQueue 线程安全的优先队列</strong></h2><p>构造时可以传入一个比较器，可以看做放进去的元素会被排序，然后读取的时候按顺序消费。某些低优先级的元素可能长期无法被消费，因为不断有更高优先级的元素进来。</p>
<h2 id="12-SynchronousQueue-数据同步交换的队列"><a href="#12-SynchronousQueue-数据同步交换的队列" class="headerlink" title="12.SynchronousQueue 数据同步交换的队列"></a><strong>12.SynchronousQueue 数据同步交换的队列</strong></h2><p>一个虚假的队列，因为它实际上没有真正用于存储元素的空间，每个插入操作都必须有对应的取出操作，没取出时无法继续放入。</p>
<p>一个简单的例子感受一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronousQueue&lt;Integer&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 没有休息，疯狂写入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">          System.out.println(<span class="string">"放入: "</span> + i);</span><br><span class="line">          queue.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 咸鱼模式取数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">"取出: "</span> + queue.take());</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">2000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出:</span></span><br><span class="line"><span class="comment">放入: 0</span></span><br><span class="line"><span class="comment">取出: 0</span></span><br><span class="line"><span class="comment">放入: 1</span></span><br><span class="line"><span class="comment">取出: 1</span></span><br><span class="line"><span class="comment">放入: 2</span></span><br><span class="line"><span class="comment">取出: 2</span></span><br><span class="line"><span class="comment">放入: 3</span></span><br><span class="line"><span class="comment">取出: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，写入的线程没有任何sleep，可以说是全力往队列放东西，而读取的线程又很不积极，读一个又sleep一会。输出的结果却是读写操作成对出现。</p>
<p>JAVA中一个使用场景就是Executors.newCachedThreadPool()，创建一个缓存线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">             <span class="number">0</span>, <span class="comment">// 核心线程为0，没用的线程都被无情抛弃</span></span><br><span class="line">             Integer.MAX_VALUE, <span class="comment">// 最大线程数理论上是无限了，还没到这个值机器资源就被掏空了</span></span><br><span class="line">             <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// 闲置线程60秒后销毁</span></span><br><span class="line">             <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); <span class="comment">// offer时如果没有空闲线程取出任务，则会失败，线程池就会新建一个线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-LinkedTransferQueue-基于链表的数据交换队列"><a href="#13-LinkedTransferQueue-基于链表的数据交换队列" class="headerlink" title="13.LinkedTransferQueue 基于链表的数据交换队列"></a><strong>13.LinkedTransferQueue 基于链表的数据交换队列</strong></h2><p>实现了接口TransferQueue，通过transfer方法放入元素时，如果发现有线程在阻塞在取元素，会直接把这个元素给等待线程。如果没有人等着消费，那么会把这个元素放到队列尾部，并且此方法阻塞直到有人读取这个元素。和SynchronousQueue有点像，但比它更强大。</p>
<h2 id="14-DelayQueue-延时队列"><a href="#14-DelayQueue-延时队列" class="headerlink" title="14.DelayQueue 延时队列"></a><strong>14.DelayQueue 延时队列</strong></h2><p>可以使放入队列的元素在指定的延时后才被消费者取出，元素需要实现Delayed接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>上面简单介绍了JAVA并发包下的一些容器类，知道有这些东西，遇到合适的场景时就能想起有个现成的东西可以用了。想要知其所以然，后续还得再深入探索一番。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/11/Java8开发的4个小技巧/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/11/Java8开发的4个小技巧/" itemprop="url">
                  Java8开发的4个小技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-11 16:48:32" itemprop="dateCreated datePublished" datetime="2020-02-11T16:48:32+08:00">2020-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-24 15:31:01" itemprop="dateModified" datetime="2020-02-24T15:31:01+08:00">2020-02-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://dzone.com/articles/java-8-top-tips" target="_blank" rel="noopener">https://dzone.com/articles/java-8-top-tips</a></p>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>Optional是一个评价过低的特性，它可以显著的降低代码抛出NullPointerException的可能。它在边界代码(你正在使用的API或者你发布的API)中特别有用。</p>
<p>但是对于它的不适当的使用和设计很容易使一个小的变动影响到很多的类，或者降低代码的可阅读性。这里有一些如何更加高效使用Optional的建议。</p>
<h3 id="Optional应该仅仅用在返回类型中"><a href="#Optional应该仅仅用在返回类型中" class="headerlink" title="Optional应该仅仅用在返回类型中"></a>Optional应该仅仅用在返回类型中</h3><p>不要用在参数或者域中。<a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="noopener">阅读这篇博文</a>可以看到如何正确使用Optional进行编码。幸运的是，IntelliJ IDEA可以打开inspections去检查你是否遵循了这些推荐规范。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalParamWarning.png" alt="OptionalParamWarning.png"></p>
<p>要尽早在Optional出现的地方对它进行处理。IntelliJ IDEA会阻止Optional出现在你代码的各个地方，所以记住一定要在Optional出现的地方就对他进行处理。</p>
<p><img src="https://www.rowkey.me/images/blog_images/java8/OptionalUseImmediately.png" alt="OptionalUseImmediately.png"></p>
<h3 id="不能简单地调用get-方法"><a href="#不能简单地调用get-方法" class="headerlink" title="不能简单地调用get()方法"></a>不能简单地调用get()方法</h3><p>Optional是用来表示这个值是有可能为空的，让你做好应对的准备。因此，很重要的一点就是在使用这个值之前务必要检查其是否存在。简单地调用get方法而不是先调用isPresent可能会导致产生空指针异常。幸运的是，IntelliJ IDEA再一次提供了对此种方案的检查。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalGetWithoutIsPresent.png" alt="OptionalGetWithoutIsPresent.png"></p>
<h3 id="更加优雅的方案"><a href="#更加优雅的方案" class="headerlink" title="更加优雅的方案"></a>更加优雅的方案</h3><p>如下代码，isPresent和get当然能够解决这个问题。</p>
<p><img src="https://www.rowkey.me/images/blog_images/java8/OptionalSimple.png" alt="OptionalSimple.png"></p>
<p>但是这里有更加优雅的方式，你可以使用orElse来设置一个默认值。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalOrElse.png" alt="OptionalOrElse.png"></p>
<p>或者你可以使用orElseGet来设置当值为null的时候去调用的方法。虽然看着和前面的方案没有什么大的不同。但是提供的方法应该仅仅在需要调用的时候才被调用。那么当这是个代价昂贵的方法时，那么使用lambda会带来更好的性能提升。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/OptionalOrElseGet.png" alt="OptionalOrElseGet.png"></p>
<h2 id="使用Lambda表达式"><a href="#使用Lambda表达式" class="headerlink" title="使用Lambda表达式"></a>使用Lambda表达式</h2><p>Lambda表达式是Java8最主要的卖点。即使你现在用不到Java8，你也应该对它有了一些基本的了解。下面讲述了一种新的方式使用Java编程，虽然这并不是一个“最佳实践”，仅仅是一个使用的指导。</p>
<h3 id="保持简短"><a href="#保持简短" class="headerlink" title="保持简短"></a>保持简短</h3><p>函数式编程对于长的lambda表达式是欢迎的，但是对于仅仅使用Java开发很多年的人发现编写短的lambda表达式会更容易一些。你甚至会想把表达式缩减到一行，也很容易把长的表达式重构成一个方法。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExtractMethod.png" alt="LambdaExtractMethod.png"></p>
<p>当然，这些甚至牵扯到了方法引用(Method References)。方法引用可能看着有点陌生，但是由于其能让代码达到更好的阅读性，还是有很大应用价值的。后面，我会讲到这个概念。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaCollapseToMethodRef.png" alt="LambdaCollapseToMethodRef.png"></p>
<h3 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h3><p>在lambda表达式中是没有类型信息的，所以你会发现在参数中包含类型信息是非常有用的。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExplicitParamTypes.png" alt="LambdaExplicitParamTypes.png"></p>
<p>如你所见，这会变得很笨重。所以我更喜欢赋予参数有意义的名字。当然，无论你是否这么做，Intellij IDEA都会让你可以看到参数的类型信息。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaParamTypes.png" alt="LambdaParamTypes.png"></p>
<p>甚至lambda表示的函数接口也能看到。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterface.png" alt="LambdaFunctionalInterface.png"></p>
<h2 id="设计Lambda表达式"><a href="#设计Lambda表达式" class="headerlink" title="设计Lambda表达式"></a>设计Lambda表达式</h2><p>我认为lambda表达式有一点类似于泛型-我们会经常使用到泛型(例如，添加类型信息到List&lt;&gt;)，但是比较罕见的是我们去设计一个具有泛型的方法或者一个类(比如像Person<t>)。同样的，我们经常会在使用诸如Streams API的时候传递lambda，但是却很少会创建一个需要传递lambda参数的方法。</t></p>
<p>如果你发现自己处在这样一种境况，那么这里有一些提示。</p>
<h3 id="IntelliJ-IDEA能够帮助你引入函数参数"><a href="#IntelliJ-IDEA能够帮助你引入函数参数" class="headerlink" title="IntelliJ IDEA能够帮助你引入函数参数"></a>IntelliJ IDEA能够帮助你引入函数参数</h3><p>能够让你创建一个参数，这个参数是一个lambda而不是一个Object。这个特性的最好的一点就是它会智能建议一个匹配规格的已存在的函数接口。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaExtractFunctionalParameter.png" alt="LambdaExtractFunctionalParameter.png"></p>
<h3 id="使用存在的函数接口"><a href="#使用存在的函数接口" class="headerlink" title="使用存在的函数接口"></a>使用存在的函数接口</h3><p>随着开发者变得对Java8越来越熟悉，当使用Supplier和Consumer这些接口时，我们将会知道什么是我们所期望的，比如创建一个ErrorMessageCreator(例子)会是令人迷惑和浪费的。可以看一下<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">函数包</a>获取已经存在的那些函数接口。</p>
<h3 id="给你的函数接口添加-FunctionalInterface"><a href="#给你的函数接口添加-FunctionalInterface" class="headerlink" title="给你的函数接口添加@FunctionalInterface"></a>给你的函数接口添加@FunctionalInterface</h3><p>如果你确实需要创建自己的函数接口，那么用这个注解去标记它。看起来不需要这么做，但是Intellij IDEA会在你的函数接口没有符合规范时提示你。当没有方法实现这个接口时，它会提示你。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterfaceNoMethod.png" alt="LambdaFunctionalInterfaceNoMethod.png"></p>
<p>当方法太多时，也会提示你。</p>
<p><img src="https://www.rowkey.me/images/blog_images/java8/LambdaFunctionalInterfaceTooManyMethods.png" alt="LambdaFunctionalInterfaceTooManyMethods.png"></p>
<p>当你把注解应用到一个类而不是接口时，也会发出提醒。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/LambdaFunctionalInterfaceNotInterface.png" alt="LambdaFunctionalInterfaceNotInterface.png"></p>
<p>Lambda表达式可以被用在任何有一个Single Abstract Method的接口中，但是它不能够应用到一个抽象类中。看起来没有啥逻辑，但它就是这样的。</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">Stream API</a>是Java8另一个最大的卖点，我认为我们到现在还是没有真的搞清楚这会如何改变我们的代码。这里有一些我自己发现很有用的东西。</p>
<h3 id="将点号对齐"><a href="#将点号对齐" class="headerlink" title="将点号对齐"></a>将点号对齐</h3><p>我个人比较喜欢对齐Stream操作。当然，你不需要非得这么做，但是我发现这样还是有很大好处的。</p>
<ul>
<li>一眼就看到所有的操作以及他们的顺序</li>
<li>更容易调试(虽然Intellij IDEA提供了在一行中的lambda表达式中任意地方打断点的功能，但是将他们分隔成单独的行会更简单)</li>
<li>可以很容易地注释掉一些操作以供测试</li>
<li>很容易地插入peek()供调试或者测试</li>
</ul>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamWrappingExample.png" alt="StreamWrappingExample.png"></p>
<p>这样做也会让代码看起来很舒服。当然，如果这么做，会增加代码的行数。</p>
<p>你可以修改一下格式化设置使点号对齐。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamWrapping.png" alt="StreamWrapping.png"></p>
<h3 id="使用方法引用-Method-References"><a href="#使用方法引用-Method-References" class="headerlink" title="使用方法引用(Method References)"></a>使用方法引用(Method References)</h3><p>你可能需要一会儿才能习惯这个奇怪的语法。但是，当我们能够正确地使用，它确实能够提高程序的可阅读性。考虑下面的代码：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamSimpleFilter.png" alt="StreamSimpleFilter.png"></p>
<p>对比一下使用新引入的Objects类的辅助方法(helper methods)：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamMethodRefFilter.png" alt="StreamMethodRefFilter.png"></p>
<p>后面的代码能够更加明显地表明它想保存的值。IntelliJ IDEA会提示你何时一个lambda可以被替换成方法引用。</p>
<h3 id="当迭代一个集合，尽可能地使用Streams-API"><a href="#当迭代一个集合，尽可能地使用Streams-API" class="headerlink" title="当迭代一个集合，尽可能地使用Streams API"></a>当迭代一个集合，尽可能地使用Streams API</h3><p>使用新的集合方法：forEach。IDEA会提示你。</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamRepalceForWithForEach.png" alt="StreamRepalceForWithForEach.png"></p>
<p>使用Streams API相比起使用循环和if语句更加清晰明了。例如：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamBefore.png" alt="StreamBefore.png"></p>
<p>IDEA会建议重构为：</p>
<p><img src="/2020/02/11/Java8开发的4个小技巧/StreamAfter.png" alt="StreamAfter.png"></p>
<p>我做的性能测试表示这个重构是令人惊奇的-无论性能是不变、提升还是变差，都是不能被预测的。因此，当你的应用对性能要求很苛刻的话，重构的时候务必做好测试。</p>
<h3 id="当遍历数组时使用循环"><a href="#当遍历数组时使用循环" class="headerlink" title="当遍历数组时使用循环"></a>当遍历数组时使用循环</h3><p>使用Java8并不是意味着你必须到处都使用Stream和新的集合方法。IDEA会智能提示哪些地方可以转换为Stream操作，但是并不意味着你必须这么做。</p>
<p>特别是当遍历一个保存基本数据类型的小数组时，使用loop循环的性能是更加好的，而且更加可阅读(至少对哪些Stream的新手来说是这样的)。</p>
<p>以上的建议，并非是固定不变，也不是必须要遵守的。但是无论你倾向于继续使用loops做某些操作还是在能够使用的地方使用Stream API, 你都要做出你自己的决定。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p><img src="/2020/02/11/Java8开发的4个小技巧/640-1581423585086.webp" alt="img"></p>
<h3 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h3><p>一行执行语句的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure>
<p>如果有多行执行语句，可以加上 <code>{}</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;    <span class="keyword">return</span> x + y;&#125;</span><br></pre></td></tr></table></figure>
<p>转换成Lambda表达式有以下几种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定参数类型及</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="comment">// 指定参数类型，不指定</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y;</span><br><span class="line"><span class="comment">// 不指定参数类型和return，编译器会自动推断</span></span><br><span class="line">(x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure>
<h3 id="Lambda用途"><a href="#Lambda用途" class="headerlink" title="Lambda用途"></a>Lambda用途</h3><h4 id="1、只有一个抽象方法的函数式接口"><a href="#1、只有一个抽象方法的函数式接口" class="headerlink" title="1、只有一个抽象方法的函数式接口"></a>1、只有一个抽象方法的函数式接口</h4><p>Lambda表达式的目标类型是函数式接口，什么是函数式接口之后会讲。</p>
<p>下面拿创建线程来举例，用lambda表达式可以有以下几种写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;        </span><br><span class="line">		<span class="meta">@Override</span>        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">			System.out.println(<span class="string">"t1"</span>);        </span><br><span class="line">		&#125;    </span><br><span class="line">	&#125;).start();    </span><br><span class="line">	Runnable runnable = () -&gt; System.out.println(<span class="string">"t2"</span>);    </span><br><span class="line">	<span class="keyword">new</span> Thread(runnable).start();    </span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"t3"</span>)).start();    </span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; run(<span class="string">"t4"</span>)).start();    </span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;        </span><br><span class="line">		String str = <span class="string">"t5"</span>;        </span><br><span class="line">		System.out.println(str);    </span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1t2t3t4t5</span><br></pre></td></tr></table></figure>
<h4 id="2、集合批量操作"><a href="#2、集合批量操作" class="headerlink" title="2、集合批量操作"></a>2、集合批量操作</h4><p>下面打印list集合的两种写法是等价的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : list) &#123;    </span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">list.forEach((e) -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>
<h4 id="3、流操作"><a href="#3、流操作" class="headerlink" title="3、流操作"></a>3、流操作</h4><p>下面是流查询list集合中等于 <code>&quot;a&quot;</code>的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter((e) -&gt; <span class="string">"a"</span>.equals(e)).count();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/11/如何提高服务器的并发处理能力/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/11/如何提高服务器的并发处理能力/" itemprop="url">
                  如何提高服务器的并发处理能力
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-11 15:22:05" itemprop="dateCreated datePublished" datetime="2020-02-11T15:22:05+08:00">2020-02-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/架构设计/" itemprop="url" rel="index"><span itemprop="name">架构设计</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下内容为入门级介绍，意在对老技术作较全的总结而不是较深的研究。主要参考《构建高性能Web站点》一书。</p>
<h2 id="什么是服务器并发处理能力"><a href="#什么是服务器并发处理能力" class="headerlink" title="什么是服务器并发处理能力"></a>什么是服务器并发处理能力</h2><p>一台服务器在单位时间里能处理的请求越多，服务器的能力越高，也就是服务器并发处理能力越强</p>
<h2 id="有什么方法衡量服务器并发处理能力"><a href="#有什么方法衡量服务器并发处理能力" class="headerlink" title="有什么方法衡量服务器并发处理能力"></a>有什么方法衡量服务器并发处理能力</h2><h3 id="1-吞吐率"><a href="#1-吞吐率" class="headerlink" title="1. 吞吐率"></a><strong>1. 吞吐率</strong></h3><p>吞吐率，单位时间里服务器处理的最大请求数，单位req/s</p>
<p>从服务器角度，实际并发用户数的可以理解为服务器当前维护的代表不同用户的文件描述符总数，也就是并发连接数。</p>
<p>服务器一般会限制同时服务的最多用户数，比如apache的MaxClents参数。</p>
<p>这里再深入一下，对于服务器来说，服务器希望支持高吞吐率，对于用户来说，用户只希望等待最少的时间，显然，双方不能满足，所以双方利益的平衡点，就是我们希望的最大并发用户数。</p>
<h3 id="2-压力测试"><a href="#2-压力测试" class="headerlink" title="2. 压力测试"></a><strong>2. 压力测试</strong></h3><p>有一个原理一定要先搞清楚，假如100个用户同时向服务器分别进行10个请求，与1个用户向服务器连续进行1000次请求，对服务器的压力是一样吗？</p>
<p>实际上是不一样的，因对每一个用户，连续发送请求实际上是指发送一个请求并接收到响应数据后再发送下一个请求。</p>
<p>这样对于1个用户向服务器连续进行1000次请求, 任何时刻服务器的网卡接收缓冲区中只有1个请求，而对于100个用户同时向服务器分别进行10个请求，服务器的网卡接收缓冲区最多有100个等待处理的请求，显然这时的服务器压力更大。</p>
<p>压力测试前提考虑的条件</p>
<ul>
<li>并发用户数: 指在某一时刻同时向服务器发送请求的用户总数(HttpWatch)</li>
<li>总请求数</li>
<li>请求资源描述</li>
<li>请求等待时间(用户等待时间)</li>
<li>用户平均请求的等待时间</li>
<li>服务器平均请求处理的时间</li>
<li>硬件环境</li>
</ul>
<p>压力测试中关心的时间又细分以下2种:</p>
<ol>
<li>用户平均请求等待时间（这里暂不把数据在网络的传输时间，还有用户PC本地的计算时间计算入内）</li>
<li>服务器平均请求处理时间</li>
</ol>
<p>用户平均请求等待时间主要用于衡量服务器在一定并发用户数下，单个用户的服务质量；而服务器平均请求处理时间就是吞吐率的倒数。</p>
<p>一般来说，用户平均请求等待时间 = 服务器平均请求处理时间 * 并发用户数</p>
<h2 id="怎么提高服务器的并发处理能力"><a href="#怎么提高服务器的并发处理能力" class="headerlink" title="怎么提高服务器的并发处理能力"></a>怎么提高服务器的并发处理能力</h2><h3 id="1-提高CPU并发计算能力"><a href="#1-提高CPU并发计算能力" class="headerlink" title="1. 提高CPU并发计算能力"></a><strong>1. 提高CPU并发计算能力</strong></h3><p>服务器之所以可以同时处理多个请求，在于操作系统通过多执行流体系设计使得多个任务可以轮流使用系统资源。</p>
<p>这些资源包括CPU，内存以及I/O. 这里的I/O主要指磁盘I/O, 和网络I/O。</p>
<h5 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程 &amp; 多线程"></a><strong>多进程 &amp; 多线程</strong></h5><p>多执行流的一般便是进程，多进程的好处可以对CPU时间的轮流使用，对CPU计算和IO操作重叠利用。这里的IO主要是指磁盘IO和网络IO，相对CPU而言，它们慢的可怜。</p>
<p>而实际上，大多数进程的时间主要消耗在I/O操作上。</p>
<p>现代计算机的DMA技术可以让CPU不参与I/O操作的全过程，比如进程通过系统调用，使得CPU向网卡或者磁盘等I/O设备发出指令，然后进程被挂起，释放出CPU资源，等待I/O设备完成工作后通过中断来通知进程重新就绪。</p>
<p>对于单任务而言，CPU大部分时间空闲，这时候多进程的作用尤为重要。</p>
<p>多进程不仅能够提高CPU的并发度。其优越性还体现在独立的内存地址空间和生命周期所带来的稳定性和健壮性，其中一个进程崩溃不会影响到另一个进程。</p>
<p>但是进程也有如下<strong>缺点</strong>：</p>
<ol>
<li>fork()系统调用开销很大: prefork</li>
<li>进程间调度和上下文切换成本: 减少进程数量</li>
<li>庞大的内存重复：共享内存</li>
<li>IPC编程相对比较麻烦</li>
</ol>
<h4 id="减少进程切换"><a href="#减少进程切换" class="headerlink" title="减少进程切换"></a><strong>减少进程切换</strong></h4><p>当硬件上下文频繁装入和移出时，所消耗的时间是非常可观的。可用Nmon工具监视服务器每秒的上下文切换次数。</p>
<p>为了尽量减少上下文切换次数，最简单的做法就是减少进程数，尽量使用线程并配合其它I/O模型来设计并发策略。</p>
<p>还可以考虑使用进程绑定CPU技术，增加CPU缓存的命中率。若进程不断在各CPU上切换，这样旧的CPU缓存就会失效。</p>
<h4 id="减少使用不必要的锁"><a href="#减少使用不必要的锁" class="headerlink" title="减少使用不必要的锁"></a><strong>减少使用不必要的锁</strong></h4><p>服务器处理大量并发请求时，多个请求处理任务时存在一些资源抢占竞争，这时一般采用“锁”机制来控制资源的占用。到底<code>什么是重入锁</code>附录内容推荐大家看下。</p>
<p>当一个任务占用资源时，我们锁住资源，这时其它任务都在等待锁的释放，这个现象称为<strong>锁竞争</strong>。</p>
<p>通过锁竞争的本质，我们要意识到尽量减少并发请求对于共享资源的竞争。</p>
<p>比如在允许情况下关闭服务器访问日志，这可以大大减少在锁等待时的延迟时间。要最大程度减少无辜的等待时间。</p>
<p>这里说下无锁编程，就是由内核完成这个锁机制，主要是使用原子操作替代锁来实现对共享资源的访问保护。</p>
<p>使用原子操作时，在进行实际的写操作时，使用了lock指令，这样就可以阻止其他任务写这块内存，避免出现数据竞争现象。<strong>原子操作速度比锁快，一般要快一倍以上</strong>。</p>
<p>例如fwrite(), fopen()，其是使用append方式写文件，其原理就是使用了无锁编程，无锁编程的复杂度高，但是效率快，而且发生死锁概率低。</p>
<h4 id="考虑进程优先级"><a href="#考虑进程优先级" class="headerlink" title="考虑进程优先级"></a><strong>考虑进程优先级</strong></h4><p>进程调度器会动态调整运行队列中进程的优先级，通过top观察进程的PR值</p>
<h4 id="考虑系统负载"><a href="#考虑系统负载" class="headerlink" title="考虑系统负载"></a><strong>考虑系统负载</strong></h4><p>可在任何时刻查看/proc/loadavg, top中的load average也可看出</p>
<h4 id="考虑CPU使用率"><a href="#考虑CPU使用率" class="headerlink" title="考虑CPU使用率"></a><strong>考虑CPU使用率</strong></h4><p>除了用户空间和内核空间的CPU使用率以外，还要关注I/O wait,它是指CPU空闲并且等待I/O操作完成的时间比例（top中查看wa的值）。</p>
<h3 id="2-考虑减少内存分配和释放"><a href="#2-考虑减少内存分配和释放" class="headerlink" title="2. 考虑减少内存分配和释放"></a><strong>2. 考虑减少内存分配和释放</strong></h3><p>服务器的工作过程中，需要大量的内存，使得内存的分配和释放工作尤为重要。</p>
<p>可以通过改善数据结构和算法复制度来适当减少中间临时变量的内存分配及数据复制时间，而服务器本身也使用了各自的策略来提高效率。</p>
<p>例如Apache,在运行开始时一次申请大片的内存作为内存池，若随后需要时就在内存池中直接获取，不需要再次分配，避免了频繁的内存分配和释放引起的内存整理时间。</p>
<p>再如Nginx使用多线程来处理请求，使得多个线程之间可以共享内存资源，从而令它的内存总体使用量大大减少。</p>
<p>另外，Nginx分阶段的内存分配策略，按需分配，及时释放，使得内存使用量保持在很小的数量范围。</p>
<p>另外，还可以考虑<strong>共享内存</strong>。</p>
<p>共享内存指在多处理器的计算机系统中，可以被不同中央处理器（CPU）访问的大容量内存，也可以由不同进程共享，是非常快的进程通信方式。</p>
<p>但是使用共享内存也有不好的地方，就是对于多机器时数据不好统一。</p>
<p>shell命令ipcs可用来显示系统下共享内存的状态，函数shmget可以创建或打开一块共享内存区，函数shmat将一个存在的共享内存段连接到本进程空间, 函数shmctl可以对共享内存段进行多种操作，函数shmdt函数分离该共享内存。</p>
<h3 id="3-考虑使用持久连接"><a href="#3-考虑使用持久连接" class="headerlink" title="3. 考虑使用持久连接"></a><strong>3. 考虑使用持久连接</strong></h3><p>持久连接也为<strong>长连接</strong>，它本身是TCP通信的一种普通方式，即在一次TCP连接中持续发送多分数据而不断开连接。</p>
<p>与它相反的方式称为<strong>短连接</strong>，也就是建立连接后发送一份数据就断开，然后再次建立连接发送下一份数据， 周而复始。</p>
<p>是否采用持久连接，完全取决于应用特点。</p>
<p>从性能角度看，建立TCP连接的操作本身是一项不小的开销，在允许的情况下，连接次数越少，越有利于性能的提升; 尤其对于密集型的图片或网页等小数据请求处理有明显的加速所用。</p>
<p>HTTP长连接需要浏览器和web服务器的共同协作，目前浏览器普遍支持长连接，表现在其发出的HTTP请求数据头中包含关于长连接的声明，如下：Connection: Keep-Alive</p>
<p>主流的web服务器都支持长连接，比如apache中，可以用KeepAlive off关闭长连接。</p>
<p>对于长连接的有效使用，还有关键一点在于长连接超时时间的设置，即长连接在什么时候关闭吗？</p>
<p>Apache的默认设置为5s, 若这个时间设置过长，则可能导致资源无效占有，维持大量空闲进程，影响服务器性能。</p>
<h3 id="4-改进I-O-模型"><a href="#4-改进I-O-模型" class="headerlink" title="4. 改进I/O 模型"></a><strong>4. 改进I/O 模型</strong></h3><p>I/O操作根据设备的不同分为很多类型，比如内存I/O, 网络I/O, 磁盘I/O。</p>
<p>对于网络I/O和磁盘I/O, 它们的速度要慢很多，尽管使用RAID磁盘阵列可通过并行磁盘磁盘来加快磁盘I/O速度，购买大连独享网络带宽以及使用高带宽网络适配器可以提高网络I/O的速度。</p>
<p>但这些I/O操作需要内核系统调用来完成，这些需要CPU来调度，这使得CPU不得不浪费宝贵的时间来等待慢速I/O操作。</p>
<p>我们希望让CPU足够少的时间在i/O操作的调度上，如何让高速的CPU和慢速的I/O设备更好地协调工作，是现代计算机一直探讨的话题。各种I/O模型的本质区别在于CPU的参与方式。</p>
<h4 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a><strong>DMA技术</strong></h4><p>I/O设备和内存之间的数据传输方式由DMA控制器完成。在DMA模式下，CPU只需向DMA下达命令，让DMA控制器来处理数据的传送，这样可以大大节省系统资源。</p>
<h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a><strong>异步I/O</strong></h4><p>异步I/O指主动请求数据后便可以继续处理其它任务，随后等待I/O操作的通知，这样进程在数据读写时不发生阻塞。</p>
<p>异步I/O是非阻塞的，当函数返回时，真正的I/O传输已经完成，这让CPU处理和I/O操作达到很好的重叠。</p>
<h4 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a><strong>I/O多路复用</strong></h4><p>epoll服务器同时处理大量的文件描述符是必不可少的，若采用同步非阻塞I/O模型，若同时接收TCP连接的数据，就必须轮流对每个socket调用接收数据的方法，不管这些socket有没有可接收的数据，都要询问一次。</p>
<p>假如大部分socket并没有数据可以接收，那么进程便会浪费很多CPU时间用于检查这些socket有没有可以接收的数据。</p>
<p>多路I/O就绪通知的出现，提供了对大量文件描述符就绪检查的高性能方案，它允许进程通过一种方法同时监视所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。</p>
<p>epoll可以同时支持水平触发和边缘触发，理论上边缘触发性能更高，但是代码实现复杂，因为任何意外的丢失事件都会造成请求处理错误。</p>
<p>epoll主要有2大改进：</p>
<ol>
<li><p>epoll只告知就绪的文件描述符，而且当调用epoll_wait()获得文件描述符时，返回并不是实际的描述符，而是一个代表就绪描述符数量的值，然后只需去epoll指定的一个数组中依次取得相应数量的文件描述符即可。</p>
<p>这里使用了内存映射(mmap)技术，这样彻底省掉了这些文件描述符在系统调用时复制的开销。</p>
</li>
<li><p>epoll采用基于事件的就绪通知方式。其事先通过epoll_ctrl()注册每一个文件描述符，一旦某个文件描述符就绪时，内核会采用类似callback的回调机制，当进程调用epoll_wait()时得到通知</p>
</li>
</ol>
<p>关于IO模型，可以参考笔者前面写的相关文章Java NIO.2；关于epoll，可以参考笔者前面写的文章select、poll和epoll简介。</p>
<h4 id="Sendfile"><a href="#Sendfile" class="headerlink" title="Sendfile"></a><strong>Sendfile</strong></h4><p>大多数时候，我们都向服务器请求静态文件，比如图片，样式表等。</p>
<p>在处理这些请求时，磁盘文件的数据先经过内核缓冲区，然后到用户内存空间，不需经过任何处理，其又被送到网卡对应的内核缓冲区，接着再被送入网卡进行发送。</p>
<p>Linux提供sendfile()系统调用，可以讲磁盘文件的特定部分直接传送到代表客户端的socket描述符，加快了静态文件的请求速度，同时减少CPU和内存的开销。</p>
<p>适用场景：对于请求较小的静态文件，sendfile发挥的作用不那么明显，因发送数据的环节在整个过程中所占时间的比例相比于大文件请求时小很多。</p>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a><strong>内存映射</strong></h4><p>Linux内核提供一种访问磁盘文件的特殊方式，它可以将内存中某块地址空间和我们指定的磁盘文件相关联，从而对这块内存的访问转换为对磁盘文件的访问。这种技术称为<strong>内存映射</strong>。</p>
<p>多数情况下，内存映射可以提高磁盘I/O的性能，无须使用read()或write()等系统调用来访问文件，而是通过mmap()系统调用来建立内存和磁盘文件的关联，然后像访问内存一样自由访问文件。</p>
<p><strong>缺点</strong>：在处理较大文件时，内存映射会导致较大的内存开销，得不偿失。</p>
<h4 id="直接I-O"><a href="#直接I-O" class="headerlink" title="直接I/O"></a><strong>直接I/O</strong></h4><p>在linux 2.6中，内存映射和直接访问文件没有本质差异，因为数据需要经过2次复制，即在磁盘与内核缓冲区之间以及在内核缓冲区与用户态内存空间。</p>
<p>引入内核缓冲区的目的在于<strong>提高磁盘文件的访问性能</strong>，然而对于一些复杂的应用，比如数据库服务器，它们为了进一步提高性能，希望绕过内核缓冲区，由自己在用户态空间实现并管理I/O缓冲区，比如数据库可根据更加合理的策略来提高查询缓存命中率。</p>
<p>另一方面，绕过内核缓冲区也可以减少系统内存的开销，因内核缓冲区本身就在使用系统内存。</p>
<p>Linux在open()系统调用中增加参数选项O_DIRECT,即可绕过内核缓冲区直接访问文件,实现直接I/O。</p>
<p>在Mysql中，对于Innodb存储引擎，自身进行数据和索引的缓存管理，可在my.cnf配置中分配raw分区跳过内核缓冲区，实现直接I/O。</p>
<h3 id="5-改进服务器并发策略"><a href="#5-改进服务器并发策略" class="headerlink" title="5. 改进服务器并发策略"></a><strong>5. 改进服务器并发策略</strong></h3><p>服务器并发策略的目的，是让I/O操作和CPU计算尽量重叠进行，一方面让CPU在I/O等待时不要空闲，另一方面让CPU在I/O调度上尽量花最少的时间。</p>
<h4 id="一个进程处理一个连接，非阻塞I-O"><a href="#一个进程处理一个连接，非阻塞I-O" class="headerlink" title="一个进程处理一个连接，非阻塞I/O"></a><strong>一个进程处理一个连接，非阻塞I/O</strong></h4><p>这样会存在多个并发请求同时到达时，服务器必然要准备多个进程来处理请求。其进程的开销限制了它的并发连接数。</p>
<p>但从稳定性和兼容性的角度，则其相对安全，任何一个子进程的崩溃不会影响服务器本身，父进程可以创建新的子进程；这种策略典型的例子就是Apache的fork和prefork模式。</p>
<p>对于并发数不高（如150以内）的站点同时依赖Apache其它功能时的应用选择Apache还是可以的。</p>
<h4 id="一个线程处理一个连接，非阻塞IO"><a href="#一个线程处理一个连接，非阻塞IO" class="headerlink" title="一个线程处理一个连接，非阻塞IO"></a><strong>一个线程处理一个连接，非阻塞IO</strong></h4><p>这种方式允许在一个进程中通过多个线程来处理多个连接，一个线程处理一个连接。Apache的worker模式就是这种典型例子，使其可支持更多的并发连接。不过这种模式的总体性能还不如prefork，所以一般不选用worker模式。</p>
<h4 id="一个进程处理多个连接，异步I-O"><a href="#一个进程处理多个连接，异步I-O" class="headerlink" title="一个进程处理多个连接，异步I/O"></a><strong>一个进程处理多个连接，异步I/O</strong></h4><p>一个线程同时处理多个连接，潜在的前提条件就是使用IO多路复用就绪通知。</p>
<p>这种情况下，将处理多个连接的进程叫做worker进程或服务进程。worker的数量可以配置，如Nginx中的worker_processes 4。</p>
<h4 id="一个线程处理多个连接，异步IO"><a href="#一个线程处理多个连接，异步IO" class="headerlink" title="一个线程处理多个连接，异步IO"></a><strong>一个线程处理多个连接，异步IO</strong></h4><p>即使有高性能的IO多路复用就绪通知，但磁盘IO的等待还是无法避免的。更加高效的方法是对磁盘文件使用异步IO，目前很少有Web服务器真正意义上支持这种异步IO。</p>
<h3 id="6-改进硬件环境"><a href="#6-改进硬件环境" class="headerlink" title="6. 改进硬件环境"></a><strong>6. 改进硬件环境</strong></h3><p>还有一点要提及的是硬件环境，服务器的硬件配置对应用程序的性能提升往往是最直接，也是最简单的方式，这就是所谓的scale up。这里不做论述。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h3><blockquote>
<p>java.util.concurrent.locks.ReentrantLock</p>
</blockquote>
<p>这个是 JDK @since 1.5 添加的一种颗粒度更小的锁，它完全可以替代 synchronized 关键字来实现它的所有功能，而且 ReentrantLock 锁的灵活度要远远大于 synchronized 关键字。</p>
<p><img src="/2020/02/11/如何提高服务器的并发处理能力/640.webp" alt="img"></p>
<p>从类结构图看出，ReentrantLock 实现了 Lock 接口，ReentrantLock 只是 Lock 接口的一个实现而已。</p>
<blockquote>
<p>java.util.concurrent.locks.Lock</p>
</blockquote>
<p>它们都是 java.util.concurrent 包里面的内容（俗称 JUC、并发包），也都是 JDK 1.5 开始加入的。</p>
<h3 id="为什么叫重入锁呢？"><a href="#为什么叫重入锁呢？" class="headerlink" title="为什么叫重入锁呢？"></a>为什么叫重入锁呢？</h3><p><code>ReentrantLock</code>，我们把它拆开来看就明了了。</p>
<p>Re-Entrant-Lock：即表示可重新反复进入的锁，但仅限于当前线程；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如示例代码所示，当前线程可以反复加锁，但也需要释放同样加锁次数的锁，即重入了多少次，就要释放多少次，不然也会导入锁不被释放。</p>
<p>试想一下，如果不设计成可重入锁，那自己如果反复给自己加锁，不是会把自己加死锁了吗？所以，到现在，重入锁的概念大概应该清楚了吧？</p>
<h3 id="重入锁最重要的几个方法"><a href="#重入锁最重要的几个方法" class="headerlink" title="重入锁最重要的几个方法"></a>重入锁最重要的几个方法</h3><p>这几个方法都是 Lock 接口中定义的：</p>
<p><img src="/2020/02/11/如何提高服务器的并发处理能力/640.webp" alt="img"></p>
<p><strong>1）lock()</strong></p>
<p>获取锁，有以下三种情况：</p>
<ul>
<li>锁空闲：直接获取锁并返回，同时设置锁持有者数量为：1；</li>
<li>当前线程持有锁：直接获取锁并返回，同时锁持有者数量递增1；</li>
<li>其他线程持有锁：当前线程会休眠等待，直至获取锁为止；</li>
</ul>
<p><strong>2）lockInterruptibly()</strong></p>
<p>获取锁，逻辑和 lock() 方法一样，但这个方法在获取锁过程中能响应中断。</p>
<p><strong>3）tryLock()</strong></p>
<p>从关键字字面理解，这是在尝试获取锁，获取成功返回：true，获取失败返回：false, 这个方法不会等待，有以下三种情况：</p>
<ul>
<li>锁空闲：直接获取锁并返回：true，同时设置锁持有者数量为：1；</li>
<li>当前线程持有锁：直接获取锁并返回：true，同时锁持有者数量递增1；</li>
<li>其他线程持有锁：获取锁失败，返回：false；</li>
</ul>
<p><strong>4）tryLock(long timeout, TimeUnit unit)</strong></p>
<p>逻辑和 tryLock() 差不多，只是这个方法是带时间的。</p>
<p><strong>5）unlock()</strong></p>
<p>释放锁，每次锁持有者数量递减 1，直到 0 为止。所以，现在知道为什么 lock 多少次，就要对应 unlock 多少次了吧。</p>
<p><strong>6）newCondition</strong></p>
<p>返回一个这个锁的 Condition 实例，可以实现 synchronized 关键字类似 wait/ notify 实现多线程通信的功能，不过这个比 wait/ notify 要更灵活，更强大！</p>
<h3 id="重入锁大概的用法"><a href="#重入锁大概的用法" class="headerlink" title="重入锁大概的用法"></a>重入锁大概的用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ... method body</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>看见没有，加锁和释放锁都在方法里面进行，可以自由控制，比 synchronized 更灵活，更方便。但要注意的是，释放锁操作必须在 finally 里面，不然如果出现异常导致锁不能被正常释放，进而会卡死后续所有访问该锁的线程。</p>
<h3 id="synchronized-是重入锁吗？"><a href="#synchronized-是重入锁吗？" class="headerlink" title="synchronized 是重入锁吗？"></a>synchronized 是重入锁吗？</h3><p>那么问题来了，synchronized 是重入锁吗？</p>
<p>你可能会说不是，因为 ReentrantLock 既然是重入锁，根据推理，相反，那 synchronized 肯定就不是重入锁，那你就错了。</p>
<p>答案是：yes，为什么？看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>operation 方法调用了 add 方法，两个方法都是用 synchronized 修饰的，add()  方法可以成功获取当前线程 operation() 方法已经获取到的锁，说明 synchronized 就是可重入锁。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/06/分布式基础要点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/分布式基础要点/" itemprop="url">
                  分布式基础要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-06 20:20:12" itemprop="dateCreated datePublished" datetime="2020-02-06T20:20:12+08:00">2020-02-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-24 21:34:27" itemprop="dateModified" datetime="2020-02-24T21:34:27+08:00">2020-02-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/架构设计/" itemprop="url" rel="index"><span itemprop="name">架构设计</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a><strong>模型</strong></h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h4><p>在具体的工程项目中，一个节点往往是一个操作系统上的进程。在本文的模型中，认为节点是一个完整的、不可分的整体，如果某个程序进程实际上由若干相对独立部分构成，则在模型中可以将一个进程划分为多个节点。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><ol>
<li><strong>机器宕机</strong>：机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</li>
<li><strong>网络异常</strong>：消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</li>
<li><strong>分布式三态</strong>：如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</li>
<li><strong>存储数据丢失</strong>:对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。</li>
<li><strong><em>异常处理原则\</em></strong>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</li>
</ol>
<h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a><strong>副本</strong></h3><p>副本（replica/copy）指在分布式系统中为数据或服务提供的冗余。对于数据副本指在不同的节点上持久化同一份数据，当出现某一个节点的存储的数据丢失时，可以从副本上读到数据。数据副本是分布式系统解决数据丢失异常的唯一手段。另一类副本是服务副本，指数个节点提供某种相同的服务，这种服务一般并不依赖于节点的本地存储，其所需数据一般来自其他节点。</p>
<p>副本协议是贯穿整个分布式系统的理论核心。</p>
<h4 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a><strong>副本一致性</strong></h4><p>分布式系统通过副本控制协议，使得从系统外部读取系统内部各个副本的数据在一定的约束条件下相同，称之为副本一致性(consistency)。副本一致性是针对分布式系统而言的，不是针对某一个副本而言。</p>
<ol>
<li><strong>强一致性(strong consistency)</strong>：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。</li>
<li><strong>单调一致性(monotonic consistency)</strong>：任何时刻，任何用户一旦读到某个数据在某次更新后的值，这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。</li>
<li><strong>会话一致性(session consistency)</strong>：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的概念，例如php 中的session 概念。</li>
<li><strong>最终一致性(eventual consistency)</strong>：最终一致性要求一旦更新成功，各个副本上的数据最终将达 到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的副本，则无法保障任何一致性。</li>
<li><strong>弱一致性(week consistency)</strong>：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。</li>
</ol>
<h3 id="衡量分布式系统的指标"><a href="#衡量分布式系统的指标" class="headerlink" title="衡量分布式系统的指标"></a><strong>衡量分布式系统的指标</strong></h3><ol>
<li><strong>性能</strong>：系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</li>
<li><strong>可用性</strong>：系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</li>
<li><strong>可扩展性</strong>：系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</li>
<li><strong>一致性</strong>：分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单。</li>
</ol>
<h2 id="分布式系统原理"><a href="#分布式系统原理" class="headerlink" title="分布式系统原理"></a><strong>分布式系统原理</strong></h2><h3 id="数据分布方式"><a href="#数据分布方式" class="headerlink" title="数据分布方式**"></a>数据分布方式**</h3><p>所谓分布式系统顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计算、存储等问题。单机系统与分布式系统的最大的区别在于问题的规模，即计算、存储的数据量的区别。将一个单机问题使用分布式解决，首先要解决的就是如何将问题拆解为可以使用多机分布式解决，使得分布式系统中的每台机器负责原问题的一个子集。由于无论是计算还是存储，其问题输入对象都是数据，所以如何拆解分布式系统的输入数据成为分布式系统的基本问题。</p>
<h4 id="哈希方式"><a href="#哈希方式" class="headerlink" title="哈希方式"></a><strong>哈希方式</strong></h4><p><img src="/2020/02/06/分布式基础要点/image-20200206203106202.png" alt="image-20200206203106202"></p>
<p>哈希分布数据的缺点同样明显，突出表现为可扩展性不高，一旦集群规模需要扩展，则几乎所有的数据需要被迁移并重新分布。工程中，扩展哈希分布数据的系统时，往往使得集群规模成倍扩展，按照数据重新计算哈希，这样原本一台机器上的数据只需迁移一半到另一台对应的机器上即可完成扩展。</p>
<p>针对哈希方式扩展性差的问题，一种思路是不再简单的将哈希值与机器做除法取模映射，而是将对应关系作为元数据由专门的元数据服务器管理.同时，哈希值取模个数往往大于机器个数，这样同一台机器上需要负责多个哈希取模的余数。但需要以较复杂的机制维护大量的元数据。哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题。</p>
<p>哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200207095335209.png" alt="image-20200207095335209"></p>
<h4 id="按数据范围分布"><a href="#按数据范围分布" class="headerlink" title="按数据范围分布"></a><strong>按数据范围分布</strong></h4><p>按数据范围分布是另一个常见的数据分布式，将数据按特征值的值域范围划分为不同的区间，使得集群中每台（组）服务器处理不同区间的数据。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203344509.png" alt="image-20200206203344509"></p>
<p>工程中，为了数据迁移等负载均衡操作的方便，往往利用动态划分区间的技术，使得每个区间中服务的数据量尽量的一样多。当某个区间的数据量较大时，通过将区间“分裂”的方式拆分为两个区间，使得每个数据区间中的数据量都尽量维持在一个较为固定的阈值之下。</p>
<p>一般的，往往需要使用专门的服务器在内存中维护数据分布信息，称这种数据的分布信息为一种元信息。甚至对于大规模的集群，由于元信息的规模非常庞大，单台 计算机无法独立维护，需要使用多台机器作为元信息服务器。</p>
<h4 id="按数据量分布"><a href="#按数据量分布" class="headerlink" title="按数据量分布"></a><strong>按数据量分布</strong></h4><p>数据量分布数据与具体的数据特征无关，而是将数据视为一个顺序增长的文件，并将这个文件按照某一较为固定的大小划分为若干数据块（chunk），不同的数据块分布到不同的服务器上。与按数据范围分布数据的方式类似的是，按数据量分布数据也需要记录数据块的具体分布情况，并将该分布信息作为元数据使用元数据服务器管理。</p>
<p>由于与具体的数据内容无关，按数据量分布数据的方式一般没有数据倾斜的问题，数据总是被均匀切分并分布到集群中。当集群需要重新负载均衡时，只需通过迁移数据块即可完成。集群扩容也没有太大的限制，只需将部分数据库迁移到新加入的机器上即可以完成扩容。按数据量划分数据的缺点是需要管理较为复杂的元信息，与按范围分布数据的方式类似，当集群规模较大时，元信息的数据量也变得很大，高效的管理元信息成为新的课题。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a><strong>一致性哈希</strong></h4><p>一致性哈希（consistent hashing）是另一个种在工程中使用较为广泛的数据分布方式。一致性哈希最初在P2P 网络中作为分布式哈希表（DHT）的常用数据分布算法。一致性哈希的基本方式是使用一个哈希函数计算数据或数据特征的哈希值，令该哈希函数的输出值域为一个封闭的环，即哈希函数输出的最大值是最小值的前序。将节点随机分布到这个环上，每个节点负责处理从自己开始顺时针至下一个节点的全部哈希值域上的数据。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203409796.png" alt="image-20200206203409796"></p>
<p>使用一致性哈希的方式需要将节点在一致性哈希环上的位置作为元信息加以管理，这点比直接使用哈希分布数据的方式要复杂。然而，节点的位置信息只于集群中的机器规模相关，其元信息的量通常比按数据范围分布数据和按数据量分布数据的元信息量要小很多。</p>
<p>为此一种常见的改进算法是引入虚节点（virtual node）的概念，系统初始时就创建许多虚节点，虚节点的个数一般远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希值域环上，其功能与基本一致性哈希算法中的节点相同。为每个节点分配若干虚节点。操作数据时，首先通过数据的哈希值在环上找到对应的虚节点，进而查找元数据找到对应的真实节点。使用虚节点改进有多个优点。首先，一旦某个节点不可用，该节点将使得多个虚节点不可用，从而使得多个相邻的真实节点负载失效节点的压里。同理，一旦加入一个新节点，可以分配多个虚节点，从而使得新节点可以 负载多个原有节点的压力，从全局看，较容易实现扩容时的负载均衡。</p>
<h4 id="副本与数据分布"><a href="#副本与数据分布" class="headerlink" title="副本与数据分布"></a><strong>副本与数据分布</strong></h4><p>分布式系统容错、提高可用性的基本手段就是使用副本。对于数据副本的分布方式主要影响系统的可扩展性。一种基本的数据副本策略是以机器为单位，若干机器互为副本，副本机器之间的数据完全相同。这种策略适用于上述各种数据分布方式。其优点是非常简单，其缺点是恢复数据的效率不高、可扩展性也不高。</p>
<p>更合适的做法不是以机器作为副本单位，而是将数据拆为较合理的数据段，以数据段为单位作为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小以内。数据段有很多不同的称谓，segment，fragment，chunk，partition 等等。数据段的选择与数据分布方式直接相关。对于哈希分数据的方式，每个哈希分桶后的余数可以作为一个数据段，为了控制数据段的大小，常常使得分桶个数大于集群规模。一旦将数据分为数据段，则可以以数据段为单位管理副本，从而副本与机器不再硬相关，每台机器都可以负责一定数据段的副本。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203433498.png" alt="image-20200206203433498"></p>
<p>一旦副本分布与机器无关，数据丢失后的恢复效率将非常高。这是因为，一旦某台机器的数据丢失，其上数据段的副本将分布在整个集群的所有机器中，而不是仅在几个副本机器中，从而可以从整个集群同时拷贝恢复数据，而集群中每台数据源机器都可以以非常低的资源做拷贝。作为恢复数据源的机器即使都限速1MB/s，若有100 台机器参与恢复，恢复速度也能达到100MB/s。再者，副本分布与机器无关也利于集群容错。如果出现机器宕机，由于宕机机器上的副本分散于整个集群，其压力也自然分散到整个集群。最后，副本分布与机器无关也利于集群扩展。理论上，设集群规模 为N 台机器，当加入一台新的机器时，只需从各台机器上迁移1/N – 1/N+1 比例的数据段到新机器即实现了新的负载均衡。由于是从集群中各机器迁移数据，与数据恢复同理，效率也较高。工程中，完全按照数据段建立副本会引起需要管理的元数据的开销增大，副本维护的难度也相应增大。一种折中的做法是将某些数据段组成一个数据段分组，按数据段分组为粒度进行副本管理。这样做可以将副本粒度控制在一个较为合适的范围内。</p>
<h4 id="本地化计算"><a href="#本地化计算" class="headerlink" title="本地化计算"></a><strong>本地化计算</strong></h4><p>在分布式系统中，数据的分布方式也深深影响着计算的分布方式。在分布式系统中计算节点和保存计算数据的存储节点可以在同一台物理机器上，也可以位于不同的物理机器。如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此种方式的开销很大，甚至网络带宽会成为系统的总体瓶颈。另一种思路是，将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一种重要优化，其体现了一种重要的分布式调度思想：“移动数据不如移动计算”。</p>
<h4 id="数据分布方式的选择"><a href="#数据分布方式的选择" class="headerlink" title="数据分布方式的选择"></a><strong>数据分布方式的选择</strong></h4><p>在实际工程实践中，可以根据需求及实施复杂度合理选择数据分布方式。另外，数据分布方式是可以灵活组合使用的，往往可以兼备各种方式的优点，收到较好的综合效果。</p>
<p>例：数据倾斜问题，在按哈希分数据的基础上引入按数据量分布数据的方式，解决该数据倾斜问题。按用户id 的哈希值分数据，当某个用户id 的数据量特别大时，该用户的数据始终落在某一台机器上。此时，引入按数据量分布数据的方式，统计用户的数据量，并按某一阈值将用户的数据切为多个均匀的数据段，将这些数据段分布到集群中去。由于大部分用户的数据量不会超过阈值，所以元数据中仅仅保存超过阈值的用户的数据段分布信息，从而可以控制元数据的规模。这种哈希分布数据方式与按数据量分布数据方式组合使用的方案，在某真实系统中使用，取得了较好的效果。</p>
<h3 id="基本副本协议"><a href="#基本副本协议" class="headerlink" title="基本副本协议"></a><strong>基本副本协议</strong></h3><p>副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一致性要求的分布式协议。副本控制协议要具有一定的对抗异常状态的容错能力，从而使得系统具有一定的可用性，同时副本控制协议要能提供一定一致性级别。由CAP 原理（在2.9 节详细分析）可知，要设计一种满足强一致性，且在出现任何网络异常时都可用的副本协议是不可能的。为此，实际中的副本控制协议总是在可用性、一致性与性能等各要素之间按照具体需求折中。</p>
<p>副本控制协议可以分为两大类：“中心化(centralized)副本控制协议”和“去中心化(decentralized)副本控制协议”。</p>
<h4 id="中心化副本控制协议"><a href="#中心化副本控制协议" class="headerlink" title="中心化副本控制协议"></a><strong>中心化副本控制协议</strong></h4><p>中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之间的一致性。图给出了中心化副本协议的通用架构。中心化副本控制协议的优点是协议相对较为简单，所有的副本相关的控制交由中心节点完成。并发控制将由中心节点完成，从而使得一个分布式并发控制问题，简化为一个单机并发控制问题。所谓并发控制，即多个节点同时需要修改副本数据时，需要解决“写写”、“读写”等并发冲突。单机系统上常用加锁等方式进行并发控制。对于分布式并发控制，加锁也是一个常用的方法，但如果没有中心节点统一进行锁管理，就需要完全分布式化的锁系统，会使得协议非常复杂。中心化副本控制协议的缺点是系统的可用性依赖于中心化节点，当中心节点异常或与中心节点通信中断时，系统将失去某些服务（通常至少失去更新服务），所以中心化副本控制协议的缺点正是存在一定的停服务时间。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203512899.png" alt="image-20200206203512899"></p>
<h4 id="primary-secondary-协议"><a href="#primary-secondary-协议" class="headerlink" title="primary-secondary 协议"></a><strong>primary-secondary 协议</strong></h4><p>在primary-secondary 类型的协议中，副本被分为两大类，其中有且仅有一个副本作为primary 副本，除primary 以外的副本都作为secondary 副本。维护primary 副本的节点作为中心节点，中心节点负责维护数据的更新、并发控制、协调副本的一致性。</p>
<p>Primary-secondary 类型的协议一般要解决四大类问题：数据更新流程、数据读取方式、Primary 副本的确定和切换、数据同步（reconcile）。</p>
<h5 id="数据更新基本流程"><a href="#数据更新基本流程" class="headerlink" title="数据更新基本流程"></a>数据更新基本流程</h5><ol>
<li>数据更新都由primary 节点协调完成。</li>
<li>外部节点将更新操作发给primary 节点</li>
<li>primary 节点进行并发控制即确定并发更新操作的先后顺序</li>
<li>primary 节点将更新操作发送给secondary 节点</li>
<li>primary 根据secondary 节点的完成情况决定更新是否成功并将结果返回外部节点</li>
</ol>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203526071.png" alt="image-20200206203526071"></p>
<p>在工程实践中，如果由primary 直接同时发送给其他N 个副本发送数据，则每个 secondary 的更新吞吐受限于primary 总的出口网络带宽，最大为primary 网络出口带宽的1/N。为了解决这个问题，有些系统（例如，GFS），使用接力的方式同步数据，即primary 将更新发送给第一 个secondary 副本，第一个secondary 副本发送给第二secondary 副本，依次类推。</p>
<h5 id="数据读取方式"><a href="#数据读取方式" class="headerlink" title="数据读取方式"></a><strong>数据读取方式</strong></h5><p>数据读取方式也与一致性高度相关。如果只需要最终一致性，则读取任何副本都可以满足需求。如果需要会话一致性，则可以为副本设置版本号，每次更新后递增版本号，用户读取副本时验证版本号，从而保证用户读到的数据在会话范围内单调递增。使用primary-secondary 比较困难的是实现强一致性。</p>
<ol>
<li>由于数据的更新流程都是由primary 控制的，primary 副本上的数据一定是最新的，所以 如果始终只读primary 副本的数据，可以实现强一致性。如果只读primary 副本，则secondary 副本将不提供读服务。实践中，如果副本不与机器绑定，而是按照数据段为单位维护副本，仅有primary 副本提供读服务在很多场景下并不会造出机器资源浪费。</li>
</ol>
<p>将副本分散到集群中个，假设primary 也是随机的确定的，那么每台机器上都有一些数据的primary 副本，也有另一些数据段的secondary 副本。从而某台服务器实际都提供读写服务。</p>
<ol>
<li>由primary 控制节点secondary 节点的可用性。当primary 更新某个secondary 副本不成功时，primary 将该secondary 副本标记为不可用，从而用户不再读取该不可用的副本。不可用的 secondary 副本可以继续尝试与primary 同步数据，当与primary 完成数据同步后，primary 可以副本标记为可用。这种方式使得所有的可用的副本，无论是primary 还是secondary 都是可读的，且在一个确定的时间内，某secondary 副本要么更新到与primary 一致的最新状态，要么被标记为不可用，从而符合较高的一致性要求。这种方式依赖于一个中心元数据管理系统，用于记录哪些副本可用，哪些副本不可用。某种意义上，该方式通过降低系统的可用性来提高系统的一致性。</li>
</ol>
<h5 id="primary-副本的确定与切换"><a href="#primary-副本的确定与切换" class="headerlink" title="primary 副本的确定与切换"></a><strong>primary 副本的确定与切换</strong></h5><p>在primary-secondary 类型的协议中，另一个核心的问题是如何确定primary 副本，尤其是在原primary 副本所在机器出现宕机等异常时，需要有某种机制切换primary 副本，使得某个secondary 副本成为新的primary 副本。</p>
<p>通常的，在primary-secondary 类型的分布式系统中，哪个副本是primary 这一信息都属于元信息，由专门的元数据服务器维护。执行更新操作时，首先查询元数据服务器获取副本的primary 信息，从而进一步执行数据更新流程。</p>
<p>由于分布式系统中可靠的发现节点异常是需要一定的探测时间的，这样的探测时间通常是10 秒级别，这也意味着一旦primary 异常，最多需要10 秒级别的发现时间，系统才能开始primary 的切换，在这10 秒时间内，由于没有primary，系统不能提供更 新服务，如果系统只能读primary 副本，则这段时间内甚至不能提供读服务。从这里可以看到，primary-backup 类副本协议的最大缺点就是由于primary 切换带来的一定的停服务时间。</p>
<h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a><strong>数据同步</strong></h5><p>不一致的secondary 副本需要与primary 进行同步（reconcile）。</p>
<p>通常不一致的形式有三种：一、由于网络分化等异常，secondary 上的数据落后于primary 上的数据。二、在某些协议下，secondary 上的数据有可能是脏数据，需要被丢弃。所谓脏数据是由于primary 副本没有进行某一更新操作，而secondary 副本上反而进行的多余的修改操作，从而造成secondary 副本数据错误。三、secondary 是一个新增加的副本，完全没有数据，需要从其他副本上拷贝数据。</p>
<p>对于第一种secondary 数据落后的情况，常见的同步方式是回放primary 上的操作日志（通常是redo 日志），从而追上primary 的更新进度。对于脏数据的情况，较好的做法是设计的分布式协议不产生脏数据。如果协议一定有产生脏数据的可能，则也应该使得产生脏数据的概率降到非常低得情况，从而一旦发生脏数据的情况可以简单的直接丢弃有脏数据的副本，这样相当于副本没有数据。另外，也可以设计一些基于undo 日志的方式从而可以删除脏数据。如果secondary 副本完全没有数据，则常见的做法是直接拷贝primary 副本的数据，这种方法往往比回放日志追更新进度的方法快很多。但拷贝数据时primary 副本需要能够继续提供更新服务，这就要求primary 副本支持快照(snapshot)功能。即对某一刻的副本数据形成快照，然后拷贝快照，拷贝完成后使用回放日志的方式追快照形成后的更新操作。</p>
<h4 id="去中心化副本控制协议"><a href="#去中心化副本控制协议" class="headerlink" title="去中心化副本控制协议"></a><strong>去中心化副本控制协议</strong></h4><p>去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商达到一致。从而去中心化协议没有因为中心化节点异常而带来的停服务等问题。</p>
<p>去中心化协议的最大的缺点是协议过程通常比较复杂。尤其当去中心化协议需要实现强一致性时，协议流程变得复杂且不容易理解。由于流程的复杂，去中心化协议的效率或者性能一般也较中心化协议低。一个不恰当的比方就是，中心化副本控制协议类似专制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影响较大；去中心化副本控制协议类似民主制度，节点集体协商，效率低下，但个别节点的异常不会对系统总体造成太大影响。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203546614.png" alt="image-20200206203546614"></p>
<h3 id="Lease-机制"><a href="#Lease-机制" class="headerlink" title="Lease 机制"></a><strong>Lease 机制</strong></h3><p>Lease 机制是最重要的分布式协议，广泛应用于各种实际的分布式系统中。</p>
<h4 id="基于lease-的分布式cache-系统"><a href="#基于lease-的分布式cache-系统" class="headerlink" title="基于lease 的分布式cache 系统"></a><strong>基于lease 的分布式cache 系统</strong></h4><p>基本的问题背景如下：在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据cache，在各个节点上 cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。另一方面，系统的正确运行严格依赖于元数据的正确，这就要求各个节点上cache 的数据始终与中心服务器上的数据一致，cache 中的数据不能是旧的脏数据。最后，设计的cache 系统要能最大可能的处理节点宕机、网络中断等异常，最大程度的提高系统的可用性。</p>
<p>为此，利用lease 机制设计一套cache 系统，其基本原理为如下。中心服务器在向各节点发送数据时同时向节点颁发一个lease。每个lease 具有一个有效期，和信用卡上的有效期类似，lease 上的 有效期通常是一个明确的时间点，例如12:00:10，一旦真实时间超过这个时间点，则lease 过期失效。这样lease 的有效期与节点收到lease 的时间无关，节点可能收到lease 时该lease 就已经过期失效。这里首先假设中心服务器与各节点的时钟是同步的，在下节中讨论时钟不同步对lease 的影响。中心服务器发出的lease 的含义为：在lease 的有效期内，中心服务器保证不会修改对应数据的值。因此，节点收到数据和lease 后，将数据加入本地Cache，一旦对应的lease 超时，节点将对应的本地cache 数据删除。中心服务器在修改数据时，首先阻塞所有新的读请求，并等待之前为该数据发出的所有lease 超时过期，然后修改数据的值。</p>
<p>基于lease 的cache，客户端节点读取元数据</p>
<ol>
<li>判断元数据是否已经处于本地cache 且lease 处于有效期内1.1 是：直接返回cache 中的元数据1.2 否：向中心服务器节点请求读取元数据信息1.2.1 服务器收到读取请求后，返回元数据及一个对应的lease 1.2.2 客户端是否成功收到服务器返回的数据  1.2.2.1 失败或超时：退出流程，读取失败，可重试1.2.2.2 成功：将元数据与该元数据的lease 记录到内存中，返回元数据</li>
<li>基于lease 的cache，客户端节点修改元数据流程2.1 节点向服务器发起修改元数据请求。2.2 服务器收到修改请求后，阻塞所有新的读数据请求，即接收读请求，但不返回数据。2.3 服务器等待所有与该元数据相关的lease 超时。2.4 服务器修改元数据并向客户端节点返回修改成功。</li>
</ol>
<p>上述机制可以保证各个节点上的cache 与中心服务器上的中心始终一致。这是因为中心服务器节点在发送数据的同时授予了节点对应的lease，在lease 有效期内，服务器不会修改数据，从而客户端节点可以放心的在lease 有效期内cache 数据。上述lease 机制可以容错的关键是：服务器一旦 发出数据及lease，无论客户端是否收到，也无论后续客户端是否宕机，也无论后续网络是否正常，服务器只要等待lease 超时，就可以保证对应的客户端节点不会再继续cache 数据，从而可以放心的修改数据而不会破坏cache 的一致性。</p>
<p>上述基础流程有一些性能和可用性上的问题，但可以很容易就优化改性。优化点一：服务器在修改元数据时首先要阻塞所有新的读请求，造成没有读服务。这是为了防止发出新的lease 从而引起不断有新客户端节点持有lease 并缓存着数据，形成“活锁”。优化的方法很简单，服务器在进入修改数据流程后，一旦收到读请求则只返回数据但不颁发lease。从而造成在修改流程执行的过程中，客户端可以读到元数据，只是不能缓存元数据。进一步的优化是，当进入修改流程，服务器颁发的lease 有效期限选择为已发出的lease 的最大有效期限。这样做，客户端可以继续在服务器进入修改流程后继续缓存元数据，但服务器的等待所有lease 过期的时间也不会因为颁发新的lease 而不断延长。</p>
<p>最后，cache 机制与多副本机制的区别。Cache 机制与多副本机制的相似之处都 是将一份数据保存在多个节点上。但Cache 机制却要简单许多，对于cache 的数据，可以随时删除丢弃，并命中cache 的后果仅仅是需要访问数据源读取数据；然而副本机制却不一样，副本是不能随意丢弃的，每失去一个副本，服务质量都在下降，一旦副本数下降到一定程度，则往往服务将不再可用。</p>
<h5 id="lease-机制的分析"><a href="#lease-机制的分析" class="headerlink" title="lease 机制的分析"></a><strong>lease 机制的分析</strong></h5><p>lease 的定义：Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发出lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要lease 不过期，颁发者一定严守承诺；另一方面，接收方在lease 的有效期内可以使用颁发者的承诺，但一旦lease 过期，接收方一定不能继续使用颁发者的承诺。</p>
<p>Lease 机制具有很高的容错能力。首先，通过引入有效期，Lease 机制能否非常好的容错网络异常。Lease 颁发过程只依赖于网络可以单向通信，即使接收方无法向颁发者发送消息，也不影响lease 的颁发。由于lease 的有效期是一个确定的时间点，lease 的语义与发送lease 的具体时间无关，所以 同一个lease 可以被颁发者不断重复向接受方发送。即使颁发者偶尔发送lease 失败，颁发者也可以 简单的通过重发的办法解决。一旦lease 被接收方成功接受，后续lease 机制不再依赖于网络通信，即使网络完全中断lease 机制也不受影响。再者，Lease 机制能较好的容错节点宕机。如果颁发者宕机，则宕机的颁发者通常无法改变之前的承诺，不会影响lease 的正确性。在颁发者机恢复后，如果颁发者恢复出了之前的lease 信息，颁发者可以继续遵守lease 的承诺。如果颁发者无法恢复lease 信息，则只需等待一个最大的lease 超时时间就可以使得所有的lease 都失效，从而不破坏lease机制。</p>
<p>例如上节中的cache 系统的例子中，一旦服务器宕机，肯定不会修改元数据，重新恢复后，只需等待一个最大的lease 超时时间，所有节点上的缓存信息都将被清空。对于接受方宕机的情况，颁发者 不需要做更多的容错处理，只需等待lease 过期失效，就可以收回承诺，实践中也就是收回之前赋予的权限、身份等。最后，lease 机制不依赖于存储。颁发者可以持久化颁发过的lease 信息，从而在 宕机恢复后可以使得在有效期的lease 继续有效。但这对于lease 机制只是一个优化，如之前的分析，即使颁发者没有持久化lease 信息，也可以通过等待一个最大的lease 时间的方式使得之前所有颁发 的lease 失效，从而保证机制继续有效。</p>
<p>Lease 机制依赖于有效期，这就要求颁发者和接收者的时钟是同步的。一方面，如果颁发者的 时钟比接收者的时钟慢，则当接收者认为lease 已经过期的时候，颁发者依旧认为lease 有效。接收者可以用在lease 到期前申请新的lease 的方式解决这个问题。另一方面，如果颁发者的时钟比接收 者的时钟快，则当颁发者认为lease 已经过期的时候，接收者依旧认为lease 有效，颁发者可能将lease 颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对lease 的有效性的影响。</p>
<h5 id="基于lease-机制确定节点状态"><a href="#基于lease-机制确定节点状态" class="headerlink" title="基于lease 机制确定节点状态"></a><strong>基于lease 机制确定节点状态</strong></h5><p>分布式协议依赖于对节点状态认知的全局一致性，即一旦节点Q 认为某个节点 A 异常，则节点A 也必须认为自己异常，从而节点A 停止作为primary，避免“双主”问题的出现。解决这种问题有两种思路，第一、设计的分布式协议可以容忍“双主”错误，即不依赖于对节点状 态的全局一致性认识，或者全局一致性状态是全体协商后的结果；第二、利用lease 机制。对于第一 种思路即放弃使用中心化的设计，而改用去中心化设计，超过本节的讨论范畴。下面着重讨论利用 lease 机制确定节点状态。</p>
<p>由中心节点向其他节点发送lease，若某个节点持有有效的lease，则认为该节点正常可以提供服 务。用于例2.3.1 中，节点A、B、C 依然周期性的发送heart beat 报告自身状态，节点Q 收到heart beat 后发送一个lease，表示节点Q 确认了节点A、B、C 的状态，并允许节点在lease 有效期内正常工 作。节点Q 可以给primary 节点一个特殊的lease，表示节点可以作为primary 工作。一旦节点Q 希望切换新的primary，则只需等前一个primary 的lease 过期，则就可以安全的颁发新的lease 给新的 primary 节点，而不会出现“双主”问题。</p>
<p>在实际系统中，若用一个中心节点发送lease 也有很大的风险，一旦该中心节点宕机或网络异常，则所有的节点没有lease，从而造成系统高度不可用。为此，实际系统总是使用多个中心节点互为副本，成为一个小的集群，该小集群具有高可用性，对外提供颁发lease 的功能。chubby 和zookeeper 都是基于这样的设计。</p>
<h5 id="lease-的有效期时间选择"><a href="#lease-的有效期时间选择" class="headerlink" title="lease 的有效期时间选择"></a><strong>lease 的有效期时间选择</strong></h5><p>工程中，常选择的lease 时长是10 秒级别，这是一个经过验证的经验值，实践中可以作为参考并综合选择合适的时长。</p>
<h3 id="Quorum-机制"><a href="#Quorum-机制" class="headerlink" title="Quorum 机制"></a><strong>Quorum 机制</strong></h3><p>先做这样的约定：更新操作（write）是一系列顺序的过程，通过其他机制确定更新操作的顺序（例如primary-secondary 架构中由primary 决定顺序），每个更新操作记为wi， i 为更新操作单调递增的序号，每个wi 执行成功后副本数据都发生变化，称为不同的数据版本，记 作vi。假设每个副本都保存了历史上所有版本的数据。</p>
<h4 id="write-all-read-one"><a href="#write-all-read-one" class="headerlink" title="write-all-read-one"></a><strong>write-all-read-one</strong></h4><p>Write-all-read-one（简称WARO）是一种最简单的副本控制规则，顾名思义即在更新时写所有的副本，只有在所有的副本上更新成功，才认为更新成功，从而保证所有的副本一致，这样在读取数据时可以读任一副本上的数据。</p>
<p>由于更新操作需要在所有的N 个副本上都成功，更新操作才能成 功，所以一旦有一个副本异常，更新操作失败，更新服务不可用。对于更新服务，虽然有N 个副本， 但系统无法容忍任何一个副本异常。另一方面，N 个副本中只要有一个副本正常，系统就可以提供读服务。对于读服务而言，当有N 个副本时，系统可以容忍N-1 个副本异常。从上述分析可以发现WARO 读服务的可用性较高，但更新服务的可用性不高，甚至虽然使用了副本，但更新服务的可用性等效于没有副本。</p>
<h4 id="Quorum-定义"><a href="#Quorum-定义" class="headerlink" title="Quorum 定义"></a><strong>Quorum 定义</strong></h4><p>在Quorum 机制下，当某次更新操作wi 一旦在所有N 个副本中的W 个副本上都成功，则就称 该更新操作为“成功提交的更新操作”，称对应的数据为“成功提交的数据”。令R&gt;N-W，由于更新 操作wi 仅在W 个副本上成功，所以在读取数据时，最多需要读取R 个副本则一定能读到wi 更新后 的数据vi 。如果某次更新wi 在W 个副本上成功，由于W+R&gt;N，任意R 个副本组成的集合一定与 成功的W个副本组成的集合有交集，所以读取R 个副本一定能读到wi 更新后的数据vi。如图 2-10， Quorum 机制的原理可以文森图表示。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203639455.png" alt="image-20200206203639455"></p>
<p>某系统有5 个副本，W=3，R=3，最初5 个副本的数据一致，都是v1，某次更新操作 w2 在前3 副本上成功，副本情况变成（v2 v2 v2 v1 v1）。此时，任意3 个副本组成的集合中一定包括 v2。在上述定义中，令W=N，R=1，就得到WARO，即WARO 是Quorum 机制的一种特例。与分析WARO 相似，分析Quorum 机制的可用性。限制Quorum 参数为W+R=N+1。由于更新 操作需要在W 个副本上都成功，更新操作才能成功，所以一旦N-W+1 个副本异常，更新操作始终无法在W 个副本上成功，更新服务不可用。另一方面，一旦N-R+1 个副本异常，则无法保证一定可以读到与W 个副本有交集的副本集合，则读服务的一致性下降。</p>
<p>再次强调：仅仅依赖quorum 机制是无法保证强一致性的。因为仅有quorum 机制时无法确定最新已成功提交的版本号，除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数据集群管理，否则很难确定最新成功提交的版本号。在下一节中，将讨论在哪些情况下，可以仅仅 通过quorum 机制来确定最新成功提交的版本号。</p>
<p>Quorum 机制的三个系统参数N、W、R 控制了系统的可用性，也是系统对用户的服务承诺：数据最多有N 个副本，但数据更新成功W 个副本即返回用户成功。对于一致性要求较高的Quorum 系统，系统还应该承诺任何时候不读取未成功提交的数据，即读取到的数据都是曾经在W 个副本上成功的数据。</p>
<h4 id="读取最新成功提交的数据"><a href="#读取最新成功提交的数据" class="headerlink" title="读取最新成功提交的数据"></a><strong>读取最新成功提交的数据</strong></h4><p>Quorum 机制只需成功更新N 个副本中的W 个，在读取R 个副本时，一定可以读到最新的成功提交的数据。但由于有不成功的更新情况存在，仅仅读取R 个副本却不一定能确定哪个版本的数据 是最新的已提交的数据。对于一个强一致性Quorum 系统，若存在个数据少于W 个，假设为X 个，则继续读取其他副本，直若成功读取到W 个 该版本的副本，则该数据为最新的成功提交的数据；如果在所有副本中该数据的个数肯定不满 足W 个，则R 中版本号第二大的为最新的成功提交的副本。例：在读取到（v2 v1 v1）时，继续读取剩余的副本，若读到剩余两个副本 为（v2 v2）则v2 是最新的已提交的副本；若读到剩余的两个副本为（v2 v1）或（v1 v1）则v1 是最新成功提交的版本；若读取后续两个副本有任一超时或失败，则无法判断哪个版本是最新的成功提交的版本。</p>
<p>可以看出，在单纯使用Quorum 机制时，若要确定最新的成功提交的版本，最多需要读取R+ （W-R-1）=N 个副本，当出现任一副本异常时，读最新的成功提交的版本这一功能都有可能不可用。实际工程中，应该尽量通过其他技术手段，回避通过Quorum 机制读取最新的成功提交的版本。例如，当quorum 机制与primary-secondary 控制协议结合使用时，可以通过读取primary 的方式读取到最新的已提交的数据。</p>
<h4 id="基于Quorum-机制选择primary副本"><a href="#基于Quorum-机制选择primary副本" class="headerlink" title="基于Quorum 机制选择primary副本"></a><strong>基于Quorum 机制选择primary副本</strong></h4><p>读取数据时依照一致性要求的不同可以有不同的做法：如果需要强一致性的立刻读取到最新的成功提交的数据，则可以简单的只读取primary 副本上的数据即可，也可以通过上节的方式读取；如果需要会话一致性，则可以根据之前已经读到的数据版本号在各个副本上进行选择性读取；如果只需要弱一致性，则可以选择任意副本读取。</p>
<p>在primary-secondary 协议中，当primary 异常时，需要选择出一个新的primary，之后secondary 副本与primary 同步数据。通常情况下，选择新的primary 的工作是由某一中心节点完成的，在引入 quorum 机制后，常用的primary 选择方式与读取数据的方式类似，即中心节点读取R 个副本，选择 R 个副本中版本号最高的副本作为新的primary。新primary 与至少W 个副本完成数据同步后作为新的primary 提供读写服务。首先，R 个副本中版本号最高的副本一定蕴含了最新的成功提交的数据。再者，虽然不能确定最高版本号的数是一个成功提交的数据，但新的primary 在随后与secondary 同 步数据，使得该版本的副本个数达到W，从而使得该版本的数据成为成功提交的数据。</p>
<p>例：在N=5，W=3，R=3 的系统中，某时刻副本最大版本号为（v2 v2 v1 v1 v1），此时v1 是系统的最新的成功提交的数据，v2 是一个处于中间状态的未成功提交的数据。假设此刻原primary 副本异常，中心节点进行primary 切换工作。这类“中间态”数据究竟作为“脏数据”被删除，还是作为新的数据被同步后成为生效的数据，完全取决于这个数据能否参与新primary 的选举。下面分别分析这两种情况。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203657503.png" alt="image-20200206203657503"></p>
<p>第一、如图 2-12，若中心节点与其中3 个副本通信成功，读取到的版本号为（v1 v1 v1），则任 选一个副本作为primary，新primary 以v1 作为最新的成功提交的版本并与其他副本同步，当与第1、第2 个副本同步数据时，由于第1、第2 个副本版本号大于primary，属于脏数据，可以按照2.2.2.4 节中介绍的处理脏数据的方式解决。实践中，新primary 也有可能与后两个副本完成同步后就提供数据服务，随后自身版本号也更新到v2，如果系统不能保证之后的v2 与之前的v2 完全一样，则新 primary 在与第1、2 个副本同步数据时不但要比较数据版本号还需要比较更新操作的具体内容是否一样。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203707864.png" alt="image-20200206203707864"></p>
<p>第二、若中心节点与其他3 个副本通信成功，读取到的版本号为（v2 v1 v1），则选取版本号为 v2 的副本作为新的primary，之后，一旦新primary 与其他2 个副本完成数据同步，则符合v2 的副 本个数达到W 个，成为最新的成功提交的副本，新primary 可以提供正常的读写服务。</p>
<h3 id="日志技术"><a href="#日志技术" class="headerlink" title="日志技术"></a><strong>日志技术</strong></h3><p>日志技术是宕机恢复的主要技术之一。日志技术最初使用在数据库系统中。严格来说日志技术不是一种分布式系统的技术，但在分布式系统的实践中，却广泛使用了日志技术做宕机恢复，甚 至如BigTable 等系统将日志保存到一个分布式系统中进一步增强了系统容错能力。</p>
<h4 id="Redo-Log-与Check-point"><a href="#Redo-Log-与Check-point" class="headerlink" title="Redo Log 与Check point"></a><strong>Redo Log 与Check point</strong></h4><p>设计一个高速的单机查询系统，将数据全部存放在内存中以实现高速的数据查询，每次更新操作更新一小部分数据（例如 key-value 中的某一个key）。现在问题为利用日志技术实现该内存查询系统的宕机恢复。与数据库的事务不同的是，这个问题模型中的每个成功的更新操作都会生效。这也等效为数据库的每个事务只有一个更新操作，且每次更新操作都可以也必须立即提交（Auto commit）。</p>
<ul>
<li><h5 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h5></li>
</ul>
<ol>
<li>将更新操作的结果（例如Set K1=1，则记录K1=1）以追加写（append）的方式写入磁盘的 日志文件</li>
<li>按更新操作修改内存中的数据</li>
<li>返回更新成功</li>
</ol>
<p>从Redo Log 的流程可以看出，Redo 写入日志的是更新操作完成后的结果（虽然本文不讨论Undo Log，这点是与Undo Log 的区别之一），且由于是顺序追加写日志文件，在磁盘等对顺序写有力的 存储设备上效率较高。</p>
<p>用Redo Log 进行宕机恢复非常简单，只需要“回放”日志即可。</p>
<p>流程2.5.2：Redo Log 的宕机恢复</p>
<ol>
<li>从头读取日志文件中的每次更新操作的结果，用这些结果修改内存中的数据。</li>
</ol>
<p>从Redo Log 的宕机恢复流程也可以看出，只有写入日志文件的更新结果才能在宕机后恢复。这也是为什么在Redo Log 流程中需要先更新日志文件再更新内存中的数据的原因。假如先更新内存中的数据，那么用户立刻就能读到更新后的数据，一旦在完成内存修改与写入日志之间发生宕机，那么最后一次更新操作无法恢复，但之前用户可能已经读取到了更新后的数据，从而引起不一致的问题。</p>
<ul>
<li><h5 id="Check-point"><a href="#Check-point" class="headerlink" title="Check point"></a>Check point</h5></li>
</ul>
<p>。在简化的模型下，check point 技术的过程即将内存中的数据以某种易于重新加载的数据组织方式完整的dump 到磁盘，从而减少宕机恢复时需要回放的日志数据。</p>
<p>流程：check point</p>
<ol>
<li>向日志文件中记录“Begin Check Point”</li>
<li>将内存中的数据以某种易于重新加载的数据组织方式dump 到磁盘上</li>
<li>向日志文件中记录“End Check Point” 在check point 流程中，数据可以继续按照流程2.5.1 被更新，这段过程中新更新的数据可以dump 到磁盘也可以不dump 到磁盘，具体取决于实现。例如，check point 开始时k1=v1，check point 过程 中某次更新为k1 = v2，那么dump 到磁盘上的k1 的值可以是v1 也可以是v2。</li>
</ol>
<p>流程：基于check point 的宕机恢复流程</p>
<ol>
<li>将dump 到磁盘的数据加载到内存。</li>
<li>从后向前扫描日志文件，寻找最后一个“End Check Point”日志。</li>
<li>从最后一个“End Check Point”日志向前找到最近的一个“Begin Check Point”日志，并回 放该日志之后的所有更新操作日志。</li>
</ol>
<ul>
<li><h4 id="No-Undo-No-Redo-log"><a href="#No-Undo-No-Redo-log" class="headerlink" title="No Undo/No Redo log"></a>No Undo/No Redo log</h4></li>
</ul>
<p>若数据维护在磁盘中，某批更新由若干个更新操作组成，这些更新操作需要原子生效，即要么同时生效，要么都不生效。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203755875.png" alt="image-20200206203755875"></p>
<p>0/1 目录技术中有两个目录结构，称为目录0(Directory 0)和目录1(Directory 1)。另有一个结构称为主记录（Master record）记录当前正在使用的目录称为活动目录。主记录中要么记录使用目录0，要么记录使用目录1。目录0 或目录1 中记录了各个数据的在日志文件中的位置。0/1 目录的数据更新过程始终在非活动目录上进行，只是在数据生效前，将主记录中的0、1 值反转，从而切换主记录。</p>
<p>流程：0/1 目录数据更新流程</p>
<ol>
<li>将活动目录完整拷贝到非活动目录。</li>
<li>对于每个更新操作，新建一个日志项纪录操作后的值，并在非活动目录中将相应数据的位置修改为新建的日志项的位置。</li>
<li>原子性修改主记录：反转主记录中的值，使得非活动目录生效。</li>
</ol>
<p>0/1 目录的更新流程非常简单，通过0、1 目录的主记录切换使得一批修改的生效是原子的。0/1 目录将批量事务操作的原子性通过目录手段归结到主记录的原子切换。由于多条记录的原子修改一般较难实现而单条记录的原子修改往往可以实现，从而降低了问题实现的难度。在工程中0/1 目录的思想运用非常广泛，其形式也不局限在上述流程中，可以是内存中的两个数据结构来回切换，也可以是磁盘上的两个文件目录来回生效切换。</p>
<h3 id="两阶段提交协议"><a href="#两阶段提交协议" class="headerlink" title="两阶段提交协议"></a><strong>两阶段提交协议</strong></h3><p>两阶段提交协议是一种经典的强一致性中心化副本控制协议。虽然在工程中该协议有较多的问题，但研究该协议能很好的理解分布式系统的几个典型问题。</p>
<h4 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a><strong>流程描述</strong></h4><p>两阶段提交协议是一种典型的“中心化副本控制”协议。在该协议中，参与的节点分为两类：一个中心化协调者节点（coordinator）和N 个参与者节点（participant）。每个参与者节点即上文背景介绍中的管理数据库副本的节点。</p>
<p>两阶段提交的思路比较简单，在第一阶段，协调者询问所有的参与者是否可以提交事务（请参与者投票），所有参与者向协调者投票。在第二阶段，协调者根据所有参与者的投票结果做出是否事务可以全局提交的决定，并通知所有的参与者执行该决定。在一个两阶段提交流程中，参与者不能改变自己的投票结果。两阶段提交协议的可以全局提交的前提是所有的参与者都同意提交事务，只要有一个参与者投票选择放弃(abort)事务，则事务必须被放弃。</p>
<p>流程：两阶段提交协调者流程</p>
<ol>
<li>写本地日志“begin_commit”，并进入WAIT 状态；</li>
<li>向所有参与者发送“prepare 消息”；</li>
<li>等待并接收参与者发送的对“prepare 消息”的响应；3.1 若收到任何一个参与者发送的“vote-abort 消息”；3.1.1 写本地“global-abort”日志，进入ABORT；3.1.2 向所有的参与者发送“global-abort 消息”；3.1.3 进入ABORT 状态；3.2 若收到所有参与者发送的“vote-commit”消息；3.2.1 写本地“global-commit”日志，进入COMMIT 状态；3.1.2 向所有的参与者发送“global-commit 消息”；</li>
<li>等待并接收参与者发送的对“global-abort 消息”或“global-commit 消息”的确认响应消息，一旦收到所有参与者的确认消息，写本地“end_transaction” 日志流程结束。</li>
</ol>
<p>流程：两阶段提交协调者流程</p>
<ol>
<li>写本地日志“init”记录，进入INIT 状态</li>
<li>等待并接受协调者发送的“prepare 消息”，收到后  2.1 若参与者可以提交本次事务 2.1.1 写本地日志“ready”，进入READY 状态 2.1.2 向协调者发送“vote-commit”消息 2.1.4 等待协调者的消息2.1.4.1 若收到协调者的“global-abort”消息2.1.4.1.1 写本地日志“abort”，进入ABORT 状态2.1.4.1.2 向协调者发送对“global-abort”的确认消息  2.1.4.2 若收到协调者的“global-commit”消息2.1.4.1.1 写本地日志“commit”，进入COMMIT 状态   2.1.4.1.2 向协调者发送对“global-commit”的确认消息  2.2 若参与者无法提交本次事务 2.2.1 写本地日志“abort”，进入ABORT 状态 2.2.2 向协调者发送“vote-abort”消息 2.2.3 流程对该参与者结束 2.2.4 若后续收到协调者的“global-abort”消息可以响应</li>
<li>即使流程结束，但任何时候收到协调者发送的“global-abort”消息或“global-commit”消息也都要发送一个对应的确认消息。</li>
</ol>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h4><h5 id="宕机恢复"><a href="#宕机恢复" class="headerlink" title="宕机恢复"></a>宕机恢复</h5><ol>
<li>协调者宕机恢复 协调者宕机恢复后，首先通过日志查找到宕机前的状态。如果日志中最后是“begin_commit”记录，说明宕机前协调者处于WAIT 状态，协调者可能已经发送过“prepare 消息”也可能还没发送，但协调者一定还没有发送过“global-commit 消息”或“global-abort 消息”，即事务的全局状态还没有确定。此时，协调者可以重新发送“prepare 消息” 继续两阶段提交流程，即使参与者已经发送过对“prepare 消息”的响应，也不过是再次重传之前的响应而不会影响协议的一致性。如果日志中最后是“global-commit”或“global-abort”记录，说明宕机前协调者处于COMMIT 或ABORT 状态。此时协调者只需重新向所有的参与者发送“global-commit 消息”或“global-abort 消息”就可以继续两阶段提交流程。</li>
<li>参与者宕机恢复参与者宕机恢复后，首先通过日志查找宕机前的状态。如果日志中最后是“init”记录，说明参与者处于INIT 状态，还没有对本次事务做出投票选择，参与者可以继续流程等待协调者发送的“prepare 消息”。如果日志中最后是“ready”记录，说明参与者处于REDAY 状态，此时说明参与者已经就本次 事务做出了投票选择，但宕机前参与者是否已经向协调者发送“vote-commit”消息并不可知。所以此时参与者可以向协调者重发“vote-commit”，并继续协议流程。如果日志中最后是“commit”或“abort”记录，说明参与者已经收到过协调者的“global-commit 消息”（处于COMMIT 状态）或者“global-abort 消息”（处于ABORT 状态）。至于是否向协调者发 送过对“global-commit”或“global-abort”的确认消息则未知。但即使没有发送过确认消息，由于协调者会不断重发“global-commit”或“global-abort”，只需在收到这些消息时发送确认消息既可，不影响协议的全局一致性。</li>
</ol>
<h4 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a><strong>协议分析</strong></h4><p>两阶段提交协议在工程实践中真正使用的较少，主要原因有以下几点：</p>
<ol>
<li>两阶段提交协议的容错能力较差。从上文的分析可以看出，两阶段提交协议在某些情况下存在流程无法执行下去的情况，且也无法判断流程状态。在工程中好的分布式协议往往总是可以在即使发生异常的情况下也能执行下去。例如，回忆Lease 机制（2.3 ），一旦lease 发出，无论出现任何异常，Lease 服务器节点总是可以通过时间判定出Lease 是否有效，也可以用等待Lease 超时的方法收回Lease 权限，整个Lease 协议的流程不存在任何流程被阻塞而无法执行下去的情况。与Lease 机制的简单有效相比，两阶段提交的协议显得较为复杂且容错能力差。</li>
<li>两阶段提交协议的性能较差。一次成功的两阶段提交协议流程中，协调者与每个参与者 之间至少需要两轮交互4 个消息“prepare”、“vote-commit”、“global-commit”、“确认global-commit”。过多的交互次数会降低性能。另一方面，协调者需要等待所有的参与者的投票结果，一旦存在较慢的参与者，会影响全局流程执行速度。</li>
</ol>
<p>虽然存在一些改进的两阶段提交协议可以提高容错能力和性能，然而这类协议依旧是在工程中使用较少的一类协议，其理论价值大于实践意义。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><p>MVCC(Multi-version Cocurrent Control，多版本并发控制)技术。MVCC 技术最初也是在数据库系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系统中同样有效。</p>
<p>MVCC 即多个不同版本的数据实现并发控制的技术，其基本思想是为每次事务生成 一个新版本的数据，在读数据时选择不同版本的数据即可以实现对事务结果的完整性读取。在使用MVCC 时，每个事务都是基于一个已生效的基础版本进行更新，事务可以并行进行，从而可以产生一种图状结构。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206203851316.png" alt="image-20200206203851316"></p>
<p>基础数据的版本为1，同时产生了两个事务：事务A 与事务B。这两个事务都各自对数据进行了一些本地修改（这些修改只有事务自己可见，不影响真正的数据），之后事务A 首先提交，生成数据版本2；基于数据版本2，又发起了事务C，事务C 继续提交，生成了数据版 本3；最后事务B 提交，此时事务B 的结果需要与事务C 的结果合并，如果数据没有冲突，即事务 B 没有修改事务A 与事务C 修改过的变量，那么事务B 可以提交，否则事务B 提交失败。MVCC 的流程过程非常类似于SVN 等版本控制系统的流程，或者说SVN 等版本控制系统就是 使用的MVCC 思想。事务在基于基础数据版本做本地修改时，为了不影响真正的数据，通常有两种做法，一是将基础数据版本中的数据完全拷贝出来再修改，SVN 即使用了这种方法，SVN check out 即是拷贝的过程；二是每个事务中只记录更新操作，而不记录完整的数据，读取数据时再将更新操作应用到用基础版本的数据从而计算出结果，这个过程也类似SVN 的增量提交。</p>
<h3 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a><strong>Paxos协议</strong></h3><p>Paxos 协议是少数在工程实践中证实的强一致性、高可用的去中心化分布式协议。Paxos 协议的流程较为复杂，但其基本思想却不难理解，类似于人类社会的投票过程。Paxos 协议中，有一组完全对等的参与节点（称为accpetor），这组节点各自就某一事件做出决议，如果某个决议获得了超过半数节点的同意则生效。Paxos 协议中只要有超过一半的节点正常，就可以工作，能很好对抗宕机、网络分化等异常情况。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a><strong>角色</strong></h4><p>Proposer：提案者。Proposer 可以有多个，Proposer 提出议案（value）。所谓value，在工程中可以是任何操作，例如“修改某个变量的值为某个值”、“设置当前primary 为某个节点”等等。Paxos 协议中统一将这些操作抽象为value。不同的Proposer 可以提出不同的甚至矛盾的value，例如某个Proposer 提议“将变量X 设置为1”，另一个Proposer 提议“将变量X 设置为2”，但对同一轮Paxos 过程，最多只有一个value 被批准。Acceptor：批准者。Acceptor 有N 个，Proposer 提出的value 必须获得超过半数(N/2+1)的Acceptor 批准后才能通过。Acceptor 之间完全对等独立。Learner：学习者。Learner 学习被批准的value。所谓学习就是通过读取各个Proposer 对value 的选择结果，如果某个value 被超过半数Proposer 通过，则Learner 学习到了这个value。回忆（2.4 ） 不难理解，这里类似Quorum 机制，某个value 需要获得W=N/2 + 1 的Acceptor 批准，从而学习者需要至少读取N/2+1 个Accpetor，至多读取N 个Acceptor 的结果后，能学习到一个通过的value。上述三类角色只是逻辑上的划分，实践中一个节点可以同时充当这三类角色。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h4><p>Paxos 协议一轮一轮的进行，每轮都有一个编号。每轮Paxos 协议可能会批准一个value，也可 能无法批准一个value。如果某一轮Paxos 协议批准了某个value，则以后各轮Paxos 只能批准这个 value。上述各轮协议流程组成了一个Paxos 协议实例，即一次Paxos 协议实例只能批准一个value，这也是Paxos 协议强一致性的重要体现。每轮Paxos 协议分为阶段，准备阶段和批准阶段，在这两个阶段Proposer 和Acceptor 有各自的处理流程。</p>
<p>流程：Proposer 的流程 （准备阶段）</p>
<ol>
<li>向所有的Acceptor 发送消息“Prepare(b)”；这里b 是Paxos 的轮数，每轮递增</li>
<li>如果收到任何一个Acceptor 发送的消息“Reject(B)”，则对于这个Proposer 而言本轮Paxos 失败，将轮数b 设置为B+1 后重新步骤1；（批准阶段，根据收到的Acceptor 的消息作出不同选择）</li>
<li>如果接收到的Acceptor 的“Promise(b, v_i)”消息达到N/2+1 个（N 为Acceptor 总数，除法取整， 下同）；v_i 表示Acceptor 最近一次在i 轮批准过value v。3.1 如果收到的“Promise(b, v)”消息中，v 都为空，Proposer 选择一个value v，向所有Acceptor 广播Accept(b, v)；3.2 否则，在所有收到的“Promise(b, v_i)”消息中，选择i 最大的value v，向所有Acceptor 广播消息Accept(b，v)；</li>
<li>如果收到Nack(B)，将轮数b 设置为B+1 后重新步骤1；</li>
</ol>
<p>流程：Accpetor 流程 （准备阶段）</p>
<ol>
<li>接受某个Propeser 的消息Prepare(b)。参数B 是该Acceptor 收到的最大Paxos 轮数编号；V 是Acceptor 批准的value，可以为空 1.1 如果b&gt;B，回复Promise(b, V_B)，设置B=b; 表示保证不再接受编号小于b 的提案。1.2 否则，回复Reject(B) （批准阶段）</li>
<li>接收Accept(b, v)， 2.1 如果b &lt; B, 回复Nack(B)，暗示proposer 有一个更大编号的提案被这个Acceptor 接收了 2.2 否则设置V=v。表示这个Acceptor 批准的Value 是v。广播Accepted 消息。</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><p>基本例子里有5 个Acceptor，1 个Proposer，不存在任何网络、宕机异常。我们着重考察各个Accpetor 上变量B 和变量V 的变化，及Proposer 上变量b 的变化。</p>
<ol>
<li><p>初始状态</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206204136621.png" alt="image-20200206204136621"></p>
</li>
<li><p>Proposer 向所有Accpetor 发送“Prepare(1)”，所有Acceptor 正确处理，并回复Promise(1, NULL)</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206204147068.png" alt="image-20200206204147068"></p>
</li>
<li><p>Proposer 收到5 个Promise(1, NULL)，满足多余半数的Promise 的value 为空，此时发送 Accept(1, v1)，其中v1 是Proposer 选择的Value。</p>
<p><img src="/2020/02/06/分布式基础要点/image-20200206204211472.png" alt="image-20200206204211472"></p>
</li>
<li><p>此时，v1 被超过半数的Acceptor 批准，v1 即是本次Paxos 协议实例批准的Value。如果Learner 学习value，学到的只能是v1</p>
</li>
</ol>
<p>在同一个Paxos 实例中，批准的Value 是无法改变的，即使后续Proposer 以更高的序号发起Paxos 协议也无法改变value。Paxos 协议的核心就在于“批准的value 无法改变”，这也是整个协议正确性的基础。</p>
<p>Paxos 协议是被人为设计出来，其设计过程也是协议的推导过程。Paxos 协议利用了Quorom 机 制，选择的W=R=N/2+1。简单而言，协议就是Proposer 更新Acceptor 的过程，一旦某个Acceptor 成功更新了超过半数的Acceptor，则更新成功。Learner 按Quorum 去读取Acceptor，一旦某个value 在超过半数的Proposer 上被成功读取，则说明这是一个被批准的value。协议通过引入轮次，使得高轮次的提议抢占低轮次的提议来避免死锁。协议设计关键点是如何满足“在一次Paxos 算法实例过程中只批准一个Value”这一约束条件。</p>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a><strong>CAP</strong></h3><p>CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性：</p>
<ul>
<li>Consistency (一致性)：CAP 理论中的副本一致性特指强一致性（1.3.4 ）；</li>
<li>Availiablity(可用性)：指系统在出现异常时已经可以提供服务；</li>
<li>Tolerance to the partition of network (分区容忍)：指系统可以对网络分区（1.1.4.2 ）这种异常情 况进行容错处理；</li>
</ul>
<p>CAP 理论指出：无法设计一种分布式协议，使得同时完全具备CAP 三个属性，即1)该种协议下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统协议只能在CAP 这三者间所有折中。</p>
<p>热力学第二定律说明了永动机是不可能存在的，不要去妄图设计永动机。与之类似，CAP 理论的意义就在于明确提出了不要去妄图设计一种对CAP 三大属性都完全拥有的完美系统，因为这种系统在理论上就已经被证明不存在。</p>
<ul>
<li>Lease 机制: Lease 机制牺牲了部分异常情况下的A，从而获得了完全的C 与很好的P。</li>
<li>Quorum 机制: Quorum 机制，在CAP 三大因素中都各做了折中，有一定的C，有较好 的A，也有较好的P，是一种较为平衡的分布式协议。</li>
<li>两阶段提交协议: 两阶段提交系统具有完全的C，很糟糕的A，很糟糕的P。</li>
<li>Paxos 协议：同样是强一致性协议，Paxos 在CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的C，较好的A，较好的P。Paxos 的A 与P 的属性与Quorum 机制类似，因为Paxos 的协议本 身就具有Quorum 机制的因素。</li>
</ul>
<h2 id="分布式服务框架"><a href="#分布式服务框架" class="headerlink" title="分布式服务框架"></a>分布式服务框架</h2><p>目前业界比较流行的分布式服务框架有：阿里的Dubbo、Spring Cloud。这里不对这些分布式服务框架做对比，简单的说说他们都做了些什么，能使我们掉用远程服务就像掉用本地服务那么简单高效。除下述内容外，分布式系统涉及到的东西还有很多，如：分布式锁、定时调度、数据分片、性能问题、各种中间件的使用等。</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务是对使用用户有功能输出的模块，以技术框架作为基础，能实现用户的需求。比如日志记录服务、权限管理服务、后台服务、配置服务、缓存服务、存储服务、消息服务等，这些服务可以灵活的组合在一起，也可以独立运行。服务需要有接口，与系统进行对接。面向服务的开发，应该是把服务拆分开发，把服务组合运行。更加直接的例子如：历史详情、留言板、评论、评级服务等。他们之间能独立运行，也要能组合在一起作为一个整体。</p>
<h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>注册中心对整个分布式系统起着最为核心的整合作用，支持对等集群，需要提供<strong>CRUD</strong>接口，支持订阅发布机制且可靠性要求非常之高，一般拿zookeeper集群来做为注册中心。<br> 分布式环境中服务提供方的服务会在多台服务器上部署，每台服务器会向注册中心提供服务方标识、服务列表、地址、对应端口、序列化协议等信息。注册中心记录下服务和服务地址的映射关系，一般一个服务会对应多个地址,这个过程我们称之为<strong>服务发布</strong>或<strong>服务注册</strong>。服务调用方会根据服务方标识、服务列表从注册中心获取所需服务的信息（<strong>地址端口信息、序列化协议等</strong>），这些信息会缓存至本地。当服务需要调用其它服务时，直接在这里找到服务的地址，进行调用，这个过程我们称之为<strong>服务发现</strong>。</p>
<p><img src="/2020/02/06/分布式基础要点/168fba730ed6c7ea" alt="分布式系统网络拓扑图">注册中心</p>
<p>下面是以zookeeper作为注册中心的简单实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建node节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNode</span><span class="params">(String node, String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = data.getBytes();</span><br><span class="line">            <span class="comment">//同步创建临时顺序节点</span></span><br><span class="line">            String path = zk.create(ZkConstant.ZK_RPC_DATA_PATH+<span class="string">"/"</span>+node+<span class="string">"-"</span>, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            log.info(<span class="string">"create zookeeper node (&#123;&#125; =&gt; &#123;&#125;)"</span>, path, data);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">        	log.error(<span class="string">""</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">        	log.error(<span class="string">""</span>, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如下面zookeeper中写入的临时顺序节点信息：</p>
<p><img src="/2020/02/06/分布式基础要点/16934302e903e720" alt="子节点1"></p>
<center>子节点1</center>

<p><img src="/2020/02/06/分布式基础要点/16934329ec3a33b7" alt="子节点2"></p>
<center>子节点2</center>

<ul>
<li>com.black.blackrpc.test.HelloWord （发布服务时对外的名称）</li>
<li>00000000010，00000000011          （zk 顺序节点id）</li>
<li>127.0.0.1:8888，127.0.0.1:8889    （服务地址端口）</li>
<li>Protostuff                        （序列化方式） 1.0                               （权值，负载均衡策略使用）</li>
</ul>
<p>这里使用的是zookeeper的临时顺序节点，为什么使用临时顺序节点。主要是考虑以下两点：</p>
<p><strong>一、</strong> 当服务提供者异常下线时，与zookeeper的连接会中断，zookeeper服务器会主动删除临时节点，同步给服务消费者。这样就能避免服务消费者去请求异常的服务器。</p>
<blockquote>
<p>校稿注： 一般消费方也会在实际发起请求前，对当前获取到的服务提供方节点进行心跳，避免请求连接有问题的节点</p>
</blockquote>
<p><strong>二、</strong> zk下面是不允许创建2个名称相同的zk子节点的，通过顺序节点就能避免创建相同的名称。当然也可以不用顺序节点的方式,直接以com.black.blackrpc.test.HelloWord创建节点，在该节点下创建数据节点。</p>
<p>下面是zk的数据同步过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步节点 （通知模式）</span></span><br><span class="line"><span class="comment">     * syncNodes会通过级联方式，在每次watcher被触发后，就会再挂上新的watcher。完成了类似链式触发的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">syncNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; nodeList = zk.getChildren(ZkConstant.ZK_RPC_DATA_PATH, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.getType() == Event.EventType.NodeChildrenChanged) &#123;</span><br><span class="line">                    	syncNodes();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Map&lt;String,List&lt;String&gt;&gt; map =<span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : nodeList) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = zk.getData(ZkConstant.ZK_RPC_DATA_PATH + <span class="string">"/"</span> + node, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                String key =node.substring(<span class="number">0</span>, node.lastIndexOf(ZkConstant.DELIMITED_MARKER));</span><br><span class="line">                String value=<span class="keyword">new</span> String(bytes);</span><br><span class="line">                Object object =map.get(key);</span><br><span class="line">                <span class="keyword">if</span>(object!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                	((List&lt;String&gt;)object).add(value);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                	List&lt;String&gt; dataList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                	dataList.add(value);</span><br><span class="line">                	map.put(key,dataList);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">"node: [&#123;&#125;] data: [&#123;&#125;]"</span>,node,<span class="keyword">new</span> String(bytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**修改连接的地址缓存*/</span></span><br><span class="line">            <span class="keyword">if</span>(MapUtil.isNotEmpty(map))&#123;</span><br><span class="line">                log.debug(<span class="string">"invoking service cache updateing...."</span>);</span><br><span class="line">            	InvokingServiceCache.updataInvokingServiceMap(map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">        	log.error(e.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当数据同步到本地时，一般会写入到本地文件中，防止因zookeeper集群异常下线而无法获取服务提者信息。</p>
<h3 id="通讯与协议"><a href="#通讯与协议" class="headerlink" title="通讯与协议"></a>通讯与协议</h3><p>服务消费者无论是与注册中心还是与服务提供者，都需要存在网络连接传输数据，而这就涉及到通讯。笔者之前也做过这方面的工作，当时使用的是<strong>java BIO</strong>简单的写了一个通讯包，使用场景没有多大的并发,阻塞式的<strong>BIO</strong>也未暴露太多问题。<strong>java BIO</strong>因其建立连接之后会阻塞线程等待数据，这种方式必须以一连接一线程的方式，即客户端有连接请求时服务器端就需要启动一个线程进行处理。当连接数过大时，会建立相当多的线程，性能直线下降。</p>
<ul>
<li><p><strong>Java NIO</strong> : 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
</li>
<li><p><strong>Java AIO</strong> : 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理， <strong>BIO、NIO、AIO</strong>适用场景分析:</p>
</li>
<li><p><strong>BIO</strong> 用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，但程序直观简单易理解。</p>
</li>
<li><p><strong>NIO</strong> 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，目前主流的通讯框架 <strong>Netty、Apache Mina、Grizzl、NIO Framework</strong>都是基于其实现的。</p>
</li>
<li><p><strong>AIO</strong> 用于连接数目多且连接比较长（重操作）的架构，比如图片服务器，文件传输等，充分调用OS参与并发操作，编程比较复杂。<br> (有兴趣可以看看这篇文章：<a href="https://blog.csdn.net/ty497122758/article/details/78979302" target="_blank" rel="noopener">BIO与NIO、AIO的区别</a> )</p>
<p>​        作为基石的通讯，其实要考虑很多东西。如：丢包粘包的情况，心跳机制，断连重连，消息缓存重发，资源的优雅释放，长连接还是短连接等。</p>
</li>
</ul>
<p>下面是<strong>Netty</strong>建立服务端，客户端的简单实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldPrepender;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayEncoder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * netty tcp 服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> v_wangshiyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTcpService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(NettyTcpService.class);</span><br><span class="line">	<span class="keyword">private</span> String host;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyTcpService</span><span class="params">(String address)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String str[] = address.split(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">this</span>.host=str[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.port=Integer.valueOf(str[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NettyTcpService</span><span class="params">(String host,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.host=host;</span><br><span class="line">		<span class="keyword">this</span>.port=port;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**用于分配处理业务线程的线程组个数 */</span>  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZGROUPSIZE = Runtime.getRuntime().availableProcessors()*<span class="number">2</span>; <span class="comment">//默认  </span></span><br><span class="line">    <span class="comment">/** 业务出现线程大小*/</span>  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIZTHREADSIZE = <span class="number">4</span>;  </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * NioEventLoopGroup实际上就是个线程,</span></span><br><span class="line"><span class="comment">     * NioEventLoopGroup在后台启动了n个NioEventLoop来处理Channel事件, </span></span><br><span class="line"><span class="comment">     * 每一个NioEventLoop负责处理m个Channel, </span></span><br><span class="line"><span class="comment">     * NioEventLoopGroup从NioEventLoop数组里挨个取出NioEventLoop来处理Channel</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(BIZGROUPSIZE);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(BIZTHREADSIZE);  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	log.info(<span class="string">"Netty Tcp Service Run..."</span>);</span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();  </span><br><span class="line">        b.group(bossGroup, workerGroup);  </span><br><span class="line">        b.channel(NioServerSocketChannel.class);  </span><br><span class="line">        b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();  </span><br><span class="line">                pipeline.addLast(<span class="string">"frameDecoder"</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"frameEncoder"</span>, <span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ByteArrayDecoder());  </span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ByteArrayEncoder());  </span><br><span class="line">              <span class="comment">//  pipeline.addLast(new Encoder());</span></span><br><span class="line">              <span class="comment">//  pipeline.addLast(new Decoder());</span></span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> TcpServerHandler());</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        b.bind(host, port).sync();  </span><br><span class="line">        log.info(<span class="string">"Netty Tcp Service Success!"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止服务并释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        workerGroup.shutdownGracefully();  </span><br><span class="line">        bossGroup.shutdownGracefully();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(TcpServerHandler.class);</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] data=(<span class="keyword">byte</span>[])msg;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.LengthFieldPrepender;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.bytes.ByteArrayEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.Future;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * netty tcp 客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> v_wangshiyu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTcpClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(NettyTcpClient.class);</span><br><span class="line">	<span class="keyword">private</span> String host;  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> port;  </span><br><span class="line">	<span class="keyword">private</span> Bootstrap bootstrap;  </span><br><span class="line">	<span class="keyword">private</span> Channel channel;</span><br><span class="line">	<span class="keyword">private</span> EventLoopGroup group;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NettyTcpClient</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">		bootstrap=getBootstrap();</span><br><span class="line">		channel= getChannel(host,port);</span><br><span class="line">		<span class="keyword">this</span>.host=host;</span><br><span class="line">		<span class="keyword">this</span>.port=port;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> host;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> port;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 初始化Bootstrap </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Bootstrap <span class="title">getBootstrap</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    	group = <span class="keyword">new</span> NioEventLoopGroup();  </span><br><span class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();  </span><br><span class="line">        b.group(group).channel(NioSocketChannel.class);  </span><br><span class="line">        b.handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();  </span><br><span class="line">                 <span class="comment">// pipeline.addLast(new Encoder());</span></span><br><span class="line">                 <span class="comment">// pipeline.addLast(new Decoder());</span></span><br><span class="line">                pipeline.addLast(<span class="string">"frameDecoder"</span>, <span class="keyword">new</span> LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"frameEncoder"</span>, <span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));  </span><br><span class="line">                pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> ByteArrayDecoder());  </span><br><span class="line">                pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> ByteArrayEncoder());  </span><br><span class="line">                </span><br><span class="line">                pipeline.addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> TcpClientHandler());</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);  </span><br><span class="line">        <span class="keyword">return</span> b;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接，获取Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Channel <span class="title">getChannel</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;  </span><br><span class="line">        Channel channel = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            channel = bootstrap.connect(host, port).sync().channel();  </span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        	log.info(String.format(<span class="string">"connect Server(IP[%s],PORT[%s]) fail!"</span>, host,port));  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMsg</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            channel.writeAndFlush(msg).sync();  </span><br><span class="line">            log.debug(<span class="string">"msg flush success"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        	log.debug(<span class="string">"msg flush fail,connect is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接断开</span></span><br><span class="line"><span class="comment">     * 并且释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">disconnectConnect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">//channel.close().awaitUninterruptibly();</span></span><br><span class="line">    	Future&lt;?&gt; future =group.shutdownGracefully();<span class="comment">//shutdownGracefully释放所有资源，并且关闭所有当前正在使用的channel</span></span><br><span class="line">    	future.syncUninterruptibly();</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(TcpClientHandler.class);</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] data=(<span class="keyword">byte</span>[])msg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到通讯就不能不说协议，通信时所遵守的规则，访问什么，传输的格式等都属于协议。作为一个开发人员，应该都了解TCP/IP协议，它是一个网络通信模型，以及一整套网络传输协议家族，是互联网的基础通信架构。也都应该用过http（超文本传输协议），Web服务器传输超文本到本地浏览器的传送协议，该协议建立在TCP/IP协议之上。分布式服务框架服务间的调用也会规定协议。为了支持不同场景，分布式服务框架会存在多种协议，如<strong>Dubbo</strong>就支持7种协议：<strong>dubbo协议(默认)</strong>，<strong>rmi协议</strong>，<strong>hessian协议</strong>，<strong>http协议</strong>，<strong>webservice协议</strong>，<strong>thrift协议</strong>，<strong>memcached协议</strong>，<strong>redis协议</strong>每种协议应对的场景不尽相同，具体场景具体对待。<br> (这里详细介绍了Dubbo 的协议：<a href="https://blog.csdn.net/xiaojin21cen/article/details/79834222" target="_blank" rel="noopener">Dubbo 的7种协议</a> )</p>
<h3 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h3><p>分布式服务上线时都是集群组网部署，集群中会存在某个服务的多实例，消费者如何从服务列表中选择合适的服务提供者进行调用，这就涉及到服务路由。分布式服务框架需要能够满足用户灵活的路由需求。</p>
<h4 id="透明化路由"><a href="#透明化路由" class="headerlink" title="透明化路由"></a>透明化路由</h4><p>很多开源的RPC框架调用者需要配置服务提供者的地址信息，尽管可以通过读取数据库的服务地址列表等方式避免硬编码地址信息，但是消费者依然要感知服务提供者的地址信息，这违反了透明化路由原则。而基于服务注册中心的服务订阅发布，消费者通过主动查询和被动通知的方式获取服务提供者的地址信息，而不再需要通过硬编码方式得到提供者的地址信息，只需要知道当前系统发布了那些服务，而不需要知道服务具体存在于什么位置，这就是透明化路由。  </p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡策略是服务的重要属性，分布式服务框架通常会提供多种负载均衡策略，同时支持用户扩展负载均衡策略。</p>
<h5 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h5><p>通常在对等集群组网中，采用随机算法进行负债均衡，随机路由算法消息分发还是比较均匀的，采用JDK提供的<strong>java.util.Random</strong>或者<strong>java.security.SecureRandom</strong>在指定服务提供者列表中生成随机地址。消费者基于随机生成的服务提供者地址进行远程调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> MAX_LEN = list.size();</span><br><span class="line">        <span class="keyword">int</span> index = RandomUtil.nextInt(MAX_LEN);</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随机还是存在缺点的，可能出现部分节点的碰撞的概率较高，另外硬件配置差异较大时，会导致各节点负载不均匀。为避免这些问题，需要对服务列表加权，性能好的机器接收的请求的概率应该高于一般机器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加权随机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightingRandomStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line">		 <span class="comment">//存放加权后的服务提供者列表</span></span><br><span class="line">        List&lt;RemoteServiceBase&gt; weightingList = <span class="keyword">new</span> ArrayList&lt;RemoteServiceBase&gt;();</span><br><span class="line">        <span class="keyword">for</span> (RemoteServiceBase remoteServiceBase : list) &#123;</span><br><span class="line">            <span class="comment">//扩大10倍</span></span><br><span class="line">            <span class="keyword">int</span> weight = (<span class="keyword">int</span>) (remoteServiceBase.getWeight()*<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++) &#123;</span><br><span class="line">            	weightingList.add(remoteServiceBase);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> MAX_LEN = weightingList.size();</span><br><span class="line">        <span class="keyword">int</span> index = RandomUtil.nextInt(MAX_LEN);</span><br><span class="line">        <span class="keyword">return</span> weightingList.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h5><p>逐个请求服务地址，到达边界之后，继续绕接。主要缺点：慢的提供者会累积请求。例如第二台机器很慢，但没挂。当请求第二台机器时被卡在那。久而久之，所有请求都卡在第二台机器上。 轮询策略实现非常简单，顺序循环遍历服务提供者列表，达到边界之后重新归零开始，继续顺序循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PollingStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line">	<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line">		RemoteServiceBase service = <span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            lock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">	            <span class="comment">//若计数大于服务提供者个数,将计数器归0</span></span><br><span class="line">	            <span class="keyword">if</span> (index &gt;= list.size()) &#123;</span><br><span class="line">	                index = <span class="number">0</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	            service = list.get(index);</span><br><span class="line">	            index++;</span><br><span class="line">	        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	            e.printStackTrace();</span><br><span class="line">	        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	            lock.unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	      <span class="comment">//兜底,保证程序健壮性,若未取到服务,则直接取第一个</span></span><br><span class="line">	        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">	            service = list.get(<span class="number">0</span>);</span><br><span class="line">	        &#125;		</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加权轮询的话，需要给服务地址添加权重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加权轮询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightingPollingStrategy</span> <span class="keyword">implements</span> <span class="title">ClusterStrategy</span> </span>&#123;</span><br><span class="line">	<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计数器锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RemoteServiceBase <span class="title">select</span><span class="params">(List&lt;RemoteServiceBase&gt; list)</span> </span>&#123;</span><br><span class="line">    	RemoteServiceBase service = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.tryLock(<span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="comment">//存放加权后的服务提供者列表</span></span><br><span class="line">            List&lt;RemoteServiceBase&gt; weightingList = <span class="keyword">new</span> ArrayList&lt;RemoteServiceBase&gt;();</span><br><span class="line">            <span class="keyword">for</span> (RemoteServiceBase remoteServiceBase : list) &#123;</span><br><span class="line">                <span class="comment">//扩大10倍</span></span><br><span class="line">                <span class="keyword">int</span> weight = (<span class="keyword">int</span>) (remoteServiceBase.getWeight()*<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight; i++) &#123;</span><br><span class="line">                	weightingList.add(remoteServiceBase);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若计数大于服务提供者个数,将计数器归0</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= weightingList.size()) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            service = weightingList.get(index);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//兜底,保证程序健壮性,若未取到服务,则直接取第一个</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务调用时延"><a href="#服务调用时延" class="headerlink" title="服务调用时延"></a>服务调用时延</h5><p>消费者缓存所有服务提供者的调用时延，周期性的计算服务调用平均时延。然后计算每个服务提供者服务调用时延与平均时延的差值，根据差值大小动态调整权重，保证服务时延大的服务提供者接收更少的消息，防止消息堆积。 该策略的特点：保证处理能力强的服务接受更多的消息，通过动态的权重分配消除服务调用时延的震荡范围，使所有服务的调用时延接近平均值，实现负载均衡。</p>
<h5 id="一致性哈希-1"><a href="#一致性哈希-1" class="headerlink" title="一致性哈希"></a>一致性哈希</h5><p>相同参数的请求总是发送到统一服务提供者，当某一台服务提供者宕机时，原本发往跟提供者的请求，基于虚拟节点，平摊到其他提供者，不会引起剧烈变动，平台提供默认的虚拟节点数，可以通过配置文件修改虚拟节点个数。一致性Hash环工作原理如下图所示：</p>
<p><img src="/2020/02/06/分布式基础要点/169314f26588cc57" alt="一致性哈希">一致性哈希</p>
<h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><p>负载均衡只能保证服务提供者压力的平衡，但是在一些业务场景中需要设置一些过滤规则，比较常用的是基本表达式的条件路由。<br> 通过IP条件表达式配置黑白名单访问控制：consumerIP != 192.168.1.1。<br> 只暴露部分服务提供者，防止这个集群服务都被冲垮，导致其他服务也不可用。例如providerIP = 192.168.3<em>。 读写分离：method=find</em>,list<em>,get</em>,query<em>=&gt;providerIP=192.168.1.</em>。 前后台分离：app=web<em>=&gt;providerIP=192.168.1.</em>,app=java<em>=&gt;providerIP=192.168.2.</em>。 灰度升级：将WEB前台应用理由到新的服务版本上：app=web<em>=&gt;provicerIP=192.168.1.</em>。</p>
<p>由于篇幅原因这里不细说，还是丢个说的比较详细的文章地址： <a href="https://blog.csdn.net/zhengzhaoyang122/article/details/80842859" target="_blank" rel="noopener">服务路由</a></p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>把对象转换为字节序列的过程称为序列化，把字节序列恢复为对象的过程称为反序列化。运程调用的时候，我们需要先将Java对象进行序列化，然后通过网络，IO进行传输，当到达目的地之后，再进行反序列化获取到我们想要的结果对象。分布式系统中，传输的对象会很多，这就要求序列化速度快，产生字节序列小的序列化技术。<br> 序列化技术：<strong>Serializable, xml, Jackson, MessagePack, fastjson, Protocol Buffer, Thrift,Gson, Avro,Hessian</strong>等</p>
<ul>
<li><strong>Serializable</strong> 是java自带的序列化技术，无法跨平台，序列化和反序列化的速度相对较慢。</li>
<li><strong>XML</strong>技术多平台支持好，常用于与银行交互的报文，但是其字节序列产生较大，不太适合用作分布式通讯框架。</li>
<li><strong>Fastjson</strong>是Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发,字节序列为json串，可读性好，序列化也速度非常的快。</li>
<li><strong>Protocol Buffer</strong> 序列化速度非常快，字节序列较小，但是可读性较差。<br> ( 这里就不一一介绍，有兴趣可以看看这篇文章：<a href="https://www.jianshu.com/p/937883b6b2e5" target="_blank" rel="noopener">序列化技术比较</a> )<br> 一般分布式服务框架会内置多种序列化协议可供选择，如<strong>Dubbo</strong> 支持的7种协议用到的序列化技术就不完全相同。</li>
</ul>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>本地环境下，使用某个接口很简单，直接调用就行。分布式环境下就不是那么简单了，消费者方只会存在接口的定义，没有具体的实现。想要像本地环境下直接调用远程接口那就得耗费一些功夫了，需要用到<strong>远程代理</strong>。<br> 下面是我盗的图：</p>
<p><img src="/2020/02/06/分布式基础要点/1692da5592a081c3" alt="远程代理"><center>远程代理</center></p>
<p>通信时序如下：</p>
<p><img src="/2020/02/06/分布式基础要点/1692da62bcb186fe" alt="通信时序">通信时序</p>
<p>消费者端没有具体的实现，需要调用接口时会动态的去创建一个代理类。与spirng集成的情况，那直接在bean构建的时候注入代理类。</p>
<p>下面是构建代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; cls)</span></span>&#123;       </span><br><span class="line">    	JdkMethodProxy invocationHandler = <span class="keyword">new</span> JdkMethodProxy();</span><br><span class="line">        Object newProxyInstance = Proxy.newProxyInstance(  </span><br><span class="line">                cls.getClassLoader(),  </span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; cls &#125;, </span><br><span class="line">                invocationHandler); </span><br><span class="line">        <span class="keyword">return</span> (Object)newProxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkMethodProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] parameters)</span>  <span class="keyword">throws</span> Throwable </span>&#123;        </span><br><span class="line">        <span class="comment">//如果传进来是一个已实现的具体类</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, parameters);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;  </span><br><span class="line">                t.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        <span class="comment">//如果传进来的是一个接口</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        	<span class="comment">//实现接口的核心方法 </span></span><br><span class="line">            <span class="comment">//return RemoteInvoking.invoking(serviceName, serializationType, //timeOut,loadBalanceStrategy,method, parameters);</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理会做很多事情，对请求服务的名称及参数信息的的序列化、通过路由选择最为合适服务提供者、建立通讯连接发送请求信息（或者直接发起http请求）、最后返回获取到的结果。当然这里面需要考虑很多问题，如调用超时，请求异常，通讯连接的缓存，同步服务调用还是异步服务调用等等。</p>
<ul>
<li><p><strong>同步服务调用</strong>：客户端发起远程服务调用请求，用户线程完成消息序列化之后，将消息投递到通信框架，然后同步阻塞，等待通信线程发送请求并接收到应答之后，唤醒同步等待的用户线程，用户线程获取到应答之后返回。</p>
</li>
<li><p><strong>异步服务调用</strong>：基于JAVA的<strong>Future</strong>机制，客户端发起远程服务调用请求，该请求会被标上<strong>requestId</strong>,同时建立一个与<strong>requestId</strong>对应 <strong>Future</strong>，客户端通过<strong>Future</strong> 的 get方法获取结果时会被阻塞。服务端收到请求应达会回传<strong>requestId</strong>，通过<strong>requestId</strong>去解除对应<strong>Future</strong>的阻塞，同时set对应结果，最后客户端获取到结果。</p>
</li>
</ul>
<p>构建Future，以requestId为key，put到线程安全的map中。get结果时需要写入timeOut超时时间，防止由于结果的未返回而导致的长时间的阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SyncFuture&lt;RpcResponse&gt; syncFuture =<span class="keyword">new</span> SyncFuture&lt;RpcResponse&gt;();</span><br><span class="line">SyncFutureCatch.syncFutureMap.put(rpcRequest.getRequestId(), syncFuture);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	RpcResponse rpcResponse= syncFuture.get(timeOut,TimeUnit.MILLISECONDS);		</span><br><span class="line">    <span class="keyword">return</span> rpcResponse.getResult();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	<span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">	SyncFutureCatch.syncFutureMap.remove(rpcRequest.getRequestId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果返回时通过回传的requestId获取对应Future写入Response,Future线程解除阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">"Tcp Client receive head："</span>+headAnalysis+<span class="string">"Tcp Client receive data："</span> +rpcResponse);</span><br><span class="line">SyncFuture&lt;RpcResponse&gt; syncFuture= SyncFutureCatch.syncFutureMap.get(rpcResponse.getRequestId());</span><br><span class="line"><span class="keyword">if</span>(syncFuture!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		syncFuture.setResponse(rpcResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 因为请求和响应是一一对应的，因此初始化CountDownLatch值为1。</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 需要响应线程设置的响应结果</span></span><br><span class="line">    <span class="keyword">private</span> T response;</span><br><span class="line">    <span class="comment">// Futrue的请求时间，用于计算Future是否超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取响应结果，直到有结果才返回。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取响应结果，直到有结果或者超过指定时间就返回。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeOut, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (latch.await(timeOut, unit)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于设置响应结果，并且做countDown操作，通知请求线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResponse</span><span class="params">(T response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getBeginTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beginTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SyncFuture&lt;RpcResponse&gt; syncFuture =<span class="keyword">new</span> SyncFuture&lt;RpcResponse&gt;();</span><br><span class="line">SyncFutureCatch.syncFutureMap.put(rpcRequest.getRequestId(), syncFuture);</span><br><span class="line">RpcResponse rpcResponse= syncFuture.get(timeOut,TimeUnit.MILLISECONDS);</span><br><span class="line">SyncFutureCatch.syncFutureMap.remove(rpcRequest.getRequestId());</span><br></pre></td></tr></table></figure>
<p>除了同步服务调用，异步服务调用，还有并行服务调用，泛化调用等调用形式<br> ( 这里就不做介绍，有兴趣可以看看这篇文章：<a href="http://www.voidcn.com/article/p-fdoonxif-mr.html" target="_blank" rel="noopener">服务框架多形式的服务调用：同步、异步、并用、泛化</a> )</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>简单的介绍了下分布式服务框架，下面来说下分布式系统的高可用。一个系统设计开发出来，三天两晚就出个大问题，导致无法使用，那这个系统也不是什么好系统。业界流传一句话：”我们系统支持X个9的可靠性”。这个X是代表一个数字，X个9表示在系统1年时间的使用过程中，系统可以正常使用时间与总时间（1年）之比。<br> 3个9：(1-99.9%)<em>365</em>24=8.76小时，表示该系统在连续运行1年时间里最多可能的业务中断时间是8.76小时，4个9即52.6分钟，5个9即5.26分钟。要做到如此高的可靠性，是非常大的挑战。一个大型分布式项目可能是由几十上百个项目构成，涉及到的服务成千上万，主链上的一个流程就需要流转多个团队维护的项目。拿4个9的可靠性来说，平摊到每个团队的时间可能不到10分钟。这10分钟内需要顶住压力，以最快的时间找到并解决问题，恢复系统的可用。<br> 下面说说为了提高系统的可靠性都有哪些方案：</p>
<ul>
<li><strong>服务检测</strong>：某台服务器与注册中心的连接中断，其提供的服务也无响应时，系统应该能主动去重启该服务，使其能正常对外提供。</li>
<li><strong>故障隔离</strong>：集群环境下，某台服务器能对外提供服务，但是因为其他原因，请求结果始终异常。这时就需要主动将该节点从集群环境中剔除，避免继续对后面的请求造成影响，非高峰时期再尝试修复该问题。至于机房故障的情况，只能去屏蔽整个机房了。目前饿了么做的是异地多活，即便单边机房挂了，流量也可以全量切换至另外一边机房，保证系统的可用。</li>
<li><strong>监控</strong>：包含业务监控、服务异常监控、db中间件性能的监控等，系统出现异常的时候能及时的通知到开发人员。等到线下报上来的时候，可能影响已经很大了。</li>
<li><strong>压测</strong>：产线主链路的压测是必不可少的，单靠集成测试，有些高并发的场景是无法覆盖到的，压测能暴露平常情况无法出现的问题，也能直观的提现系统的吞吐能力。当业务激增时，可以考虑直接做系统扩容。</li>
<li><strong>sop方案与演练</strong>：产线上随时都可能会发生问题，抱着出现问题时再想办法解决的态度是肯定不行的，时间根本来不及。提前做好对应问题的sop方案，能节省大量时间，尽快的恢复系统的正常。当然平常的演练也是不可少的，一旦产线故障可以做到从容不迫的去应对和处理。</li>
</ul>
<p>除了上述方案外，还可以考虑<strong>服务策略</strong>的使用：</p>
<h3 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h3><p>业务高峰期，为了保证核心服务，需要停掉一些不太重要的业务，如双十一期间不允许发起退款(*￣▽￣)、只允许查看3个月之内的历史订单等业务的降级，调用服务接口时，直接返回的空结果或异常等服务的降级,都属于分布式系统的降级策略。服务降级是可逆操作，当系统压力恢复到一定值不需要降级服务时，需要去除降级，将服务状态恢复正常。 服务降级主要包括<strong>屏蔽降级</strong>和<strong>容错降级</strong>：<br> <strong>屏蔽降级</strong>:分布式服务框架直接屏蔽对远程接口的请求，不发起对远程服务的调用，直接返回空结果、抛出指定异常、执行本地模拟接口实现等方式。<br> <strong>容错降级</strong>：非核心服务不可调用时，可以对故障服务做业务放通，保证主流程不受影响。如请求超时、消息解码异常、系统拥塞保护异常， 服务提供方系统异常等情况。 笔者之前就碰到过因双方没有做容错降级导致的系统故障的情况。午高峰时期，对方调用我们的一个非核心查询接口，我们系统因为bug问题一直异常，导致对方调用这个接口的页面异常而无法跳转到主流程页面，影响了产线的生产。当时对方紧急发版才使系统恢复正常。</p>
<h3 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h3><p>说到限流，最先想到的就是秒杀活动了，一场秒杀活动的流量可能是正常流量的几百至几千倍，如此高的流量系统根本无法处理，只能通过限流来避免系统的崩溃。服务的限流本质和秒杀活动的限流是一样的，都是限制请求的流入，防止服务提供方因大量的请求而崩溃。<br> 限流算法：<strong>令牌桶、漏桶、计数器算法</strong><br> 上述算法适合单机的限流，但涉及到整个集群的限流时，得考虑使用缓存中间件了。例如：某个服务1分钟内只允许请求2次，或者一天只允许使用1000次。由于负载均衡存在，可能集群内每台机器都会收到请求，这种时候就需要缓存来记录调用方某段时间内的请求次数，再做限流处理。redis就很适合做此事。 <a href="https://www.jianshu.com/p/76cc8ba5ca91" target="_blank" rel="noopener">限流算法的实现</a></p>
<h3 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h3><p>熔断本质上是一种过载保护机制，这一概念来源于电子工程中的断路器，当电流过大时，保险丝会熔断，从而保护整个电路。同样在分布式系统中，当被调用的远程服务无法使用时，如果没有过载保护，就会导致请求的资源阻塞在远程服务器上耗尽资源。很多时候，刚开始可能只是出现了局部小规模的故障，然而由于种种原因，故障影响范围越来越大，最终导致全局性的后果。当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护自己以及系统整体的可用性，可以暂时切断对下游服务的调用。<br> <strong>熔断器的设计思路</strong><br> <strong>Closed</strong>：初始状态，熔断器关闭，正常提供服务<br> <strong>Open</strong>: 失败次数，失败百分比达到一定的阈值之后，熔断器打开，停止访问服务<br> <strong>Half-Open</strong>：熔断一定时间之后，小流量尝试调用服务，如果成功则恢复，熔断器变为<strong>Closed</strong>状态</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><p>一个系统设计开发出来，必须保证其运行的数据准确和一致性。拿支付系统来说：用户银行卡已经扣款成功，系统里却显示失败，没有给用户的虚拟帐户充值上，这会引起客诉。说的再严重点，用户发起提现，资金已经转到其银行账户，系统却没扣除对应虚拟帐号的余额，直接导致资金损失了。如果这时候用户一直发起提现，那就酸爽了。</p>
<h3 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h3><p>说到数据一致性，就不得不说到<strong>CAP原则</strong>。<strong>CAP原则</strong>中指出任何一个分布式系统中，<strong>Consistency（一致性 C）</strong>、 <strong>Availability（可用性 A）</strong>、<strong>Partition tolerance（分区容错性P）</strong>，三者不可兼得。传统单机数据库基于<strong>ACID特性（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability））</strong> ，放弃了分区容错性，能做到可用性和一致性。对于一个分布式系统而言，分区容错性是一个最基本的要求。既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，会出现节点与节点之间的网络通讯，而网络问题又是一定会出现的异常情况，<strong>分区容错性</strong>也就成为了一个分布式系统必然需要面对和解决的问题。系统架构师往往需要把精力花在如何根据业务特点在<strong>一致性</strong>和<strong>可用性</strong>之间寻求平衡。</p>
<p>集中式系统，通过数据库事务的控制，能做到数据的强一致性。但是分布式系统中，涉及多服务间的调用，通过分布式事务的方案：<strong>两阶段提交（2PC）</strong>、<strong>三阶段提交（3PC）</strong>、<strong>补偿事务（TCC）</strong>等虽然能实现数据的强一致，但是都是通过牺牲可用性来实现。</p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p><strong>BASE理论</strong>是对<strong>CAP原则</strong>中一致性和可用性权衡的结果：<strong>Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</strong>。BASE理论，其来源于对大规模互联网系统分布式实践的总结，是基于<strong>CAP原则</strong>逐步演化而来的。其最核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<ul>
<li><strong>基本可用</strong><br>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，这不等价于系统不可用。</li>
<li><strong>软状态</strong><br>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li>
<li><strong>最终一致性</strong><br>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
<p>总的来说，<strong>BASE理论</strong>面向的是大型高可用可扩展的分布式系统，和传统的事物<strong>ACID特性</strong>是相反的，它完全不同于<strong>ACID</strong>的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p>
<p>下面2篇文章对分布式事务和数据一致性这块有较深的讲解。</p>
<ul>
<li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案 </a></li>
<li><a href="https://www.jianshu.com/p/b264a196b177" target="_blank" rel="noopener">微服务下的数据一致性的几种实现方式之概述 </a></li>
</ul>
<h2 id="微服务下的数据一致性的几种实现方式之概述"><a href="#微服务下的数据一致性的几种实现方式之概述" class="headerlink" title="微服务下的数据一致性的几种实现方式之概述"></a>微服务下的数据一致性的几种实现方式之概述</h2><h3 id="传统应用的事务管理"><a href="#传统应用的事务管理" class="headerlink" title="传统应用的事务管理"></a>传统应用的事务管理</h3><h4 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h4><p>再介绍微服务下的数据一致性之前，先简单地介绍一下事务的背景。传统单机应用使用一个RDBMS作为数据源。应用开启事务，进行CRUD，提交或回滚事务，统统发生在本地事务中，由资源管理器（RM）直接提供事务支持。数据的一致性在一个本地事务中得到保证。</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-9ec90b4be2f13084.webp" alt="img"></p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>#####两阶段提交（2PC）</p>
<p>当应用逐渐扩展，出现一个应用使用多个数据源的情况，这个时候本地事务已经无法满足数据一致性的要求。由于多个数据源的同时访问，事务需要跨多个数据源管理，分布式事务应运而生。其中最流行的就是两阶段提交（2PC），分布式事务由事务管理器（TM）统一管理。</p>
<p>两阶段提交分为准备阶段和提交阶段。</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-87d7372a81a076d9.webp" alt="img"></p>
<center>两阶段提交-commit</center>

<p><img src="/2020/02/06/分布式基础要点/5618351-60418578c36b49a6.webp" alt="img"></p>
<center>两阶段提交-rollback</center>

<p>然而两阶段提交也不能完全保证数据一致性问题，并且有同步阻塞的问题，所以其优化版本三阶段提交（3PC）被发明了出来。</p>
<p>#####三阶段提交（3PC）</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-eda6a74280b005f1.webp" alt="img"></p>
<center>三阶段提交</center>

<p>然而3PC也只能保证绝大多数情况下的数据一致性。</p>
<p>具体分布式事务2PC和3PC的详细介绍请见<a href="https://cloud.tencent.com/developer/article/1334942" target="_blank" rel="noopener">关于分布式事务、两阶段提交协议、三阶提交协议</a>。分布式事务不是本文的重点，故不展开。</p>
<p>###微服务下的事务管理</p>
<p>那么，分布式事务2PC或者3PC是否适合于微服务下的事务管理呢？答案是否定的，原因有三点：</p>
<ol>
<li>由于微服务间无法直接进行数据访问，微服务间互相调用通常通过RPC（dubbo）或Http API（SpringCloud）进行，所以已经无法使用TM统一管理微服务的RM。</li>
<li>不同的微服务使用的数据源类型可能完全不同，如果微服务使用了NoSQL之类不支持事务的数据库，则事务根本无从谈起。</li>
<li>即使微服务使用的数据源都支持事务，那么如果使用一个大事务将许多微服务的事务管理起来，这个大事务维持的时间，将比本地事务长几个数量级。如此长时间的事务及跨服务的事务，将为产生很多锁及数据不可用，严重影响系统性能。</li>
</ol>
<p>由此可见，传统的分布式事务已经无法满足微服务架构下的事务管理需求。那么，既然无法满足传统的ACID事务，在微服务下的事务管理必然要遵循新的法则－－BASE理论。</p>
<p>BASE理论由eBay的架构师Dan Pritchett提出，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性，应用应该可以采用合适的方式达到最终一致性。BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p>
<p><code>基本可用</code>：指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p>
<p><code>软状态</code>：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。</p>
<p><code>最终一致性</code>：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p>
<p>BASE中的<code>最终一致性</code>是对于微服务下的事务管理的根本要求，既基于微服务的事务管理无法达到强一致性，但必须保证最重一致性。那么，有哪些方法可以保证微服务下的事务管理的最终一致性呢，按照实现原理分主要有两类，事件通知型和补偿型，其中事件通知型又可分为可靠事件通知模式及最大努力通知模式，而补偿型又可分为TCC模式、和业务补偿模式两种。这四种模式都可以达到微服务下的数据最终一致性。</p>
<h3 id="实现微服务下数据一致性的方式"><a href="#实现微服务下数据一致性的方式" class="headerlink" title="实现微服务下数据一致性的方式"></a>实现微服务下数据一致性的方式</h3><h4 id="可靠事件通知模式"><a href="#可靠事件通知模式" class="headerlink" title="可靠事件通知模式"></a>可靠事件通知模式</h4><h5 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h5><p>可靠事件通知模式的设计理念比较容易理解，即是主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性。首先能想到的也是最简单的就是同步事件通知，业务处理与消息发送同步执行，实现逻辑见下方代码及时序图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 操作数据库</span></span><br><span class="line">        <span class="keyword">bool</span> result = dao.update(data);<span class="comment">// 操作数据库失败，会抛出异常</span></span><br><span class="line">    <span class="comment">// 2. 如果数据库操作成功则发送消息</span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            mq.send(data);<span class="comment">// 如果方法执行失败，会抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        roolback();<span class="comment">// 如果发生异常，就回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/06/分布式基础要点/5618351-fc7a0d55a3e9a50a.webp" alt="img"></p>
<p>上面的逻辑看上去天衣无缝，如果数据库操作失败则直接退出，不发送消息；如果发送消息失败，则数据库回滚；如果数据库操作成功且消息发送成功，则业务成功，消息发送给下游消费。然后仔细思考后，同步消息通知其实有两点不足的地方。</p>
<ol>
<li><p>在微服务的架构下，有可能出现网络IO问题或者服务器宕机的问题，如果这些问题出现在时序图的第7步，使得消息投递后无法正常通知主服务（网络问题），或无法继续提交事务（宕机），那么主服务将会认为消息投递失败，会滚主服务业务，然而实际上消息已经被从服务消费，那么就会造成主服务和从服务的数据不一致。具体场景可见下面两张时序图。</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-7bdb231cc5a94f60.webp" alt="img"></p>
</li>
</ol>
<p><img src="/2020/02/06/分布式基础要点/5618351-2cc0b39471d0aa4a.webp" alt="img"></p>
<ol>
<li>事件服务（在这里就是消息服务）与业务过于耦合，如果消息服务不可用，会导致业务不可用。应该将事件服务与业务解耦，独立出来异步执行，或者在业务执行后先尝试发送一次消息，如果消息发送失败，则降级为异步发送。</li>
</ol>
<h5 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h5><h6 id="本地事件服务"><a href="#本地事件服务" class="headerlink" title="本地事件服务"></a>本地事件服务</h6><p>为了解决3.1.1中描述的同步事件的问题，异步事件通知模式被发展了出来，既业务服务和事件服务解耦，事件异步进行，由单独的事件服务保证事件的可靠投递。</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-8ba6d36120dee489.webp" alt="img"></p>
<p><em>异步事件通知－本地事件服务</em></p>
<p>当业务执行时，在同一个本地事务中将事件写入本地事件表，同时投递该事件，如果事件投递成功，则将该事件从事件表中删除。如果投递失败，则使用事件服务定时地异步统一处理投递失败的事件，进行重新投递，直到事件被正确投递，并将事件从事件表中删除。这种方式最大可能地保证了事件投递的实效性，并且当第一次投递失败后，也能使用异步事件服务保证事件至少被投递一次。</p>
<p>然而，这种使用本地事件服务保证可靠事件通知的方式也有它的不足之处，那便是业务仍旧与事件服务有一定耦合（第一次同步投递时），更为严重的是，本地事务需要负责额外的事件表的操作，为数据库带来了压力，在高并发的场景，由于每一个业务操作就要产生相应的事件表操作，几乎将数据库的可用吞吐量砍了一半，这无疑是无法接受的。正是因为这样的原因，可靠事件通知模式进一步地发展－外部事件服务出现在了人们的眼中。</p>
<h6 id="外部事件服务"><a href="#外部事件服务" class="headerlink" title="外部事件服务"></a>外部事件服务</h6><p>外部事件服务在本地事件服务的基础上更进了一步，将事件服务独立出主业务服务，主业务服务不在对事件服务有任何强依赖。</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-50c94922574a439d.webp" alt="img"></p>
<p><em>异步事件通知－外部事件服务</em></p>
<p>业务服务在提交前，向事件服务发送事件，事件服务只记录事件，并不发送。业务服务在提交或回滚后通知事件服务，事件服务发送事件或者删除事件。不用担心业务系统在提交或者会滚后宕机而无法发送确认事件给事件服务，因为事件服务会定时获取所有仍未发送的事件并且向业务系统查询，根据业务系统的返回来决定发送或者删除该事件。</p>
<p>外部事件虽然能够将业务系统和事件系统解耦，但是也带来了额外的工作量：外部事件服务比起本地事件服务来说多了两次网络通信开销（提交前、提交／回滚后），同时也需要业务系统提供单独的查询接口给事件系统用来判断未发送事件的状态。</p>
<h6 id="可靠事件通知模式的注意事项"><a href="#可靠事件通知模式的注意事项" class="headerlink" title="可靠事件通知模式的注意事项"></a>可靠事件通知模式的注意事项</h6><p>可靠事件模式需要注意的有两点，1. 事件的正确发送； 2. 事件的重复消费。<br> 通过异步消息服务可以确保事件的正确发送，然而事件是有可能重复发送的，那么就需要消费端保证同一条事件不会重复被消费，简而言之就是保证事件消费的<code>幂等性</code>。</p>
<p>如果事件本身是具备幂等性的状态型事件，如订单状态的通知（已下单、已支付、已发货等），则需要判断事件的顺序。一般通过时间戳来判断，既消费过了新的消息后，当接受到老的消息直接丢弃不予消费。如果无法提供全局时间戳，则应考虑使用全局统一的序列号。</p>
<p>对于不具备幂等性的事件，一般是动作行为事件，如扣款100，存款200，则应该将事件id及事件结果持久化，在消费事件前查询事件id，若已经消费则直接返回执行结果；若是新消息，则执行，并存储执行结果。</p>
<h4 id="最大努力通知模式"><a href="#最大努力通知模式" class="headerlink" title="最大努力通知模式"></a>最大努力通知模式</h4><p>相比可靠事件通知模式，最大努力通知模式就容易理解多了。最大努力通知型的特点是，业务服务在提交事务后，进行有限次数（设置最大次数限制）的消息发送，比如发送三次消息，若三次消息发送都失败，则不予继续发送。所以有可能导致消息的丢失。同时，主业务方需要提供查询接口给从业务服务，用来恢复丢失消息。最大努力通知型对于时效性保证比较差（既可能会出现较长时间的软状态），所以对于数据一致性的时效性要求比较高的系统无法使用。这种模式通常使用在不同业务平台服务或者对于第三方业务服务的通知，如银行通知、商户通知等，这里不再展开。</p>
<h4 id="业务补偿模式"><a href="#业务补偿模式" class="headerlink" title="业务补偿模式"></a>业务补偿模式</h4><p>接下来介绍两种补偿模式，补偿模式比起事件通知模式最大的不同是，补偿模式的上游服务依赖于下游服务的运行结果，而事件通知模式上游服务不依赖于下游服务的运行结果。首先介绍业务补偿模式，业务补偿模式是一种纯补偿模式，其设计理念为，业务在调用的时候正常提交，当一个服务失败的时候，所有其依赖的上游服务都进行业务补偿操作。举个例子，小明从杭州出发，去往美国纽约出差，现在他需要定从杭州去往上海的火车票，以及从上海飞往纽约的飞机票。如果小明成功购买了火车票之后发现那天的飞机票已经售空了，那么与其在上海再多待一天，小明还不如取消去上海的火车票，选择飞往北京再转机纽约，所以小明就取消了去上海的火车票。这个例子中购买杭州到上海的火车票是服务a，购买上海到纽约的飞机票是服务b，业务补偿模式就是在服务b失败的时候，对服务a进行补偿操作，在例子中就是取消杭州到上海的火车票。</p>
<p>补偿模式要求每个服务都提供补偿借口，且这种补偿一般来说是<code>不完全补偿</code>，既即使进行了补偿操作，那条取消的火车票记录还是一直存在数据库中可以被追踪（一般是有相信的状态字段“已取消”作为标记），毕竟已经提交的线上数据一般是不能进行物理删除的。</p>
<p>业务补偿模式最大的缺点是软状态的时间比较长，既数据一致性的时效性很低，多个服务常常可能处于数据不一致的情况。</p>
<h4 id="TCC-Try-Confirm-Cancel模式"><a href="#TCC-Try-Confirm-Cancel模式" class="headerlink" title="TCC/Try Confirm Cancel模式"></a>TCC/Try Confirm Cancel模式</h4><p>TCC模式是一种优化了的业务补偿模式，它可以做到<code>完全补偿</code>，既进行补偿后不留下补偿的纪录，就好像什么事情都没有发生过一样。同时，TCC的软状态时间很短，原因是因为TCC是一种两阶段型模式（已经忘了两阶段概念的可以回顾一下1.2.1），只有在所有的服务的第一阶段（try）都成功的时候才进行第二阶段确认（Confirm）操作，否则进行补偿(Cancel)操作，而在try阶段是不会进行真正的业务处理的。</p>
<p><img src="/2020/02/06/分布式基础要点/5618351-dcbf289d3013b723.webp" alt="img"></p>
<p><em>TCC模式</em></p>
<p>TCC模式的具体流程为两个阶段：</p>
<ol>
<li>Try，业务服务完成所有的业务检查，预留必需的业务资源</li>
<li>如果Try在所有服务中都成功，那么执行Confirm操作，Confirm操作不做任何的业务检查（因为try中已经做过），只是用Try阶段预留的业务资源进行业务处理；否则进行Cancel操作，Cancel操作释放Try阶段预留的业务资源。</li>
</ol>
<p>这么说可能比较模糊，下面我举一个具体的例子，小明在线从招商银行转账100元到广发银行。这个操作可看作两个服务，服务a从小明的招行账户转出100元，服务b从小明的广发银行帐户汇入100元。</p>
<p>服务a（小明从招行转出100元）:</p>
<p>try: update cmb_account set balance=balance-100, freeze=freeze+100 where acc_id=1 and balance&gt;100;</p>
<p>confirm: update cmb_account set freeze=freeze-100 where acc_id=1;</p>
<p>cancel: update cmb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;</p>
<p>服务b（小明往广发银行汇入100元）:</p>
<p>try: update cgb_account set freeze=freeze+100 where acc_id=1;</p>
<p>confirm: update cgb_account set balance=balance+100, freeze=freeze-100 where acc_id=1;</p>
<p>cancel: update cgb_account set freeze=freeze-100 where acc_id=1;</p>
<p>具体说明：<br> a的try阶段，服务做了两件事，1：业务检查，这里是检查小明的帐户里的钱是否多余100元；2:预留资源，将100元从余额中划入冻结资金。</p>
<p>a的confirm阶段，这里不再进行业务检查，因为try阶段已经做过了，同时由于转账已经成功，将冻结资金扣除。</p>
<p>a的cancel阶段，释放预留资源，既100元冻结资金，并恢复到余额。</p>
<p>b的try阶段进行，预留资源，将100元冻结。</p>
<p>b的confirm阶段，使用try阶段预留的资源，将100元冻结资金划入余额。</p>
<p>b的cancel阶段，释放try阶段的预留资源，将100元从冻结资金中减去。</p>
<p>从上面的简单例子可以看出，TCC模式比纯业务补偿模式更加复杂，所以在实现上每个服务都需要实现Cofirm和Cancel两个接口。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下面的表格对这四种常用的模式进行了比较：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数据一致性的实时性</th>
<th>开发成本</th>
<th>上游服务是否依赖下游服务结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>通知型</td>
<td>最大努力</td>
<td>低</td>
<td>低</td>
<td>不依赖</td>
</tr>
<tr>
<td>通知型</td>
<td>可靠事件</td>
<td>高</td>
<td>高</td>
<td>不依赖</td>
</tr>
<tr>
<td>补偿型</td>
<td>业务补偿</td>
<td>低</td>
<td>低</td>
<td>依赖</td>
</tr>
<tr>
<td>补偿型</td>
<td>TCC</td>
<td>高</td>
<td>高</td>
<td>依赖</td>
</tr>
</tbody>
</table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol>
<li><a href="https://juejin.im/post/5c7cd6eee51d457c042d4b52" target="_blank" rel="noopener">https://juejin.im/post/5c7cd6eee51d457c042d4b52</a></li>
<li><a href="https://www.jianshu.com/p/b264a196b177" target="_blank" rel="noopener">https://www.jianshu.com/p/b264a196b177</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/06/HTTP协议要点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/HTTP协议要点/" itemprop="url">
                  HTTP协议要点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-06 14:22:39" itemprop="dateCreated datePublished" datetime="2020-02-06T14:22:39+08:00">2020-02-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下文章来源于Java建设者 ，作者cxuan</p>
<h2 id="HTTP-内容协商"><a href="#HTTP-内容协商" class="headerlink" title="HTTP 内容协商"></a><strong>HTTP 内容协商</strong></h2><h3 id="什么是内容协商"><a href="#什么是内容协商" class="headerlink" title="什么是内容协商"></a><strong>什么是内容协商</strong></h3><p>在 HTTP 中，<code>内容协商</code>是一种用于在同一 URL 上提供资源的不同表示形式的机制。内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的标准。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<h3 id="内容协商的种类"><a href="#内容协商的种类" class="headerlink" title="内容协商的种类"></a><strong>内容协商的种类</strong></h3><p>内容协商主要有以下3种类型：</p>
<ul>
<li><code>服务器驱动协商（Server-driven Negotiation）</code></li>
</ul>
<p>这种协商方式是由服务器端进行内容协商。服务器端会根据请求首部字段进行自动处理</p>
<ul>
<li><code>客户端驱动协商（Agent-driven Negotiation）</code></li>
</ul>
<p>这种协商方式是由客户端来进行内容协商。</p>
<ul>
<li><code>透明协商（Transparent Negotiation）</code></li>
</ul>
<p>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</p>
<p>内容协商的分类有很多种，主要的几种类型是 <strong>Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language</strong>。</p>
<p>一般来说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。</p>
<h3 id="为什么需要内容协商"><a href="#为什么需要内容协商" class="headerlink" title="为什么需要内容协商"></a><strong>为什么需要内容协商</strong></h3><p>我们为什么需要内容协商呢？在回答这个问题前我们先来看一下 TCP 和 HTTP 的不同。</p>
<p>在 TCP / IP 协议栈里，传输数据基本上都是 <code>header+body</code> 的格式。但 TCP、UDP 因为是传输层的协议，它们不会关心 body 数据是什么，只要把数据发送到对方就算是完成了任务。</p>
<p>而 HTTP 协议则不同，它是应用层的协议，数据到达之后需要告诉应用程序这是什么数据。当然不告诉应用这是哪种类型的数据，应用也可以通过不断尝试来判断，但这种方式无疑十分低效，而且有很大几率会检查不出来文件类型。</p>
<p>所以鉴于此，浏览器和服务器需要就数据的传输达成一致，浏览器需要告诉服务器自己希望能够接收什么样的数据，需要什么样的压缩格式，什么语言，哪种字符集等；而服务器需要告诉客户端自己能够提供的服务是什么。</p>
<p>所以我们就引出了内容协商的几种概念，下面依次来进行探讨</p>
<h3 id="内容协商标头"><a href="#内容协商标头" class="headerlink" title="内容协商标头"></a><strong>内容协商标头</strong></h3><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>接受请求 HTTP 标头会通告客户端自己能够接受的 <code>MIME</code> 类型</p>
<p>那么什么是 MIME 类型呢？在回答这个问题前你应该先了解一下什么是 MIME</p>
<blockquote>
<p>MIME: MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
</blockquote>
<p>也就是说，MIME 类型其实就是一系列消息内容类型的集合。那么 MIME 类型都有哪些呢？</p>
<p><code>文本文件</code>：text/html、text/plain、text/css、application/xhtml+xml、application/xml</p>
<p><code>图片文件</code>：image/jpeg、image/gif、image/png</p>
<p><code>视频文件</code>：video/mpeg、video/quicktime</p>
<p><code>应用程序二进制文件</code>：application/octet-stream、application/zip</p>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。</p>
<p>一般 MIME 类型也会和 <code>q</code> 这个属性一起使用，q 是什么？q 表示的是权重，来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure>
<p>这是什么意思呢？若想要给显示的<strong>媒体类型增加优先级</strong>，则使用 <code>q=</code> 来额外表示权重值，没有显示权重的时候默认值是1.0 ，我给你列个表格你就明白了</p>
<table>
<thead>
<tr>
<th style="text-align:left">q</th>
<th style="text-align:left">MIME</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.0</td>
<td style="text-align:left">text/html</td>
</tr>
<tr>
<td style="text-align:left">1.0</td>
<td style="text-align:left">application/xhtml+xml</td>
</tr>
<tr>
<td style="text-align:left">0.9</td>
<td style="text-align:left">application/xml</td>
</tr>
<tr>
<td style="text-align:left">0.8</td>
<td style="text-align:left"><em> / </em></td>
</tr>
</tbody>
</table>
<p>也就是说，这是一个放置顺序，权重高的在前，低的在后，<code>application/xml;q=0.9</code> 是不可分割的整体。</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p>Accept-charset 属性规定服务器处理表单数据所接受的字符编码；Accept-charset 属性允许你指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。</p>
<p>Accept-Charset 没有对应的标头，服务器会把这个值放在 <code>Content-Type</code>中用<strong>charset=xxx</strong>来表示，</p>
<p>例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返回的是 UTF-8 编码，就是下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: gbk, utf-8</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和 Accept 首部字段一样，按权重值 <code>q=</code> 来表示相对优先级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: en-US,en;q=0.5</span><br></pre></td></tr></table></figure>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>表示 HTTP 标头会标明客户端希望服务端返回的内容编码，这通常是一种压缩算法。Accept-Encoding 也是属于<code>内容协商</code> 的一部分，使用并通过客户端选择 <code>Content-Encoding</code> 内容进行返回。</p>
<p>即使客户端和服务器都能够支持相同的压缩算法，服务器也可能选择不压缩并返回，这种情况可能是由于这两种情况造成的:</p>
<ul>
<li>要发送的数据已经被压缩了一次，第二次压缩并不会导致发送的数据更小</li>
<li>服务器过载，无法承受压缩带来的性能开销，通常，如果服务器使用 CPU 超过 80% ，<code>Microsoft</code> 则建议不要使用压缩</li>
</ul>
<p>下面是 Accept-Encoding 的使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip</span><br><span class="line">Accept-Encoding: compress</span><br><span class="line">Accept-Encoding: deflate</span><br><span class="line">Accept-Encoding: br</span><br><span class="line">Accept-Encoding: identity</span><br><span class="line">Accept-Encoding: *</span><br><span class="line">Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5</span><br></pre></td></tr></table></figure>
<p>上面的几种表述方式就已经把 Accept-Encoding 的属性列全了</p>
<ul>
<li><p><code>gzip</code>: 由文件压缩程序 gzip 生成的编码格式，使用 <code>Lempel-Ziv编码（LZ77）</code>和32位CRC的压缩格式，感兴趣的同学可以读一下 （<a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77）</a></p>
</li>
<li><p><code>compress</code>: 使用<code>Lempel-Ziv-Welch（LZW）</code>算法的压缩格式，有兴趣的同学可以读 （<a href="https://en.wikipedia.org/wiki/LZW）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/LZW）</a></p>
</li>
<li><p><code>deflate</code>: 使用 zlib 结构和 deflate 压缩算法的压缩格式，参考 （<a href="https://en.wikipedia.org/wiki/Zlib）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Zlib）</a> 和 （<a href="https://en.wikipedia.org/wiki/DEFLATE）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/DEFLATE）</a></p>
</li>
<li><p><code>br</code>: 使用 Brotli 算法的压缩格式，参考 （<a href="https://en.wikipedia.org/wiki/Brotli）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Brotli）</a></p>
</li>
<li><p>不执行压缩或不会变化的默认编码格式</p>
</li>
<li><p><code>*</code> : 匹配标头中未列出的任何内容编码，如果没有列出 <code>Accept-Encoding</code> ，这就是默认值，并不意味着支</p>
<p>持任何算法，只是表示没有偏好</p>
</li>
<li><p><code>;q=</code> 采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。</p>
</li>
</ul>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>Content-Type 实体标头用于指示资源的 MIME 类型。作为响应，Content-Type 标头告诉客户端返回的内容的内容类型实际上是什么。Content-type 有两种值 : MIME 类型和字符集编码，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些情况下，浏览器将执行 MIME 嗅探，并且不一定遵循此标头的值；为防止此行为，可以将标头 X-Content-Type-Options 设置为 nosniff。</p>
</blockquote>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>Content-Encoding 实体标头用于压缩媒体类型，它让客户端知道如何进行解码操作，从而使客户端获得 Content-Type 标头引用的 MIME 类型。表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br><span class="line">Content-Encoding: identity</span><br><span class="line">Content-Encoding: br</span><br><span class="line">Content-Encoding: gzip, identity</span><br><span class="line">Content-Encoding: deflate, gzip</span><br></pre></td></tr></table></figure>
<h3 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h3><p>Content-Language 实体标头用于描述面向受众的语言，以便使用户根据用户自己的首选语言进行区分。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: de-DE</span><br><span class="line">Content-Language: en-US</span><br><span class="line">Content-Language: de-DE, en-CA</span><br></pre></td></tr></table></figure>
<p>下面根据内容协商对应的请求/响应标头，我列了一张图供你参考，注意其中 Accept-Charset 没有对应的 Content-Charset ，而是通过 Content-Type 来表示。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>HTTP 认证</p>
<p>HTTP 提供了用于访问控制和身份认证的功能，下面就对 HTTP 的权限和认证功能进行介绍</p>
<h3 id="通用-HTTP-认证框架"><a href="#通用-HTTP-认证框架" class="headerlink" title="通用 HTTP 认证框架"></a><strong>通用 HTTP 认证框架</strong></h3><p>RFC 7235 定义了 HTTP 身份认证框架，服务器可以根据其文档的定义来检查客户端请求。客户端也可以根据其文档定义来提供身份验证信息。</p>
<p>请求/响应的工作流程如下：服务器以<code>401(未授权)</code> 的状态响应客户端告诉客户端服务器需要认证信息，客户端提供至少一个 <code>www-Authenticate</code> 的响应标头进行授权信息的认证。想要通过服务器进行身份认证的客户端可以在请求标头字段中添加认证标头进行身份认证，一般的认证过程如下</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>首先客户端发起一个 HTTP 请求，不带有任何认证标头，服务器对此 HTTP 请求作出响应，发现此 HTTP 信息未带有认证凭据，服务器通过 <code>www-Authenticate</code>标头返回 401 告诉客户端此请求未通过认证。然后客户端进行用户认证，认证完毕后重新发起 HTTP 请求，这次 HTTP 请求带有用户认证凭据（注意，整个身份认证的过程必须通过 HTTPS 连接保证安全），到达服务器后服务器会检查认证信息，如果不符合服务器认证信息，会返回 <code>403 Forbidden</code> 表示用户认证失败，如果满足认证信息，则返回 <code>200 OK</code>。</p>
<p>我们知道，客户端和服务器之间的 HTTP 连接可以被代理缓存重新发送，所以认证信息也适用于代理服务器。</p>
<h3 id="代理认证"><a href="#代理认证" class="headerlink" title="代理认证"></a><strong>代理认证</strong></h3><p>由于资源认证和代理认证可以共存，因此需要不同的头和状态码，在代理的情况下，会返回状态码 <code>407(需要代理认证)</code>， <code>Proxy-Authenticate</code> 响应头包含至少一个适用于代理的情况，<code>Proxy-Authorization</code>请求头用于将证书提供给代理服务器。下面分别来认识一下这两个标头</p>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><p>HTTP <code>Proxy-Authenticate</code> 响应标头定义了身份验证方法，应使用该身份验证方法来访问代理服务器后面的资源。它将请求认证到代理服务器，从而允许它进一步发送请求。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic</span><br><span class="line">Proxy-Authenticate: Basic realm=&quot;Access to the internal site&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><p>这个 HTTP <code>请求</code>标头和上面的 <code>Proxy-Authenticate</code> 拼接很相似，但是概念不同，这个标头用于向代理服务器提供凭据，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</span><br></pre></td></tr></table></figure>
<p>下面是代理服务器的请求/响应认证过程</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这个过程和通用的过程类似，我们就不再详细展开描述了。</p>
<h3 id="禁止访问"><a href="#禁止访问" class="headerlink" title="禁止访问"></a><strong>禁止访问</strong></h3><p>如果<code>代理服务器</code>收到的有效凭据不足以获取对给定资源的访问权限，则服务器应使用<code>403 Forbidden</code>状态代码进行响应。与 <code>401 Unauthorized</code> 和 <code>407 Proxy Authorization Required</code> 不同，该用户无法进行身份验证。</p>
<h4 id="WWW-Authenticate-和-Proxy-Authenticate-头"><a href="#WWW-Authenticate-和-Proxy-Authenticate-头" class="headerlink" title="WWW-Authenticate 和 Proxy-Authenticate 头"></a>WWW-Authenticate 和 Proxy-Authenticate 头</h4><p><code>WWW-Authenticate</code> 和 <code>Proxy-Authenticate</code> 响应头定义了获得对资源访问权限的身份验证方法。他们需要指定使用哪种身份验证方案，以便希望授权的客户端知道如何提供凭据。它们的一般表示形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: &lt;type&gt; realm=&lt;realm&gt;</span><br><span class="line">Proxy-Authenticate: &lt;type&gt; realm=&lt;realm&gt;</span><br></pre></td></tr></table></figure>
<p>我想你从上面看到这里一定会好奇 <code></code> 和 <code>realm</code>是什么东西，现在就来解释下。</p>
<ul>
<li><code></code> 是认证协议，<code>Basic</code> 是下面协议中最普遍使用的</li>
</ul>
<blockquote>
<p>RFC 7617 中定义了<code>Basic</code> HTT P身份验证方案，该方案将凭据作为用户ID /密码对传输，并使用 base64 进行编码。(感兴趣的同学可以看看 <a href="https://tools.ietf.org/html/rfc7617" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7617</a>)</p>
</blockquote>
<p>其他的认证协议主要有</p>
<table>
<thead>
<tr>
<th style="text-align:left">认证协议</th>
<th style="text-align:left">参考来源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Basic</td>
<td style="text-align:left">查阅 RFC 7617，base64编码的凭据</td>
</tr>
<tr>
<td style="text-align:left">Bearer</td>
<td style="text-align:left">查阅 RFC 6750，承载令牌来访问受 OAuth 2.0保护的资源</td>
</tr>
<tr>
<td style="text-align:left">Digest</td>
<td style="text-align:left">查阅 RFC 7616，Firefox仅支持md5哈希，请参见错误bug 472823以获得SHA加密支持</td>
</tr>
<tr>
<td style="text-align:left">HOBA</td>
<td style="text-align:left">查阅 RFC 7486</td>
</tr>
<tr>
<td style="text-align:left">Mutual</td>
<td style="text-align:left">查阅 RFC 8120</td>
</tr>
<tr>
<td style="text-align:left">AWS4-HMAC-SHA256</td>
<td style="text-align:left">查阅 <strong>AWS docs</strong></td>
</tr>
</tbody>
</table>
<ul>
<li><code>realm</code> 用于描述保护区或指示保护范围，这可能是诸如 <strong>Access to the staging site(访问登陆站点)</strong> 或者类似的，这样用户就可以知道他们要访问哪个区域。</li>
</ul>
<h4 id="Authorization-和-Proxy-Authorization-标头"><a href="#Authorization-和-Proxy-Authorization-标头" class="headerlink" title="Authorization 和 Proxy-Authorization 标头"></a>Authorization 和 Proxy-Authorization 标头</h4><p>Authorization 和 Proxy-Authorization 请求标头包含用于通过代理服务器对用户代理进行身份验证的凭据。在此，再次需要类型，其后是凭据，取决于使用哪种身份验证方案，可以对凭据进行编码或加密。一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</span><br><span class="line">Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a><strong>HTTP 缓存</strong></h2><p>通过把<code>请求/响应</code>缓存起来有助于提升系统的性能，<code>Web 缓存</code>减少了延迟和网络传输量，因此减少资源获取锁需要的时间。由于链路漫长，网络时延不可控，浏览器使用 HTTP 获取资源的成本较高。所以，非常有必要把数据缓存起来，下次再请求的时候尽可能地复用。当 Web 缓存在其存储中具有请求的资源时，它将拦截该请求并直接返回资源，而不是到达源服务器重新下载并获取。这样做可以实现两个小目标</p>
<ul>
<li>减轻服务器负载</li>
<li>提升系统性能</li>
</ul>
<p>下面我们就一起来探讨一下 HTTP 缓存都有哪些</p>
<h3 id="不同类型的缓存"><a href="#不同类型的缓存" class="headerlink" title="不同类型的缓存"></a>不同类型的缓存</h3><p>HTTP 缓存有几种不同的类型，这些可以分为两个主要类别：<code>私有缓存</code> 和 <code>共享缓存</code>。</p>
<ul>
<li>共享缓存：共享缓存是一种缓存，它可以存储多个用户重复使用的请求/响应。</li>
<li>私有缓存：私有缓存也称为<code>专用缓存</code>，它只适用于单个用户。</li>
<li>不缓存过期资源：所有的请求都会直接到达服务器，由服务器来下载资源并返回。</li>
</ul>
<blockquote>
<p>我们主要探讨<code>浏览器缓存</code>和<code>代理缓存</code>，但真实情况不只有这两种缓存，还有网关缓存，CDN，反向代理缓存和负载平衡器，把它们部署在 Web 服务器上，可以提高网站和 Web 应用程序的可靠性，性能和可伸缩性。</p>
</blockquote>
<h4 id="不缓存过期资源"><a href="#不缓存过期资源" class="headerlink" title="不缓存过期资源"></a>不缓存过期资源</h4><p>不缓存过期资源即浏览器和代理不会缓存过期资源，客户端发起的请求会直接到达服务器，可以使用 <code>no-cache</code> 标头代表不缓存过期资源。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>no-cache 属于 Cache-Control 通用标头，其一般的表示方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>max-age = 0</code> 来实现不缓存的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure>
<h4 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h4><p>私有缓存只用来缓存单个用户，你可能在浏览器设置中看到了 <code>缓存</code>，浏览器缓存包含服务器通过 HTTP 下载下来的所有文档。这个高速缓存用于使访问的文档可以进行前进/后退，保存操作而无需重新发送请求到源服务器。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>可以使用 <code>private</code> 来实现私有缓存，这与 <code>public</code> 的用法相反，缓存服务器只对特定的客户端进行缓存，其他客户端发送过来的请求，缓存服务器则不会返回缓存。它的一般表示方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>
<h4 id="共享缓存"><a href="#共享缓存" class="headerlink" title="共享缓存"></a>共享缓存</h4><p>共享缓存是一种用于存储要由多个用户重用的响应缓存。共享缓存一般使用 <code>public</code> 来表示，<code>public</code> 属性只出现在客户端响应中，表示响应可以被任何缓存所缓存。一般表示方法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a><strong>缓存控制</strong></h3><p>HTTP/1.1 中的 <code>Cache-Control</code> 常规标头字段用于执行缓存控制，使用此标头可通过其提供的各种指令来定义缓存策略。下面我们依次介绍一下这些属性</p>
<h4 id="不缓存"><a href="#不缓存" class="headerlink" title="不缓存"></a>不缓存</h4><p><code>no-store</code> 才是真正意义上的<code>不缓存</code>，每次服务器接受到客户端的请求后，都会返回最新的资源给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>
<h4 id="缓存但需要验证"><a href="#缓存但需要验证" class="headerlink" title="缓存但需要验证"></a>缓存但需要验证</h4><p>同上面的 不缓存过期资源</p>
<h4 id="私有和共享缓存"><a href="#私有和共享缓存" class="headerlink" title="私有和共享缓存"></a>私有和共享缓存</h4><p>同上</p>
<h4 id="缓存过期"><a href="#缓存过期" class="headerlink" title="缓存过期"></a>缓存过期</h4><p>缓存中一个很重要的指令就是<code>max-age</code>，这是资源被视为<code>新鲜</code>的最长时间 ，与 <code>Expires</code>相反，此指令是相对于请求时间的。对于应用程序中不会更改的文件，通常可以添加主动缓存。下面是 mag-age 的表示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>
<h4 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h4><p><code>must-revalidate</code> 表示缓存必须在使用之前验证过时资源的状态，并且不应使用过期的资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>
<p>下面是一个缓存验证图</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>什么是新鲜的数据</p>
<p>一旦资源存储在缓存中，理论上就可以永远被缓存使用。但是不管是浏览器缓存还是代理缓存，其存储空间是有限的，所以缓存会定期进行清除，这个过程叫做 <code>缓存回收(cache eviction)</code> （自译）。另一方面，服务器上的缓存也会定期进行更新，HTTP 作为应用层的协议，它是一种<code>客户-服务器</code>模式，HTTP 是无状态的协议，因此当资源发生更改时，服务器无法通知缓存和客户端。因此服务器必须通过某种方式告知客户端缓存已经被更新。服务器会提供<code>过期时间</code>这个概念，告知客户端在此到期时间之前，资源是<code>新鲜的</code>，也就是未更改过的。在此到期时间的范围之外，资源已过时。<code>过期算法(Eviction algorithms)</code> 通常会将新资源优先于陈旧资源使用。</p>
<p>这里需要注意一下，过期的资源并不会被回收或忽略，当高速缓存接收到过期资源时，它会使用 <code>If-None-Match</code> 转发此请求，以检查它是否仍然有效。如果有效，服务器会返回 <code>304 Not Modified</code>响应头并且没有任何响应体，从而节省了一些带宽。</p>
<p>下面是使用共享缓存代理的过程</p>
<p>这个图应该比较好理解，只说一下 Age 的作用，Age 是 HTTP 响应标头告诉客户端源服务器在多久之前创建了响应，它的单位为<code>秒</code>，Age 标头通常接近于0，如果是0则可能是从源服务器获取的，如果不是表示可能是由代理服务器创建，那么 Age 的值表示的是<strong>缓存后的响应再次发起认证到认证完成的时间值</strong>。</p>
<p>缓存的有效性是由多个标头来共同决定的，而并非某一个标头来决定。如果指定了<code>Cache-control:max-age=N</code> ，那么缓存会保存 N 秒。如果这个通用标头不存在的话，则会检查是否存在 <code>Expires</code> 标头。如果 Exprires 标头存在，那么它的值减去 Date 标头的值就可以确定其有效性。最后，如果<code>max-age</code> 和 <code>expires</code> 都不存在，就去寻找 <code>Last-Modified</code> 标头，如果存在此标头，则高速缓存的有效性等于 Date 标头的值减去 Last-modified 标头的值除以10。</p>
<h3 id="缓存验证-1"><a href="#缓存验证-1" class="headerlink" title="缓存验证"></a><strong>缓存验证</strong></h3><p>当到达缓存资源的有效期时，将对其进行验证或再次获取。仅当服务器提供了<code>强验证器</code>或<code>弱验证器</code>时，才可以进行验证。</p>
<p>当用户按下重新加载按钮时，将触发重新验证。如果缓存的响应包含 <code>Cache-control：must-revalidate</code>标头，则在正常浏览下也会触发该事件。另一个因素是 高级 -&gt; 缓存首选项 面板中的缓存验证首选项。有一个选项可在每次加载文档时强制进行验证。</p>
<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>我们上面提到了强验证器和弱验证器，实现验证器功能的标头正式 Etag 的作用，这意味着 HTTP 用户代理（例如浏览器）不知道该字符串表示什么，并且无法预测其值。如果 Etag 标头是资源响应的一部分，则客户端可以在未来请求的标头中发出 <code>If-None-Match</code>，以验证缓存的资源。</p>
<p><code>Last-Modified</code>响应标头可以用作弱验证器，因为它只有1秒可以分辨的时间。如果响应中存在 <code>Last-Modified</code>标头，则客户端可以发出 <code>If-Modified-Since</code>请求标头来验证缓存资源。（关于 Etag 更多我们会在条件请求介绍）</p>
<h4 id="避免碰撞"><a href="#避免碰撞" class="headerlink" title="避免碰撞"></a>避免碰撞</h4><p>通过使用 Etag 和 If-Match 标头，你可以检测避免碰撞。</p>
<p>例如，在编辑 MDN 时，将对当前 Wiki 内容进行哈希处理并将其放入响应中的 Etag 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<p>当将更改保存到 Wiki 页面（发布数据）时，POST 请求将包含 If-Match 标头，其中包含 Etag 值以检查有效性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<p>如果哈希值不匹配，则表示文档已在中间进行了编辑，并返回 <code>412 Precondition Failed</code>错误。</p>
<h4 id="缓存未占用资源"><a href="#缓存未占用资源" class="headerlink" title="缓存未占用资源"></a>缓存未占用资源</h4><p>Etag 标头的另一个典型用法是缓存未更改的资源，如果用户再次访问给定的 URL（已设置Etag），并且该 URL过时，则客户端将在 If-None-Match 标头字段中发送其 Etag 的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<p>服务器将客户端的 Etag（通过 If-None-Match 发送）与 Etag 进行比较，以获取其当前资源版本，如果两个值都匹配（即资源未更改），则服务器会发回 <code>304 Not Modified</code>状态，没有主体，它告诉客户端响应的缓存仍然可以使用。</p>
<h2 id="HTTP-CROS-跨域"><a href="#HTTP-CROS-跨域" class="headerlink" title="HTTP CROS 跨域"></a><strong>HTTP CROS 跨域</strong></h2><p>CROS 的全称是 <code>Cross-Origin Resource Sharing(CROS)</code>，中文译为 <code>跨域资源共享</code>，它是一种机制。是一种什么机制呢？它是一种让运行在一个<code>域(origin)</code>上的 Web 应用被准许访问来自不同源服务器上指定资源的机制。在搞懂这个机制前，你需要线了解什么是 <code>域(origin)</code></p>
<h3 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a><strong>Origin</strong></h3><p>Web 概念中<code>域(Origin)</code> 的内容由<code>scheme(protocol) - 协议</code>，<code>host(domain) - 主机</code>和用于访问它的 URL <code>port - 端口</code>定义。仅仅当 scheme 、host、port 都匹配时，两个对象才有相同的来源。这种协议相同，域名相同，端口相同的安全策略也被称为 <code>同源策略（Same Origin Policy)</code>。某些操作仅限于具有相同来源的内容，可以使用 CORS 取消此限制。</p>
<h3 id="跨域的特点"><a href="#跨域的特点" class="headerlink" title="跨域的特点"></a><strong>跨域的特点</strong></h3><ul>
<li>下面是跨域问题的例子，看看你是否清楚什么是跨域了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) http://example.com/app1/index.html</span><br><span class="line">(2) http://example.com/app2/index.html</span><br></pre></td></tr></table></figure>
<p>上面这两个 URL 是否具有跨域问题呢？</p>
<p>上面两个 URL 是不具有跨域问题的，因为这两个 URL 具有相同的<code>协议(scheme)</code>和<code>主机(host)</code></p>
<ul>
<li>那么下面这两个是否具有跨域问题呢？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://Example.com:80</span><br><span class="line">http://example.com</span><br></pre></td></tr></table></figure>
<p>这两个 URL 也不具有跨域问题，为什么不具有，端口不一样啊。其实它们两个端口是一样的。</p>
<p>或许你会认为这两个 URL 是不一样的，放心，关于一样不一样的论据我给你抛出来了</p>
<blockquote>
<p>协议和域名部分是不区分大小写的，但是路径部分则根据服务器平台而定。Windows 和 Mac OS X 系统是不区分大小写的，而采用UNIX和Linux系的服务器系统是区分大小写的，</p>
</blockquote>
<p>也就是说上面的 <code>Example.com</code> 和 <code>example.com</code> 其实是一个网址，并且由于两个地址具有相同的 scheme 和 host ，默认情况下服务器通过端口80传递 HTTP 内容，所以上面这两个地址也是相同的。</p>
<ul>
<li>下面这两个 URL 地址是否具有跨域问题？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/app1</span><br><span class="line">https://example.com/app2</span><br></pre></td></tr></table></figure>
<p>这两个 URL 的 scheme 不同，所以这两个 URL 具有跨域问题</p>
<ul>
<li>再看下面这三个 URL 是否具有跨域问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://www.example.com</span><br><span class="line">http://myapp.example.com</span><br></pre></td></tr></table></figure>
<p>这三个 URL 也是具有跨域问题的，因为它们隶属于不通服务器的主机 host。</p>
<ul>
<li>下面这两个 URL 是否具有跨域问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com</span><br><span class="line">http://example.com:8080</span><br></pre></td></tr></table></figure>
<p>这两个 URL 也是具有跨域问题，因为这两个 URL 的默认端口不一样。</p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><strong>同源策略</strong></h3><p>处于安全的因素，浏览器限制了从脚本发起跨域的 HTTP 请求。<code>XMLHttpRequest</code> 和其他 <code>Fetch 接口</code> 会遵循 <code>同源策略(same-origin policy)</code>。也就是说使用这些 API 的应用程序想要请求相同的资源，那么他们应该具有相同的来源，除非来自其他来源的响应包括正确的 CORS 标头也可以。</p>
<p>同源策略是一种很重要的安全策略，它限制了从一个来源加载的文档或脚本如何与另一个来源的资源进行交互。它有助于隔离潜在的恶意文档，减少可能的攻击媒介。</p>
<p>我们上面提到，如果两个 URL 具有相同的协议、主机和端口号（如果指定）的话，那么两个 URL 具有相同的来源。下面有一些实例，你判断一下是不是具有相同的来源</p>
<p>目标来源 <code>http://store.company.com/dir/page.html</code></p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>现在我带你认识了两遍不同的源，现在你应该知道如何区分两个 URL 是否属于同一来源了吧！</p>
<p>好，你现在知道了什么是跨域问题，现在我要问你，哪些请求会产生跨域请求呢？这是我们下面要讨论的问题</p>
<h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a><strong>跨域请求</strong></h3><p>跨域请求可能会从下面这几种请求中发出：</p>
<ol>
<li>调用 <code>XMLHttpRequest</code> 或者 <code>Fetch</code> api。</li>
</ol>
<p>XMLHttpRequest 是什么？（我是后端程序员，前端不太懂，简单解释下，如果解释的不好，还请前端大佬们不要胖揍我）</p>
<p>所有的现代浏览器都有一个内置的 <code>XMLHttpReqeust</code> 对象，这个对象可以用于从服务器请求数据。</p>
<p>XMLHttpReqeust 对于开发人员来说很重要，XMLHttpReqeust 对象可以用来做下面这些事情</p>
<ul>
<li>更新网页无需重新刷新页面</li>
<li>页面加载后从服务器请求数据</li>
<li>页面加载后从服务端获取数据</li>
<li>在后台将数据发送到服务器</li>
</ul>
<p>使用 XMLHttpRequest(XHR) 对象与服务器进行交互，你可以从 URL 检索数据从而不必刷新整个页面，这使网页可以更新页面的一部分，而不会中断用户的操作。XMLHttpRequest 在 <code>AJAX</code> 异步编程中使用很广泛。</p>
<p>再来说一下 Fetch API 是什么，Fetch 提供了请求和响应对象（以及其他网络请求）的通用定义。它还提供了相关概念的定义，例如 CORS 和 HTTP Origin 头语义，并在其他地方取代了它们各自的定义。</p>
<ol>
<li>Web 字体（用于 CSS 中@ font-face中的跨域字体使用），以便服务器可以部署 TrueType 字体，这些字体只能由允许跨站点加载和使用的网站使用。</li>
<li>WebGL 纹理</li>
<li>使用 <code>drawImage()</code> 绘制到画布上的图像/视频帧</li>
<li>图片的 CSS 形状</li>
</ol>
<h3 id="跨域功能概述"><a href="#跨域功能概述" class="headerlink" title="跨域功能概述"></a><strong>跨域功能概述</strong></h3><p>跨域资源共享标准通过添加新的 HTTP 标头来工作，这些标头允许服务器描述允许哪些来源从 Web 浏览器读取信息。另外，对于可能导致服务器数据产生副作用的 HTTP 请求方法（尤其是 GET 或者具有某些 MIME 类型 POST 方法以外 HTTP 方法），该规范要求浏览器<code>预检</code>请求，使用 HTTP OPTIONS 请求方法从服务器请求受支持的方法，然后在服务器<code>批准</code>后发送实际请求。服务器还可以通知客户端是否应与请求一起发送<code>凭据</code>（例如 Cookies 和 HTTP 身份验证）。</p>
<blockquote>
<p>注意：CORS 故障会导致错误，但是出于安全原因，该错误的详细信息不适用于 JavaScript。所有代码都知道发生了错误。确定具体出问题的唯一方法是查看浏览器的控制台以获取详细信息。</p>
</blockquote>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h3><p>下面我会和大家探讨三种方案，这些方案都演示了跨域资源共享的工作方式。所有这些示例都使用XMLHttpRequest，它可以在任何支持的浏览器中发出跨站点请求。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>一些请求不会触发 <code>CORS预检</code>（关于预检我们后面再介绍）。<code>简单请求</code>是满足一下所有条件的请求</p>
<ul>
<li><p>允许以下的方法：<code>GET</code>、<code>HEAD</code>和 <code>POST</code></p>
</li>
<li><p>除了由用户代理自动设置的标头（例如 Connection、User-Agent 或者在 Fetch 规范中定义为禁止标头名称的其他标头）外，唯一允许手动设置的标头是那些 Fetch 规范将其定义为 <code>CORS安全列出的请求标头</code> ，它们是：</p>
</li>
<li><ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type（下面会介绍）</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
<li><p>Content-Type 标头的唯一允许的值是</p>
</li>
<li><ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
<li><p>没有在请求中使用的任何 XMLHttpRequestUpload 对象上注册事件侦听器；这些可以使用XMLHttpRequest.upload 属性进行访问。</p>
</li>
<li><p>请求中未使用 ReadableStream对象。</p>
<p>例如，假定 web 内容 <code>https://foo.example</code> 想要获取 <code>https://bar.other</code> 域的资源，那么 JavaScript 中的代码可能会像下面这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">const url = &apos;https://bar.other/resources/public-data/&apos;;</span><br><span class="line">   </span><br><span class="line">xhr.open(&apos;GET&apos;, url);</span><br><span class="line">xhr.onreadystatechange = someHandler;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这使用 CORS 标头来处理特权，从而在客户端和服务器之间执行某种转换。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>让我们看看在这种情况下浏览器将发送到服务器的内容，并让我们看看服务器如何响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/public-data/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Origin: https://foo.example</span><br></pre></td></tr></table></figure>
<p>注意请求的标头 Origin ，它表明调用来自于 <code>https://foo.example</code>。让我们看看服务器是如何响应的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 00:23:53 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: application/xml</span><br><span class="line"></span><br><span class="line">[…XML Data…]</span><br></pre></td></tr></table></figure>
<p>服务端发送 <code>Access-Control-Allow-Origin</code> 作为响应。使用 <code>Origin</code> 标头和  <code>Access-Control-Allow-Origin</code> 展示了最简单的访问控制协议。在这个事例中，服务端使用<code>Access-Control-Allow-Origin</code> 作为响应，也就说明该资源可以被任何域访问。</p>
<p>如果位于<code>https://bar.other</code>的资源所有者希望将对资源的访问限制为仅来自<code>https://foo.example</code>的请求，他们应该发送如下响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br></pre></td></tr></table></figure>
<p>现在除了 <code>https://foo.example</code> 之外的任何域都无法以跨域方式访问到 <code>https://bar.other</code>的资源。</p>
<h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>和上面探讨的简单请求不同，<code>预检</code>请求首先通过 <code>OPTIONS</code> 方法向另一个域上的资源发送 HTTP 请求，用来确定实际请求是否可以安全的发送。跨站点这样被<code>预检</code>，因为它们可能会影响用户数据。</p>
<p>下面是一个预检事例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, &apos;https://bar.other/resources/post-here/&apos;);</span><br><span class="line">xhr.setRequestHeader(&apos;X-PINGOTHER&apos;, &apos;pingpong&apos;);</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/xml&apos;);</span><br><span class="line">xhr.onreadystatechange = handler;</span><br><span class="line">xhr.send(&apos;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的事例创建了一个 XML 请求体用来和 POST 请求一起发送。此外，设置了非标准请求头 <code>X-PINGOTHER</code> ，这个标头不是 HTTP/1.1 的一部分，但通常对 Web 程序很有用。由于请求的 <code>Content-Type</code> 使用 <code>application/xml</code>，并且设置了自定义标头，因此该请求被<code>预检</code>。如下图所示</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<blockquote>
<p>如下所述，实际的 POST 请求不包含 Access-Control-Request- * 标头；只有 OPTIONS 请求才需要它们。</p>
</blockquote>
<p>下面我们来看一下完整的客户端/服务器交互，首先是预检请求/响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Origin: http://foo.example</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">HTTP/1.1 204 No Content</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br><span class="line">Vary: Accept-Encoding, Origin</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>上面的1 -11 行代表预检请求，预检请求使用 <code>OPYIIONS</code> 方法，浏览器根据上面的 JavaScript 代码段所使用的请求参数确定是否需要发送此请求，以便服务器可以响应是否可以使用实际请求参数发送请求。OPTIONS 是一种 HTTP / 1.1方法，用于确定来自服务器的更多信息，并且是一种安全的方法，这意味着它不能用于更改资源。请注意，与 OPTIONS 请求一起，还发送了另外两个请求标头（分别是第9行和第10行）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>
<p><code>Access-Control-Request-Method</code> 标头作为预检请求的一部分通知服务器，当发送实际请求时，将使用<code>POST</code> 请求方法发送该请求。</p>
<p><code>Access-Control-Request-Headers</code> 标头通知服务器，当发送请求时，它将与X-PINGOTHER 和 Content-Type 自定义标头一起发送。服务器可以确定这种情况下是否接受请求。</p>
<p>下面的 1 - 11行是服务器发回的响应，表示<code>POST</code> 请求和 <code>X-PINGOTHER</code> 是可以接受的，我们着重看一下下面这几行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://foo.example</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: X-PINGOTHER, Content-Type</span><br><span class="line">Access-Control-Max-Age: 86400</span><br></pre></td></tr></table></figure>
<p>服务器完成响应表明源 <code>http://foo.example</code> 是可以接受的 URL，能够允许 <code>POST、GET、OPTIONS</code> 进行请求，允许自定义标头 <code>X-PINGOTHER, Content-Type</code>。最后，<code>Access-Control-Max-Age</code> 以秒为单位给出一个值，这个值表示对预检请求的响应可以缓存多长时间，在此期间内无需发送其他预检请求。</p>
<p>完成预检请求后，将发送实际请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">POST /resources/post-here/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-PINGOTHER: pingpong</span><br><span class="line">Content-Type: text/xml; charset=UTF-8</span><br><span class="line">Referer: https://foo.example/examples/preflightInvocation.html</span><br><span class="line">Content-Length: 55</span><br><span class="line">Origin: https://foo.example</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line"></span><br><span class="line">&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:40 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">Vary: Accept-Encoding, Origin</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 235</span><br><span class="line">Keep-Alive: timeout=2, max=99</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">[Some GZIP&apos;d payload]</span><br></pre></td></tr></table></figure>
<p>正式响应中很多标头我们在之前的文章已经探讨过了，本篇不再做详细的介绍，读者可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;mid=2247485214&amp;idx=1&amp;sn=2cec80cfd606f4b4444db974246ee75e&amp;chksm=fc45faedcb3273fb48dd5a16e4c375680adb8c6e59a52455f14ac2c2e0afda0c9265ff544044&amp;token=347964925&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"><strong>你还在为 HTTP 的这些概念头疼吗？</strong></a> 查阅</p>
<h4 id="带凭证的请求"><a href="#带凭证的请求" class="headerlink" title="带凭证的请求"></a>带凭证的请求</h4><p>XMLHttpRequest 或 Fetch 和 CORS 最有趣的功能就是能够发出知道 HTTP Cookie 和 HTTP 身份验证的 <code>凭证</code> 请求。默认情况下，在跨站点 XMLHttpRequest 或 Fetch 调用中，浏览器将不发送凭据。调用 XMLHttpRequest对象或 Request 构造函数时必须设置一个特定的标志。</p>
<p>在下面这个例子中，最初从 <code>http://foo.example</code> 加载的内容对设置了 Cookies 的<code>http://bar.other</code> 上的资源进行了简单的 GET 请求， foo.example 上可能的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const invocation = new XMLHttpRequest();</span><br><span class="line">const url = &apos;http://bar.other/resources/credentialed-content/&apos;;</span><br><span class="line">    </span><br><span class="line">function callOtherDomain() &#123;</span><br><span class="line">  if (invocation) &#123;</span><br><span class="line">    invocation.open(&apos;GET&apos;, url, true);</span><br><span class="line">    invocation.withCredentials = true;</span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行显示 XMLHttpRequest 上的标志，必须设置该标志才能使用 Cookie 进行调用。默认情况下，调用是不在使用 Cookie 的情况下进行的。由于这是一个简单的 GET 请求，因此不会进行预检，但是浏览器将拒绝任何没有 Access-Control-Allow-Credentials 的响应：标头为true，指的是响应不会返回 web 页面的内容。</p>
<p>上面的请求用下图可以表示</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这是客户端和服务器之间的示例交换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/access-control-with-credentials/ HTTP/1.1</span><br><span class="line">Host: bar.other</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-us,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://foo.example/examples/credential.html</span><br><span class="line">Origin: http://foo.example</span><br><span class="line">Cookie: pageAccess=2</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:34:52 GMT</span><br><span class="line">Server: Apache/2</span><br><span class="line">Access-Control-Allow-Origin: https://foo.example</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</span><br><span class="line">Vary: Accept-Encoding, Origin</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 106</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[text/plain payload]</span><br></pre></td></tr></table></figure>
<p>上面第10行包含指向<code>http://bar.other</code> 上的内容 Cookie，但是如果 bar.other 没有以<code>Access-Control-Allow-Credentials:true</code> 响应（下面第五行），响应将被忽略，并且不能使用网站返回的内容。</p>
<p><strong>请求凭证和通配符</strong></p>
<p>当回应凭证请求时，服务器必须在 <code>Access-Control-Allow-Credentials</code> 中指定一个来源，而不能直接写<code>*</code> 通配符</p>
<p>因为上面示例代码中的请求标头包含 Cookie 标头，如果 <code>Access-Control-Allow-Credentials</code> 中是指定的通配符 <code>*</code> 的话，请求会失败。</p>
<p>注意上面示例中的 <code>Set-Cookie</code> 响应标头还设置了另外一个值，如果发生故障，将引发异常（取决于所使用的API）。</p>
<h3 id="HTTP-响应标头"><a href="#HTTP-响应标头" class="headerlink" title="HTTP 响应标头"></a><strong>HTTP 响应标头</strong></h3><p>下面会列出一些服务器跨域共享规范定义的 HTTP 标头，上面简单概述了一下，现在一起来认识一下，主要会介绍下面这些</p>
<ul>
<li>Access-Control-Allow-Origin</li>
<li>Access-Control-Allow-Credentials</li>
<li>Access-Control-Allow-Headers</li>
<li>Access-Control-Allow-Methods</li>
<li>Access-Control-Expose-Headers</li>
<li>Access-Control-Max-Age</li>
<li>Access-Control-Request-Headers</li>
<li>Access-Control-Request-Method</li>
<li>Origin</li>
</ul>
<h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h4><p><code>Access-Control-Allow-Origin</code> 是 HTTP 响应标头，指示响应是否能够和给定的源共享资源。Access-Control-Allow-Origin 指定单个资源会告诉浏览器允许指定来源访问资源。对于没有凭据的请求 <code>*</code>通配符，告诉浏览器允许任何源访问资源。</p>
<p>例如，如果要允许源 <code>https://mozilla.org</code> 的代码访问资源，可以使用如下的指定方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://mozilla.org</span><br><span class="line">Vary: Origin</span><br></pre></td></tr></table></figure>
<p>如果服务器指定单个来源而不是<code>*</code>通配符，则服务器还应在 Vary 响应标头中包含该来源。</p>
<h4 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h4><p><code>Access-Control-Allow-Credentials</code> 是 HTTP 的响应标头，这个标头告诉浏览器，当包含凭证请求（Request.credentials）时是否将响应公开给前端 JavaScript 代码。</p>
<p>这时候你会问到 <code>Request.credentials</code> 是什么玩意？不要着急，来给你看一下，首先来看 Request 是什么玩意，</p>
<p>实际上，Request 是 Fetch API 的一类接口代表着资源请求。一般创建 Request 对象有两种方式</p>
<ul>
<li>使用 Request() 构造函数创建一个 Request 对象</li>
<li>还可以通过 FetchEvent.request api 操作来创建</li>
</ul>
<p>再来说下 Request.credentials 是什么意思，Request 接口的凭据只读属性指示在跨域请求的情况下，用户代理是否应从其他域发送 cookie。（其他 Request 对象的方法详见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request）" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Request）</a></p>
<p>当发送的是凭证模式的请求包含 （Request.credentials）时，如果 Access-Control-Allow-Credentials 值为 true，浏览器将仅向前端 JavaScript 代码公开响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>凭证一般包括 <strong>cookie、认证头和 TLS 客户端证书</strong></p>
<blockquote>
<p>当用作对预检请求响应的一部分时，这表明是否可以使用凭据发出实际请求。注意简单的<code>GET</code> 请求不会进行预检。</p>
</blockquote>
<p>可以参考一个实际的例子 <a href="https://www.jianshu.com/p/ea485e5665b3" target="_blank" rel="noopener">https://www.jianshu.com/p/ea485e5665b3</a></p>
<h4 id="Access-Control-Allow-Headers"><a href="#Access-Control-Allow-Headers" class="headerlink" title="Access-Control-Allow-Headers"></a>Access-Control-Allow-Headers</h4><p><code>Access-Control-Allow-Headers</code> 是一个响应标头，这个标头用来响应预检请求，它发出实际请求时可以使用哪些HTTP标头。</p>
<p><strong>示例</strong></p>
<ul>
<li>自定义标头</li>
</ul>
<p>这是 Access-Control-Allow-Headers 标头的示例。它表明除了像 CROS 安全列出的请求标头外，对服务器的 CROS 请求还支持名为 <code>X-Custom-Header</code> 的自定义标头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br></pre></td></tr></table></figure>
<ul>
<li>多个标头</li>
</ul>
<p>这个例子展示了 Access-Control-Allow-Headers 如何使用多个标头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: X-Custom-Header, Upgrade-Insecure-Requests</span><br></pre></td></tr></table></figure>
<ul>
<li>绕过其他限制</li>
</ul>
<p>尽管始终允许使用 CORS 安全列出的请求标头，并且通常不需要在 Access-Control-Allow-Headers 中列出这些标头，但是无论如何列出它们都将绕开适用的其他限制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: Accept</span><br></pre></td></tr></table></figure>
<p>这里你可能会有疑问，哪些是 CORS 列出的安全标头？（别嫌累，就是这么麻烦）</p>
<p>有下面这些 <strong>Accep、Accept-Language、Content-Language、Content-Type</strong> ，当且仅当包含这些标头时，无需在 CORS 上下文中发送预检请求。</p>
<h4 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a>Access-Control-Allow-Methods</h4><p><code>Access-Control-Allow-Methods</code> 也是响应标头，它指定了哪些访问资源的方法可以使用预检请求。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS</span><br><span class="line">Access-Control-Allow-Methods: *</span><br></pre></td></tr></table></figure>
<h4 id="Access-Control-Expose-Headers"><a href="#Access-Control-Expose-Headers" class="headerlink" title="Access-Control-Expose-Headers"></a>Access-Control-Expose-Headers</h4><p>Access-Control-Expose-Headers 响应标头表明哪些标头可以作为响应的一部分公开。默认情况下，仅公开6个CORS安全列出的响应标头，分别是</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>如果希望客户端能够访问其他标头，则必须使用 Access-Control-Expose-Headers 标头列出它们。下面是示例</p>
<p>要公开非 CORS 安全列出的请求标头，可以像如下这样指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: Content-Length</span><br></pre></td></tr></table></figure>
<p>要另外公开自定义标头，例如 X-Kuma-Revision，可以指定多个标头，并用逗号分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision</span><br></pre></td></tr></table></figure>
<p>在不是凭证请求中，你还可以使用通配符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: *</span><br></pre></td></tr></table></figure>
<p>但是，这不会通配 <code>Authorization</code> 标头，因此如果需要公开它，则需要明确列出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Expose-Headers: *, Authorization</span><br></pre></td></tr></table></figure>
<h4 id="Access-Control-Max-Age"><a href="#Access-Control-Max-Age" class="headerlink" title="Access-Control-Max-Age"></a>Access-Control-Max-Age</h4><p>Access-Control-Max-Age 响应头表示预检请求的结果可以缓存多长时间，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: 600</span><br></pre></td></tr></table></figure>
<p>表示预检请求可以缓存10分钟</p>
<h4 id="Access-Control-Request-Headers"><a href="#Access-Control-Request-Headers" class="headerlink" title="Access-Control-Request-Headers"></a>Access-Control-Request-Headers</h4><p>浏览器在发出预检请求时使用 Access-Control-Request-Headers 请求标头，使服务器知道在发出实际请求时客户端可能发送的 HTTP 标头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>
<h4 id="Access-Control-Request-Method"><a href="#Access-Control-Request-Method" class="headerlink" title="Access-Control-Request-Method"></a>Access-Control-Request-Method</h4><p>同样的，Access-Control-Request-Method 响应标头告诉服务器发出预检请求时将使用那种 HTTP 方法。此标头是必需的，<strong>因为预检请求始终是 OPTIONS</strong>，并且使用的方法与实际请求不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: POST</span><br></pre></td></tr></table></figure>
<h4 id="Origin-1"><a href="#Origin-1" class="headerlink" title="Origin"></a>Origin</h4><p>Origin 请求标头表明匹配的来源，它不包含任何信息，仅仅包含服务器名称，它与 CORS 请求以及 POST 请求一起发送，它类似于 <code>Referer</code> 标头，但与此标头不同，它没有公开整个路径。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: https://developer.mozilla.org</span><br></pre></td></tr></table></figure>
<h2 id="HTTP-条件请求"><a href="#HTTP-条件请求" class="headerlink" title="HTTP 条件请求"></a><strong>HTTP 条件请求</strong></h2><p>HTTP 具有条件请求的概念，通过比较资源更新生成的值与验证器的值进行比较，来确定资源是否进行过更新。这样的请求对于验证缓存的内容、条件请求、验证资源的完整性来说非常重要。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>HTTP 条件请求是根据特定标头的值执行不同的请求，这些标头定义了一个前提条件，如果前提条件匹配或不匹配，则请求的结果将有所不同。</p>
<ul>
<li>对于 <code>安全</code> 的方法，像是 <code>GET</code>、用于请求文档的资源，仅当条件请求的条件满足时发回文档资源，所以，这种方式可以节约带宽。</li>
</ul>
<blockquote>
<p>什么是安全的方法，对于 HTTP 来说，<strong>安全的方法是不会改变服务器状态的方法</strong>，换句话说，如果方法只是只读操作，那么它肯定是安全的方法，比如说 GET 请求，它肯定是安全的方法，因为它只是请求资源。几种常见的方法肯定是安全的，它们是 <strong>GET、HEAD和 OPTIONS</strong>。所有安全的方法都是<code>幂等的</code>（这他妈幂等又是啥意思？）但不是所有幂等的方法都是安全的，例如 PUT 和 DELETE 都是幂等的，但不安全。</p>
<p>幂等性：如果相同的客户端发起一次或者多次 HTTP 请求会得到相同的结果，则说明 HTTP 是幂等的。（我们这次不深究幂等性）</p>
</blockquote>
<ul>
<li>对于 <code>非安全</code> 的方法，像是 PUT，只有原始文档与服务器上存储的资源相同时，才可以使用条件请求来传输文档。（PUT 方法通常用来传输文件，就像 FTP 协议的文件上传一样）</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h3><p>所有的条件请求都会尝试检查服务器上存储的资源是否与某个特定版本的资源相匹配。为了满足这种情况，条件请求需要指示资源的版本。由于无法和整个文件逐个字符进行比较，因此需要把整个文件描绘成一个值，然后把此值和服务器上的资源进行比较，这种方式称为比较器，比较器有两个条件</p>
<ul>
<li>文档的最后修改日期</li>
<li>一个不透明的字符串，用于唯一标识每个版本，称为实体标签或 <code>Etag</code>。</li>
</ul>
<p>比较两个资源是否时相同的版本有些复杂，根据上下文，有两种相等性检查</p>
<ul>
<li>当期望的是字节对字节进行比较时，例如在恢复下载时，使用<code>强 Etag</code>进行验证</li>
<li>当用户代理需要比较两个资源是否具有相同的内容时，使用<code>若 Etag</code> 进行验证</li>
</ul>
<p>HTTP 协议默认使用 <code>强验证</code>，它指定何时进行弱验证</p>
<h4 id="强验证"><a href="#强验证" class="headerlink" title="强验证"></a>强验证</h4><p>强验证保证的是<code>字节</code> 级别的验证，严格的验证非常严格，可能在服务器级别难以保证，但是它能够保证任何时候都不会丢失数据，但这种验证丢失性能。</p>
<p>要使用 <code>Last-Modified</code> 很难实现强验证，通常，这是通过使用带有资源的 MD5 哈希值的<code>Etag</code> 来完成的。</p>
<h4 id="弱验证"><a href="#弱验证" class="headerlink" title="弱验证"></a>弱验证</h4><p>弱验证不同于强验证，因为如果内容相等，它将认为文档的两个版本相同，例如，一个页面与另一个页面的不同之处仅在于页脚的日期不同，因此该页面被认为与其他页面相同。而使用强验证时则被认为这两个版本是不同的。构建一个若验证的 Etag 系统可能会非常复杂，因为这需要了解每个页面元素的重要性，但是对于优化缓存性能非常有用。</p>
<p>下面介绍一下 Etag 如何实现强弱验证。</p>
<p>Etag 响应头是<code>特定版本</code>的标识，它能够使缓存变得更高效并能够节省带宽，因为如果缓存内容未发生变更，Web 服务器则不需要重新发送完整的响应。除此之外，Etag 能够防止资源同时更新互相覆盖。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>如果给定 URL 上的资源发生变更，必须生成一个新的 <code>Etag</code> 值，通过比较它们可以确定资源的两个表示形式是否相同。</p>
<p>Etag 值有两种，一种是强 Etag，一种是弱 Etag；</p>
<ul>
<li>强 Etag 值，无论实体发生多么细微的变化都会改变其值，一般的表示如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>弱 Etag 值，弱 Etag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 Etag 值。这时，会在字段值最开始处附加 W/。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: W/&quot;0815&quot;</span><br></pre></td></tr></table></figure>
<p>下面就来具体探讨一下条件请求的标头和 Etag 的关系</p>
<h3 id="条件请求"><a href="#条件请求" class="headerlink" title="条件请求"></a><strong>条件请求</strong></h3><p>条件请求主要包含的标头如下</p>
<ul>
<li>If-Match</li>
<li>If-None-Match</li>
<li>If-Modified-Since</li>
<li>If-Unmodified-Since</li>
<li>If-Range</li>
</ul>
<h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><p>对于 <code>GET</code> 和 <code>POST</code> 方法，服务器仅在与列出的 <code>Etag（响应标头）</code> 之一匹配时才返回请求的资源。这里又多了一个新词 <code>Etag</code>，我们稍后再说 Etag 的用法。对于像是 <code>PUT</code>和其他非安全的方法，在这种情况下，它仅仅将上传资源。</p>
<p>下面是两种常见的案例</p>
<ul>
<li>对于 <code>GET</code> 和 <code>POST</code> 方法，会结合使用 <code>Range</code> 标头，它可以确保新发送请求的范围与上一个请求的资源相同，如果不匹配的话，会返回 <code>416</code> 响应。</li>
<li>对于其他方法，特别是 <code>PUT</code> 方法，<code>If-Match</code> 可以防止丢失更新，服务器会比对 If-Match 的字段值和资源的 Etag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。例如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;</span><br><span class="line">If-Match: *</span><br></pre></td></tr></table></figure>
<h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h4><p>条件请求，它与 <code>If-Match</code> 的作用相反，仅当 <code>If-None-Match</code> 的字段值与 <code>Etag</code> 值不一致时，可处理该请求。对于<code>GET</code> 和 <code>HEAD</code> ，仅当服务器没有与给定资源匹配的 <code>Etag</code> 时，服务器将返回 <code>200 OK</code>作为响应。对于其他方法，仅当最终现有资源的 Etag 与列出的任何值都不匹配时，才会处理请求。</p>
<p>当 <code>GET</code> 和 <code>POST</code> 发送的 <code>If-None-Match</code>与 <code>Etag</code> 匹配时，服务器会返回 <code>304</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;bfc13a64729c4290ef5b2c2730249c88ca92d82d&quot;</span><br><span class="line">If-None-Match: W/&quot;67ab43&quot;, &quot;54ed21&quot;, &quot;7892dd&quot;</span><br><span class="line">If-None-Match: *</span><br></pre></td></tr></table></figure>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><p><code>If-Modified-Since</code> 是 HTTP 条件请求的一部分，只有在给定日期之后，服务端修改了请求所需要的资源，才会返回 200 OK 的响应。如果在给定日期之后，服务端没有修改内容，响应会返回 <code>304</code> 并且不带任何响应体。If-Modified-Since 只能使用 <code>GET</code> 和 <code>HEAD</code>请求。</p>
<p>If-Modified-Since 与 If-None-Match 结合使用时，它将被忽略，除非服务器不支持 If-None-Match。一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这是格林威治标准时间。HTTP 日期始终以格林尼治标准时间表示，而不是本地时间。</p>
</blockquote>
<h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4><p><code>If-Range</code> 也是条件请求，如果满足条件（If-Range 的值和 Etag 值或者更新的日期时间一致），则会发出范围请求，否则将会返回全部资源。它的一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-Range: Wed, 21 Oct 2015 07:28:00 GMT</span><br><span class="line">If-Range: bfc13a64729c4290ef5b2c2730249c88ca92d82d</span><br></pre></td></tr></table></figure>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><p><code>If-Unmodified-Since</code> HTTP 请求标头也是一个条件请求，服务器只有在给定日期之后没有对其进行修改时，服务器才返回请求资源。如果在指定日期时间后发生了更新，则以状态码 <code>412 Precondition Failed</code> 作为响应返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<h3 id="条件请求示例"><a href="#条件请求示例" class="headerlink" title="条件请求示例"></a><strong>条件请求示例</strong></h3><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>条件请求最常见的示例就是更新缓存，如果缓存是空或没有缓存，则以<code>200 OK</code>的状态发送回请求的资源。如下图所示</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>客户端第一次发送请求没有，缓存为空并且没有条件请求，服务器在收到客户端请求后，设置验证器 <code>Last-Modified</code> 和 <code>Etag</code> 标签，并把这两个标签随着响应一起发送回客户端。</p>
<p>下一次客户端再发送相同的请求后，会直接从缓存中提取，只要缓存没有过期，就不会有任何新的请求到达服务器重新下载资源。但是，一旦缓存过期，客户端不会直接使用缓存的值，而是发出条件请求。验证器的值用作 <code>If-Modified-Since</code> 和<code>If-Match</code>标头的参数。</p>
<p>缓存过期后客户端重新发起请求，服务器收到请求后发现如果资源没有更改，服务器会发回 <code>304 Not Modified</code>响应，这使缓存再次刷新，并让客户端使用缓存的资源。尽管有一个响应/请求往返消耗一些资源，但是这比再次通过有线传输整个资源更有效。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>如果资源已经发生更改，则服务器仅使用新版本的资源返回 200 OK 响应，就像没有条件请求，并且客户端会重新使用新的资源，从这个角度来讲，<strong>缓存是条件请求的前置条件</strong>。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><p>HTTP 可以支持文件的部分下载，通过保留已获得的信息，此功能允许恢复先前的操作，从而节省带宽和时间。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>支持断点续传的服务器通过发送 <code>Accept-Ranges</code> 标头广播此消息，一旦发生这种情况，客户端可以通过发送缺少范围的 <code>Ranges</code>标头来恢复下载</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这里你可能有疑问 <code>Ranges</code> 和 <code>Content-Range</code>是什么，来解释一下</p>
<p><strong>Range</strong></p>
<p><code>Range</code> HTTP 请求标头指示服务器应返回文档指定部分的资源，可以一次请求一个 Range 来返回多个部分，服务器会将这些资源返回各个文档中。如果服务器成功返回，那么将返回 206 响应；如果 Range 范围无效，服务器返回<code>416 Range Not Satisfiable</code>错误；服务器还可以忽略 Range 标头，并且返回 200 作为响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=200-1000, 2000-6576, 19000-</span><br></pre></td></tr></table></figure>
<p>还有一种表示是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=0-499, -500</span><br></pre></td></tr></table></figure>
<p>它们分别表示请求前500个字节和最后500个字节，如果范围重叠，则服务器可能会拒绝该请求。</p>
<p><strong>Content-Range</strong></p>
<p>HTTP 的 Content-Range 响应标头是针对范围请求而设定的，返回响应时使用首部字段<code>Content-Range</code>，能够告知客户端响应实体的哪部分是符合客户端请求的，字段以字节为单位。它的一般表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 200-1000/67589</span><br></pre></td></tr></table></figure>
<p>上段代码表示从所有 <code>67589</code> 个字节中返回 <code>200-1000</code> 个字节的内容</p>
<p>那么上面的 <code>Content-Range</code>你也应该知道是什么意思了</p>
<p><code>断点续传</code>的原理比较简单，但是这种方式存在潜在的问题：如果在两次下载资源的期间进行了资源更新，那么获得的范围将对应于资源的两个不同版本，并且最终文档将被破坏。</p>
<p>为了阻止这种情况的出现，就会使用<code>条件请求</code>。对于范围来说，有两种方法可以做到这一点。一种方法是使用 <code>If-Modified-Since</code>和<code>If-Match</code>，如果前提条件失败，服务器将返回错误；然后客户端从头开始重新下载。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>即使此方法有效，当文档资源发生改变时，它也会添加额外的 <code>响应/请求</code> 交换。这会降低性能，并且 HTTP 具有特定的标头来避免这种情况 <code>If-Range</code>。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>该解决方案效率更高，但灵活性稍差一些，因为在这种情况下只能使用一个 Etag。</p>
<h4 id="通过乐观锁避免丢失更新"><a href="#通过乐观锁避免丢失更新" class="headerlink" title="通过乐观锁避免丢失更新"></a>通过乐观锁避免丢失更新</h4><p>Web 应用程序中最普遍的操作是资源更新。这在任何文件系统或应用程序中都很常见，但是任何允许存储远程资源的应用程序都需要这种机制。</p>
<p>使用 <code>put</code> 方法，你可以实现这一点，客户端首先读取原始文件对其进行修改，然后把它们发送到服务器。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>上面这种请求响应存在问题，一旦考虑到并发性，事情就会变得不准确。当客户端在本地修改资源打算重新发送之前，第二个客户端可以获取相同的资源并对资源进行修改操作，这样就会造成问题。当它们重新发送请求到服务器时，第一个客户端所做的修改将被第二次客户端的修改所覆盖，因为第二次客户端修改并不知道第一次客户端正在修改。资源提交并更新的一方不会传达给另外一方，所以要保留哪个客户的更改，将随着他们提交的速度而变化；这取决于客户端，服务器的性能，甚至取决于人工在客户端编辑文档的性能。例如下面这个流程</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>如果没有两个用户同时操作服务器，也就不存在这个问题。但是，现实情况是不可能只有单个用户出现的，所以为了规避或者避免这个问题，我们希望客户端资源在更新时进行提示或者修改被拒绝时收到通知。</p>
<p>条件请求允许实现乐观锁算法。这个概念是允许所有的客户端获取资源的副本，然后让他们在本地修改资源，并成功通过允许第一个客户端提交更新来控制并发，基于此服务端的后面版本的更新都将被拒绝。</p>
<p><img src="/2020/02/06/HTTP协议要点/640.webp" alt="img"></p>
<p>这是使用 <code>If-Match</code> 或 <code>If-Unmodified-Since</code>标头实现的。如果 Etag 与原始文件不匹配，或者自获取以来已对文件进行了修改，则更改为拒绝更新，并显示<code>412 Precondition Failed</code>错误。</p>
<h2 id="HTTP-Cookies"><a href="#HTTP-Cookies" class="headerlink" title="HTTP Cookies"></a><strong>HTTP Cookies</strong></h2><p>HTTP 协议中的 Cookie 包括 <code>Web Cookie</code> 和<code>浏览器 Cookie</code>，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p>
<blockquote>
<p>HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良</p>
</blockquote>
<p>Cookie 主要用于下面三个目的</p>
<ul>
<li><code>会话管理</code></li>
</ul>
<p>登陆、购物车、游戏得分或者服务器应该记住的其他内容</p>
<ul>
<li><code>个性化</code></li>
</ul>
<p>用户偏好、主题或者其他设置</p>
<ul>
<li><code>追踪</code></li>
</ul>
<p>记录和分析用户行为</p>
<p>Cookie 曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端上存储数据的唯一方法，但如今建议使用现代存储 API。Cookie 随每个请求一起发送，因此它们可能会降低性能（尤其是对于移动数据连接而言）。客户端存储的现代 API 是 Web 存储 API（localStorage 和 sessionStorage）和 IndexedDB。</p>
<h3 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a><strong>创建 Cookie</strong></h3><p>当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 <code>Set-Cookie</code> 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求。可以指定到期日期或持续时间，之后将不再发送Cookie。此外，可以设置对特定域和路径的限制，从而限制 cookie 的发送位置。</p>
<h4 id="Set-Cookie-和-Cookie-标头"><a href="#Set-Cookie-和-Cookie-标头" class="headerlink" title="Set-Cookie 和 Cookie 标头"></a>Set-Cookie 和 Cookie 标头</h4><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<p>此标头告诉客户端存储 Cookie</p>
<p>现在，随着对服务器的每个新请求，浏览器将使用 Cookie 头将所有以前存储的 cookie 发送回服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/2.0</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<p>Cookie 主要分为三类，它们是 <code>会话Cookie</code>、<code>永久Cookie</code> 和 <code>Cookie的 Secure 和 HttpOnly 标记</code>，下面依次来介绍一下</p>
<h4 id="会话-Cookies"><a href="#会话-Cookies" class="headerlink" title="会话 Cookies"></a><strong>会话 Cookies</strong></h4><p>上面的示例创建的是会话 Cookie ，会话 Cookie 有个特征，客户端关闭时 Cookie 会删除，因为它没有指定Expires 或 Max-Age 指令。这两个指令你看到这里应该比较熟悉了。</p>
<p>但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样</p>
<h4 id="永久性-Cookies"><a href="#永久性-Cookies" class="headerlink" title="永久性 Cookies"></a><strong>永久性 Cookies</strong></h4><p>永久性 Cookie 不会在客户端关闭时过期，而是在特定日期（Expires）或特定时间长度（Max-Age）外过期。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>
<h4 id="Cookie的-Secure-和-HttpOnly-标记"><a href="#Cookie的-Secure-和-HttpOnly-标记" class="headerlink" title="Cookie的 Secure 和 HttpOnly 标记"></a><strong>Cookie的 Secure 和 HttpOnly 标记</strong></h4><p>安全的 Cookie 需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。</p>
<p><strong>HttpOnly 的作用</strong></p>
<ul>
<li>会话 cookie 中缺少 HttpOnly 属性会导致攻击者可以通过程序(JS脚本、Applet等)获取到用户的 cookie  信息，造成用户cookie 信息泄露，增加攻击者的跨站脚本攻击威胁。</li>
<li>HttpOnly 是微软对 cookie 做的扩展，该值指定 cookie 是否可通过客户端脚本访问。</li>
<li>如果在 Cookie 中没有设置 HttpOnly 属性为 true，可能导致 Cookie 被窃取。窃取的 Cookie 可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的 Cookie，以便伪装成用户或获取敏感信息，进行跨站脚本攻击等。</li>
</ul>
<h3 id="Cookie-的作用域"><a href="#Cookie-的作用域" class="headerlink" title="Cookie 的作用域"></a><strong>Cookie 的作用域</strong></h3><p><code>Domain</code> 和 <code>Path</code> 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(<strong>不包含子域名</strong>）。如果指定了<code>Domain</code>，则一般包含子域名。</p>
<p>例如，如果设置 <code>Domain=mozilla.org</code>，则 Cookie 也包含在子域名中（如<code>developer.mozilla.org</code>）。</p>
<p>例如，设置 <code>Path=/docs</code>，则以下地址都会匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/docs</span><br><span class="line">/docs/Web/</span><br><span class="line">/docs/Web/HTTP</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/Mermaid-实用教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/Mermaid-实用教程/" itemprop="url">
                  Mermaid 实用教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:40:12" itemprop="dateCreated datePublished" datetime="2020-02-04T21:40:12+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/mermaid/" itemprop="url" rel="index"><span itemprop="name">mermaid</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h1><p><a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://github.com/knsv/mermaid" target="_blank" rel="noopener">Github地址</a></p>
<p>语句末尾分号是可选的。<code>%%</code> 行注释。</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="图表方向"><a href="#图表方向" class="headerlink" title="图表方向"></a>图表方向</h3><p>Mermaid 支持多种图表的方向，语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph 方向描述</span><br><span class="line">    图表中的其他语句...</span><br></pre></td></tr></table></figure>
<p>其中“方向描述”为</p>
<table>
<thead>
<tr>
<th>用词</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TB</td>
<td>从上到下</td>
</tr>
<tr>
<td>BT</td>
<td>从下到上</td>
</tr>
<tr>
<td>RL</td>
<td>从右到左</td>
</tr>
<tr>
<td>LR</td>
<td>从左到右</td>
</tr>
</tbody>
</table>
<h3 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h3><p>即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid 中每个节点都有一个 id，以及节点的文字。</p>
<table>
<thead>
<tr>
<th>表述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id[文字]</code></td>
<td>矩形节点</td>
</tr>
<tr>
<td><code>id(文字)</code></td>
<td>圆角矩形节点</td>
</tr>
<tr>
<td><code>id((文字))</code></td>
<td>圆形节点</td>
</tr>
<tr>
<td><code>id&gt;文字]</code></td>
<td>右向旗帜状节点</td>
</tr>
<tr>
<td><code>id{文字}</code></td>
<td>菱形节点</td>
</tr>
</tbody>
</table>
<p>需要注意的是，如果节点的文字中包含标点符号，需要时用双引号包裹起来。<br>另外如果希望在文字中使用换行，请使用<br>替换换行</p>
<h3 id="节点间的连线"><a href="#节点间的连线" class="headerlink" title="节点间的连线"></a>节点间的连线</h3><table>
<thead>
<tr>
<th>表述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>添加尾部箭头</td>
</tr>
<tr>
<td><code>-</code></td>
<td>不添加尾部箭头</td>
</tr>
<tr>
<td><code>--</code></td>
<td>单线</td>
</tr>
<tr>
<td><code>--text--</code></td>
<td>单线上加文字</td>
</tr>
<tr>
<td><code>==</code></td>
<td>粗线</td>
</tr>
<tr>
<td><code>==text==</code></td>
<td>粗线加文字</td>
</tr>
<tr>
<td><code>-.-</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>-.text.-</code></td>
<td>虚线加文字</td>
</tr>
</tbody>
</table>
<h3 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h3><p>使用以下语法添加子图表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subgraph 子图表名称</span><br><span class="line">    子图表中的描述语句...</span><br><span class="line">end123</span><br></pre></td></tr></table></figure>
<h3 id="对-font-awesome-的支持"><a href="#对-font-awesome-的支持" class="headerlink" title="对 font awesome 的支持"></a>对 font awesome 的支持</h3><p>使用 <code>fa: #图表名称#</code> 的语法添加 fontawesome。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/p2chh5tny9.png" alt="img"></p>
<h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><ul>
<li>TB/TD - top bottom</li>
<li>BT - bottom top</li>
<li>RL - right left</li>
<li>LR - left right</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    Start --&gt; Stop</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/rpmt1s8371.png" alt="img"></p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/k5j7lcf2he.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id[带文字节点]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/5oqklmc0rz.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id(圆角节点)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/m1l8w2srpz.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id((圆形节点))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/hzg2snr471.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id&gt;不对称节点]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/d28pv3fqx3.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id&#123;菱形节点&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/3v5j4fczmb.png" alt="img"></p>
<h2 id="连接线"><a href="#连接线" class="headerlink" title="连接线"></a>连接线</h2><h3 id="实线，箭头，无文字"><a href="#实线，箭头，无文字" class="headerlink" title="实线，箭头，无文字"></a>实线，箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/riv4kf6dae.png" alt="img"></p>
<h3 id="实线，无箭头，无文字"><a href="#实线，无箭头，无文字" class="headerlink" title="实线，无箭头，无文字"></a>实线，无箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A---B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/101km96s26.png" alt="img"></p>
<h3 id="实线，无箭头，文字"><a href="#实线，无箭头，文字" class="headerlink" title="实线，无箭头，文字"></a>实线，无箭头，文字</h3><p>前面<strong>两个</strong> <code>-</code>，后面<strong>三个</strong> <code>-</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A-- 文字 ---B</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--- |文字| B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/vofik65ttt.png" alt="img"></p>
<h3 id="实线，箭头，文字"><a href="#实线，箭头，文字" class="headerlink" title="实线，箭头，文字"></a>实线，箭头，文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A-- 文字 --&gt;B</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt; |文字| B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/hlimub9499.png" alt="img"></p>
<h3 id="虚线，箭头，无文字"><a href="#虚线，箭头，无文字" class="headerlink" title="虚线，箭头，无文字"></a>虚线，箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">   A-.-&gt;B;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/793ve0ql3.png" alt="img"></p>
<h3 id="虚线，箭头，文字"><a href="#虚线，箭头，文字" class="headerlink" title="虚线，箭头，文字"></a>虚线，箭头，文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   A-. text .-&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/famuxq0vqf.png" alt="img"></p>
<h3 id="大箭头，无文字"><a href="#大箭头，无文字" class="headerlink" title="大箭头，无文字"></a>大箭头，无文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   A ==&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/0kdfo5h802.png" alt="img"></p>
<h3 id="大箭头，文字"><a href="#大箭头，文字" class="headerlink" title="大箭头，文字"></a>大箭头，文字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   A == text ==&gt; B</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/za7vuejw2d.png" alt="img"></p>
<h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>文字里用引号避免一些特殊字符的错误。比如矩形节点里有 <code>()</code> 时就无法渲染，所以加上引号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1[<span class="string">"This is the (text) in the box"</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/zcfze0sen3.png" alt="img"></p>
<h3 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h3><p>可以使用 HTML 中的实体字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">     A[<span class="string">"A double quote:#quot;"</span>] --&gt;B[<span class="string">"A dec char:#9829;"</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/fjcviqs56s.png" alt="img"></p>
<h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/z3b2vu7vmf.png" alt="img"></p>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br><span class="line">    linkStyle 0 stroke:#0ff,stroke-width:2px;</span><br><span class="line">    linkStyle 3 stroke:#ff3,stroke-width:4px;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/9mwcxke502.png" alt="img"></p>
<p>可以设置节点背景，边框颜色，粗细，实线还是虚线</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1(Start)--&gt;id2(Stop)</span><br><span class="line">    style id1 fill:#f9f,stroke:#333,stroke-width:4px</span><br><span class="line">    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/deqsocy55j.png" alt="img"></p>
<h3 id="样式类"><a href="#样式类" class="headerlink" title="样式类"></a>样式类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A--&gt;B</span><br><span class="line"></span><br><span class="line">    %% 定义样式类</span><br><span class="line">    classDef className fill:#f9f,stroke:#333,stroke-width:4px;</span><br><span class="line"></span><br><span class="line">    %% 应用样式类，markdown里没效果</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">className</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/pdafavbwpk.png" alt="img"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classDef default fill:#f9f,stroke:#333,stroke-width:4px;</span><br></pre></td></tr></table></figure>
<p>定义一个名为 <code>default</code> 的类，节点没有指定特定样式类时，将都会应用这个样式类。</p>
<h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>可以使用 <a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a> 图标。语法 <code>fa:icon class name</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">   B[<span class="string">"fa:fa-twitter for peace"</span>]</span><br><span class="line">   B--&gt;C[fa:fa-ban forbidden]</span><br><span class="line">   B--&gt;D(fa:fa-spinner);</span><br><span class="line">   B--&gt;E(A fa:fa-camera-retro perhaps?);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/xdstdd6e2k.png" alt="img"></p>
<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right <span class="keyword">of</span> John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/180rjui5io.png" alt="img"></p>
<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><p>如果不显示声明，参与者将根据第一次出现的顺序排列，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/eleicv4hs1.png" alt="img"></p>
<p>第一条语句出现了两个参与者角色，而在这条语句中，Alice 在 John 之前，所以图中也是这个顺序。如果不想根据第一次出现的顺序来排，可以主动声明以定义顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant John</span><br><span class="line">    participant Alice</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/aq8hilfa2o.png" alt="img"></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>可以给角色写一个简短的别名以方便书写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant A <span class="keyword">as</span> Alice</span><br><span class="line">    participant J <span class="keyword">as</span> John</span><br><span class="line">    A-&gt;&gt;J: Hello John, how are you?</span><br><span class="line">    J-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/ys9jab2wqg.png" alt="img"></p>
<h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息连线有六种样式。</p>
<p>有<strong>一个</strong><code>-</code>是实线，<strong>两个</strong><code>-</code>是虚线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    A-&gt;B: 无箭头实线</span><br><span class="line">    A--&gt;B: 无箭头虚线(点线)</span><br><span class="line">    A-&gt;&gt;B: 有箭头实线</span><br><span class="line">    A--&gt;&gt;B: 有箭头实线</span><br><span class="line">    A-x B: 有箭头实线，加上叉</span><br><span class="line">    A--x B: 有箭头虚线，加上叉</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/7qplows8g4.png" alt="img"></p>
<h2 id="活动期"><a href="#活动期" class="headerlink" title="活动期"></a>活动期</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    %% activate 角色名 表示激活控制焦点</span><br><span class="line">    activate John</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    %% deactivate 角色名 表示控制焦点结束</span><br><span class="line">    deactivate John</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/jx85ho8ny2.png" alt="img"></p>
<p>使用 <code>+/-</code> 的更方便的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;+John: Hello John, how are you?</span><br><span class="line">    John--&gt;&gt;-Alice: Great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/2q1cxx79gd.png" alt="img"></p>
<p>可以嵌套：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;+John: Hello John, how are you?</span><br><span class="line">    Alice-&gt;&gt;+John: John, can you hear me?</span><br><span class="line">    John--&gt;&gt;-Alice: Hi Alice, I can hear you!</span><br><span class="line">    John--&gt;&gt;-Alice: I feel great!</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/jee37p2zzs.png" alt="img"></p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>语法：Note [ right of | left of | over ] [Actor]。</p>
<table>
<thead>
<tr>
<th>表述</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>right of</td>
<td>右侧</td>
</tr>
<tr>
<td>left of</td>
<td>左侧</td>
</tr>
<tr>
<td>over</td>
<td>在当中，可以横跨多个参与者</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant John</span><br><span class="line">    Note right <span class="keyword">of</span> John: Text <span class="keyword">in</span> note</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/vks6zmd1s5.png" alt="img"></p>
<p>over 可用于单独一个角色上，也可以用于相邻两个角色间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    Note over Alice,<span class="attr">John</span>: A typical interaction</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/5b8q8sacis.png" alt="img"></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loop Loop text</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    %% loop 后跟循环体说明文字</span><br><span class="line">    loop Every minute</span><br><span class="line">        John--&gt;Alice: Great!</span><br><span class="line">    %% 标记循环结束</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/4o0mms4o5z.png" alt="img"></p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alt Describing text</span><br><span class="line">... statements ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">... statements ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>可选条件，比如在没有 else 分支的情况下使用，有点类似 java 中的 switch 的 default 分支，代表剩下所有情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">opt Describing text</span><br><span class="line">... statements ...</span><br><span class="line">end</span><br><span class="line">sequenceDiagram</span><br><span class="line">    Alice-&gt;&gt;Bob: Hello Bob, how are you?</span><br><span class="line">    alt is sick</span><br><span class="line">        Bob-&gt;&gt;Alice: Not so good :(</span><br><span class="line">    <span class="keyword">else</span> is well</span><br><span class="line">        Bob-&gt;&gt;Alice: Feeling fresh like a daisy</span><br><span class="line">    end</span><br><span class="line">    opt Extra response</span><br><span class="line">        Bob-&gt;&gt;Alice: Thanks <span class="keyword">for</span> asking</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/Mermaid-实用教程/ruwizvoin8.png" alt="img"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/" itemprop="url">
                  使用Apache Bench和Gnuplot产生性能测试图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:13:26" itemprop="dateCreated datePublished" datetime="2020-02-04T21:13:26+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/性能测试/" itemprop="url" rel="index"><span itemprop="name">性能测试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener">Apache Beach</a> (ab)是Apache自带的一个性能测试工具，专门用来测试网站的性能， 不仅限于Apache web服务器。</p>
<p>它可以同时模拟多个并发请求，测试Web服务器的最大承载压力，同时也可以根据Apache Bench提供的测试结果对服务器性能参数进行调整。它可以记录测试数据，其它工具比如Gnuplot可以利用测试数据进行分析。它也可以提供一个summary，可以直观显示当前测试的web服务器的性能。</p>
<h2 id="安装ab"><a href="#安装ab" class="headerlink" title="安装ab"></a>安装ab</h2><p>  ab是Apache httpd的一部分。不同的发行版提供了不同的安装方法。<br>  比如在笔者使用的redhat 6.4上可以查看此工具在哪个包里：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#yum provides /usr/bin/ab</span></span><br><span class="line">......</span><br><span class="line">httpd-tools-2.2.15-30.el6.centos.x86_64 : Tools <span class="keyword">for</span> use with the Apache HTTP</span><br><span class="line">                                        : Server</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/ab</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>它被打包在httpd-tools包里，安装httpd-tools:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure>
<p>安装成功后查看帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -h</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ab</span><br></pre></td></tr></table></figure>
<h2 id="运行ab"><a href="#运行ab" class="headerlink" title="运行ab"></a>运行ab</h2><p>  一个最简单的ab例子就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ab -n 100 -c 10 http://www.google.com/</span></span><br></pre></td></tr></table></figure>
<p>注意网址后面要加”/“或者明确的path如”<a href="https://www.google.com/?gfe_rd=cr&amp;ei=_BvfU77ZGMeL8QfugIHAAw&quot;" target="_blank" rel="noopener">https://www.google.com/?gfe_rd=cr&amp;ei=_BvfU77ZGMeL8QfugIHAAw&quot;</a>.<br>“-c”是并发数，可以模拟同时有多少个clients并发访问。<br>“-n”表示总的请求数。每个client发送的请求数为此数字除以client数（上面的数字）。<br>“-t”可以指定测试的最大时间，如果还不到此数请求已经发完，那么测试也会结束。当使用-t参数时，ab内部默认最大的请求数为50000，为了同时使用”-n”指定的参数，可以将”-t”参数放在”-n”参数之前， 如果想了解更多的信息， 可以查看这篇<a href="http://100continue.iteye.com/blog/1325398" target="_blank" rel="noopener">文章</a>.</p>
<h2 id="实际运行ab"><a href="#实际运行ab" class="headerlink" title="实际运行ab"></a>实际运行ab</h2><p>  我使用apache ab要测试的是一个tomcat搭建的集群，上面跑着CPU密集型的一个应用程序，前面使用nginx作为load balancer。<br>  此应用的一个主要的服务通过RESTful service提供， 并且是POST类型的。 Request body是一个XML。<br>  我想随机的替换body中的一个属性，以便测试动态请求对服务器的影响。 但是Apache ab只能提供静态的数据，所以我下载了它的代码并改造了一下。<br>  <strong>首先创建了一个request.xml， 并将其中的那个属性改为占位符</strong> 修改ab.c文件，将发送请求中的占位符用随机数代替<br>  修改的代码可重用性不高，在这里就不贴了。</p>
<p>写了一个脚本，可以测试不同的并发数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;4,20,50,100,150,200,300&#125;</span><br><span class="line">do</span><br><span class="line">        ab -g plot/biz$var.dat -r -c $&#123;var&#125; -n $&#123;total&#125; -H 'Accept:application/xml'  -p request.xml -T 'application/xml' http://localhost:8080/app/biz</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="使用Gnuplot生成图表"><a href="#使用Gnuplot生成图表" class="headerlink" title="使用Gnuplot生成图表"></a>使用Gnuplot生成图表</h2><p>  在上一步中生成了测试数据，我们可以通过Gnuplot这一强大的工具生成漂亮的图表了。<br>  在生成图表之前，我们还需要处理一下获得的数据，<br>  如果直接使用测试生成报表，我们可能得到这样一个图表：<br>  <img src="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/image-20200204213258370.png" alt="响应时间"></p>
<p>相应的Gnuplot文件为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#output as png image</span></span><br><span class="line"><span class="string">set</span> <span class="string">terminal</span> <span class="string">png</span> <span class="string">size</span> <span class="number">1000</span><span class="string">,560</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#save file to "domain.png"</span></span><br><span class="line"><span class="string">set</span> <span class="string">output</span> <span class="string">"biz.png"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#graph title</span></span><br><span class="line"><span class="string">set</span> <span class="string">title</span> <span class="string">"Biz Performance"</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">invert</span> <span class="string">reverse</span> <span class="string">Left</span> <span class="string">outside</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nicer aspect ratio for image size</span></span><br><span class="line"><span class="comment">#set size 1,0.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># y-axis grid</span></span><br><span class="line"><span class="string">set</span> <span class="string">grid</span> <span class="string">y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#x-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">xlabel</span> <span class="string">"requests"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#y-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">ylabel</span> <span class="string">"response time (ms)"</span></span><br><span class="line"><span class="comment">#plot data from "biz.dat" using column 9 with smooth sbezier lines</span></span><br><span class="line"><span class="comment">#and title of "Biz Performance" for the given data</span></span><br><span class="line"><span class="string">plot</span> <span class="string">"biz4.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 4"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz20.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 20"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz50.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 50"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz100.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 100"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz150.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 150"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz200.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 200"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"biz300.dat"</span> <span class="string">using</span> <span class="number">9</span> <span class="string">smooth</span> <span class="string">sbezier</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 300"</span></span><br></pre></td></tr></table></figure>
<p>这张图有参考价值，我们可以看到大部分的请求的相应时间落在那个数值段中，但是不能以时间序列显示服务器的性能。 它是以”总用时“ (ttime) 进行排序，所以一般它会一条上升的曲线来显示。<br>这篇<a href="http://www.bradlanders.com/2013/04/15/apache-bench-and-gnuplot-youre-probably-doing-it-wrong/" target="_blank" rel="noopener">文章</a>中指出了一种按照时间序列显示数据的方法。 Apapche ab生成的测试数据中已经包含了时间戳，可以修改Gnuplot生成按时间序列显示的响应时间图：<br>[<img src="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/image-20200204213452892.png" alt="时间序列"></p>
<p>Gnuplot文件为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let's output to a jpeg file</span></span><br><span class="line"><span class="string">set</span> <span class="string">terminal</span> <span class="string">jpeg</span> <span class="string">size</span> <span class="number">500</span><span class="string">,500</span></span><br><span class="line"><span class="comment"># This sets the aspect ratio of the graph</span></span><br><span class="line"><span class="string">set</span> <span class="string">size</span> <span class="number">1</span><span class="string">,</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># The file we'll write to</span></span><br><span class="line"><span class="string">set</span> <span class="string">output</span> <span class="string">"graphs/timeseries.jpg"</span></span><br><span class="line"><span class="comment"># The graph title</span></span><br><span class="line"><span class="string">set</span> <span class="string">title</span> <span class="string">"Benchmark testing"</span></span><br><span class="line"><span class="comment"># Where to place the legend/key</span></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">left</span> <span class="string">top</span></span><br><span class="line"><span class="comment"># Draw gridlines oriented on the y axis</span></span><br><span class="line"><span class="string">set</span> <span class="string">grid</span> <span class="string">y</span></span><br><span class="line"><span class="comment"># Specify that the x-series data is time data</span></span><br><span class="line"><span class="string">set</span> <span class="string">xdata</span> <span class="string">time</span></span><br><span class="line"><span class="comment"># Specify the *input* format of the time data</span></span><br><span class="line"><span class="string">set</span> <span class="string">timefmt</span> <span class="string">"%s"</span></span><br><span class="line"><span class="comment"># Specify the *output* format for the x-axis tick labels</span></span><br><span class="line"><span class="string">set</span> <span class="string">format</span> <span class="string">x</span> <span class="string">"%S"</span></span><br><span class="line"><span class="comment"># Label the x-axis</span></span><br><span class="line"><span class="string">set</span> <span class="string">xlabel</span> <span class="string">'seconds'</span></span><br><span class="line"><span class="comment"># Label the y-axis</span></span><br><span class="line"><span class="string">set</span> <span class="string">ylabel</span> <span class="string">"response time (ms)"</span></span><br><span class="line"><span class="comment"># Tell gnuplot to use tabs as the delimiter instead of spaces (default)</span></span><br><span class="line"><span class="string">set</span> <span class="string">datafile</span> <span class="string">separator</span> <span class="string">'\t'</span></span><br><span class="line"><span class="comment"># Plot the data</span></span><br><span class="line"><span class="string">plot</span> <span class="string">"data/testing.tsv"</span> <span class="string">every</span> <span class="string">::2</span> <span class="string">using</span> <span class="number">2</span><span class="string">:5</span> <span class="string">title</span> <span class="string">'response time'</span> <span class="string">with</span> <span class="string">points</span></span><br><span class="line"><span class="string">exit</span></span><br></pre></td></tr></table></figure>
<p>为了得到按时间序列显示的吞吐率图表，我们可以处理一下得到的测试数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;4,20,50,100,150,200,300&#125;</span><br><span class="line">do</span><br><span class="line">   start_time=`awk '&#123;print $6&#125;' plot/biz$var.dat | grep -v 'wait' | sort | uniq -c|head -1|awk '&#123;print $2&#125;'`</span><br><span class="line">  awk '&#123;print $6&#125;' plot/biz$var.dat | grep -v 'wait' | sort | uniq -c|awk -v t=$start_time '&#123;print $2-t,$1&#125;' &gt; plot/epochtime$var.dat</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>然后根据一下的Gnuplot配置生成图表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#output as png image</span></span><br><span class="line"><span class="string">set</span> <span class="string">terminal</span> <span class="string">png</span>  <span class="string">size</span> <span class="number">1000</span><span class="string">,560</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">output</span> <span class="string">"throughput.png"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#graph title</span></span><br><span class="line"><span class="string">set</span> <span class="string">title</span> <span class="string">"Throughput"</span></span><br><span class="line"></span><br><span class="line"><span class="string">set</span> <span class="string">key</span> <span class="string">invert</span> <span class="string">reverse</span> <span class="string">Left</span> <span class="string">outside</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#nicer aspect ratio for image size</span></span><br><span class="line"><span class="comment">#set size 1,0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># y-axis grid</span></span><br><span class="line"><span class="string">set</span> <span class="string">grid</span> <span class="string">y</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#x-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">xlabel</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#y-axis label</span></span><br><span class="line"><span class="string">set</span> <span class="string">ylabel</span> <span class="string">"responses per second"</span></span><br><span class="line"><span class="string">plot</span> <span class="string">"epochtime4.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 4"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime20.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 20"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime50.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 50"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime100.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 100"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime150.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 150"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime200.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 200"</span><span class="string">,</span> <span class="string">\</span></span><br><span class="line"><span class="string">"epochtime300.dat"</span> <span class="string">using</span> <span class="number">1</span><span class="string">:2</span> <span class="string">with</span> <span class="string">lines</span> <span class="string">title</span> <span class="string">"concurrency 300"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/04/使用Apache-Bench-和-Gnuplot产生性能测试图/image-20200204213604555.png" alt="吞吐率"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/12个Git高级命令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/12个Git高级命令/" itemprop="url">
                  12个Git高级命令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:03:00" itemprop="dateCreated datePublished" datetime="2020-02-04T21:03:00+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用Git时常用的命令有pull、commit、push等，貌似很简单。不过，有时你会遇到合并冲突的情况，Git这时会将冲突标记出来，需要你手工来解决。有时，你会不小心将代码提交到错误的分支上，并且又推送到了远程仓库。还有些时候，你需要切换到不同的分支，但Git却不让你这么做，因为还有未保存的修改。如果需要通过另一个分支的提交来为代码打补丁该怎么做呢？本文就将介绍12个Git高级命令，合理使用这些命令可以大大提升应用Git的效率。</p>
<h2 id="1-使用rebase而非merge来拉取上游修改"><a href="#1-使用rebase而非merge来拉取上游修改" class="headerlink" title="1. 使用rebase而非merge来拉取上游修改"></a><strong>1. 使用rebase而非merge来拉取上游修改</strong></h2><p>分支合并会被记录为一次合并提交，这种做法是很有意义的。比如说，可以通过这种方式来标识一个新特性被合并到了发布分支中。不过，当多个团队成员工作在一个项目中并使用常规的git pull来同步分支时，提交时间线就会被不必要的合并提交所污染。更好的做法则是使用git rebase将一个feature分支变基到master分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout feature</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure>
<p>这么做会将整个feature分支移动到master分支的起点，它会合并master分支上所有新的提交。不过，相比于使用合并提交来说，变基会通过在原来的分支中为每次提交创建全新提交来重写项目历史。变基的主要好处在于你会得到一个更加整洁的项目历史。此外，这里还有关于变基的陷阱的一些讨论。</p>
<h2 id="2-在执行git-rebase后解决合并冲突"><a href="#2-在执行git-rebase后解决合并冲突" class="headerlink" title="2. 在执行git rebase后解决合并冲突"></a><strong>2. 在执行git rebase后解决合并冲突</strong></h2><p>正如能力越大责任就越大一样。在执行git rebase时，你可能会遇到合并冲突的情况。合并冲突表示两个提交修改了同一个文件的同一行，Git不知道该应用哪一个修改。</p>
<p>Git会为你提供3个选择来修复导致冲突的提交（fa39187）：</p>
<ul>
<li>可以运行git rebase –abort来完全取消变基。这么做会取消变基修改，并将分支置回到执行git rebase之前的状态。</li>
<li>可以运行git rebase –skip来完全忽略该提交。这样，有问题的提交所引入的变化就不会被添加到历史中。</li>
<li>可以使用与合并冲突相同的标准步骤来解决冲突。</li>
</ul>
<h2 id="3-临时性保存修改"><a href="#3-临时性保存修改" class="headerlink" title="3. 临时性保存修改"></a><strong>3. 临时性保存修改</strong></h2><p>在工作进行中时，有些东西常常会处于凌乱的状态。如果这时需要切换到不同的分支该怎么办呢？Git是不允许你这么做的，因为还有尚未保存的修改。坦率地说，你并不想将半成品提交上去，后面再来修改。这个问题的解决之道就是使用git stash命令。Stash会接收工作目录的当前状态（比如说，修改了的追踪文件与暂存区的修改等），并将其保存到未完成的修改栈中，这样后面随时可以再来修改。可以通过如下命令来暂存你的工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on feature: 3fc175f fix race condition</span><br><span class="line">HEAD is now at 3fc175f fix race condition</span><br></pre></td></tr></table></figure>
<p>现在，工作目录就是干净的了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="comment"># On branch feature</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>这时就可以安全地切换分支做别的事情了。不过不必担心，暂存的提交依旧还在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on feature: 3fc175f fix race condition</span><br></pre></td></tr></table></figure>
<p>稍后，在回到feature分支后，你就可以取回所有暂存的变更了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch feature</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add ..."</span> to update what will be committed)</span><br><span class="line"></span><br><span class="line">     modified:   index.html</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (ac2321cc3a33ba712b8e50c99a99d3c20da9d6b8)</span><br></pre></td></tr></table></figure>
<p>关于暂存，还有其他一些选项可用，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash save <span class="string">"describe it"</span>   <span class="comment"># give the stash a name</span></span><br><span class="line">$ git stash clear                <span class="comment"># delete a stashed commit</span></span><br><span class="line">$ git stash save --keep-index    <span class="comment"># stash only unstaged files</span></span><br></pre></td></tr></table></figure>
<h2 id="4-克隆一个特定的远程分支"><a href="#4-克隆一个特定的远程分支" class="headerlink" title="4. 克隆一个特定的远程分支"></a><strong>4. 克隆一个特定的远程分支</strong></h2><p>如果想要从远程仓库中克隆一个特定的分支该怎么做呢？通常你会使用git clone，不过这么做会将所有其他分支都一并克隆下来。一个便捷的方式是使用git remote add：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init  </span><br><span class="line">$ git remote add -t  -f origin </span><br><span class="line">$ git checkout</span><br></pre></td></tr></table></figure>
<h2 id="5-将cherry-pick远程提交合并到自己的分支中"><a href="#5-将cherry-pick远程提交合并到自己的分支中" class="headerlink" title="5. 将cherry-pick远程提交合并到自己的分支中"></a><strong>5. 将cherry-pick远程提交合并到自己的分支中</strong></h2><p>更有甚者，如果只想将远程仓库的一个特定提交合并到自己的分支中该怎么做呢？可以使用git cherry-pick 来选择给定SHA值的提交，然后将其合并到当前分支中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick</span><br></pre></td></tr></table></figure>
<h2 id="6-应用来自于不相关的本地仓库的补丁"><a href="#6-应用来自于不相关的本地仓库的补丁" class="headerlink" title="6. 应用来自于不相关的本地仓库的补丁"></a><strong>6. 应用来自于不相关的本地仓库的补丁</strong></h2><p>如果需要将另一个不相关的本地仓库的提交补丁应用到当前仓库该怎么做呢？答案就是下面这条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --git-dir=/.git format-patch -k -1 --stdout  | git am -3 -k</span><br></pre></td></tr></table></figure>
<h2 id="7-忽略追踪文件中的变更"><a href="#7-忽略追踪文件中的变更" class="headerlink" title="7. 忽略追踪文件中的变更"></a><strong>7. 忽略追踪文件中的变更</strong></h2><p>如果你和你的同事操纵的是相同分支，那么很有可能需要频繁执行git merge或是git rebase。不过，这么做可能会重置一些与环境相关的配置文件，这样在每次合并后都需要修改。与之相反，你可以通过如下命令永久性地告诉Git不要管某个本地文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-index --assume-unchanged</span><br></pre></td></tr></table></figure>
<h2 id="8-每隔X秒运行一次git-pull"><a href="#8-每隔X秒运行一次git-pull" class="headerlink" title="8. 每隔X秒运行一次git pull"></a><strong>8. 每隔X秒运行一次git pull</strong></h2><p>通常，合并冲突出现的原因在于你正在工作的本地仓库不再反映远程仓库的当前状态。这正是我们为什么每天早晨要首先执行一次git pull的缘故。此外，你还可以在后台通过脚本（或是使用GNU Screen）每隔X秒调用一次git pull：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ screen</span><br><span class="line">$ <span class="keyword">for</span>((i=1;i&lt;=10000;i+=1)); <span class="keyword">do</span> sleep X &amp;&amp; git pull; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="9-将子目录分隔为新的仓库"><a href="#9-将子目录分隔为新的仓库" class="headerlink" title="9. 将子目录分隔为新的仓库"></a><strong>9. 将子目录分隔为新的仓库</strong></h2><p>有时，你可能需要将Git仓库中某个特定的目录转换为一个全新的仓库。这可以通过git filter-branch来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git filter-branch --prune-empty --subdirectory-filter  master</span><br><span class="line"><span class="comment"># Filter the master branch to your directory and remove empty commits</span></span><br><span class="line">Rewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (89/89)</span><br><span class="line">Ref <span class="string">'refs/heads/master'</span> was rewritten</span><br></pre></td></tr></table></figure>
<p>现在，仓库会包含指定子目录中的所有文件。虽然之前的所有文件都会被删除，但他们依旧存在于Git历史中。现在可以将新的本地仓库推送到远程了。</p>
<h2 id="10-清理"><a href="#10-清理" class="headerlink" title="10. 清理"></a><strong>10. 清理</strong></h2><p>有时，Git会提示“untracked working tree files”会“overwritten by checkout”。造成这种情况的原因有很多。不过通常来说，我们可以使用如下命令来保持工作树的整洁，从而防止这种情况的发生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clean -f     <span class="comment"># remove untracked files</span></span><br><span class="line">$ git clean -fd    <span class="comment"># remove untracked files/directories</span></span><br><span class="line">$ git clean -nfd   <span class="comment"># list all files/directories that would be removed</span></span><br></pre></td></tr></table></figure>
<h2 id="11-将项目文件打成tar包，并且排除-git目录"><a href="#11-将项目文件打成tar包，并且排除-git目录" class="headerlink" title="11. 将项目文件打成tar包，并且排除.git目录"></a><strong>11. 将项目文件打成tar包，并且排除.git目录</strong></h2><p>有时，你需要将项目副本提供给无法访问GitHub仓库的外部成员。最简单的方式就是使用tar或zip来打包所有的项目文件。不过，如果不小心，隐藏的.git目录就会包含到tar文件中，这会导致文件体积变大；同时，如果里面的文件与接收者自己的Git仓库弄混了，那就更加令人头疼了。轻松的做法则是自动从tar文件中排除掉.git目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar cJf .tar.xz / --exclude-vcs</span><br></pre></td></tr></table></figure>
<h2 id="12-查找修改者"><a href="#12-查找修改者" class="headerlink" title="12. 查找修改者"></a><strong>12. 查找修改者</strong></h2><p>最后，如果出现混乱的情况，你一定想要找出是谁造成的。如果生产服务器宕机，那么找到罪魁祸首是比较容易的事情：只需执行git blame。该命令会显示出文件中每一行的作者，提交hash则会找出该行的上一次修改，还能看到提交的时间戳：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vincentruan.github.io/2020/02/04/在CentOS上安装Git/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="vincent">
      <meta itemprop="description" content="The King is dead, long live the King!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星辰大海">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/在CentOS上安装Git/" itemprop="url">
                  在CentOS上安装Git
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-04 21:00:57" itemprop="dateCreated datePublished" datetime="2020-02-04T21:00:57+08:00">2020-02-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-17 10:40:44" itemprop="dateModified" datetime="2020-02-17T10:40:44+08:00">2020-02-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CentOS的yum源中没有git，只能自己编译安装，现在记录下编译安装的内容，留给自己备忘。</p>
<p>确保已安装了依赖的包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum install curl</span><br><span class="line">yum install curl-devel</span><br><span class="line">yum install zlib-devel</span><br><span class="line">yum install openssl-devel</span><br><span class="line">yum install perl</span><br><span class="line">yum install cpio</span><br><span class="line">yum install expat-devel</span><br><span class="line">yum install gettext-devel yum install perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker</span><br></pre></td></tr></table></figure>
<p>下载最新的git包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.gz</span><br><span class="line">tar xzvf git-latest.tar.gz</span><br><span class="line"><span class="built_in">cd</span> git-2011-11-30 ＃你的目录可能不是这个</span><br><span class="line">autoconf</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>检查下安装的版本，大功告成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">vincent</p>
              <p class="site-description motion-element" itemprop="description">The King is dead, long live the King!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/vincentruan" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vincent</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>





  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  
    
  

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/xiaomai.model.json"},"display":{"position":"left","width":280,"height":375},"mobile":{"show":false},"log":false});</script></body>
</html>
